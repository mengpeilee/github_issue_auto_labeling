[
    {
        "issue_id": 1566201687,
        "title": "Suspense API forces coupling of page-load sequence with runtime updates",
        "label": [
            "Type: Discussion",
            "Component: Suspense",
            "Component: Concurrent Features"
        ],
        "date": "2023-02-01T14:18:27Z",
        "status": "open",
        "description": "_(the prelude to this issue may be a bit abstract, but please bear with me!)_\r\n\r\n## Problem statement\r\nAs it has usually been the case in React and already stated in [its docs](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react):\r\n\r\n> When we [React] design APIs, we try to hide implementation details from developers. As a React developer, you focus on what you want the user experience to look like, and React handles how to deliver that experience...\r\n\r\nBut I think the new Suspense API -with all of its great features- contradicts this mindset to some degree.\r\nBecause looking at the library from the \u201cusage\u201d perspective, Suspense API enforces coupling of independent features together. Features that although are related from a technical standpoint, in reality can be fundamentally different.\r\n- For example, code-splitting is basically a separate subject from the other features. Because a developer may need code-splitting (for bundle size optimizations), but it doesn\u2019t necessarily mean they want to render the lazy-loaded component in a delayed manner in the initial html coming from the SSR stream. They also may not want to delay that component\u2019s hydration after other (non-suspense) parts are hydrated either.\r\n\r\nBut the main issue I\u2019m referring to is about the other Suspense features that basically seem to enable a \u201cfederated-mode\u201d (for the lack of a better word) that makes each suspended component act independently in the tree.\r\nThe problem is, they are coupling \u201cSSR and page-load sequence\u201d with \u201cclient-side runtime\u201d and forcing product decisions on developers. Because:\r\n- On SSR, a developer may want to use partial streaming and selective/async hydration to provide performance boost for the initial page-load sequence. For example, if an end user initially opens a page that includes the details of an article scattered among multiple nested components, it makes sense to stream/render/hydrate different components of the article\u2019s details (photos, title/description, ratings, comments, etc.) separately and as soon as possible (with some optional priorities).\r\n- But the developer doesn't necessarily need the application to act in the same way for the future updates and renders on the client side when a **change** happens. So for example when the user clicks to show a similar article and the page has to update on the client side to show the data of this different article, the developer should have the choice to make the page\u2019s content (photos, title/description, ratings, comments, etc.) update together in a single graceful step - or batch some of the nested components\u2019 loadings together (regardless of whether nested suspense boundaries were used). As opposed to each component getting updated independently, showing their own fallbacks independently, and rendering the new content independently while another component is still showing the old content or a fallback. Because this can cause discrepancies on the page, and aside from that, is inherently forcing a product decision on the developer. Basically, how/where to show fallback/loading states is a product/UX decision and the API shouldn\u2019t force an approach.\r\n- Last but not least, regardless of all the previous usages of Suspense, it should still be possible to opt into **interruptible/concurrent rendering** on client side during runtime changes (after page-load) which allows pausing a rendering sequence and prioritizing user interactions, to benefit from the improvements to the user experience and the perceived performance.\r\n\r\n## Working example\r\nI think [this issue](https://github.com/facebook/react/issues/25082) is a great practical use-case of the problem of coupling behaviors on \"SSR/page-load sequence\" and \"client-side changes\" **even with the use of the `useTransition` api**, which also includes a working codeSandbox example.\r\n\r\n## Suggested solution\r\nI\u2019m not sure what the \"best\" solution would be (e.g. to have a separate component other than Suspense, or change the `useTransition` behavior as suggested in the [previously mentioned issue](https://github.com/facebook/react/issues/25082) or\u2026), but a solution that can also work is:\r\n\r\nAdding two new props to the `Suspense` component like:\r\n- `hoistSuspenseHandling`: If `true`, skips the handling of the Suspense status (to show a fallback etc) inside component\u2019s own suspense boundary, and instead give it to its parent to be merged with parent\u2019s Suspense handling (if accepted by the parent).\r\n- `handleChildrenSuspense`: The other side of the previous prop, acting as a safety net to ensure the parent can (wants to) handle its children\u2019s suspense. It is passed to the parent Suspense component. If `true`, it will allow merging of the suspense conditions of children with its own suspense handling.\r\n\r\n(Depending on the real life usage, they could instead be functions passed to the Suspended component as well, so it can change the values internally during runtime)\r\nAlso a component that has both `hoistSuspenseHandling` and `handleChildrenSuspense` as `true`, could add its children\u2019s suspense conditions to its own and pass them all up to the parent.\r\n\r\nWith this, a developer can differentiate between SSR/page-load sequence and client side updates/changes (or even more different scenarios) and handle components\u2019 fallback/loading states in different places on the tree.\r\n",
        "remove_template_description": "_(the prelude to this issue may be a bit abstract, but please bear with me!)_    ## Problem statement  As it has usually been the case in React and already stated in [its docs](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react):    > When we [React] design APIs, we try to hide implementation details from developers. As a React developer, you focus on what you want the user experience to look like, and React handles how to deliver that experience...    But I think the new Suspense API -with all of its great features- contradicts this mindset to some degree.  Because looking at the library from the \u201cusage\u201d perspective, Suspense API enforces coupling of independent features together. Features that although are related from a technical standpoint, in reality can be fundamentally different.  - For example, code-splitting is basically a separate subject from the other features. Because a developer may need code-splitting (for bundle size optimizations), but it doesn\u2019t necessarily mean they want to render the lazy-loaded component in a delayed manner in the initial html coming from the SSR stream. They also may not want to delay that component\u2019s hydration after other (non-suspense) parts are hydrated either.    But the main issue I\u2019m referring to is about the other Suspense features that basically seem to enable a \u201cfederated-mode\u201d (for the lack of a better word) that makes each suspended component act independently in the tree.  The problem is, they are coupling \u201cSSR and page-load sequence\u201d with \u201cclient-side runtime\u201d and forcing product decisions on developers. Because:  - On SSR, a developer may want to use partial streaming and selective/async hydration to provide performance boost for the initial page-load sequence. For example, if an end user initially opens a page that includes the details of an article scattered among multiple nested components, it makes sense to stream/render/hydrate different components of the article\u2019s details (photos, title/description, ratings, comments, etc.) separately and as soon as possible (with some optional priorities).  - But the developer doesn't necessarily need the application to act in the same way for the future updates and renders on the client side when a **change** happens. So for example when the user clicks to show a similar article and the page has to update on the client side to show the data of this different article, the developer should have the choice to make the page\u2019s content (photos, title/description, ratings, comments, etc.) update together in a single graceful step - or batch some of the nested components\u2019 loadings together (regardless of whether nested suspense boundaries were used). As opposed to each component getting updated independently, showing their own fallbacks independently, and rendering the new content independently while another component is still showing the old content or a fallback. Because this can cause discrepancies on the page, and aside from that, is inherently forcing a product decision on the developer. Basically, how/where to show fallback/loading states is a product/UX decision and the API shouldn\u2019t force an approach.  - Last but not least, regardless of all the previous usages of Suspense, it should still be possible to opt into **interruptible/concurrent rendering** on client side during runtime changes (after page-load) which allows pausing a rendering sequence and prioritizing user interactions, to benefit from the improvements to the user experience and the perceived performance.    ## Working example  I think [this issue](https://github.com/facebook/react/issues/25082) is a great practical use-case of the problem of coupling behaviors on \"SSR/page-load sequence\" and \"client-side changes\" **even with the use of the `useTransition` api**, which also includes a working codeSandbox example.    ## Suggested solution  I\u2019m not sure what the \"best\" solution would be (e.g. to have a separate component other than Suspense, or change the `useTransition` behavior as suggested in the [previously mentioned issue](https://github.com/facebook/react/issues/25082) or\u2026), but a solution that can also work is:    Adding two new props to the `Suspense` component like:  - `hoistSuspenseHandling`: If `true`, skips the handling of the Suspense status (to show a fallback etc) inside component\u2019s own suspense boundary, and instead give it to its parent to be merged with parent\u2019s Suspense handling (if accepted by the parent).  - `handleChildrenSuspense`: The other side of the previous prop, acting as a safety net to ensure the parent can (wants to) handle its children\u2019s suspense. It is passed to the parent Suspense component. If `true`, it will allow merging of the suspense conditions of children with its own suspense handling.    (Depending on the real life usage, they could instead be functions passed to the Suspended component as well, so it can change the values internally during runtime)  Also a component that has both `hoistSuspenseHandling` and `handleChildrenSuspense` as `true`, could add its children\u2019s suspense conditions to its own and pass them all up to the parent.    With this, a developer can differentiate between SSR/page-load sequence and client side updates/changes (or even more different scenarios) and handle components\u2019 fallback/loading states in different places on the tree.",
        "human_words": "_(the prelude to this issue may be a bit abstract, but please bear with me!)_    ## Problem statement  As it has usually been the case in React and already stated in [its docs](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react):    > When we [React] design APIs, we try to hide implementation details from developers. As a React developer, you focus on what you want the user experience to look like, and React handles how to deliver that experience...    But I think the new Suspense API -with all of its great features- contradicts this mindset to some degree.  Because looking at the library from the \u201cusage\u201d perspective, Suspense API enforces coupling of independent features together. Features that although are related from a technical standpoint, in reality can be fundamentally different.  - For example, code-splitting is basically a separate subject from the other features. Because a developer may need code-splitting (for bundle size optimizations), but it doesn\u2019t necessarily mean they want to render the lazy-loaded component in a delayed manner in the initial html coming from the SSR stream. They also may not want to delay that component\u2019s hydration after other (non-suspense) parts are hydrated either.    But the main issue I\u2019m referring to is about the other Suspense features that basically seem to enable a \u201cfederated-mode\u201d (for the lack of a better word) that makes each suspended component act independently in the tree.  The problem is, they are coupling \u201cSSR and page-load sequence\u201d with \u201cclient-side runtime\u201d and forcing product decisions on developers. Because:  - On SSR, a developer may want to use partial streaming and selective/async hydration to provide performance boost for the initial page-load sequence. For example, if an end user initially opens a page that includes the details of an article scattered among multiple nested components, it makes sense to stream/render/hydrate different components of the article\u2019s details (photos, title/description, ratings, comments, etc.) separately and as soon as possible (with some optional priorities).  - But the developer doesn't necessarily need the application to act in the same way for the future updates and renders on the client side when a **change** happens. So for example when the user clicks to show a similar article and the page has to update on the client side to show the data of this different article, the developer should have the choice to make the page\u2019s content (photos, title/description, ratings, comments, etc.) update together in a single graceful step - or batch some of the nested components\u2019 loadings together (regardless of whether nested suspense boundaries were used). As opposed to each component getting updated independently, showing their own fallbacks independently, and rendering the new content independently while another component is still showing the old content or a fallback. Because this can cause discrepancies on the page, and aside from that, is inherently forcing a product decision on the developer. Basically, how/where to show fallback/loading states is a product/UX decision and the API shouldn\u2019t force an approach.  - Last but not least, regardless of all the previous usages of Suspense, it should still be possible to opt into **interruptible/concurrent rendering** on client side during runtime changes (after page-load) which allows pausing a rendering sequence and prioritizing user interactions, to benefit from the improvements to the user experience and the perceived performance.    ## Working example  I think [this issue](https://github.com/facebook/react/issues/25082) is a great practical use-case of the problem of coupling behaviors on \"SSR/page-load sequence\" and \"client-side changes\" **even with the use of the `useTransition` api**, which also includes a working codeSandbox example.    ## Suggested solution  I\u2019m not sure what the \"best\" solution would be (e.g. to have a separate component other than Suspense, or change the `useTransition` behavior as suggested in the [previously mentioned issue](https://github.com/facebook/react/issues/25082) or\u2026), but a solution that can also work is:    Adding two new props to the `Suspense` component like:  - `hoistSuspenseHandling`: If `true`, skips the handling of the Suspense status (to show a fallback etc) inside component\u2019s own suspense boundary, and instead give it to its parent to be merged with parent\u2019s Suspense handling (if accepted by the parent).  - `handleChildrenSuspense`: The other side of the previous prop, acting as a safety net to ensure the parent can (wants to) handle its children\u2019s suspense. It is passed to the parent Suspense component. If `true`, it will allow merging of the suspense conditions of children with its own suspense handling.    (Depending on the real life usage, they could instead be functions passed to the Suspended component as well, so it can change the values internally during runtime)  Also a component that has both `hoistSuspenseHandling` and `handleChildrenSuspense` as `true`, could add its children\u2019s suspense conditions to its own and pass them all up to the parent.    With this, a developer can differentiate between SSR/page-load sequence and client side updates/changes (or even more different scenarios) and handle components\u2019 fallback/loading states in different places on the tree.",
        "human_words_regrex": "_(the prelude to this issue may be a bit abstract, but please bear with me!)_ ## Problem statement As it has usually been the case in React and already stated in : > When we  is a great practical use-case of the problem of coupling behaviors on \"SSR/page-load sequence\" and \"client-side changes\" **even with the use of the `useTransition` api**, which also includes a working codeSandbox example. ## Suggested solution I\u2019m not sure what the \"best\" solution would be (e.g. to have a separate component other than Suspense, or change the `useTransition` behavior as suggested in the  or\u2026), but a solution that can also work is: Adding two new props to the `Suspense` component like: - `hoistSuspenseHandling`: If `true`, skips the handling of the Suspense status (to show a fallback etc) inside component\u2019s own suspense boundary, and instead give it to its parent to be merged with parent\u2019s Suspense handling (if accepted by the parent). - `handleChildrenSuspense`: The other side of the previous prop, acting as a safety net to ensure the parent can (wants to) handle its children\u2019s suspense. It is passed to the parent Suspense component. If `true`, it will allow merging of the suspense conditions of children with its own suspense handling. (Depending on the real life usage, they could instead be functions passed to the Suspended component as well, so it can change the values internally during runtime) Also a component that has both `hoistSuspenseHandling` and `handleChildrenSuspense` as `true`, could add its children\u2019s suspense conditions to its own and pass them all up to the parent. With this, a developer can differentiate between SSR/page-load sequence and client side updates/changes (or even more different scenarios) and handle components\u2019 fallback/loading states in different places on the tree.",
        "human_words_stopwords_removal_lemmatization": "_ ( prelude issue may bit abstract , please bear ! ) _ # # problem statement usually case react already stated : > great practical use-case problem coupling behavior `` ssr/page-load sequence '' `` client-side change '' * * even use ` usetransition ` api * * , also includes working codesandbox example . # # suggested solution \u2019 sure `` best '' solution would ( e.g . separate component suspense , change ` usetransition ` behavior suggested or\u2026 ) , solution also work : adding two new prop ` suspense ` component like : - ` hoistsuspensehandling ` : ` true ` , skip handling suspense status ( show fallback etc ) inside component \u2019 suspense boundary , instead give parent merged parent \u2019 suspense handling ( accepted parent ) . - ` handlechildrensuspense ` : side previous prop , acting safety net ensure parent ( want ) handle child \u2019 suspense . passed parent suspense component . ` true ` , allow merging suspense condition child suspense handling . ( depending real life usage , could instead function passed suspended component well , change value internally runtime ) also component ` hoistsuspensehandling ` ` handlechildrensuspense ` ` true ` , could add child \u2019 suspense condition pas parent . , developer differentiate ssr/page-load sequence client side updates/changes ( even different scenario ) handle component \u2019 fallback/loading state different place tree .",
        "title_stopwords_removal_lemmatization": "suspense api force coupling page-load sequence runtime update"
    },
    {
        "issue_id": 1447684556,
        "title": "Bug: False positive warning with nested roots: Attempted to synchronously unmount a root while React was already rendering.",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2022-11-14T09:17:39Z",
        "status": "open",
        "description": "we get a warning on (legitimate?) use case, if there is a manually added react root inside another parent root\r\n(for example for part of Backbone view that is inserted into parent react component)\r\non unmount we can see that child root is in commit context, so we cant unmount it\r\n\r\nReact version: 18.2\r\n\r\n## Steps To Reproduce\r\n\r\n1. have nested react roots, child is manually added/removed on parent mount/unmount\r\n2. unmount parent root\r\n\r\nI have 2 way bindings for backbone.marionette and react\r\n* reactToMarionette\r\n* useMarionetteInReact hook\r\nwhen root/parent component gets rendered/destroyed React gives this warning\r\n\r\n```\r\nWarning: Attempted to synchronously unmount a root while React was already rendering.\r\nReact cannot finish unmounting the root until the current render has completed,\r\nwhich may lead to a race condition.\r\n```\r\nI am looking for ways to fix this warning\r\n\r\nI think ReactChild node is somehow marked as `toBeRendered` at the app render, even though I would expect that app.root would not know about nested/inserted MView react root\r\n\r\nLink to code example: https://codesandbox.io/s/my-test-adapters-forked-tdbgdb\r\n\r\n<details><summary>problematic code </summary>\r\n\r\n```jsx\r\nimport { View } from \"backbone.marionette\";\r\nimport React, { useCallback, useRef, useState } from \"react\";\r\n\r\nimport { createRoot } from \"react-dom/client\";\r\n\r\nexport function App() {\r\n  // create a reason to render inner component\r\n  const [isVisible, setVisible] = useState(true);\r\n  const toggle = useCallback(() => setVisible((i) => !i), []);\r\n\r\n  console.log(\"render app\", isVisible);\r\n  return (\r\n    <>\r\n      <button onClick={toggle}>{`toggle: ${isVisible}`}</button>\r\n      {isVisible ? <SomeComponent /> : null}\r\n    </>\r\n  );\r\n}\r\n\r\n// component that children are controlled from outside (by marionette)\r\nconst SomeComponent = () => {\r\n  console.log(\"render SomeComponent\");\r\n  const ref = useMarionetteInReact();\r\n  return <div ref={ref} className=\"stable-react-div\"></div>;\r\n};\r\n\r\n// hook, for rendering marionette view\r\nconst useMarionetteInReact = () => {\r\n  const viewRef = useRef(null);\r\n\r\n  const divRef = useCallback((el) => {\r\n    if (el === null) {\r\n      console.log(\"MView destroy in useCallback\", viewRef.current);\r\n      viewRef.current && viewRef.current.destroy();\r\n    } else {\r\n      console.log(\"created MView\");\r\n      const MView = new reactToMarionette({\r\n        className: \"reactToMarionette\",\r\n        template: false,\r\n        component: <ReactChild />\r\n      });\r\n      viewRef.current = MView;\r\n      MView.render();\r\n      el.appendChild(MView.el);\r\n    }\r\n  }, []);\r\n\r\n  return divRef;\r\n};\r\n\r\nclass reactToMarionette extends View {\r\n  constructor(options) {\r\n    super(options);\r\n    this.component = options.component;\r\n    this.el.textContent = \"I am Marionette\";\r\n\r\n    console.log(\"create root\", this.el);\r\n    this.divEl = document.createElement(\"div\");\r\n    this.divEl.classList.add(\"portal-root\");\r\n    this.root = createRoot(this.divEl);\r\n    this.el.append(this.divEl);\r\n  }\r\n\r\n  render() {\r\n    console.log(\"MView render\");\r\n    this.root.render(this.component);\r\n  }\r\n\r\n  onBeforeDestroy() {\r\n    console.log(\"onBeforeDestroy\", this.root);\r\n    if (this.root) {\r\n      // setTimeout(() => this.root.unmount());\r\n      this.root.unmount();\r\n    }\r\n  }\r\n}\r\n\r\nconst ReactChild = () => {\r\n  console.log(\"render ReactChild\");\r\n  return <div> Hello, I am react child </div>;\r\n};\r\n\r\n```\r\n</details>\r\n\r\n## The current behavior\r\nwarning is displayed\r\n\r\n## The expected behavior\r\nno warning ?\r\n",
        "remove_template_description": "we get a warning on (legitimate?) use case, if there is a manually added react root inside another parent root  (for example for part of Backbone view that is inserted into parent react component)  on unmount we can see that child root is in commit context, so we cant unmount it    React version: 18.2        1. have nested react roots, child is manually added/removed on parent mount/unmount  2. unmount parent root    I have 2 way bindings for backbone.marionette and react  * reactToMarionette  * useMarionetteInReact hook  when root/parent component gets rendered/destroyed React gives this warning    ```  Warning: Attempted to synchronously unmount a root while React was already rendering.  React cannot finish unmounting the root until the current render has completed,  which may lead to a race condition.  ```  I am looking for ways to fix this warning    I think ReactChild node is somehow marked as `toBeRendered` at the app render, even though I would expect that app.root would not know about nested/inserted MView react root    Link to code example: https://codesandbox.io/s/my-test-adapters-forked-tdbgdb    <details><summary>problematic code </summary>    ```jsx  import { View } from \"backbone.marionette\";  import React, { useCallback, useRef, useState } from \"react\";    import { createRoot } from \"react-dom/client\";    export function App() {    // create a reason to render inner component    const [isVisible, setVisible] = useState(true);    const toggle = useCallback(() => setVisible((i) => !i), []);      console.log(\"render app\", isVisible);    return (      <>        <button onClick={toggle}>{`toggle: ${isVisible}`}</button>        {isVisible ? <SomeComponent /> : null}      </>    );  }    // component that children are controlled from outside (by marionette)  const SomeComponent = () => {    console.log(\"render SomeComponent\");    const ref = useMarionetteInReact();    return <div ref={ref} className=\"stable-react-div\"></div>;  };    // hook, for rendering marionette view  const useMarionetteInReact = () => {    const viewRef = useRef(null);      const divRef = useCallback((el) => {      if (el === null) {        console.log(\"MView destroy in useCallback\", viewRef.current);        viewRef.current && viewRef.current.destroy();      } else {        console.log(\"created MView\");        const MView = new reactToMarionette({          className: \"reactToMarionette\",          template: false,          component: <ReactChild />        });        viewRef.current = MView;        MView.render();        el.appendChild(MView.el);      }    }, []);      return divRef;  };    class reactToMarionette extends View {    constructor(options) {      super(options);      this.component = options.component;      this.el.textContent = \"I am Marionette\";        console.log(\"create root\", this.el);      this.divEl = document.createElement(\"div\");      this.divEl.classList.add(\"portal-root\");      this.root = createRoot(this.divEl);      this.el.append(this.divEl);    }      render() {      console.log(\"MView render\");      this.root.render(this.component);    }      onBeforeDestroy() {      console.log(\"onBeforeDestroy\", this.root);      if (this.root) {        // setTimeout(() => this.root.unmount());        this.root.unmount();      }    }  }    const ReactChild = () => {    console.log(\"render ReactChild\");    return <div> Hello, I am react child </div>;  };    ```  </details>      warning is displayed      no warning ?",
        "human_words": "we get a warning on (legitimate?) use case, if there is a manually added react root inside another parent root  (for example for part of Backbone view that is inserted into parent react component)  on unmount we can see that child root is in commit context, so we cant unmount it    React version: 18.2        1. have nested react roots, child is manually added/removed on parent mount/unmount  2. unmount parent root    I have 2 way bindings for backbone.marionette and react  * reactToMarionette  * useMarionetteInReact hook  when root/parent component gets rendered/destroyed React gives this warning      I am looking for ways to fix this warning    I think ReactChild node is somehow marked as `toBeRendered` at the app render, even though I would expect that app.root would not know about nested/inserted MView react root    Link to code example: https://codesandbox.io/s/my-test-adapters-forked-tdbgdb    <details><summary>problematic code </summary>      </details>      warning is displayed      no warning ?",
        "human_words_regrex": "we get a warning on (legitimate?) use case, if there is a manually added react root inside another parent root (for example for part of Backbone view that is inserted into parent react component) on unmount we can see that child root is in commit context, so we cant unmount it React version: 18.2 1. have nested react roots, child is manually added/removed on parent mount/unmount 2. unmount parent root I have 2 way bindings for backbone.marionette and react * reactToMarionette * useMarionetteInReact hook when root/parent component gets rendered/destroyed React gives this warning I am looking for ways to fix this warning I think ReactChild node is somehow marked as `toBeRendered` at the app render, even though I would expect that app.root would not know about nested/inserted MView react root Link to code example:  problematic code   warning is displayed no warning ?",
        "human_words_stopwords_removal_lemmatization": "get warning ( legitimate ? ) use case , manually added react root inside another parent root ( example part backbone view inserted parent react component ) unmount see child root commit context , cant unmount react version : 18.2 1. nested react root , child manually added/removed parent mount/unmount 2. unmount parent root 2 way binding backbone.marionette react * reacttomarionette * usemarionetteinreact hook root/parent component get rendered/destroyed react give warning looking way fix warning think reactchild node somehow marked ` toberendered ` app render , even though would expect app.root would know nested/inserted mview react root link code example : problematic code warning displayed warning ?",
        "title_stopwords_removal_lemmatization": "bug : false positive warning nested root : attempted synchronously unmount root react already rendering ."
    },
    {
        "issue_id": 1335944522,
        "title": "useTransition should optionally also consider nested suspense boundaries",
        "label": [
            "Type: Discussion",
            "Component: Suspense"
        ],
        "date": "2022-08-11T13:14:19Z",
        "status": "open",
        "description": "React version: 18.2.0\r\n\r\n## Background\r\nWe are working on a web framework that can be used to build highly personalized and data-driven applications. A page that is rendered by the framework consists of a tree of composable, declarative and self-sufficient widgets. A widget can be seen as a mini-application that specifies its own data dependencies and behavior. Since the widgets are self-sufficient, it gives us lots of flexibility to choose which widgets should be shown on page and how they are arranged. It allows us to have personalized pages or layouts per user depending on certain criteria, e.g. their browsing history. The way widgets are chosen to be displayed on the page can be seen as a dynamic, nested routing mechanism.\r\n\r\nHere is an example of an outfit view that can be used in an ecommerce application:\r\n![showing the structure of an example page with above described concept](https://img01.ztat.net/engineering-blog/posts/2021/09/images/rengine-outfit-page.png)\r\n\r\nWe are currently migrating the framework to React 18 with the new Suspense SSR and streaming architecture. The main idea is that we wrap each widget in its own suspense boundary to handle the loading of their code and data as soon as the framework decides to display it on the page. For initial requests it works well, but we face a problem with client-side updates that lead to new sub-tree of widgets.\r\n\r\n\r\n## Steps to Reproduce\r\nHere is a link to a code sandbox that contains a minimal code example to reproduce the problem with \u201cnew\u201d suspense boundaries and useTransition: https://codesandbox.io/s/romantic-haslett-psc4f4?file=/src/App.js\r\n\r\n\r\n## Current Behavior\r\n\r\nuseTransition waits for the first Suspense boundary to be ready and then re-renders the DOM although nested Suspense boundaries are still in their fallback state. It is similar to the problem that has been reported in [this issue](https://github.com/facebook/react/issues/24759).\r\n\r\nIn our code example, you can see a big loading overlay after clicking the button to fetch a new collection of widgets. Fetching a new collection of widgets means the following: determine which widgets should be displayed on the page and start loading their code and data. In a real application, this would be data-driven. In the code example, it has been simplified to randomly select a Square or Circle widget and lazy-load them via React.lazy().\r\n\r\n\r\n## Expected Behavior\r\n\r\nYou have suggested [two approaches](https://github.com/facebook/react/issues/24759#issuecomment-1160605913) to overcome the issue which do not work well for us. \r\n\r\n> Why is it a problem that moving to a page shows the spinners? Is it because there are many of them?\r\n\r\nYes, in general there are many widgets and it might change to completely new page layouts. But the type of all widgets could also be the same as before the state update. Then it would be odd if the user first sees a big loading overlay for the whole page and when the new tree of widgets has been determined (which is the same as before, just the data changed), they will see individual loading spinners for each \u201cnew\u201d widget.\r\n\r\n> In that case, move the Suspense boundaries from individual dashboard items widgets to wrap all of them.\r\n\r\nThis seems to be impossible for us. A page consists of a tree of widgets. A widget can contain other widgets and each widget can trigger a state update. If a widget triggers a state update, it normally requests some data from backend services and that data determines which child widgets should then be displayed. These child widgets could have their own data dependencies and could again render other widgets, and so on. The whole code is very generic.\r\n\r\nOur proposal is that useTransition should have an option to wait for the entire subtree to be ready, before re-rendering the component. In our use case, the widget of which the state should be updated, would use startTransition with some new flag that will additionally wait for the whole widget\u2019s subtree to complete as well.",
        "remove_template_description": "React version: 18.2.0    ## Background  We are working on a web framework that can be used to build highly personalized and data-driven applications. A page that is rendered by the framework consists of a tree of composable, declarative and self-sufficient widgets. A widget can be seen as a mini-application that specifies its own data dependencies and behavior. Since the widgets are self-sufficient, it gives us lots of flexibility to choose which widgets should be shown on page and how they are arranged. It allows us to have personalized pages or layouts per user depending on certain criteria, e.g. their browsing history. The way widgets are chosen to be displayed on the page can be seen as a dynamic, nested routing mechanism.    Here is an example of an outfit view that can be used in an ecommerce application:  ![showing the structure of an example page with above described concept](https://img01.ztat.net/engineering-blog/posts/2021/09/images/rengine-outfit-page.png)    We are currently migrating the framework to React 18 with the new Suspense SSR and streaming architecture. The main idea is that we wrap each widget in its own suspense boundary to handle the loading of their code and data as soon as the framework decides to display it on the page. For initial requests it works well, but we face a problem with client-side updates that lead to new sub-tree of widgets.      ## Steps to Reproduce  Here is a link to a code sandbox that contains a minimal code example to reproduce the problem with \u201cnew\u201d suspense boundaries and useTransition: https://codesandbox.io/s/romantic-haslett-psc4f4?file=/src/App.js      ## Current Behavior    useTransition waits for the first Suspense boundary to be ready and then re-renders the DOM although nested Suspense boundaries are still in their fallback state. It is similar to the problem that has been reported in [this issue](https://github.com/facebook/react/issues/24759).    In our code example, you can see a big loading overlay after clicking the button to fetch a new collection of widgets. Fetching a new collection of widgets means the following: determine which widgets should be displayed on the page and start loading their code and data. In a real application, this would be data-driven. In the code example, it has been simplified to randomly select a Square or Circle widget and lazy-load them via React.lazy().      ## Expected Behavior    You have suggested [two approaches](https://github.com/facebook/react/issues/24759#issuecomment-1160605913) to overcome the issue which do not work well for us.     > Why is it a problem that moving to a page shows the spinners? Is it because there are many of them?    Yes, in general there are many widgets and it might change to completely new page layouts. But the type of all widgets could also be the same as before the state update. Then it would be odd if the user first sees a big loading overlay for the whole page and when the new tree of widgets has been determined (which is the same as before, just the data changed), they will see individual loading spinners for each \u201cnew\u201d widget.    > In that case, move the Suspense boundaries from individual dashboard items widgets to wrap all of them.    This seems to be impossible for us. A page consists of a tree of widgets. A widget can contain other widgets and each widget can trigger a state update. If a widget triggers a state update, it normally requests some data from backend services and that data determines which child widgets should then be displayed. These child widgets could have their own data dependencies and could again render other widgets, and so on. The whole code is very generic.    Our proposal is that useTransition should have an option to wait for the entire subtree to be ready, before re-rendering the component. In our use case, the widget of which the state should be updated, would use startTransition with some new flag that will additionally wait for the whole widget\u2019s subtree to complete as well.",
        "human_words": "React version: 18.2.0    ## Background  We are working on a web framework that can be used to build highly personalized and data-driven applications. A page that is rendered by the framework consists of a tree of composable, declarative and self-sufficient widgets. A widget can be seen as a mini-application that specifies its own data dependencies and behavior. Since the widgets are self-sufficient, it gives us lots of flexibility to choose which widgets should be shown on page and how they are arranged. It allows us to have personalized pages or layouts per user depending on certain criteria, e.g. their browsing history. The way widgets are chosen to be displayed on the page can be seen as a dynamic, nested routing mechanism.    Here is an example of an outfit view that can be used in an ecommerce application:  ![showing the structure of an example page with above described concept](https://img01.ztat.net/engineering-blog/posts/2021/09/images/rengine-outfit-page.png)    We are currently migrating the framework to React 18 with the new Suspense SSR and streaming architecture. The main idea is that we wrap each widget in its own suspense boundary to handle the loading of their code and data as soon as the framework decides to display it on the page. For initial requests it works well, but we face a problem with client-side updates that lead to new sub-tree of widgets.      ## Steps to Reproduce  Here is a link to a code sandbox that contains a minimal code example to reproduce the problem with \u201cnew\u201d suspense boundaries and useTransition: https://codesandbox.io/s/romantic-haslett-psc4f4?file=/src/App.js      ## Current Behavior    useTransition waits for the first Suspense boundary to be ready and then re-renders the DOM although nested Suspense boundaries are still in their fallback state. It is similar to the problem that has been reported in [this issue](https://github.com/facebook/react/issues/24759).    In our code example, you can see a big loading overlay after clicking the button to fetch a new collection of widgets. Fetching a new collection of widgets means the following: determine which widgets should be displayed on the page and start loading their code and data. In a real application, this would be data-driven. In the code example, it has been simplified to randomly select a Square or Circle widget and lazy-load them via React.lazy().      ## Expected Behavior    You have suggested [two approaches](https://github.com/facebook/react/issues/24759#issuecomment-1160605913) to overcome the issue which do not work well for us.     > Why is it a problem that moving to a page shows the spinners? Is it because there are many of them?    Yes, in general there are many widgets and it might change to completely new page layouts. But the type of all widgets could also be the same as before the state update. Then it would be odd if the user first sees a big loading overlay for the whole page and when the new tree of widgets has been determined (which is the same as before, just the data changed), they will see individual loading spinners for each \u201cnew\u201d widget.    > In that case, move the Suspense boundaries from individual dashboard items widgets to wrap all of them.    This seems to be impossible for us. A page consists of a tree of widgets. A widget can contain other widgets and each widget can trigger a state update. If a widget triggers a state update, it normally requests some data from backend services and that data determines which child widgets should then be displayed. These child widgets could have their own data dependencies and could again render other widgets, and so on. The whole code is very generic.    Our proposal is that useTransition should have an option to wait for the entire subtree to be ready, before re-rendering the component. In our use case, the widget of which the state should be updated, would use startTransition with some new flag that will additionally wait for the whole widget\u2019s subtree to complete as well.",
        "human_words_regrex": "React version: 18.2.0 ## Background We are working on a web framework that can be used to build highly personalized and data-driven applications. A page that is rendered by the framework consists of a tree of composable, declarative and self-sufficient widgets. A widget can be seen as a mini-application that specifies its own data dependencies and behavior. Since the widgets are self-sufficient, it gives us lots of flexibility to choose which widgets should be shown on page and how they are arranged. It allows us to have personalized pages or layouts per user depending on certain criteria, e.g. their browsing history. The way widgets are chosen to be displayed on the page can be seen as a dynamic, nested routing mechanism. Here is an example of an outfit view that can be used in an ecommerce application: ! We are currently migrating the framework to React 18 with the new Suspense SSR and streaming architecture. The main idea is that we wrap each widget in its own suspense boundary to handle the loading of their code and data as soon as the framework decides to display it on the page. For initial requests it works well, but we face a problem with client-side updates that lead to new sub-tree of widgets. ## Steps to Reproduce Here is a link to a code sandbox that contains a minimal code example to reproduce the problem with \u201cnew\u201d suspense boundaries and useTransition:  ## Current Behavior useTransition waits for the first Suspense boundary to be ready and then re-renders the DOM although nested Suspense boundaries are still in their fallback state. It is similar to the problem that has been reported in . In our code example, you can see a big loading overlay after clicking the button to fetch a new collection of widgets. Fetching a new collection of widgets means the following: determine which widgets should be displayed on the page and start loading their code and data. In a real application, this would be data-driven. In the code example, it has been simplified to randomly select a Square or Circle widget and lazy-load them via React.lazy(). ## Expected Behavior You have suggested  to overcome the issue which do not work well for us. > Why is it a problem that moving to a page shows the spinners? Is it because there are many of them? Yes, in general there are many widgets and it might change to completely new page layouts. But the type of all widgets could also be the same as before the state update. Then it would be odd if the user first sees a big loading overlay for the whole page and when the new tree of widgets has been determined (which is the same as before, just the data changed), they will see individual loading spinners for each \u201cnew\u201d widget. > In that case, move the Suspense boundaries from individual dashboard items widgets to wrap all of them. This seems to be impossible for us. A page consists of a tree of widgets. A widget can contain other widgets and each widget can trigger a state update. If a widget triggers a state update, it normally requests some data from backend services and that data determines which child widgets should then be displayed. These child widgets could have their own data dependencies and could again render other widgets, and so on. The whole code is very generic. Our proposal is that useTransition should have an option to wait for the entire subtree to be ready, before re-rendering the component. In our use case, the widget of which the state should be updated, would use startTransition with some new flag that will additionally wait for the whole widget\u2019s subtree to complete as well.",
        "human_words_stopwords_removal_lemmatization": "react version : 18.2.0 # # background working web framework used build highly personalized data-driven application . page rendered framework consists tree composable , declarative self-sufficient widget . widget seen mini-application specifies data dependency behavior . since widget self-sufficient , give u lot flexibility choose widget shown page arranged . allows u personalized page layout per user depending certain criterion , e.g . browsing history . way widget chosen displayed page seen dynamic , nested routing mechanism . example outfit view used ecommerce application : ! currently migrating framework react 18 new suspense ssr streaming architecture . main idea wrap widget suspense boundary handle loading code data soon framework decides display page . initial request work well , face problem client-side update lead new sub-tree widget . # # step reproduce link code sandbox contains minimal code example reproduce problem \u201c new \u201d suspense boundary usetransition : # # current behavior usetransition wait first suspense boundary ready re-renders dom although nested suspense boundary still fallback state . similar problem reported . code example , see big loading overlay clicking button fetch new collection widget . fetching new collection widget mean following : determine widget displayed page start loading code data . real application , would data-driven . code example , simplified randomly select square circle widget lazy-load via react.lazy ( ) . # # expected behavior suggested overcome issue work well u . > problem moving page show spinner ? many ? yes , general many widget might change completely new page layout . type widget could also state update . would odd user first see big loading overlay whole page new tree widget determined ( , data changed ) , see individual loading spinner \u201c new \u201d widget . > case , move suspense boundary individual dashboard item widget wrap . seems impossible u . page consists tree widget . widget contain widget widget trigger state update . widget trigger state update , normally request data backend service data determines child widget displayed . child widget could data dependency could render widget , . whole code generic . proposal usetransition option wait entire subtree ready , re-rendering component . use case , widget state updated , would use starttransition new flag additionally wait whole widget \u2019 subtree complete well .",
        "title_stopwords_removal_lemmatization": "usetransition optionally also consider nested suspense boundary"
    },
    {
        "issue_id": 1316963162,
        "title": "[Portals] DOM order accessibility",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2022-07-25T14:56:33Z",
        "status": "open",
        "description": "**Components built with Portals include accessibility defects leading to poor usability/task abandonment.**\r\n\r\nDuring accessibility audits and usability testing of Shopify components, we\u2019ve noticed a prominent defect with components built with Portals; DOM structure.\r\n\r\nPortals sets dynamically generated content containers at the bottom of the DOM. This is fine for modal window components since keyboard focus is explicitly placed on/within the modal container. The Portals documentation even calls this out and links to APG for more documentation.\r\n\r\nThe issue lies with other component patterns; [disclosures](https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/) (popovers, drop-down navigation, etc,) [comboboxes](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/), [tooltips](https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/), etc. The expectation for these components is for focus to **remain** on the activator and for dynamic content containers to appear **next** in the DOM, a direct sibling to the related activator control.\r\n\r\nFor example, during usability testing, testers struggled to use one such component which was built using Portals. When the dynamic container appeared after interacting with the activator, testers would move their screen reader virtual cursor forward from the activator, expecting to interact with the dynamic content. Instead, the cursor moved \"underneath\" the container, bypassing the content, to the next (unrelated) item in the DOM. This led to a confusing user experience.\r\n\r\nIn addition, this issue is a violation of WCAG [1.3.2: Meaningful Sequence](https://www.w3.org/WAI/WCAG21/Understanding/meaningful-sequence.html) (Level A.) Specifically, [Failure of Success Criterion 1.3.2 due to changing the meaning of content by positioning information with CSS](https://www.w3.org/WAI/WCAG21/Techniques/failures/F1).\r\n\r\n**Is it possible to adjust the position of the dynamic content container to be a sibling of the activator?**\r\n\r\nThis would be a big win for accessibility, not only for Shopify components built with Portals, but for all platforms.",
        "remove_template_description": "**Components built with Portals include accessibility defects leading to poor usability/task abandonment.**    During accessibility audits and usability testing of Shopify components, we\u2019ve noticed a prominent defect with components built with Portals; DOM structure.    Portals sets dynamically generated content containers at the bottom of the DOM. This is fine for modal window components since keyboard focus is explicitly placed on/within the modal container. The Portals documentation even calls this out and links to APG for more documentation.    The issue lies with other component patterns; [disclosures](https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/) (popovers, drop-down navigation, etc,) [comboboxes](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/), [tooltips](https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/), etc. The expectation for these components is for focus to **remain** on the activator and for dynamic content containers to appear **next** in the DOM, a direct sibling to the related activator control.    For example, during usability testing, testers struggled to use one such component which was built using Portals. When the dynamic container appeared after interacting with the activator, testers would move their screen reader virtual cursor forward from the activator, expecting to interact with the dynamic content. Instead, the cursor moved \"underneath\" the container, bypassing the content, to the next (unrelated) item in the DOM. This led to a confusing user experience.    In addition, this issue is a violation of WCAG [1.3.2: Meaningful Sequence](https://www.w3.org/WAI/WCAG21/Understanding/meaningful-sequence.html) (Level A.) Specifically, [Failure of Success Criterion 1.3.2 due to changing the meaning of content by positioning information with CSS](https://www.w3.org/WAI/WCAG21/Techniques/failures/F1).    **Is it possible to adjust the position of the dynamic content container to be a sibling of the activator?**    This would be a big win for accessibility, not only for Shopify components built with Portals, but for all platforms.",
        "human_words": "**Components built with Portals include accessibility defects leading to poor usability/task abandonment.**    During accessibility audits and usability testing of Shopify components, we\u2019ve noticed a prominent defect with components built with Portals; DOM structure.    Portals sets dynamically generated content containers at the bottom of the DOM. This is fine for modal window components since keyboard focus is explicitly placed on/within the modal container. The Portals documentation even calls this out and links to APG for more documentation.    The issue lies with other component patterns; [disclosures](https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/) (popovers, drop-down navigation, etc,) [comboboxes](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/), [tooltips](https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/), etc. The expectation for these components is for focus to **remain** on the activator and for dynamic content containers to appear **next** in the DOM, a direct sibling to the related activator control.    For example, during usability testing, testers struggled to use one such component which was built using Portals. When the dynamic container appeared after interacting with the activator, testers would move their screen reader virtual cursor forward from the activator, expecting to interact with the dynamic content. Instead, the cursor moved \"underneath\" the container, bypassing the content, to the next (unrelated) item in the DOM. This led to a confusing user experience.    In addition, this issue is a violation of WCAG [1.3.2: Meaningful Sequence](https://www.w3.org/WAI/WCAG21/Understanding/meaningful-sequence.html) (Level A.) Specifically, [Failure of Success Criterion 1.3.2 due to changing the meaning of content by positioning information with CSS](https://www.w3.org/WAI/WCAG21/Techniques/failures/F1).    **Is it possible to adjust the position of the dynamic content container to be a sibling of the activator?**    This would be a big win for accessibility, not only for Shopify components built with Portals, but for all platforms.",
        "human_words_regrex": "**Components built with Portals include accessibility defects leading to poor usability/task abandonment.** During accessibility audits and usability testing of Shopify components, we\u2019ve noticed a prominent defect with components built with Portals; DOM structure. Portals sets dynamically generated content containers at the bottom of the DOM. This is fine for modal window components since keyboard focus is explicitly placed on/within the modal container. The Portals documentation even calls this out and links to APG for more documentation. The issue lies with other component patterns;  (popovers, drop-down navigation, etc,) , , etc. The expectation for these components is for focus to **remain** on the activator and for dynamic content containers to appear **next** in the DOM, a direct sibling to the related activator control. For example, during usability testing, testers struggled to use one such component which was built using Portals. When the dynamic container appeared after interacting with the activator, testers would move their screen reader virtual cursor forward from the activator, expecting to interact with the dynamic content. Instead, the cursor moved \"underneath\" the container, bypassing the content, to the next (unrelated) item in the DOM. This led to a confusing user experience. In addition, this issue is a violation of WCAG  (Level A.) Specifically, . **Is it possible to adjust the position of the dynamic content container to be a sibling of the activator?** This would be a big win for accessibility, not only for Shopify components built with Portals, but for all platforms.",
        "human_words_stopwords_removal_lemmatization": "* * component built portal include accessibility defect leading poor usability/task abandonment . * * accessibility audit usability testing shopify component , \u2019 noticed prominent defect component built portal ; dom structure . portal set dynamically generated content container bottom dom . fine modal window component since keyboard focus explicitly placed on/within modal container . portal documentation even call link apg documentation . issue lie component pattern ; ( popover , drop-down navigation , etc , ) , , etc . expectation component focus * * remain * * activator dynamic content container appear * * next * * dom , direct sibling related activator control . example , usability testing , tester struggled use one component built using portal . dynamic container appeared interacting activator , tester would move screen reader virtual cursor forward activator , expecting interact dynamic content . instead , cursor moved `` underneath '' container , bypassing content , next ( unrelated ) item dom . led confusing user experience . addition , issue violation wcag ( level . ) specifically , . * * possible adjust position dynamic content container sibling activator ? * * would big win accessibility , shopify component built portal , platform .",
        "title_stopwords_removal_lemmatization": "[ portal ] dom order accessibility"
    },
    {
        "issue_id": 1199041750,
        "title": "Suggestion: Process higher priority renders after each useEffect callback",
        "label": [
            "Type: Discussion"
        ],
        "date": "2022-04-10T13:51:41Z",
        "status": "open",
        "description": "## React Version: 18\r\n## Steps to Reproduce:\r\nUsing the classic useDeferredValue demo which shows how an input can be responsive even when components have a slow render,  place the delay (loop) in a useEffect callback rather than in the render itself.  This can be demonstrated in this [sandbox](https://codesandbox.io/s/quirky-hofstadter-h8yvu1?file=/src/App.js).  When you check the box to make the delay in the useEffect rather than the render function the input is no longer responsive. \r\n## Current Behavior\r\nThe input is not responsive because all useEffect callbacks run to completion before the higher priority render of the input component can occur.\r\n## Expected  Behavior\r\nThe input remains responsive as the high priority render occurs after the completion of each useEffect callback.\r\n## Related\r\n While this example is contrived, a real example, where the problem was uncovered, is a fractal application that by necessity does it's canvas processing in a useEffect callback.\r\n",
        "remove_template_description": "## React Version: 18  ## Steps to Reproduce:  Using the classic useDeferredValue demo which shows how an input can be responsive even when components have a slow render,  place the delay (loop) in a useEffect callback rather than in the render itself.  This can be demonstrated in this [sandbox](https://codesandbox.io/s/quirky-hofstadter-h8yvu1?file=/src/App.js).  When you check the box to make the delay in the useEffect rather than the render function the input is no longer responsive.   ## Current Behavior  The input is not responsive because all useEffect callbacks run to completion before the higher priority render of the input component can occur.  ## Expected  Behavior  The input remains responsive as the high priority render occurs after the completion of each useEffect callback.  ## Related   While this example is contrived, a real example, where the problem was uncovered, is a fractal application that by necessity does it's canvas processing in a useEffect callback.",
        "human_words": "## React Version: 18  ## Steps to Reproduce:  Using the classic useDeferredValue demo which shows how an input can be responsive even when components have a slow render,  place the delay (loop) in a useEffect callback rather than in the render itself.  This can be demonstrated in this [sandbox](https://codesandbox.io/s/quirky-hofstadter-h8yvu1?file=/src/App.js).  When you check the box to make the delay in the useEffect rather than the render function the input is no longer responsive.   ## Current Behavior  The input is not responsive because all useEffect callbacks run to completion before the higher priority render of the input component can occur.  ## Expected  Behavior  The input remains responsive as the high priority render occurs after the completion of each useEffect callback.  ## Related   While this example is contrived, a real example, where the problem was uncovered, is a fractal application that by necessity does it's canvas processing in a useEffect callback.",
        "human_words_regrex": "## React Version: 18 ## Steps to Reproduce: Using the classic useDeferredValue demo which shows how an input can be responsive even when components have a slow render, place the delay (loop) in a useEffect callback rather than in the render itself. This can be demonstrated in this . When you check the box to make the delay in the useEffect rather than the render function the input is no longer responsive. ## Current Behavior The input is not responsive because all useEffect callbacks run to completion before the higher priority render of the input component can occur. ## Expected Behavior The input remains responsive as the high priority render occurs after the completion of each useEffect callback. ## Related While this example is contrived, a real example, where the problem was uncovered, is a fractal application that by necessity does it's canvas processing in a useEffect callback.",
        "human_words_stopwords_removal_lemmatization": "# # react version : 18 # # step reproduce : using classic usedeferredvalue demo show input responsive even component slow render , place delay ( loop ) useeffect callback rather render . demonstrated . check box make delay useeffect rather render function input longer responsive . # # current behavior input responsive useeffect callback run completion higher priority render input component occur . # # expected behavior input remains responsive high priority render occurs completion useeffect callback . # # related example contrived , real example , problem uncovered , fractal application necessity 's canvas processing useeffect callback .",
        "title_stopwords_removal_lemmatization": "suggestion : process higher priority render useeffect callback"
    },
    {
        "issue_id": 1196695161,
        "title": "Bug: React 18 types broken since the type release a view hours ago",
        "label": [
            "Type: Discussion"
        ],
        "date": "2022-04-08T00:37:44Z",
        "status": "closed",
        "description": "### Edit: If you have issues but you did NOT upgrade to 18, or if you upgraded but get confusing errors from dependencies, the problem is likely that some library (incorrectly) specifies `@types/react` as a dependency with version `*` rather than an optional peer dependency. Find which library it is and file an issue for it. See https://github.com/facebook/react/issues/24304#issuecomment-1094565891 for diagnostics and common workarounds. \r\n\r\nA few hours ago, a major version of React types for Typescript was released.\r\n\r\nI have tried to test this right away to see if there are any changes that require adaptation in my own projects.\r\n\r\nDue to a very large number of users using React's type library (we use fundamental types like React.FC by the hundreds in our own projects), it's reasonable to question whether there's been a small mistake here.\r\n\r\nSpecifically, the following type declaration still exists in the 18 release.\r\n\r\n```\r\ntype PropsWithChildren<P> = P & { children?: ReactNode | undefined };\r\n```\r\n\r\nHowever, this is no longer used in the library, at least not when looking at the diff\r\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/commit/55dc209ceb6dbcd59c4c68cc8dfb77faadd9de12\r\n\r\nA quick search on Github yields millions of hits that use the type alias React.FC to the actual type React.FunctionalComponent.\r\n\r\nBefore \r\n```\r\ninterface FunctionComponent<P = {}> {\r\n      (props: PropsWithChildren<P>, context?: any): ReactElement<any, any> | null;\r\n      ...\r\n}\r\n```\r\n\r\nNow\r\n```\r\ninterface FunctionComponent<P = {}> {\r\n      (props: P, context?: any): ReactElement<any, any> | null;\r\n}\r\n```\r\n\r\nI think matching very, very many places in a single project doesn't seem to do justice to the change made; always the property children?: ReactNode to be redefined is definitely too much effort.\r\n\r\n**Positions at which PropsWithChildren were used before** \r\n- FunctionComponent, as shown in the example\r\n- ForwardRefRenderFunction,\r\n- und das Funktions-Interface propsAreEqual von memo\r\n\r\nThx!",
        "remove_template_description": "### Edit: If you have issues but you did NOT upgrade to 18, or if you upgraded but get confusing errors from dependencies, the problem is likely that some library (incorrectly) specifies `@types/react` as a dependency with version `*` rather than an optional peer dependency. Find which library it is and file an issue for it. See https://github.com/facebook/react/issues/24304#issuecomment-1094565891 for diagnostics and common workarounds.     A few hours ago, a major version of React types for Typescript was released.    I have tried to test this right away to see if there are any changes that require adaptation in my own projects.    Due to a very large number of users using React's type library (we use fundamental types like React.FC by the hundreds in our own projects), it's reasonable to question whether there's been a small mistake here.    Specifically, the following type declaration still exists in the 18 release.    ```  type PropsWithChildren<P> = P & { children?: ReactNode | undefined };  ```    However, this is no longer used in the library, at least not when looking at the diff  https://github.com/DefinitelyTyped/DefinitelyTyped/commit/55dc209ceb6dbcd59c4c68cc8dfb77faadd9de12    A quick search on Github yields millions of hits that use the type alias React.FC to the actual type React.FunctionalComponent.    Before   ```  interface FunctionComponent<P = {}> {        (props: PropsWithChildren<P>, context?: any): ReactElement<any, any> | null;        ...  }  ```    Now  ```  interface FunctionComponent<P = {}> {        (props: P, context?: any): ReactElement<any, any> | null;  }  ```    I think matching very, very many places in a single project doesn't seem to do justice to the change made; always the property children?: ReactNode to be redefined is definitely too much effort.    **Positions at which PropsWithChildren were used before**   - FunctionComponent, as shown in the example  - ForwardRefRenderFunction,  - und das Funktions-Interface propsAreEqual von memo    Thx!",
        "human_words": "### Edit: If you have issues but you did NOT upgrade to 18, or if you upgraded but get confusing errors from dependencies, the problem is likely that some library (incorrectly) specifies `@types/react` as a dependency with version `*` rather than an optional peer dependency. Find which library it is and file an issue for it. See https://github.com/facebook/react/issues/24304#issuecomment-1094565891 for diagnostics and common workarounds.     A few hours ago, a major version of React types for Typescript was released.    I have tried to test this right away to see if there are any changes that require adaptation in my own projects.    Due to a very large number of users using React's type library (we use fundamental types like React.FC by the hundreds in our own projects), it's reasonable to question whether there's been a small mistake here.    Specifically, the following type declaration still exists in the 18 release.        However, this is no longer used in the library, at least not when looking at the diff  https://github.com/DefinitelyTyped/DefinitelyTyped/commit/55dc209ceb6dbcd59c4c68cc8dfb77faadd9de12    A quick search on Github yields millions of hits that use the type alias React.FC to the actual type React.FunctionalComponent.    Before       Now      I think matching very, very many places in a single project doesn't seem to do justice to the change made; always the property children?: ReactNode to be redefined is definitely too much effort.    **Positions at which PropsWithChildren were used before**   - FunctionComponent, as shown in the example  - ForwardRefRenderFunction,  - und das Funktions-Interface propsAreEqual von memo    Thx!",
        "human_words_regrex": "### Edit: If you have issues but you did NOT upgrade to 18, or if you upgraded but get confusing errors from dependencies, the problem is likely that some library (incorrectly) specifies `@types/react` as a dependency with version `*` rather than an optional peer dependency. Find which library it is and file an issue for it. See  for diagnostics and common workarounds. A few hours ago, a major version of React types for Typescript was released. I have tried to test this right away to see if there are any changes that require adaptation in my own projects. Due to a very large number of users using React's type library (we use fundamental types like React.FC by the hundreds in our own projects), it's reasonable to question whether there's been a small mistake here. Specifically, the following type declaration still exists in the 18 release. However, this is no longer used in the library, at least not when looking at the diff  A quick search on Github yields millions of hits that use the type alias React.FC to the actual type React.FunctionalComponent. Before Now I think matching very, very many places in a single project doesn't seem to do justice to the change made; always the property children?: ReactNode to be redefined is definitely too much effort. **Positions at which PropsWithChildren were used before** - FunctionComponent, as shown in the example - ForwardRefRenderFunction, - und das Funktions-Interface propsAreEqual von memo Thx!",
        "human_words_stopwords_removal_lemmatization": "# # # edit : issue upgrade 18 , upgraded get confusing error dependency , problem likely library ( incorrectly ) specifies ` @ types/react ` dependency version ` * ` rather optional peer dependency . find library file issue . see diagnostics common workarounds . hour ago , major version react type typescript released . tried test right away see change require adaptation project . due large number user using react 's type library ( use fundamental type like react.fc hundred project ) , 's reasonable question whether 's small mistake . specifically , following type declaration still exists 18 release . however , longer used library , least looking diff quick search github yield million hit use type alias react.fc actual type react.functionalcomponent . think matching , many place single project n't seem justice change made ; always property child ? : reactnode redefined definitely much effort . * * position propswithchildren used * * - functioncomponent , shown example - forwardrefrenderfunction , - und da funktions-interface propsareequal von memo thx !",
        "title_stopwords_removal_lemmatization": "bug : react 18 type broken since type release view hour ago"
    },
    {
        "issue_id": 1188107507,
        "title": "Server-side rendering performance degradation with renderToPipeableStream",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-31T13:46:59Z",
        "status": "open",
        "description": "Hello!\r\n\r\nWhen switching from `renderToString` to `renderToPipeableStream`, I run load tests on the application, and found a decrease in server throughput, from 50 to 15 RPS, and an increase in response timings.\r\nWhen profiling the CPU, I see a large overhead on the internal work of the stream, specifically the methods `Writable.write` and `Writable.uncork`. \r\nAll these method calls together take more than twice as much CPU time (about 50-60ms) as rendering my test page (about 15-20ms)\r\n\r\nAlso, I don't want to give the HTML to the client in the stream, this approach has some disadvantages.\r\nSo I have to buffer the data, and it slows down the application a bit more.\r\n\r\nCPU profiler in production mode:\r\n- [CPU-react-18-prod.cpuprofile.zip](https://github.com/facebook/react/files/8389879/CPU-react-18-prod.cpuprofile.zip)\r\n<img width=\"1792\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 00\" src=\"https://user-images.githubusercontent.com/15360667/161067856-6f3a2573-d49a-4f9b-ab8c-732f1f2f5afe.png\">\r\n\r\nCPU profiler in development mode:\r\n- [CPU-react-18-dev.cpuprofile.zip](https://github.com/facebook/react/files/8389878/CPU-react-18-dev.cpuprofile.zip)\r\n<img width=\"1789\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 36\" src=\"https://user-images.githubusercontent.com/15360667/161067867-fb934850-5267-4b67-8c3b-1a407de7a004.png\">\r\n\r\nMy custom Writable stream with buffering:\r\n\r\n```js\r\nclass HtmlWritable extends Writable {\r\n  chunks = [];\r\n  html = '';\r\n\r\n  getHtml() {\r\n    return this.html;\r\n  }\r\n\r\n  _write(chunk, encoding, callback) {\r\n    this.chunks.push(chunk);\r\n    callback();\r\n  }\r\n\r\n  _final(callback) {\r\n    this.html = Buffer.concat(this.chunks).toString();\r\n    callback();\r\n  }\r\n}\r\n```\r\n\r\nAnd rendering flow:\r\n\r\n```js\r\nimport { renderToPipeableStream } from 'react-dom/server';\r\n \r\nnew Promise((resolve, reject) => {\r\n  const htmlWritable = new HtmlWritable();\r\n\r\n  const { pipe, abort } = renderToPipeableStream(renderResult, {\r\n    onAllReady() {\r\n      pipe(htmlWritable);\r\n    },\r\n    onError(error) {\r\n      reject(error);\r\n    },\r\n  });\r\n\r\n  htmlWritable.on('finish', () => {\r\n    resolve(htmlWritable.getHtml());\r\n  });\r\n});\r\n```",
        "remove_template_description": "Hello!    When switching from `renderToString` to `renderToPipeableStream`, I run load tests on the application, and found a decrease in server throughput, from 50 to 15 RPS, and an increase in response timings.  When profiling the CPU, I see a large overhead on the internal work of the stream, specifically the methods `Writable.write` and `Writable.uncork`.   All these method calls together take more than twice as much CPU time (about 50-60ms) as rendering my test page (about 15-20ms)    Also, I don't want to give the HTML to the client in the stream, this approach has some disadvantages.  So I have to buffer the data, and it slows down the application a bit more.    CPU profiler in production mode:  - [CPU-react-18-prod.cpuprofile.zip](https://github.com/facebook/react/files/8389879/CPU-react-18-prod.cpuprofile.zip)  <img width=\"1792\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 00\" src=\"https://user-images.githubusercontent.com/15360667/161067856-6f3a2573-d49a-4f9b-ab8c-732f1f2f5afe.png\">    CPU profiler in development mode:  - [CPU-react-18-dev.cpuprofile.zip](https://github.com/facebook/react/files/8389878/CPU-react-18-dev.cpuprofile.zip)  <img width=\"1789\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 36\" src=\"https://user-images.githubusercontent.com/15360667/161067867-fb934850-5267-4b67-8c3b-1a407de7a004.png\">    My custom Writable stream with buffering:    ```js  class HtmlWritable extends Writable {    chunks = [];    html = '';      getHtml() {      return this.html;    }      _write(chunk, encoding, callback) {      this.chunks.push(chunk);      callback();    }      _final(callback) {      this.html = Buffer.concat(this.chunks).toString();      callback();    }  }  ```    And rendering flow:    ```js  import { renderToPipeableStream } from 'react-dom/server';     new Promise((resolve, reject) => {    const htmlWritable = new HtmlWritable();      const { pipe, abort } = renderToPipeableStream(renderResult, {      onAllReady() {        pipe(htmlWritable);      },      onError(error) {        reject(error);      },    });      htmlWritable.on('finish', () => {      resolve(htmlWritable.getHtml());    });  });  ```",
        "human_words": "Hello!    When switching from `renderToString` to `renderToPipeableStream`, I run load tests on the application, and found a decrease in server throughput, from 50 to 15 RPS, and an increase in response timings.  When profiling the CPU, I see a large overhead on the internal work of the stream, specifically the methods `Writable.write` and `Writable.uncork`.   All these method calls together take more than twice as much CPU time (about 50-60ms) as rendering my test page (about 15-20ms)    Also, I don't want to give the HTML to the client in the stream, this approach has some disadvantages.  So I have to buffer the data, and it slows down the application a bit more.    CPU profiler in production mode:  - [CPU-react-18-prod.cpuprofile.zip](https://github.com/facebook/react/files/8389879/CPU-react-18-prod.cpuprofile.zip)  <img width=\"1792\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 00\" src=\"https://user-images.githubusercontent.com/15360667/161067856-6f3a2573-d49a-4f9b-ab8c-732f1f2f5afe.png\">    CPU profiler in development mode:  - [CPU-react-18-dev.cpuprofile.zip](https://github.com/facebook/react/files/8389878/CPU-react-18-dev.cpuprofile.zip)  <img width=\"1789\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 36\" src=\"https://user-images.githubusercontent.com/15360667/161067867-fb934850-5267-4b67-8c3b-1a407de7a004.png\">    My custom Writable stream with buffering:        And rendering flow:    ",
        "human_words_regrex": "Hello! When switching from `renderToString` to `renderToPipeableStream`, I run load tests on the application, and found a decrease in server throughput, from 50 to 15 RPS, and an increase in response timings. When profiling the CPU, I see a large overhead on the internal work of the stream, specifically the methods `Writable.write` and `Writable.uncork`. All these method calls together take more than twice as much CPU time (about 50-60ms) as rendering my test page (about 15-20ms) Also, I don't want to give the HTML to the client in the stream, this approach has some disadvantages. So I have to buffer the data, and it slows down the application a bit more. CPU profiler in production mode: -  <img width=\"1792\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 00\" src=\" CPU profiler in development mode: -  <img width=\"1789\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 36\" src=\" My custom Writable stream with buffering: And rendering flow: ",
        "human_words_stopwords_removal_lemmatization": "hello ! switching ` rendertostring ` ` rendertopipeablestream ` , run load test application , found decrease server throughput , 50 15 rps , increase response timing . profiling cpu , see large overhead internal work stream , specifically method ` writable.write ` ` writable.uncork ` . method call together take twice much cpu time ( 50-60ms ) rendering test page ( 15-20ms ) also , n't want give html client stream , approach disadvantage . buffer data , slows application bit . cpu profiler production mode : - < img width= '' 1792 '' alt= '' \u0441\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 00 '' src= '' cpu profiler development mode : - < img width= '' 1789 '' alt= '' \u0441\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-03-31 \u0432 16 21 36 '' src= '' custom writable stream buffering : rendering flow :",
        "title_stopwords_removal_lemmatization": "server-side rendering performance degradation rendertopipeablestream"
    },
    {
        "issue_id": 1186770178,
        "title": "Improve DevTools protocol version handling",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2022-03-30T17:26:49Z",
        "status": "open",
        "description": "# How does DevTools work and what is the \"protocol version\"?\r\n\r\nThe React DevTools extension consists of multiple pieces:\r\n* The **frontend** portion is the extension you see (the Components tree, the Profiler, etc.).\r\n* The **backend** portion is invisible. It runs in the same context as React itself.\r\n\r\nThe frontend displays the current React tree, but it has no way to observe the tree directly because it runs in different memory space. It relies on the backend to describe the tree by sending \"messages\" through an API like [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\r\n\r\nThe most optimized way for the backend to share the state of the React tree is to send a small packet of [\"op codes\"](https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#serializing-the-tree) whenever the tree changes (e.g. whenever React DOM modifies the page). These \"op codes\" are just an array of numbers which correspond to _operations_ like \"add something to the tree\" or \"remove something from the tree\". For example, the operation to add a component to the tree might look like this:\r\n```js\r\n[\r\n  // ...\r\n  1,   // number 1 signifies an \"add\" operation\r\n  2,   // component id\r\n  1,   // type: class component\r\n  1,   // parent id\r\n  0,   // owner id\r\n  1,   // id of component display name (corresponds to the string table)\r\n  0,   // id of key string in the string table (zero indicates no key)\r\n  // ...\r\n]\r\n```\r\n\r\nThe format described above is highly optimized but also inflexible. (For example, if the backend needs to add an additional piece of information to the above operation, the frontend needs to also know to advance its index within the operations array by one additional place.)\r\n\r\nDevTools version 4.13 introduced the concept of a [_protocol version number_](https://github.com/facebook/react/pull/21331) to allow the frontend to ask the backend which version of the protcol it used. In hindsight, **this number should have included in the operations array itself** (as the first digit).\r\n\r\n# The current problem\r\nGenerally the DevTools frontend and backend pieces are bundled together. For example, the most common DevTools surface\u2013 the browser extension\u2013 ships both pieces together and _injects_ the backend into the page during initialization. However there are some less common targets are not so tightly coupled\u2013 such as React Native (which embeds the backend into the application itself) or [Replay](https://replay.io/) (which records the backend \"operations\" array as part of its session data). In these cases, the frontend (UI) launched by the user (or embedded in the Replay player) may depend on an **incompatible protocol**.\r\n\r\nThis results in errors like #24142 and #23307 (and even https://github.com/RecordReplay/devtools/issues/5344):\r\n<img width=\"791\" alt=\"React DevTools Unsupported Bridge operation error\" src=\"https://user-images.githubusercontent.com/29597/160892306-2bac3e5f-7bcc-4194-8a4d-4f2eecee618d.png\">\r\n\r\n# Potential solutions\r\nAs mentioned above, **the protocol version should have included in the operations array itself** (as the first digit). We should fix this when we eventually make a major breaking change (aka DevTools version 5) but in the meanwhile, maybe there's a way we can improve the current situation.\r\n\r\nSome changes have already been made to support older protocol versions when possible (#24093) and to more clearly communicate _the reason_ for the error when that is not possible (#24147) but perhaps there's more still that we could do?\r\n\r\n## Option 1: Add protocol version to the start of the \"operations\" array\r\nWe could retroactively update the \"operations\" array to always begin with the protocol version number.\r\n\r\nWe'd need a way to _detect_ this though (to distinguish this _newer_ message format from older ones). Currently, each \"operations\" message begins with two numbers\u2013 representing the renderer and the root (tree root). For example:\r\n```js\r\n// Older message format\r\n[\r\n  3, // renderer id\r\n  1, // (tree) root element id\r\n  0, // string table size\r\n  // operations ...\r\n]\r\n```\r\n\r\nSince the current operations array starts with a positive integer (the renderer ID) it would be ambiguous to insert another positive integer (the bridge protocol version). For this reason, I propose inserting _two_ new numbers to the start of the operations array: The first one being `0` (so we can reliably detect the newer format) and the second one being the protocol version. For example:\r\n```js\r\n// Newer message format\r\n[\r\n  0, // signifies the newer operations array format\r\n  2, // bridge protocol version\r\n  3, // renderer id\r\n  1, // (tree) root element id\r\n  0, // string table size\r\n  // operations ...\r\n]\r\n```\r\n\r\nThe frontend could then reliably distinguish between these two backend formats:\r\n```js\r\n[3,1,0,...] // old format\r\n[0,2,3,1,0,...] // new format\r\n```\r\n\r\n* **Pros**:\r\n  * Would enable DevTools to get rid of the separate protocol version request method and more easily differentiate between different versions of the operations array when parsing.\r\n  * Would also enable newer DevTools frontends to parse recorded operations arrays from older backends (e.g. the Replay case).\r\n* **Cons**:\r\n  * Would require us to retroactively publish patch updates to older backend releases.\r\n  * Older frontends wouldn't support this change\u2013 and would error. (Although this is arguably no worse than the current situation.)\r\n\r\n## Option 2: Automatically fall back to support older protocols\r\nWe could leave the current architecture in place (at least until version 5) but in the case of a protocol error (`UnsupportedBridgeOperationError`) we could have DevTools try to automatically force-downgrade replay the \"operations\" array with the assumption of an older protocol version number.\r\n\r\nThis is essentially how things already work for the React Native case, (as of version [4.24.1](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#4241)), but formalizing it would expand to also cover usecases like Replay.\r\n* **Pros**:\r\n  * Works with pre-existing DevTools backends.\r\n* **Cons**:\r\n  * Adds code complexity.\r\n\r\n## Option 3: User configurable protocol version number\r\nWe could leave the current architecture in place (at least until version 5) but provide some sort of UI mechanism to allow users to override the default assumed protocol version number.\r\n* **Pros**:\r\n  * Works with pre-existing DevTools backends.\r\n* **Cons**:\r\n  * Poor/confusing UX.\r\n\r\n# Solutions not considered\r\nOne solution _not_ mentined above would be to add a new message type (e.g. \"new-operations\") that begins with the bridge protocol version number. Newer frontends could listen for this message, but still fall back to listening for the old message (\"operations\"). Older frontends would continue to listen to the older message and not break (at least not in any new way).\r\n\r\nThe reason I think this solution is probably not worth pursuing is that it would double the amount of information the backend sends to the frontend via e.g. `postMessage` during performance-sensitive times. One of the main goals of the new DevTools was to reduce this kind of overhead, so I don't think that's worth compromising on.\r\n\r\nA variation of this might be for backends to send the newer message type (e.g. \"new-operations\") _only_ and no longer continue to send the \"operations\" message. This would avoid the perfromance problem but would leave older frontends in a broken state (perpetually waiting on the \"operations\" array that is never sent).",
        "remove_template_description": "# How does DevTools work and what is the \"protocol version\"?    The React DevTools extension consists of multiple pieces:  * The **frontend** portion is the extension you see (the Components tree, the Profiler, etc.).  * The **backend** portion is invisible. It runs in the same context as React itself.    The frontend displays the current React tree, but it has no way to observe the tree directly because it runs in different memory space. It relies on the backend to describe the tree by sending \"messages\" through an API like [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).    The most optimized way for the backend to share the state of the React tree is to send a small packet of [\"op codes\"](https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#serializing-the-tree) whenever the tree changes (e.g. whenever React DOM modifies the page). These \"op codes\" are just an array of numbers which correspond to _operations_ like \"add something to the tree\" or \"remove something from the tree\". For example, the operation to add a component to the tree might look like this:  ```js  [    // ...    1,   // number 1 signifies an \"add\" operation    2,   // component id    1,   // type: class component    1,   // parent id    0,   // owner id    1,   // id of component display name (corresponds to the string table)    0,   // id of key string in the string table (zero indicates no key)    // ...  ]  ```    The format described above is highly optimized but also inflexible. (For example, if the backend needs to add an additional piece of information to the above operation, the frontend needs to also know to advance its index within the operations array by one additional place.)    DevTools version 4.13 introduced the concept of a [_protocol version number_](https://github.com/facebook/react/pull/21331) to allow the frontend to ask the backend which version of the protcol it used. In hindsight, **this number should have included in the operations array itself** (as the first digit).    # The current problem  Generally the DevTools frontend and backend pieces are bundled together. For example, the most common DevTools surface\u2013 the browser extension\u2013 ships both pieces together and _injects_ the backend into the page during initialization. However there are some less common targets are not so tightly coupled\u2013 such as React Native (which embeds the backend into the application itself) or [Replay](https://replay.io/) (which records the backend \"operations\" array as part of its session data). In these cases, the frontend (UI) launched by the user (or embedded in the Replay player) may depend on an **incompatible protocol**.    This results in errors like #24142 and #23307 (and even https://github.com/RecordReplay/devtools/issues/5344):  <img width=\"791\" alt=\"React DevTools Unsupported Bridge operation error\" src=\"https://user-images.githubusercontent.com/29597/160892306-2bac3e5f-7bcc-4194-8a4d-4f2eecee618d.png\">    # Potential solutions  As mentioned above, **the protocol version should have included in the operations array itself** (as the first digit). We should fix this when we eventually make a major breaking change (aka DevTools version 5) but in the meanwhile, maybe there's a way we can improve the current situation.    Some changes have already been made to support older protocol versions when possible (#24093) and to more clearly communicate _the reason_ for the error when that is not possible (#24147) but perhaps there's more still that we could do?    ## Option 1: Add protocol version to the start of the \"operations\" array  We could retroactively update the \"operations\" array to always begin with the protocol version number.    We'd need a way to _detect_ this though (to distinguish this _newer_ message format from older ones). Currently, each \"operations\" message begins with two numbers\u2013 representing the renderer and the root (tree root). For example:  ```js  // Older message format  [    3, // renderer id    1, // (tree) root element id    0, // string table size    // operations ...  ]  ```    Since the current operations array starts with a positive integer (the renderer ID) it would be ambiguous to insert another positive integer (the bridge protocol version). For this reason, I propose inserting _two_ new numbers to the start of the operations array: The first one being `0` (so we can reliably detect the newer format) and the second one being the protocol version. For example:  ```js  // Newer message format  [    0, // signifies the newer operations array format    2, // bridge protocol version    3, // renderer id    1, // (tree) root element id    0, // string table size    // operations ...  ]  ```    The frontend could then reliably distinguish between these two backend formats:  ```js  [3,1,0,...] // old format  [0,2,3,1,0,...] // new format  ```    * **Pros**:    * Would enable DevTools to get rid of the separate protocol version request method and more easily differentiate between different versions of the operations array when parsing.    * Would also enable newer DevTools frontends to parse recorded operations arrays from older backends (e.g. the Replay case).  * **Cons**:    * Would require us to retroactively publish patch updates to older backend releases.    * Older frontends wouldn't support this change\u2013 and would error. (Although this is arguably no worse than the current situation.)    ## Option 2: Automatically fall back to support older protocols  We could leave the current architecture in place (at least until version 5) but in the case of a protocol error (`UnsupportedBridgeOperationError`) we could have DevTools try to automatically force-downgrade replay the \"operations\" array with the assumption of an older protocol version number.    This is essentially how things already work for the React Native case, (as of version [4.24.1](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#4241)), but formalizing it would expand to also cover usecases like Replay.  * **Pros**:    * Works with pre-existing DevTools backends.  * **Cons**:    * Adds code complexity.    ## Option 3: User configurable protocol version number  We could leave the current architecture in place (at least until version 5) but provide some sort of UI mechanism to allow users to override the default assumed protocol version number.  * **Pros**:    * Works with pre-existing DevTools backends.  * **Cons**:    * Poor/confusing UX.    # Solutions not considered  One solution _not_ mentined above would be to add a new message type (e.g. \"new-operations\") that begins with the bridge protocol version number. Newer frontends could listen for this message, but still fall back to listening for the old message (\"operations\"). Older frontends would continue to listen to the older message and not break (at least not in any new way).    The reason I think this solution is probably not worth pursuing is that it would double the amount of information the backend sends to the frontend via e.g. `postMessage` during performance-sensitive times. One of the main goals of the new DevTools was to reduce this kind of overhead, so I don't think that's worth compromising on.    A variation of this might be for backends to send the newer message type (e.g. \"new-operations\") _only_ and no longer continue to send the \"operations\" message. This would avoid the perfromance problem but would leave older frontends in a broken state (perpetually waiting on the \"operations\" array that is never sent).",
        "human_words": "# How does DevTools work and what is the \"protocol version\"?    The React DevTools extension consists of multiple pieces:  * The **frontend** portion is the extension you see (the Components tree, the Profiler, etc.).  * The **backend** portion is invisible. It runs in the same context as React itself.    The frontend displays the current React tree, but it has no way to observe the tree directly because it runs in different memory space. It relies on the backend to describe the tree by sending \"messages\" through an API like [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).    The most optimized way for the backend to share the state of the React tree is to send a small packet of [\"op codes\"](https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#serializing-the-tree) whenever the tree changes (e.g. whenever React DOM modifies the page). These \"op codes\" are just an array of numbers which correspond to _operations_ like \"add something to the tree\" or \"remove something from the tree\". For example, the operation to add a component to the tree might look like this:      The format described above is highly optimized but also inflexible. (For example, if the backend needs to add an additional piece of information to the above operation, the frontend needs to also know to advance its index within the operations array by one additional place.)    DevTools version 4.13 introduced the concept of a [_protocol version number_](https://github.com/facebook/react/pull/21331) to allow the frontend to ask the backend which version of the protcol it used. In hindsight, **this number should have included in the operations array itself** (as the first digit).    # The current problem  Generally the DevTools frontend and backend pieces are bundled together. For example, the most common DevTools surface\u2013 the browser extension\u2013 ships both pieces together and _injects_ the backend into the page during initialization. However there are some less common targets are not so tightly coupled\u2013 such as React Native (which embeds the backend into the application itself) or [Replay](https://replay.io/) (which records the backend \"operations\" array as part of its session data). In these cases, the frontend (UI) launched by the user (or embedded in the Replay player) may depend on an **incompatible protocol**.    This results in errors like #24142 and #23307 (and even https://github.com/RecordReplay/devtools/issues/5344):  <img width=\"791\" alt=\"React DevTools Unsupported Bridge operation error\" src=\"https://user-images.githubusercontent.com/29597/160892306-2bac3e5f-7bcc-4194-8a4d-4f2eecee618d.png\">    # Potential solutions  As mentioned above, **the protocol version should have included in the operations array itself** (as the first digit). We should fix this when we eventually make a major breaking change (aka DevTools version 5) but in the meanwhile, maybe there's a way we can improve the current situation.    Some changes have already been made to support older protocol versions when possible (#24093) and to more clearly communicate _the reason_ for the error when that is not possible (#24147) but perhaps there's more still that we could do?    ## Option 1: Add protocol version to the start of the \"operations\" array  We could retroactively update the \"operations\" array to always begin with the protocol version number.    We'd need a way to _detect_ this though (to distinguish this _newer_ message format from older ones). Currently, each \"operations\" message begins with two numbers\u2013 representing the renderer and the root (tree root). For example:      Since the current operations array starts with a positive integer (the renderer ID) it would be ambiguous to insert another positive integer (the bridge protocol version). For this reason, I propose inserting _two_ new numbers to the start of the operations array: The first one being `0` (so we can reliably detect the newer format) and the second one being the protocol version. For example:      The frontend could then reliably distinguish between these two backend formats:      * **Pros**:    * Would enable DevTools to get rid of the separate protocol version request method and more easily differentiate between different versions of the operations array when parsing.    * Would also enable newer DevTools frontends to parse recorded operations arrays from older backends (e.g. the Replay case).  * **Cons**:    * Would require us to retroactively publish patch updates to older backend releases.    * Older frontends wouldn't support this change\u2013 and would error. (Although this is arguably no worse than the current situation.)    ## Option 2: Automatically fall back to support older protocols  We could leave the current architecture in place (at least until version 5) but in the case of a protocol error (`UnsupportedBridgeOperationError`) we could have DevTools try to automatically force-downgrade replay the \"operations\" array with the assumption of an older protocol version number.    This is essentially how things already work for the React Native case, (as of version [4.24.1](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#4241)), but formalizing it would expand to also cover usecases like Replay.  * **Pros**:    * Works with pre-existing DevTools backends.  * **Cons**:    * Adds code complexity.    ## Option 3: User configurable protocol version number  We could leave the current architecture in place (at least until version 5) but provide some sort of UI mechanism to allow users to override the default assumed protocol version number.  * **Pros**:    * Works with pre-existing DevTools backends.  * **Cons**:    * Poor/confusing UX.    # Solutions not considered  One solution _not_ mentined above would be to add a new message type (e.g. \"new-operations\") that begins with the bridge protocol version number. Newer frontends could listen for this message, but still fall back to listening for the old message (\"operations\"). Older frontends would continue to listen to the older message and not break (at least not in any new way).    The reason I think this solution is probably not worth pursuing is that it would double the amount of information the backend sends to the frontend via e.g. `postMessage` during performance-sensitive times. One of the main goals of the new DevTools was to reduce this kind of overhead, so I don't think that's worth compromising on.    A variation of this might be for backends to send the newer message type (e.g. \"new-operations\") _only_ and no longer continue to send the \"operations\" message. This would avoid the perfromance problem but would leave older frontends in a broken state (perpetually waiting on the \"operations\" array that is never sent).",
        "human_words_regrex": "# How does DevTools work and what is the \"protocol version\"? The React DevTools extension consists of multiple pieces: * The **frontend** portion is the extension you see (the Components tree, the Profiler, etc.). * The **backend** portion is invisible. It runs in the same context as React itself. The frontend displays the current React tree, but it has no way to observe the tree directly because it runs in different memory space. It relies on the backend to describe the tree by sending \"messages\" through an API like . The most optimized way for the backend to share the state of the React tree is to send a small packet of  whenever the tree changes (e.g. whenever React DOM modifies the page). These \"op codes\" are just an array of numbers which correspond to _operations_ like \"add something to the tree\" or \"remove something from the tree\". For example, the operation to add a component to the tree might look like this: The format described above is highly optimized but also inflexible. (For example, if the backend needs to add an additional piece of information to the above operation, the frontend needs to also know to advance its index within the operations array by one additional place.) DevTools version 4.13 introduced the concept of a  to allow the frontend to ask the backend which version of the protcol it used. In hindsight, **this number should have included in the operations array itself** (as the first digit). # The current problem Generally the DevTools frontend and backend pieces are bundled together. For example, the most common DevTools surface\u2013 the browser extension\u2013 ships both pieces together and _injects_ the backend into the page during initialization. However there are some less common targets are not so tightly coupled\u2013 such as React Native (which embeds the backend into the application itself) or  (which records the backend \"operations\" array as part of its session data). In these cases, the frontend (UI) launched by the user (or embedded in the Replay player) may depend on an **incompatible protocol**. This results in errors like #24142 and #23307 (and even  <img width=\"791\" alt=\"React DevTools Unsupported Bridge operation error\" src=\" # Potential solutions As mentioned above, **the protocol version should have included in the operations array itself** (as the first digit). We should fix this when we eventually make a major breaking change (aka DevTools version 5) but in the meanwhile, maybe there's a way we can improve the current situation. Some changes have already been made to support older protocol versions when possible (#24093) and to more clearly communicate _the reason_ for the error when that is not possible (#24147) but perhaps there's more still that we could do? ## Option 1: Add protocol version to the start of the \"operations\" array We could retroactively update the \"operations\" array to always begin with the protocol version number. We'd need a way to _detect_ this though (to distinguish this _newer_ message format from older ones). Currently, each \"operations\" message begins with two numbers\u2013 representing the renderer and the root (tree root). For example: Since the current operations array starts with a positive integer (the renderer ID) it would be ambiguous to insert another positive integer (the bridge protocol version). For this reason, I propose inserting _two_ new numbers to the start of the operations array: The first one being `0` (so we can reliably detect the newer format) and the second one being the protocol version. For example: The frontend could then reliably distinguish between these two backend formats: * **Pros**: * Would enable DevTools to get rid of the separate protocol version request method and more easily differentiate between different versions of the operations array when parsing. * Would also enable newer DevTools frontends to parse recorded operations arrays from older backends (e.g. the Replay case). * **Cons**: * Would require us to retroactively publish patch updates to older backend releases. * Older frontends wouldn't support this change\u2013 and would error. (Although this is arguably no worse than the current situation.) ## Option 2: Automatically fall back to support older protocols We could leave the current architecture in place (at least until version 5) but in the case of a protocol error (`UnsupportedBridgeOperationError`) we could have DevTools try to automatically force-downgrade replay the \"operations\" array with the assumption of an older protocol version number. This is essentially how things already work for the React Native case, (as of version ), but formalizing it would expand to also cover usecases like Replay. * **Pros**: * Works with pre-existing DevTools backends. * **Cons**: * Adds code complexity. ## Option 3: User configurable protocol version number We could leave the current architecture in place (at least until version 5) but provide some sort of UI mechanism to allow users to override the default assumed protocol version number. * **Pros**: * Works with pre-existing DevTools backends. * **Cons**: * Poor/confusing UX. # Solutions not considered One solution _not_ mentined above would be to add a new message type (e.g. \"new-operations\") that begins with the bridge protocol version number. Newer frontends could listen for this message, but still fall back to listening for the old message (\"operations\"). Older frontends would continue to listen to the older message and not break (at least not in any new way). The reason I think this solution is probably not worth pursuing is that it would double the amount of information the backend sends to the frontend via e.g. `postMessage` during performance-sensitive times. One of the main goals of the new DevTools was to reduce this kind of overhead, so I don't think that's worth compromising on. A variation of this might be for backends to send the newer message type (e.g. \"new-operations\") _only_ and no longer continue to send the \"operations\" message. This would avoid the perfromance problem but would leave older frontends in a broken state (perpetually waiting on the \"operations\" array that is never sent).",
        "human_words_stopwords_removal_lemmatization": "# devtools work `` protocol version '' ? react devtools extension consists multiple piece : * * * frontend * * portion extension see ( component tree , profiler , etc. ) . * * * backend * * portion invisible . run context react . frontend display current react tree , way observe tree directly run different memory space . relies backend describe tree sending `` message '' api like . optimized way backend share state react tree send small packet whenever tree change ( e.g . whenever react dom modifies page ) . `` op code '' array number correspond _operations_ like `` add something tree '' `` remove something tree '' . example , operation add component tree might look like : format described highly optimized also inflexible . ( example , backend need add additional piece information operation , frontend need also know advance index within operation array one additional place . ) devtools version 4.13 introduced concept allow frontend ask backend version protcol used . hindsight , * * number included operation array * * ( first digit ) . # current problem generally devtools frontend backend piece bundled together . example , common devtools surface\u2013 browser extension\u2013 ship piece together _injects_ backend page initialization . however le common target tightly coupled\u2013 react native ( embeds backend application ) ( record backend `` operation '' array part session data ) . case , frontend ( ui ) launched user ( embedded replay player ) may depend * * incompatible protocol * * . result error like # 24142 # 23307 ( even < img width= '' 791 '' alt= '' react devtools unsupported bridge operation error '' src= '' # potential solution mentioned , * * protocol version included operation array * * ( first digit ) . fix eventually make major breaking change ( aka devtools version 5 ) meanwhile , maybe 's way improve current situation . change already made support older protocol version possible ( # 24093 ) clearly communicate _the reason_ error possible ( # 24147 ) perhaps 's still could ? # # option 1 : add protocol version start `` operation '' array could retroactively update `` operation '' array always begin protocol version number . 'd need way _detect_ though ( distinguish _newer_ message format older one ) . currently , `` operation '' message begin two numbers\u2013 representing renderer root ( tree root ) . example : since current operation array start positive integer ( renderer id ) would ambiguous insert another positive integer ( bridge protocol version ) . reason , propose inserting _two_ new number start operation array : first one ` 0 ` ( reliably detect newer format ) second one protocol version . example : frontend could reliably distinguish two backend format : * * * pro * * : * would enable devtools get rid separate protocol version request method easily differentiate different version operation array parsing . * would also enable newer devtools frontends parse recorded operation array older backends ( e.g . replay case ) . * * * con * * : * would require u retroactively publish patch update older backend release . * older frontends would n't support change\u2013 would error . ( although arguably worse current situation . ) # # option 2 : automatically fall back support older protocol could leave current architecture place ( least version 5 ) case protocol error ( ` unsupportedbridgeoperationerror ` ) could devtools try automatically force-downgrade replay `` operation '' array assumption older protocol version number . essentially thing already work react native case , ( version ) , formalizing would expand also cover usecases like replay . * * * pro * * : * work pre-existing devtools backends . * * * con * * : * add code complexity . # # option 3 : user configurable protocol version number could leave current architecture place ( least version 5 ) provide sort ui mechanism allow user override default assumed protocol version number . * * * pro * * : * work pre-existing devtools backends . * * * con * * : * poor/confusing ux . # solution considered one solution _not_ mentined would add new message type ( e.g . `` new-operations '' ) begin bridge protocol version number . newer frontends could listen message , still fall back listening old message ( `` operation '' ) . older frontends would continue listen older message break ( least new way ) . reason think solution probably worth pursuing would double amount information backend sends frontend via e.g . ` postmessage ` performance-sensitive time . one main goal new devtools reduce kind overhead , n't think 's worth compromising . variation might backends send newer message type ( e.g . `` new-operations '' ) _only_ longer continue send `` operation '' message . would avoid perfromance problem would leave older frontends broken state ( perpetually waiting `` operation '' array never sent ) .",
        "title_stopwords_removal_lemmatization": "improve devtools protocol version handling"
    },
    {
        "issue_id": 1186631103,
        "title": "Request: replace the variables with object wrappers",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-30T15:27:01Z",
        "status": "closed",
        "description": "Thanks for the great work of React and React 18!\r\n\r\nI notice that the there are quite a few important variables in React source code to hold the state, \r\nwonder if it is worth it to replace them with object properties?\r\n\r\n# What's the point ?\r\n\r\nDoing so would make it easier to understand about the internals of React or event make some tools out of it. \r\n\r\nfor example, for `workInProgress`. \r\n\r\n```js\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n```\r\n\r\nWe are unable to monitor the change of `workInProgress`, if we put it as properties as below\r\n\r\n```js\r\nlet variables = {\r\n   workInProgress: null\r\n}\r\n```\r\n\r\nthen we can easily set up `Proxy` traps to inspect what is going on.\r\n\r\n",
        "remove_template_description": "Thanks for the great work of React and React 18!    I notice that the there are quite a few important variables in React source code to hold the state,   wonder if it is worth it to replace them with object properties?    # What's the point ?    Doing so would make it easier to understand about the internals of React or event make some tools out of it.     for example, for `workInProgress`.     ```js  // The fiber we're working on  let workInProgress: Fiber | null = null;  ```    We are unable to monitor the change of `workInProgress`, if we put it as properties as below    ```js  let variables = {     workInProgress: null  }  ```    then we can easily set up `Proxy` traps to inspect what is going on.",
        "human_words": "Thanks for the great work of React and React 18!    I notice that the there are quite a few important variables in React source code to hold the state,   wonder if it is worth it to replace them with object properties?    # What's the point ?    Doing so would make it easier to understand about the internals of React or event make some tools out of it.     for example, for `workInProgress`.         We are unable to monitor the change of `workInProgress`, if we put it as properties as below        then we can easily set up `Proxy` traps to inspect what is going on.",
        "human_words_regrex": "Thanks for the great work of React and React 18! I notice that the there are quite a few important variables in React source code to hold the state, wonder if it is worth it to replace them with object properties? # What's the point ? Doing so would make it easier to understand about the internals of React or event make some tools out of it. for example, for `workInProgress`. We are unable to monitor the change of `workInProgress`, if we put it as properties as below then we can easily set up `Proxy` traps to inspect what is going on.",
        "human_words_stopwords_removal_lemmatization": "thanks great work react react 18 ! notice quite important variable react source code hold state , wonder worth replace object property ? # 's point ? would make easier understand internals react event make tool . example , ` workinprogress ` . unable monitor change ` workinprogress ` , put property easily set ` proxy ` trap inspect going .",
        "title_stopwords_removal_lemmatization": "request : replace variable object wrapper"
    },
    {
        "issue_id": 1186340421,
        "title": "Question about automatic batching behavior in React 18",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-30T11:48:42Z",
        "status": "closed",
        "description": "<!--\r\n  In one scenario Automatic batching is not working  \r\n-->\r\n\r\n In one scenario Automatic batching is not working  \r\n\r\nhaving proper setup for react 18, everything else is working as it should be,\r\n\r\n but it does multiple rending , when it should do automatic batching and re-render only single time\r\n \r\n here is example\r\n```\r\nconst [num, setNum ] = useState();\r\n  useEffect( () => {\r\n         setTimeout(() => {\r\n          setNum(Math.random())\r\n          setNum(Math.random())\r\n          setNum(Math.random())\r\n          setNum(Math.random())\r\n         })\r\n      }, [])\r\n\r\n```\r\nPlease let us know if Automatic batching  is limited",
        "remove_template_description": "<!--    In one scenario Automatic batching is not working    -->     In one scenario Automatic batching is not working      having proper setup for react 18, everything else is working as it should be,     but it does multiple rending , when it should do automatic batching and re-render only single time      here is example  ```  const [num, setNum ] = useState();    useEffect( () => {           setTimeout(() => {            setNum(Math.random())            setNum(Math.random())            setNum(Math.random())            setNum(Math.random())           })        }, [])    ```  Please let us know if Automatic batching  is limited",
        "human_words": "<!--    In one scenario Automatic batching is not working    -->     In one scenario Automatic batching is not working      having proper setup for react 18, everything else is working as it should be,     but it does multiple rending , when it should do automatic batching and re-render only single time      here is example    Please let us know if Automatic batching  is limited",
        "human_words_regrex": " In one scenario Automatic batching is not working having proper setup for react 18, everything else is working as it should be, but it does multiple rending , when it should do automatic batching and re-render only single time here is example Please let us know if Automatic batching is limited",
        "human_words_stopwords_removal_lemmatization": "one scenario automatic batching working proper setup react 18 , everything else working , multiple rending , automatic batching re-render single time example please let u know automatic batching limited",
        "title_stopwords_removal_lemmatization": "question automatic batching behavior react 18"
    },
    {
        "issue_id": 1185660992,
        "title": "React 18 error: \"'node_modules/react/jsx-dev-runtime.js' does not provide an export named 'jsxDEV'\"",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-30T00:50:44Z",
        "status": "closed",
        "description": "Hi, I started migrating from react@17 to react@18, before I replaced the old `render()` function for the new one, `createRoot()`, everything was fine. Once I replaced it, the error appeared:\r\n```shell\r\nUncaught SyntaxError:\r\nThe requested module '/@fs/home/gabriel/Documents/VSCode/my_projects/muse/node_modules/react/jsx-dev-runtime.js'\r\ndoes not provide an export named 'jsxDEV' (at index.tsx:16:10)\r\n```\r\n\r\nI'm using vite@2.8.6 with typescript@4.6.3, does anyone knows what to do here?",
        "remove_template_description": "Hi, I started migrating from react@17 to react@18, before I replaced the old `render()` function for the new one, `createRoot()`, everything was fine. Once I replaced it, the error appeared:  ```shell  Uncaught SyntaxError:  The requested module '/@fs/home/gabriel/Documents/VSCode/my_projects/muse/node_modules/react/jsx-dev-runtime.js'  does not provide an export named 'jsxDEV' (at index.tsx:16:10)  ```    I'm using vite@2.8.6 with typescript@4.6.3, does anyone knows what to do here?",
        "human_words": "Hi, I started migrating from react@17 to react@18, before I replaced the old `render()` function for the new one, `createRoot()`, everything was fine. Once I replaced it, the error appeared:      I'm using vite@2.8.6 with typescript@4.6.3, does anyone knows what to do here?",
        "human_words_regrex": "Hi, I started migrating from react@17 to react@18, before I replaced the old `render()` function for the new one, `createRoot()`, everything was fine. Once I replaced it, the error appeared: I'm using vite@2.8.6 with typescript@4.6.3, does anyone knows what to do here?",
        "human_words_stopwords_removal_lemmatization": "hi , started migrating react @ 17 react @ 18 , replaced old ` render ( ) ` function new one , ` createroot ( ) ` , everything fine . replaced , error appeared : 'm using vite @ 2.8.6 typescript @ 4.6.3 , anyone know ?",
        "title_stopwords_removal_lemmatization": "react 18 error : `` 'node_modules/react/jsx-dev-runtime.js ' provide export named 'jsxdev ' ''"
    },
    {
        "issue_id": 1185371446,
        "title": "Bug: Lazy components recreates all Suspense content when using createRoot",
        "label": [
            "Type: Discussion"
        ],
        "date": "2022-03-29T20:23:46Z",
        "status": "closed",
        "description": "React version: 18.0.0\r\n\r\n## Steps To Reproduce\r\n\r\n1. Open https://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js\r\n2. Open console\r\n\r\nLink to code example:\r\nhttps://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js\r\n\r\n## The current behavior\r\nWhen using `ReactDOM.createRoot`, all `Suspense` content seems to be rendered as 'new' (with clean slate) when `LazyComponent` promise finishes, as if it's `key` prop has changed.\r\n\r\n## The expected behavior\r\n`Suspense` content should be updated (retain id/refs/useMemo/initial state) not 'clean rendered', just like with 'old' `ReactDOM.render` root",
        "remove_template_description": "React version: 18.0.0        1. Open https://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js  2. Open console    Link to code example:  https://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js      When using `ReactDOM.createRoot`, all `Suspense` content seems to be rendered as 'new' (with clean slate) when `LazyComponent` promise finishes, as if it's `key` prop has changed.      `Suspense` content should be updated (retain id/refs/useMemo/initial state) not 'clean rendered', just like with 'old' `ReactDOM.render` root",
        "human_words": "React version: 18.0.0        1. Open https://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js  2. Open console    Link to code example:  https://codesandbox.io/s/romantic-mopsa-0zxehy?file=/src/App.js      When using `ReactDOM.createRoot`, all `Suspense` content seems to be rendered as 'new' (with clean slate) when `LazyComponent` promise finishes, as if it's `key` prop has changed.      `Suspense` content should be updated (retain id/refs/useMemo/initial state) not 'clean rendered', just like with 'old' `ReactDOM.render` root",
        "human_words_regrex": "React version: 18.0.0 1. Open  2. Open console Link to code example:  When using `ReactDOM.createRoot`, all `Suspense` content seems to be rendered as 'new' (with clean slate) when `LazyComponent` promise finishes, as if it's `key` prop has changed. `Suspense` content should be updated (retain id/refs/useMemo/initial state) not 'clean rendered', just like with 'old' `ReactDOM.render` root",
        "human_words_stopwords_removal_lemmatization": "react version : 18.0.0 1. open 2. open console link code example : using ` reactdom.createroot ` , ` suspense ` content seems rendered 'new ' ( clean slate ) ` lazycomponent ` promise finish , 's ` key ` prop changed . ` suspense ` content updated ( retain id/refs/usememo/initial state ) 'clean rendered ' , like 'old ' ` reactdom.render ` root",
        "title_stopwords_removal_lemmatization": "bug : lazy component recreates suspense content using createroot"
    },
    {
        "issue_id": 1185166786,
        "title": "[ bug ]: createRoot type error. Does not accept the root element from DOM",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-29T17:08:28Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "[ bug ] : createroot type error . accept root element dom"
    },
    {
        "issue_id": 1180610564,
        "title": "React 18 bug: Immutable.js List of components not working anymore",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-25T10:25:50Z",
        "status": "closed",
        "description": "Hello!\r\nWe have a lot of existing code with Immutable.js data, sometimes we map an `Immutable.List` for a list of components so we get a `Immutable.List` of components. This used to work pretty good, but after the update to react 18 it stopped working and the app crashes.\r\n\r\n### Reproduction\r\nI forked the SSR sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22): https://codesandbox.io/s/sad-brook-ytzfvs?file=/src/App.js:726-934\r\n\r\nHere is also the code I used in our project:\r\n```js\r\nconst App = (\r\n  <ul>\r\n    {Immutable.fromJS([\r\n      { name: 'a', value: 'a' },\r\n      { name: 'b', value: 'b' },\r\n    ]).map((item) => (\r\n      <li key={item.get('value')}>{item.get('name')}</li>\r\n    ))}\r\n  </ul>\r\n)\r\nconst stream = ReactDOMServer.renderToPipeableStream(App)\r\n```\r\n\r\n### Error\r\n```\r\nTypeError: Cannot read property '__iterator' of undefined\r\n    at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5862:32)\r\n    at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5966:12)\r\n    at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5390:3)\r\n    at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5699:5)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5832:11)\r\n    at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6204:5)\r\n    at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6251:7)\r\n    at Immediate._onImmediate (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6575:12)\r\n    at processImmediate (internal/timers.js:464:21)\r\nevents.js:377\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\n\r\nTypeError: Cannot read property '__iterator' of undefined\r\n    at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5862:32)\r\n    at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5966:12)\r\n    at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5390:3)\r\n    at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5699:5)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5832:11)\r\n    at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6204:5)\r\n    at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6251:7)\r\n    at Immediate._onImmediate (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6575:12)\r\n    at processImmediate (internal/timers.js:464:21)\r\nEmitted 'error' event on Transform instance at:\r\n    at emitErrorNT (internal/streams/destroy.js:106:8)\r\n    at emitErrorCloseNT (internal/streams/destroy.js:74:3)\r\n    at processTicksAndRejections (internal/process/task_queues.js:82:21)\r\n    at runNextTicks (internal/process/task_queues.js:64:3)\r\n    at processImmediate (internal/timers.js:437:9)\r\n[nodemon] app crashed - waiting for file changes before starting...\r\n```\r\nWith `stream.renderToNodeStream(App)` the app does not crash but still throws a very similar error. Seems like our `stream.on('error',` handler catches the error with `renderToNodeStream` but not with `renderToPipeableStream`.\r\nThis error originates from `react-dom-server-legacy.node.development.js` instead of `react-dom-server.node.development.js`, but most lines look almost the same except the line numbers.\r\n```\r\nTypeError: Cannot read property '__iterator' of undefined\r\n    at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5918:32)\r\n    at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6022:12)\r\n    at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5446:3)\r\n    at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5755:5)\r\n    at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5888:11)\r\n    at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6260:5)\r\n    at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6307:7)\r\n    at /home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6628:12\r\n    at scheduleWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:82:3)\r\n```",
        "remove_template_description": "Hello!  We have a lot of existing code with Immutable.js data, sometimes we map an `Immutable.List` for a list of components so we get a `Immutable.List` of components. This used to work pretty good, but after the update to react 18 it stopped working and the app crashes.    ### Reproduction  I forked the SSR sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22): https://codesandbox.io/s/sad-brook-ytzfvs?file=/src/App.js:726-934    Here is also the code I used in our project:  ```js  const App = (    <ul>      {Immutable.fromJS([        { name: 'a', value: 'a' },        { name: 'b', value: 'b' },      ]).map((item) => (        <li key={item.get('value')}>{item.get('name')}</li>      ))}    </ul>  )  const stream = ReactDOMServer.renderToPipeableStream(App)  ```    ### Error  ```  TypeError: Cannot read property '__iterator' of undefined      at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5862:32)      at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5966:12)      at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5390:3)      at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5699:5)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5832:11)      at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6204:5)      at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6251:7)      at Immediate._onImmediate (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6575:12)      at processImmediate (internal/timers.js:464:21)  events.js:377        throw er; // Unhandled 'error' event        ^    TypeError: Cannot read property '__iterator' of undefined      at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5862:32)      at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5966:12)      at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5390:3)      at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5699:5)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:5832:11)      at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6204:5)      at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6251:7)      at Immediate._onImmediate (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server.node.development.js:6575:12)      at processImmediate (internal/timers.js:464:21)  Emitted 'error' event on Transform instance at:      at emitErrorNT (internal/streams/destroy.js:106:8)      at emitErrorCloseNT (internal/streams/destroy.js:74:3)      at processTicksAndRejections (internal/process/task_queues.js:82:21)      at runNextTicks (internal/process/task_queues.js:64:3)      at processImmediate (internal/timers.js:437:9)  [nodemon] app crashed - waiting for file changes before starting...  ```  With `stream.renderToNodeStream(App)` the app does not crash but still throws a very similar error. Seems like our `stream.on('error',` handler catches the error with `renderToNodeStream` but not with `renderToPipeableStream`.  This error originates from `react-dom-server-legacy.node.development.js` instead of `react-dom-server.node.development.js`, but most lines look almost the same except the line numbers.  ```  TypeError: Cannot read property '__iterator' of undefined      at values (/home/foellerich/Git/epages-ui/node_modules/immutable/dist/immutable.js:4446:19)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5918:32)      at renderNode (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6022:12)      at renderHostElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5446:3)      at renderElement (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5755:5)      at renderNodeDestructive (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:5888:11)      at retryTask (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6260:5)      at performWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6307:7)      at /home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:6628:12      at scheduleWork (/home/foellerich/Git/epages-ui/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js:82:3)  ```",
        "human_words": "Hello!  We have a lot of existing code with Immutable.js data, sometimes we map an `Immutable.List` for a list of components so we get a `Immutable.List` of components. This used to work pretty good, but after the update to react 18 it stopped working and the app crashes.    ### Reproduction  I forked the SSR sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22): https://codesandbox.io/s/sad-brook-ytzfvs?file=/src/App.js:726-934    Here is also the code I used in our project:      ### Error    With `stream.renderToNodeStream(App)` the app does not crash but still throws a very similar error. Seems like our `stream.on('error',` handler catches the error with `renderToNodeStream` but not with `renderToPipeableStream`.  This error originates from `react-dom-server-legacy.node.development.js` instead of `react-dom-server.node.development.js`, but most lines look almost the same except the line numbers.  ",
        "human_words_regrex": "Hello! We have a lot of existing code with Immutable.js data, sometimes we map an `Immutable.List` for a list of components so we get a `Immutable.List` of components. This used to work pretty good, but after the update to react 18 it stopped working and the app crashes. ### Reproduction I forked the SSR sandbox from :  Here is also the code I used in our project: ### Error With `stream.renderToNodeStream(App)` the app does not crash but still throws a very similar error. Seems like our `stream.on('error',` handler catches the error with `renderToNodeStream` but not with `renderToPipeableStream`. This error originates from `react-dom-server-legacy.node.development.js` instead of `react-dom-server.node.development.js`, but most lines look almost the same except the line numbers. ",
        "human_words_stopwords_removal_lemmatization": "hello ! lot existing code immutable.js data , sometimes map ` immutable.list ` list component get ` immutable.list ` component . used work pretty good , update react 18 stopped working app crash . # # # reproduction forked ssr sandbox : also code used project : # # # error ` stream.rendertonodestream ( app ) ` app crash still throw similar error . seems like ` stream.on ( 'error ' , ` handler catch error ` rendertonodestream ` ` rendertopipeablestream ` . error originates ` react-dom-server-legacy.node.development.js ` instead ` react-dom-server.node.development.js ` , line look almost except line number .",
        "title_stopwords_removal_lemmatization": "react 18 bug : immutable.js list component working anymore"
    },
    {
        "issue_id": 1180585855,
        "title": "React 18: Updates scheduled from useInsertionEffect",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-25T10:03:02Z",
        "status": "closed",
        "description": "Following up on https://github.com/reactjs/reactjs.org/pull/4486#discussion_r834319756 (/cc @acdlite )\r\n\r\nReact version: 18.0.0-rc.3-next-1159ff619-20220324\r\n\r\n## Steps To Reproduce\r\n\r\n1. schedule an update (e.g. `setState`) from within `useInsertionEffect` \r\n\r\n\r\nLink to code example: https://codesandbox.io/s/naughty-bogdan-boghf6?file=/src/index.js\r\n\r\n\r\n## The current behavior\r\n\r\nUpdate is applied and no warning is issued.\r\n\r\n## The expected behavior\r\n\r\nAccording to https://github.com/reactjs/reactjs.org/pull/4486/files#diff-a1c8ec10dc40c86b4bbd55ad3f0126835bd45e9aa9e56c846a2e28ad6dd6acffR602 `useInsertionEffect` cannot schedule updates. But `setState` seems to \"work\". Maybe this is just incidental because it's the first render?\r\n\r\nI got the impression that this should definitely cause a warning (not implemented) but I wonder if we also should consistently drop updates from `useInsertionEffect`?",
        "remove_template_description": "Following up on https://github.com/reactjs/reactjs.org/pull/4486#discussion_r834319756 (/cc @acdlite )    React version: 18.0.0-rc.3-next-1159ff619-20220324        1. schedule an update (e.g. `setState`) from within `useInsertionEffect`       Link to code example: https://codesandbox.io/s/naughty-bogdan-boghf6?file=/src/index.js          Update is applied and no warning is issued.        According to https://github.com/reactjs/reactjs.org/pull/4486/files#diff-a1c8ec10dc40c86b4bbd55ad3f0126835bd45e9aa9e56c846a2e28ad6dd6acffR602 `useInsertionEffect` cannot schedule updates. But `setState` seems to \"work\". Maybe this is just incidental because it's the first render?    I got the impression that this should definitely cause a warning (not implemented) but I wonder if we also should consistently drop updates from `useInsertionEffect`?",
        "human_words": "Following up on https://github.com/reactjs/reactjs.org/pull/4486#discussion_r834319756 (/cc @acdlite )    React version: 18.0.0-rc.3-next-1159ff619-20220324        1. schedule an update (e.g. `setState`) from within `useInsertionEffect`       Link to code example: https://codesandbox.io/s/naughty-bogdan-boghf6?file=/src/index.js          Update is applied and no warning is issued.        According to https://github.com/reactjs/reactjs.org/pull/4486/files#diff-a1c8ec10dc40c86b4bbd55ad3f0126835bd45e9aa9e56c846a2e28ad6dd6acffR602 `useInsertionEffect` cannot schedule updates. But `setState` seems to \"work\". Maybe this is just incidental because it's the first render?    I got the impression that this should definitely cause a warning (not implemented) but I wonder if we also should consistently drop updates from `useInsertionEffect`?",
        "human_words_regrex": "Following up on  (/cc @acdlite ) React version: 18.0.0-rc.3-next-1159ff619-20220324 1. schedule an update (e.g. `setState`) from within `useInsertionEffect` Link to code example:  Update is applied and no warning is issued. According to  `useInsertionEffect` cannot schedule updates. But `setState` seems to \"work\". Maybe this is just incidental because it's the first render? I got the impression that this should definitely cause a warning (not implemented) but I wonder if we also should consistently drop updates from `useInsertionEffect`?",
        "human_words_stopwords_removal_lemmatization": "following ( /cc @ acdlite ) react version : 18.0.0-rc.3-next-1159ff619-20220324 1. schedule update ( e.g . ` setstate ` ) within ` useinsertioneffect ` link code example : update applied warning issued . according ` useinsertioneffect ` schedule update . ` setstate ` seems `` work '' . maybe incidental 's first render ? got impression definitely cause warning ( implemented ) wonder also consistently drop update ` useinsertioneffect ` ?",
        "title_stopwords_removal_lemmatization": "react 18 : update scheduled useinsertioneffect"
    },
    {
        "issue_id": 1179684811,
        "title": "React 18 - infinite loop and function as child issue with transition and suspense with useMemo",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-24T15:33:16Z",
        "status": "closed",
        "description": "I've turned off strict mode, and tried to create a simple example that breaks in v18 rc3.\r\n\r\n I'm trying to use `useMemo` to detect when some state changes and create a new memoized promise. Another `useMemo` call detects when the promise changes and wraps it in a \"resource\" object. I am passing the resource down to a child. There are multiple suspense boundaries between where I am creating the \"resource\" and where I'm calling `.read()`. I expect this to load once with no errors, and when I click the button I expect a single transition. Instead, although the app loads I get this error `react-dom.development.js:86 Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function`. When I click the button, it then goes into an infinite loop. This is unexpected because `<App>` should not be suspending, only `<Child>`. I'm also not returning any components without calling them from what I can tell.\r\n\r\nIf I set the \"resource\" into state it works fine. This only seems to happen if I try to create the \"resource\" with `useMemo`.\r\n\r\n\r\nMinimal reproduction case\r\n```js\r\nimport {\r\n  startTransition,\r\n  Suspense,\r\n  useRef,\r\n  useEffect,\r\n  useState,\r\n  useMemo,\r\n} from \"react\";\r\nimport logo from \"./logo.svg\";\r\nimport \"./App.css\";\r\n\r\nfunction App() {\r\n  const ref = useRef(0);\r\n  const [validQueryParams, setValidQueryParams] = useState();\r\n\r\n  const promise = useMemo(() => {\r\n    console.log(\"making promise that resolves in 3s\", ref.current);\r\n    ref.current++;\r\n    return new Promise((res) => {\r\n      setTimeout(() => {\r\n        console.log(validQueryParams);\r\n        return res();\r\n      }, 3000);\r\n    });\r\n  }, [validQueryParams]);\r\n\r\n  const query = useMemo(() => {\r\n    console.log(\"wrapping promise in resource object\");\r\n    return wrapPromise(promise);\r\n  }, [promise]);\r\n\r\n  useEffect(() => {\r\n    console.log(\"mount\");\r\n    return () => console.log(\"unmount\");\r\n  }, []);\r\n\r\n  console.log({ query });\r\n  return (\r\n    <>\r\n      <Suspense fallback={() => <div>fallback</div>}>\r\n        <Child query={query} />\r\n        <button\r\n          onClick={() => {\r\n            startTransition(() => {\r\n              setValidQueryParams(Math.random());\r\n            });\r\n          }}\r\n        >\r\n          Start transition\r\n        </button>\r\n      </Suspense>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction Child({ query }) {\r\n  if (!query) return null;\r\n  return (\r\n    <Suspense fallback={() => <div>fallback</div>}>\r\n      <div>{JSON.stringify(query.read())}</div>\r\n    </Suspense>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\nexport function wrapPromise(promise) {\r\n  let status = \"pending\";\r\n  let result;\r\n  const suspender = promise.then(\r\n    (r) => {\r\n      status = \"success\";\r\n      result = r;\r\n    },\r\n    (e) => {\r\n      status = \"error\";\r\n      result = e;\r\n    }\r\n  );\r\n  return {\r\n    read() {\r\n      if (status === \"pending\") {\r\n        throw suspender;\r\n      } else if (status === \"error\") {\r\n        throw result;\r\n      } else if (status === \"success\") {\r\n        return result;\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n```",
        "remove_template_description": "I've turned off strict mode, and tried to create a simple example that breaks in v18 rc3.     I'm trying to use `useMemo` to detect when some state changes and create a new memoized promise. Another `useMemo` call detects when the promise changes and wraps it in a \"resource\" object. I am passing the resource down to a child. There are multiple suspense boundaries between where I am creating the \"resource\" and where I'm calling `.read()`. I expect this to load once with no errors, and when I click the button I expect a single transition. Instead, although the app loads I get this error `react-dom.development.js:86 Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function`. When I click the button, it then goes into an infinite loop. This is unexpected because `<App>` should not be suspending, only `<Child>`. I'm also not returning any components without calling them from what I can tell.    If I set the \"resource\" into state it works fine. This only seems to happen if I try to create the \"resource\" with `useMemo`.      Minimal reproduction case  ```js  import {    startTransition,    Suspense,    useRef,    useEffect,    useState,    useMemo,  } from \"react\";  import logo from \"./logo.svg\";  import \"./App.css\";    function App() {    const ref = useRef(0);    const [validQueryParams, setValidQueryParams] = useState();      const promise = useMemo(() => {      console.log(\"making promise that resolves in 3s\", ref.current);      ref.current++;      return new Promise((res) => {        setTimeout(() => {          console.log(validQueryParams);          return res();        }, 3000);      });    }, [validQueryParams]);      const query = useMemo(() => {      console.log(\"wrapping promise in resource object\");      return wrapPromise(promise);    }, [promise]);      useEffect(() => {      console.log(\"mount\");      return () => console.log(\"unmount\");    }, []);      console.log({ query });    return (      <>        <Suspense fallback={() => <div>fallback</div>}>          <Child query={query} />          <button            onClick={() => {              startTransition(() => {                setValidQueryParams(Math.random());              });            }}          >            Start transition          </button>        </Suspense>      </>    );  }    function Child({ query }) {    if (!query) return null;    return (      <Suspense fallback={() => <div>fallback</div>}>        <div>{JSON.stringify(query.read())}</div>      </Suspense>    );  }    export default App;    export function wrapPromise(promise) {    let status = \"pending\";    let result;    const suspender = promise.then(      (r) => {        status = \"success\";        result = r;      },      (e) => {        status = \"error\";        result = e;      }    );    return {      read() {        if (status === \"pending\") {          throw suspender;        } else if (status === \"error\") {          throw result;        } else if (status === \"success\") {          return result;        }      },    };  }    ```",
        "human_words": "I've turned off strict mode, and tried to create a simple example that breaks in v18 rc3.     I'm trying to use `useMemo` to detect when some state changes and create a new memoized promise. Another `useMemo` call detects when the promise changes and wraps it in a \"resource\" object. I am passing the resource down to a child. There are multiple suspense boundaries between where I am creating the \"resource\" and where I'm calling `.read()`. I expect this to load once with no errors, and when I click the button I expect a single transition. Instead, although the app loads I get this error `react-dom.development.js:86 Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function`. When I click the button, it then goes into an infinite loop. This is unexpected because `<App>` should not be suspending, only `<Child>`. I'm also not returning any components without calling them from what I can tell.    If I set the \"resource\" into state it works fine. This only seems to happen if I try to create the \"resource\" with `useMemo`.      Minimal reproduction case  ",
        "human_words_regrex": "I've turned off strict mode, and tried to create a simple example that breaks in v18 rc3. I'm trying to use `useMemo` to detect when some state changes and create a new memoized promise. Another `useMemo` call detects when the promise changes and wraps it in a \"resource\" object. I am passing the resource down to a child. There are multiple suspense boundaries between where I am creating the \"resource\" and where I'm calling `.read()`. I expect this to load once with no errors, and when I click the button I expect a single transition. Instead, although the app loads I get this error `react-dom.development.js:86 Warning: Functions are not valid as a React child. This may happen if you return a Component instead of  from render. Or maybe you meant to call this function`. When I click the button, it then goes into an infinite loop. This is unexpected because `` should not be suspending, only ``. I'm also not returning any components without calling them from what I can tell. If I set the \"resource\" into state it works fine. This only seems to happen if I try to create the \"resource\" with `useMemo`. Minimal reproduction case ",
        "human_words_stopwords_removal_lemmatization": "'ve turned strict mode , tried create simple example break v18 rc3 . 'm trying use ` usememo ` detect state change create new memoized promise . another ` usememo ` call detects promise change wrap `` resource '' object . passing resource child . multiple suspense boundary creating `` resource '' 'm calling ` .read ( ) ` . expect load error , click button expect single transition . instead , although app load get error ` react-dom.development.js:86 warning : function valid react child . may happen return component instead render . maybe meant call function ` . click button , go infinite loop . unexpected `` suspending , `` . 'm also returning component without calling tell . set `` resource '' state work fine . seems happen try create `` resource '' ` usememo ` . minimal reproduction case",
        "title_stopwords_removal_lemmatization": "react 18 - infinite loop function child issue transition suspense usememo"
    },
    {
        "issue_id": 1175305605,
        "title": "Allowing custom reconciler host-context in React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-21T12:22:40Z",
        "status": "open",
        "description": "in a custom renderer we would like to do something like this:\r\n\r\n```jsx\r\n<inject foo=\"bar\">\r\n  <group>\r\n    <group>\r\n      <obj />\r\n    </group>\r\n  </group>\r\n</inject>\r\n```\r\n\r\n\u2705 `obj` is supposed to know it is within `inject`, this is possible\r\n\r\n\u274c `inject` is supposed to make its props (foo=\"bar\") the host context for all of its nested contents, `obj` should be able to access it. this is not possible\r\n\r\nwe create a host context like this:\r\n\r\n```jsx\r\ngetRootHostContext(rootContainer) { return {} }\r\ngetChildHostContext(parentHostContext, type, rootContainer) {\r\n if (type === \"inject\") {}\r\n else return parentHostContext\r\n```\r\n\r\nwhen `getChildHostContext` gets called for `inject`, we only have access to string type, not props. i thought i can return an empty object `{}` and fill it later in:\r\n\r\n```jsx\r\nfinalizeInitialChildren(instance, type, props, rootContainer, hostContext) {\r\n  if (type === \"inject) hostContext.props = props\r\n```\r\n\r\nbut when `finalizeInitialChildren` is called for `inject` it refers to root context, it can't refer to its own host context that was created by `getChildHostContext`. \r\n\r\ni find this puzzling, we don't seem to have any relation between a host context and the element that created it.\r\n\r\n## solution\r\n\r\nif we can access the current context it would be very useful to create a richer host context, that will also update.\r\n\r\n```jsx\r\nfinalizeInitialChildren(instance, type, props, rootContainer, hostContext, currentContext)\r\nprepareUpdate(instance, type, oldProps, newProps, rootContainer, hostContext, currentContext)\r\n```\r\n\r\nalternatively, allowing us to receive props would at least allow for a static host context that doesn't update but at least carrier some deeper information.\r\n\r\n```jsx\r\ngetChildHostContext(parentHostContext, type, rootContainer, props)\r\n```",
        "remove_template_description": "in a custom renderer we would like to do something like this:    ```jsx  <inject foo=\"bar\">    <group>      <group>        <obj />      </group>    </group>  </inject>  ```    \u2705 `obj` is supposed to know it is within `inject`, this is possible    \u274c `inject` is supposed to make its props (foo=\"bar\") the host context for all of its nested contents, `obj` should be able to access it. this is not possible    we create a host context like this:    ```jsx  getRootHostContext(rootContainer) { return {} }  getChildHostContext(parentHostContext, type, rootContainer) {   if (type === \"inject\") {}   else return parentHostContext  ```    when `getChildHostContext` gets called for `inject`, we only have access to string type, not props. i thought i can return an empty object `{}` and fill it later in:    ```jsx  finalizeInitialChildren(instance, type, props, rootContainer, hostContext) {    if (type === \"inject) hostContext.props = props  ```    but when `finalizeInitialChildren` is called for `inject` it refers to root context, it can't refer to its own host context that was created by `getChildHostContext`.     i find this puzzling, we don't seem to have any relation between a host context and the element that created it.    ## solution    if we can access the current context it would be very useful to create a richer host context, that will also update.    ```jsx  finalizeInitialChildren(instance, type, props, rootContainer, hostContext, currentContext)  prepareUpdate(instance, type, oldProps, newProps, rootContainer, hostContext, currentContext)  ```    alternatively, allowing us to receive props would at least allow for a static host context that doesn't update but at least carrier some deeper information.    ```jsx  getChildHostContext(parentHostContext, type, rootContainer, props)  ```",
        "human_words": "in a custom renderer we would like to do something like this:        \u2705 `obj` is supposed to know it is within `inject`, this is possible    \u274c `inject` is supposed to make its props (foo=\"bar\") the host context for all of its nested contents, `obj` should be able to access it. this is not possible    we create a host context like this:        when `getChildHostContext` gets called for `inject`, we only have access to string type, not props. i thought i can return an empty object `{}` and fill it later in:        but when `finalizeInitialChildren` is called for `inject` it refers to root context, it can't refer to its own host context that was created by `getChildHostContext`.     i find this puzzling, we don't seem to have any relation between a host context and the element that created it.    ## solution    if we can access the current context it would be very useful to create a richer host context, that will also update.        alternatively, allowing us to receive props would at least allow for a static host context that doesn't update but at least carrier some deeper information.    ",
        "human_words_regrex": "in a custom renderer we would like to do something like this: \u2705 `obj` is supposed to know it is within `inject`, this is possible \u274c `inject` is supposed to make its props (foo=\"bar\") the host context for all of its nested contents, `obj` should be able to access it. this is not possible we create a host context like this: when `getChildHostContext` gets called for `inject`, we only have access to string type, not props. i thought i can return an empty object `{}` and fill it later in: but when `finalizeInitialChildren` is called for `inject` it refers to root context, it can't refer to its own host context that was created by `getChildHostContext`. i find this puzzling, we don't seem to have any relation between a host context and the element that created it. ## solution if we can access the current context it would be very useful to create a richer host context, that will also update. alternatively, allowing us to receive props would at least allow for a static host context that doesn't update but at least carrier some deeper information. ",
        "human_words_stopwords_removal_lemmatization": "custom renderer would like something like : \u2705 ` obj ` supposed know within ` inject ` , possible \u274c ` inject ` supposed make prop ( foo= '' bar '' ) host context nested content , ` obj ` able access . possible create host context like : ` getchildhostcontext ` get called ` inject ` , access string type , prop . thought return empty object ` { } ` fill later : ` finalizeinitialchildren ` called ` inject ` refers root context , ca n't refer host context created ` getchildhostcontext ` . find puzzling , n't seem relation host context element created . # # solution access current context would useful create richer host context , also update . alternatively , allowing u receive prop would least allow static host context n't update least carrier deeper information .",
        "title_stopwords_removal_lemmatization": "allowing custom reconciler host-context react 18"
    },
    {
        "issue_id": 1174428798,
        "title": "[edited]",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-20T03:25:06Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n\r\n1. ",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->    1.",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->    1.",
        "human_words_regrex": " 1.",
        "human_words_stopwords_removal_lemmatization": "1 .",
        "title_stopwords_removal_lemmatization": "[ edited ]"
    },
    {
        "issue_id": 1174402432,
        "title": "React 18",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-20T00:21:39Z",
        "status": "closed",
        "description": "<!--\n  Ask a question or share feedback about the React 18 release here.\n-->",
        "remove_template_description": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1173691359,
        "title": "React 18 bug: Uncaught Error when renderToString on server and hydrateRoot on client for Suspense lazy component",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-18T15:02:32Z",
        "status": "closed",
        "description": "Hello!\r\n\r\nI get the uncaught error while hydration Suspense component, but except this error, looks like hydration working correctly - fallback changed to lazy component successfully.\r\n\r\n### Prerequisites\r\n\r\n- `react@18.0.0-rc.2`\r\n- `renderToString` on server and `hydrateRoot` on client\r\n- render `Suspense` + `lazy` component\r\n- load page first time\r\n\r\n### Reproduction\r\n\r\nForked sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22) - https://codesandbox.io/s/modest-cdn-we3fvr\r\n\r\n### Error\r\n\r\n```\r\nUncaught Error: The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\r\n    at updateDehydratedSuspenseComponent (react-dom.development.js:21341:9)\r\n    at updateSuspenseComponent (react-dom.development.js:21005:24)\r\n    at beginWork (react-dom.development.js:22225:18)\r\n    at beginWork$1 (react-dom.development.js:27022:18)\r\n    at performUnitOfWork (react-dom.development.js:26220:16)\r\n    at workLoopSync (react-dom.development.js:26134:9)\r\n    at renderRootSync (react-dom.development.js:26103:11)\r\n    at performConcurrentWorkOnRoot (react-dom.development.js:25419:78)\r\n    at workLoop (scheduler.development.js:266:34)\r\n    at flushWork (scheduler.development.js:239:14)\r\n```\r\n\r\n### Component example\r\n\r\n```\r\nconst LazyFallback = () => <div>Loading...</div>;\r\nconst LazyBlock = lazy(() => import('../components/Block'));\r\n\r\nexport const App = () => {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<LazyFallback />}>\r\n        <LazyBlock />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n};\r\n```",
        "remove_template_description": "Hello!    I get the uncaught error while hydration Suspense component, but except this error, looks like hydration working correctly - fallback changed to lazy component successfully.    ### Prerequisites    - `react@18.0.0-rc.2`  - `renderToString` on server and `hydrateRoot` on client  - render `Suspense` + `lazy` component  - load page first time    ### Reproduction    Forked sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22) - https://codesandbox.io/s/modest-cdn-we3fvr    ### Error    ```  Uncaught Error: The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.      at updateDehydratedSuspenseComponent (react-dom.development.js:21341:9)      at updateSuspenseComponent (react-dom.development.js:21005:24)      at beginWork (react-dom.development.js:22225:18)      at beginWork$1 (react-dom.development.js:27022:18)      at performUnitOfWork (react-dom.development.js:26220:16)      at workLoopSync (react-dom.development.js:26134:9)      at renderRootSync (react-dom.development.js:26103:11)      at performConcurrentWorkOnRoot (react-dom.development.js:25419:78)      at workLoop (scheduler.development.js:266:34)      at flushWork (scheduler.development.js:239:14)  ```    ### Component example    ```  const LazyFallback = () => <div>Loading...</div>;  const LazyBlock = lazy(() => import('../components/Block'));    export const App = () => {    return (      <div>        <Suspense fallback={<LazyFallback />}>          <LazyBlock />        </Suspense>      </div>    );  };  ```",
        "human_words": "Hello!    I get the uncaught error while hydration Suspense component, but except this error, looks like hydration working correctly - fallback changed to lazy component successfully.    ### Prerequisites    - `react@18.0.0-rc.2`  - `renderToString` on server and `hydrateRoot` on client  - render `Suspense` + `lazy` component  - load page first time    ### Reproduction    Forked sandbox from [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22) - https://codesandbox.io/s/modest-cdn-we3fvr    ### Error        ### Component example    ",
        "human_words_regrex": "Hello! I get the uncaught error while hydration Suspense component, but except this error, looks like hydration working correctly - fallback changed to lazy component successfully. ### Prerequisites - `react@18.0.0-rc.2` - `renderToString` on server and `hydrateRoot` on client - render `Suspense` + `lazy` component - load page first time ### Reproduction Forked sandbox from  -  ### Error ### Component example ",
        "human_words_stopwords_removal_lemmatization": "hello ! get uncaught error hydration suspense component , except error , look like hydration working correctly - fallback changed lazy component successfully . # # # prerequisite - ` react @ 18.0.0-rc.2 ` - ` rendertostring ` server ` hydrateroot ` client - render ` suspense ` + ` lazy ` component - load page first time # # # reproduction forked sandbox - # # # error # # # component example",
        "title_stopwords_removal_lemmatization": "react 18 bug : uncaught error rendertostring server hydrateroot client suspense lazy component"
    },
    {
        "issue_id": 1173373655,
        "title": "[Enhancement] Imply empty array of dependencies",
        "label": [
            "Type: Discussion"
        ],
        "date": "2022-03-18T09:24:00Z",
        "status": "open",
        "description": "Sometimes I receive following warning, even if my `useCallback` does not need external dependencies.\r\n\r\n```\r\nReact Hook useCallback does nothing when called with only one argument. Did you forget to pass an array of dependencies?\r\n```\r\n\r\nThis requires an extra working-step to add an empty array for dependencies.\r\n\r\nWould it not be possible to internally imply an empty dependency array by default?",
        "remove_template_description": "Sometimes I receive following warning, even if my `useCallback` does not need external dependencies.    ```  React Hook useCallback does nothing when called with only one argument. Did you forget to pass an array of dependencies?  ```    This requires an extra working-step to add an empty array for dependencies.    Would it not be possible to internally imply an empty dependency array by default?",
        "human_words": "Sometimes I receive following warning, even if my `useCallback` does not need external dependencies.        This requires an extra working-step to add an empty array for dependencies.    Would it not be possible to internally imply an empty dependency array by default?",
        "human_words_regrex": "Sometimes I receive following warning, even if my `useCallback` does not need external dependencies. This requires an extra working-step to add an empty array for dependencies. Would it not be possible to internally imply an empty dependency array by default?",
        "human_words_stopwords_removal_lemmatization": "sometimes receive following warning , even ` usecallback ` need external dependency . requires extra working-step add empty array dependency . would possible internally imply empty dependency array default ?",
        "title_stopwords_removal_lemmatization": "[ enhancement ] imply empty array dependency"
    },
    {
        "issue_id": 1172382240,
        "title": "Bug: <StrictMode> unexpected behavior for double invoked functions ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-17T13:22:45Z",
        "status": "open",
        "description": "Detailed explanation of the case and reproducible example is in the sandbox itself:\r\nhttps://codesandbox.io/s/smoosh-wind-9lrpp3?file=/src/App.js\r\n\r\nI can only guess that there is a reason behind this decision but I can't understand it, or maybe I'm right and this could be changed.\r\nAt the moment this behavior looks more like a bug than intentional implementation.",
        "remove_template_description": "Detailed explanation of the case and reproducible example is in the sandbox itself:  https://codesandbox.io/s/smoosh-wind-9lrpp3?file=/src/App.js    I can only guess that there is a reason behind this decision but I can't understand it, or maybe I'm right and this could be changed.  At the moment this behavior looks more like a bug than intentional implementation.",
        "human_words": "Detailed explanation of the case and reproducible example is in the sandbox itself:  https://codesandbox.io/s/smoosh-wind-9lrpp3?file=/src/App.js    I can only guess that there is a reason behind this decision but I can't understand it, or maybe I'm right and this could be changed.  At the moment this behavior looks more like a bug than intentional implementation.",
        "human_words_regrex": "Detailed explanation of the case and reproducible example is in the sandbox itself:  I can only guess that there is a reason behind this decision but I can't understand it, or maybe I'm right and this could be changed. At the moment this behavior looks more like a bug than intentional implementation.",
        "human_words_stopwords_removal_lemmatization": "detailed explanation case reproducible example sandbox : guess reason behind decision ca n't understand , maybe 'm right could changed . moment behavior look like bug intentional implementation .",
        "title_stopwords_removal_lemmatization": "bug : < strictmode > unexpected behavior double invoked function"
    },
    {
        "issue_id": 1167829490,
        "title": "React 18  Whether to support keepalive\uff1f",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-14T03:10:06Z",
        "status": "open",
        "description": "Vue officially supports the keepalive method, and it works well\r\nhttps://vuejs.org/guide/built-ins/keep-alive.html\r\n",
        "remove_template_description": "Vue officially supports the keepalive method, and it works well  https://vuejs.org/guide/built-ins/keep-alive.html",
        "human_words": "Vue officially supports the keepalive method, and it works well  https://vuejs.org/guide/built-ins/keep-alive.html",
        "human_words_regrex": "Vue officially supports the keepalive method, and it works well ",
        "human_words_stopwords_removal_lemmatization": "vue officially support keepalive method , work well",
        "title_stopwords_removal_lemmatization": "react 18 whether support keepalive\uff1f"
    },
    {
        "issue_id": 1166722930,
        "title": "OnError Fallback in Suspense when fetching  Data",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-11T18:22:12Z",
        "status": "closed",
        "description": "### Introduction\r\nReact 18 introduces the feature Suspense for providing Fallback for any asynchronous job primary Data-fetching to be loosely-coupled and providing it as a JSX. \r\n\r\n### What does a Fallback mean in React 18 ?\r\nMost Commonly, In React 18, Fallback is for showing loading or anything when doing asyc stuff.\r\n\r\n**_But, wouldn't be cool if we provide, Error Handling when we are data-fetching integrated in Suspense as well instead of using Error Boundaries._**\r\n\r\nWe can assume this that Error Boundary will be shown if Component fails to render.\r\n\r\n### For Example\r\n\r\nRight now, Suspense Works like this\r\n\r\n```sh\r\n<Suspense fallback={<Loading />}>   \r\n    <Page />\r\n</Suspense>\r\n```\r\n\r\nAbove provides Loading Fallback Whenever Page is fetching data, but **_what happens when data-fetching fails ?_** Did I write Error Boundry or handle onError inside the Page Component which will negate the React principles.\r\n\r\n### Solution\r\nIf we can add something like this, \r\n```sh\r\n<Suspense fallback={<Loading />} onErrorFallback={<Error />}>   \r\n    <Page />\r\n</Suspense>\r\n```\r\n\r\n1- Whenever Page Component is Fetching data, Loading will be shown.\r\n2- If Any Error Occurs during Fetching Data, Error Component will be shown.\r\n\r\nNow we have **_de-coupled our onError Logic_** which perfectly aligns with the principles of the react and provide a good readability of the code.\r\n\r\n**Moreover, We can easily integrate monitoring Solutions in the Error Component that will message Sentry or something else that An Error Occurred, Log of the Error And Reason as well.**\r\n\r\n\r\nLet me know of your thoughts.\r\n\r\n\r\n\r\n\r\n",
        "remove_template_description": "### Introduction  React 18 introduces the feature Suspense for providing Fallback for any asynchronous job primary Data-fetching to be loosely-coupled and providing it as a JSX.     ### What does a Fallback mean in React 18 ?  Most Commonly, In React 18, Fallback is for showing loading or anything when doing asyc stuff.    **_But, wouldn't be cool if we provide, Error Handling when we are data-fetching integrated in Suspense as well instead of using Error Boundaries._**    We can assume this that Error Boundary will be shown if Component fails to render.    ### For Example    Right now, Suspense Works like this    ```sh  <Suspense fallback={<Loading />}>         <Page />  </Suspense>  ```    Above provides Loading Fallback Whenever Page is fetching data, but **_what happens when data-fetching fails ?_** Did I write Error Boundry or handle onError inside the Page Component which will negate the React principles.    ### Solution  If we can add something like this,   ```sh  <Suspense fallback={<Loading />} onErrorFallback={<Error />}>         <Page />  </Suspense>  ```    1- Whenever Page Component is Fetching data, Loading will be shown.  2- If Any Error Occurs during Fetching Data, Error Component will be shown.    Now we have **_de-coupled our onError Logic_** which perfectly aligns with the principles of the react and provide a good readability of the code.    **Moreover, We can easily integrate monitoring Solutions in the Error Component that will message Sentry or something else that An Error Occurred, Log of the Error And Reason as well.**      Let me know of your thoughts.",
        "human_words": "### Introduction  React 18 introduces the feature Suspense for providing Fallback for any asynchronous job primary Data-fetching to be loosely-coupled and providing it as a JSX.     ### What does a Fallback mean in React 18 ?  Most Commonly, In React 18, Fallback is for showing loading or anything when doing asyc stuff.    **_But, wouldn't be cool if we provide, Error Handling when we are data-fetching integrated in Suspense as well instead of using Error Boundaries._**    We can assume this that Error Boundary will be shown if Component fails to render.    ### For Example    Right now, Suspense Works like this        Above provides Loading Fallback Whenever Page is fetching data, but **_what happens when data-fetching fails ?_** Did I write Error Boundry or handle onError inside the Page Component which will negate the React principles.    ### Solution  If we can add something like this,       1- Whenever Page Component is Fetching data, Loading will be shown.  2- If Any Error Occurs during Fetching Data, Error Component will be shown.    Now we have **_de-coupled our onError Logic_** which perfectly aligns with the principles of the react and provide a good readability of the code.    **Moreover, We can easily integrate monitoring Solutions in the Error Component that will message Sentry or something else that An Error Occurred, Log of the Error And Reason as well.**      Let me know of your thoughts.",
        "human_words_regrex": "### Introduction React 18 introduces the feature Suspense for providing Fallback for any asynchronous job primary Data-fetching to be loosely-coupled and providing it as a JSX. ### What does a Fallback mean in React 18 ? Most Commonly, In React 18, Fallback is for showing loading or anything when doing asyc stuff. **_But, wouldn't be cool if we provide, Error Handling when we are data-fetching integrated in Suspense as well instead of using Error Boundaries._** We can assume this that Error Boundary will be shown if Component fails to render. ### For Example Right now, Suspense Works like this Above provides Loading Fallback Whenever Page is fetching data, but **_what happens when data-fetching fails ?_** Did I write Error Boundry or handle onError inside the Page Component which will negate the React principles. ### Solution If we can add something like this, 1- Whenever Page Component is Fetching data, Loading will be shown. 2- If Any Error Occurs during Fetching Data, Error Component will be shown. Now we have **_de-coupled our onError Logic_** which perfectly aligns with the principles of the react and provide a good readability of the code. **Moreover, We can easily integrate monitoring Solutions in the Error Component that will message Sentry or something else that An Error Occurred, Log of the Error And Reason as well.** Let me know of your thoughts.",
        "human_words_stopwords_removal_lemmatization": "# # # introduction react 18 introduces feature suspense providing fallback asynchronous job primary data-fetching loosely-coupled providing jsx . # # # fallback mean react 18 ? commonly , react 18 , fallback showing loading anything asyc stuff . * * _but , would n't cool provide , error handling data-fetching integrated suspense well instead using error boundaries._ * * assume error boundary shown component fails render . # # # example right , suspense work like provides loading fallback whenever page fetching data , * * _what happens data-fetching fails ? _ * * write error boundry handle onerror inside page component negate react principle . # # # solution add something like , 1- whenever page component fetching data , loading shown . 2- error occurs fetching data , error component shown . * * _de-coupled onerror logic_ * * perfectly aligns principle react provide good readability code . * * moreover , easily integrate monitoring solution error component message sentry something else error occurred , log error reason well . * * let know thought .",
        "title_stopwords_removal_lemmatization": "onerror fallback suspense fetching data"
    },
    {
        "issue_id": 1166270168,
        "title": "Why return now directly in the RenderContext or CommitContext",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-11T10:48:14Z",
        "status": "open",
        "description": "```\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    return now();  // why ????\r\n  }\r\n  if (currentEventTime !== NoTimestamp) {\r\n    return currentEventTime;\r\n  }\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n```\r\nWhy return now directly in the RenderContext or CommitContext\r\n",
        "remove_template_description": "```  export function requestEventTime() {    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {      return now();  // why ????    }    if (currentEventTime !== NoTimestamp) {      return currentEventTime;    }    currentEventTime = now();    return currentEventTime;  }  ```  Why return now directly in the RenderContext or CommitContext",
        "human_words": "  Why return now directly in the RenderContext or CommitContext",
        "human_words_regrex": " Why return now directly in the RenderContext or CommitContext",
        "human_words_stopwords_removal_lemmatization": "return directly rendercontext commitcontext",
        "title_stopwords_removal_lemmatization": "return directly rendercontext commitcontext"
    },
    {
        "issue_id": 1165695019,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-03-10T20:38:44Z",
        "status": "closed",
        "description": "<!--\r\n React 17 and 18 are good but lots of packages not working with it. How to solve this problem \r\n-->\r\n",
        "remove_template_description": "<!--   React 17 and 18 are good but lots of packages not working with it. How to solve this problem   -->",
        "human_words": "<!--   React 17 and 18 are good but lots of packages not working with it. How to solve this problem   -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1140699794,
        "title": "Strange behavior when rendering two instances of react component",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-16T23:41:14Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nI have a component that is essentially a table view with rows and columns each row has an edit button, when I click the button it should populate the value of each row this is my goal of the component. Also, I have to render two instances of this component on the same page. The strange thing is when I click on the edit button in the first table, it populates the correct value, but when I click on the second table, it always populates the value of the first table. Moreover, if I console.log the value of the second table, it shows the correct value.\r\nI posted the question on StackoverFlow with formatted codes \r\nhttps://stackoverflow.com/questions/71143971/strange-behavior-when-rendering-two-instances-of-react-component/71144058?noredirect=1#comment125760915_71144058",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  I have a component that is essentially a table view with rows and columns each row has an edit button, when I click the button it should populate the value of each row this is my goal of the component. Also, I have to render two instances of this component on the same page. The strange thing is when I click on the edit button in the first table, it populates the correct value, but when I click on the second table, it always populates the value of the first table. Moreover, if I console.log the value of the second table, it shows the correct value.  I posted the question on StackoverFlow with formatted codes   https://stackoverflow.com/questions/71143971/strange-behavior-when-rendering-two-instances-of-react-component/71144058?noredirect=1#comment125760915_71144058",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  I have a component that is essentially a table view with rows and columns each row has an edit button, when I click the button it should populate the value of each row this is my goal of the component. Also, I have to render two instances of this component on the same page. The strange thing is when I click on the edit button in the first table, it populates the correct value, but when I click on the second table, it always populates the value of the first table. Moreover, if I console.log the value of the second table, it shows the correct value.  I posted the question on StackoverFlow with formatted codes   https://stackoverflow.com/questions/71143971/strange-behavior-when-rendering-two-instances-of-react-component/71144058?noredirect=1#comment125760915_71144058",
        "human_words_regrex": " I have a component that is essentially a table view with rows and columns each row has an edit button, when I click the button it should populate the value of each row this is my goal of the component. Also, I have to render two instances of this component on the same page. The strange thing is when I click on the edit button in the first table, it populates the correct value, but when I click on the second table, it always populates the value of the first table. Moreover, if I console.log the value of the second table, it shows the correct value. I posted the question on StackoverFlow with formatted codes ",
        "human_words_stopwords_removal_lemmatization": "component essentially table view row column row edit button , click button populate value row goal component . also , render two instance component page . strange thing click edit button first table , populates correct value , click second table , always populates value first table . moreover , console.log value second table , show correct value . posted question stackoverflow formatted code",
        "title_stopwords_removal_lemmatization": "strange behavior rendering two instance react component"
    },
    {
        "issue_id": 1139579908,
        "title": "React 18 upgrade: Hydration error while upgrading to react18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-16T06:03:38Z",
        "status": "closed",
        "description": "I have a NextJs application with React. To explore the possible features in react18. I tried upgrading the react package but seems to get stuck with a hydration error on the screen. Seeing this error I can assume that there is a difference in DOM generated on the server-side with what we have on the client-side but I don\u2019t point to the file or line where the difference exists.\r\n\r\n**Error Message: An error occurred during hydration. The server HTML was replaced with client content**\r\n\r\n**Screenshot of the stack trace.**\r\n\r\n\r\n<img width=\"880\" alt=\"Screenshot 2022-02-16 at 1 52 54 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205253-0b2764b5-95ae-4d44-9e34-5ef089bf26a6.png\">\r\n\r\n<img width=\"708\" alt=\"Screenshot 2022-02-16 at 1 53 06 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205236-c1f47565-0041-46ce-99af-6431156bbe3f.png\">\r\n\r\nPS: I have tried upgrading the nextJS version to 12 but this issue still exists even when I am not enabling experimental flags in the Next config.\r\n\r\n",
        "remove_template_description": "I have a NextJs application with React. To explore the possible features in react18. I tried upgrading the react package but seems to get stuck with a hydration error on the screen. Seeing this error I can assume that there is a difference in DOM generated on the server-side with what we have on the client-side but I don\u2019t point to the file or line where the difference exists.    **Error Message: An error occurred during hydration. The server HTML was replaced with client content**    **Screenshot of the stack trace.**      <img width=\"880\" alt=\"Screenshot 2022-02-16 at 1 52 54 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205253-0b2764b5-95ae-4d44-9e34-5ef089bf26a6.png\">    <img width=\"708\" alt=\"Screenshot 2022-02-16 at 1 53 06 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205236-c1f47565-0041-46ce-99af-6431156bbe3f.png\">    PS: I have tried upgrading the nextJS version to 12 but this issue still exists even when I am not enabling experimental flags in the Next config.",
        "human_words": "I have a NextJs application with React. To explore the possible features in react18. I tried upgrading the react package but seems to get stuck with a hydration error on the screen. Seeing this error I can assume that there is a difference in DOM generated on the server-side with what we have on the client-side but I don\u2019t point to the file or line where the difference exists.    **Error Message: An error occurred during hydration. The server HTML was replaced with client content**    **Screenshot of the stack trace.**      <img width=\"880\" alt=\"Screenshot 2022-02-16 at 1 52 54 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205253-0b2764b5-95ae-4d44-9e34-5ef089bf26a6.png\">    <img width=\"708\" alt=\"Screenshot 2022-02-16 at 1 53 06 PM\" src=\"https://user-images.githubusercontent.com/12985829/154205236-c1f47565-0041-46ce-99af-6431156bbe3f.png\">    PS: I have tried upgrading the nextJS version to 12 but this issue still exists even when I am not enabling experimental flags in the Next config.",
        "human_words_regrex": "I have a NextJs application with React. To explore the possible features in react18. I tried upgrading the react package but seems to get stuck with a hydration error on the screen. Seeing this error I can assume that there is a difference in DOM generated on the server-side with what we have on the client-side but I don\u2019t point to the file or line where the difference exists. **Error Message: An error occurred during hydration. The server HTML was replaced with client content** **Screenshot of the stack trace.** <img width=\"880\" alt=\"Screenshot 2022-02-16 at 1 52 54 PM\" src=\" <img width=\"708\" alt=\"Screenshot 2022-02-16 at 1 53 06 PM\" src=\" PS: I have tried upgrading the nextJS version to 12 but this issue still exists even when I am not enabling experimental flags in the Next config.",
        "human_words_stopwords_removal_lemmatization": "nextjs application react . explore possible feature react18 . tried upgrading react package seems get stuck hydration error screen . seeing error assume difference dom generated server-side client-side \u2019 point file line difference exists . * * error message : error occurred hydration . server html replaced client content * * * * screenshot stack trace . * * < img width= '' 880 '' alt= '' screenshot 2022-02-16 1 52 54 pm '' src= '' < img width= '' 708 '' alt= '' screenshot 2022-02-16 1 53 06 pm '' src= '' p : tried upgrading nextjs version 12 issue still exists even enabling experimental flag next config .",
        "title_stopwords_removal_lemmatization": "react 18 upgrade : hydration error upgrading react18"
    },
    {
        "issue_id": 1138723068,
        "title": "React 18 feedback",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-15T13:50:44Z",
        "status": "closed",
        "description": "I love it .its awesome with functional components",
        "remove_template_description": "I love it .its awesome with functional components",
        "human_words": "I love it .its awesome with functional components",
        "human_words_regrex": "I love it .its awesome with functional components",
        "human_words_stopwords_removal_lemmatization": "love .its awesome functional component",
        "title_stopwords_removal_lemmatization": "react 18 feedback"
    },
    {
        "issue_id": 1129441018,
        "title": "react18 strictMode not work same as react17 strictMode",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-10T04:39:09Z",
        "status": "closed",
        "description": "While using react18 createRoot API with StrictMode.\r\n\r\nThe useEffect's behavior is not same as react17 ReactDom.render.\r\n\r\nIn React18 the clean function will be execute. But React17 not.\r\n\r\nHere is the demo. https://codesandbox.io/s/peaceful-hertz-epw2z\r\n\r\n![image](https://user-images.githubusercontent.com/17702287/153338213-a399ab68-e71d-450b-b6d7-2ef954a9f679.png)\r\n",
        "remove_template_description": "While using react18 createRoot API with StrictMode.    The useEffect's behavior is not same as react17 ReactDom.render.    In React18 the clean function will be execute. But React17 not.    Here is the demo. https://codesandbox.io/s/peaceful-hertz-epw2z    ![image](https://user-images.githubusercontent.com/17702287/153338213-a399ab68-e71d-450b-b6d7-2ef954a9f679.png)",
        "human_words": "While using react18 createRoot API with StrictMode.    The useEffect's behavior is not same as react17 ReactDom.render.    In React18 the clean function will be execute. But React17 not.    Here is the demo. https://codesandbox.io/s/peaceful-hertz-epw2z    ![image](https://user-images.githubusercontent.com/17702287/153338213-a399ab68-e71d-450b-b6d7-2ef954a9f679.png)",
        "human_words_regrex": "While using react18 createRoot API with StrictMode. The useEffect's behavior is not same as react17 ReactDom.render. In React18 the clean function will be execute. But React17 not. Here is the demo.  !",
        "human_words_stopwords_removal_lemmatization": "using react18 createroot api strictmode . useeffect 's behavior react17 reactdom.render . react18 clean function execute . react17 . demo . !",
        "title_stopwords_removal_lemmatization": "react18 strictmode work react17 strictmode"
    },
    {
        "issue_id": 1127571882,
        "title": "React 18 - production mode only: 2 * useSyncExternalStore + useState = Explosion",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-08T17:50:33Z",
        "status": "closed",
        "description": "I tried to migrate an app from React 18 beta and useMutableSource to RC0 and useSyncExternalStore. Everything worked fine, except:\r\n\r\n- If a component has more than one useSyncExternalStore hooks\r\n- And if the component has useState hook\r\n- And if the useState's setter is invoked\r\n- And if the mode is production\r\n- Then React explodes 100% repeatably\r\n\r\nThe exact 'explosion' seems to depend on where/how useState setter is invoked and/or what other hooks are used. In some cases useRef starts returning 'undefined' and in some cases useCallback starts throwing internally \"typeError: Cannot read property 'length' of undefined\".\r\n\r\nThe above is in our real app - I haven't tried isolated repro. Also in our app, the two useSyncExternalStore hooks are subscribed to different stores, not sure if that is related or relevant.\r\n\r\nMaybe you could quickly add the above case (2x useSyncExternalStore + useState) to your existing tests, and if it doesn't reproduce the bug, then I can do a minimal isolated repro?\r\n",
        "remove_template_description": "I tried to migrate an app from React 18 beta and useMutableSource to RC0 and useSyncExternalStore. Everything worked fine, except:    - If a component has more than one useSyncExternalStore hooks  - And if the component has useState hook  - And if the useState's setter is invoked  - And if the mode is production  - Then React explodes 100% repeatably    The exact 'explosion' seems to depend on where/how useState setter is invoked and/or what other hooks are used. In some cases useRef starts returning 'undefined' and in some cases useCallback starts throwing internally \"typeError: Cannot read property 'length' of undefined\".    The above is in our real app - I haven't tried isolated repro. Also in our app, the two useSyncExternalStore hooks are subscribed to different stores, not sure if that is related or relevant.    Maybe you could quickly add the above case (2x useSyncExternalStore + useState) to your existing tests, and if it doesn't reproduce the bug, then I can do a minimal isolated repro?",
        "human_words": "I tried to migrate an app from React 18 beta and useMutableSource to RC0 and useSyncExternalStore. Everything worked fine, except:    - If a component has more than one useSyncExternalStore hooks  - And if the component has useState hook  - And if the useState's setter is invoked  - And if the mode is production  - Then React explodes 100% repeatably    The exact 'explosion' seems to depend on where/how useState setter is invoked and/or what other hooks are used. In some cases useRef starts returning 'undefined' and in some cases useCallback starts throwing internally \"typeError: Cannot read property 'length' of undefined\".    The above is in our real app - I haven't tried isolated repro. Also in our app, the two useSyncExternalStore hooks are subscribed to different stores, not sure if that is related or relevant.    Maybe you could quickly add the above case (2x useSyncExternalStore + useState) to your existing tests, and if it doesn't reproduce the bug, then I can do a minimal isolated repro?",
        "human_words_regrex": "I tried to migrate an app from React 18 beta and useMutableSource to RC0 and useSyncExternalStore. Everything worked fine, except: - If a component has more than one useSyncExternalStore hooks - And if the component has useState hook - And if the useState's setter is invoked - And if the mode is production - Then React explodes 100% repeatably The exact 'explosion' seems to depend on where/how useState setter is invoked and/or what other hooks are used. In some cases useRef starts returning 'undefined' and in some cases useCallback starts throwing internally \"typeError: Cannot read property 'length' of undefined\". The above is in our real app - I haven't tried isolated repro. Also in our app, the two useSyncExternalStore hooks are subscribed to different stores, not sure if that is related or relevant. Maybe you could quickly add the above case (2x useSyncExternalStore + useState) to your existing tests, and if it doesn't reproduce the bug, then I can do a minimal isolated repro?",
        "human_words_stopwords_removal_lemmatization": "tried migrate app react 18 beta usemutablesource rc0 usesyncexternalstore . everything worked fine , except : - component one usesyncexternalstore hook - component usestate hook - usestate 's setter invoked - mode production - react explodes 100 % repeatably exact 'explosion ' seems depend where/how usestate setter invoked and/or hook used . case useref start returning 'undefined ' case usecallback start throwing internally `` typeerror : read property 'length ' undefined '' . real app - n't tried isolated repro . also app , two usesyncexternalstore hook subscribed different store , sure related relevant . maybe could quickly add case ( 2x usesyncexternalstore + usestate ) existing test , n't reproduce bug , minimal isolated repro ?",
        "title_stopwords_removal_lemmatization": "react 18 - production mode : 2 * usesyncexternalstore + usestate = explosion"
    },
    {
        "issue_id": 1125866986,
        "title": "React 18 Is there a way to use mongodb when using rsc",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-07T11:34:23Z",
        "status": "open",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nSince there is a package `react-pg` for people to use pg with rsc, I wonder that is there also a way to use mongodb with rsc\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Since there is a package `react-pg` for people to use pg with rsc, I wonder that is there also a way to use mongodb with rsc",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Since there is a package `react-pg` for people to use pg with rsc, I wonder that is there also a way to use mongodb with rsc",
        "human_words_regrex": " Since there is a package `react-pg` for people to use pg with rsc, I wonder that is there also a way to use mongodb with rsc",
        "human_words_stopwords_removal_lemmatization": "since package ` react-pg ` people use pg rsc , wonder also way use mongodb rsc",
        "title_stopwords_removal_lemmatization": "react 18 way use mongodb using rsc"
    },
    {
        "issue_id": 1125342301,
        "title": "React 18 - Using SSR with bundle splitting is possible with `renderToString`",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-06T22:55:59Z",
        "status": "open",
        "description": "I'm using Apollo Client with SSR, streaming is not an option for me, but bundle-splitting was always a pain point. I decided to investigate a bit. After a few hacks/adjustments, I'm having a fully working SSR site of React 18, Lazy components + Bundle splitting, and Apollo Client.\r\n\r\nDocs/publications are stating that it's not possible because during render it'll immediately return upon finding a Promise. This is what was called limited Suspense support. However, in my case, I only need Suspense for Lazy.\r\n\r\nI started to experiment with React 18 + Apollo's `getDataFromTree` (what I used before with 17 until now). I had to switch from `renderToStaticMarkup` to `renderToString` to preserve the special markers React is using during hydration. This wasn't a problem, Apollo supports passing a custom `renderFunction` which allowed me to replace.\r\n\r\nTesting this simple setup with lazy components led to some interesting results. SSR was working, but on each refresh always new parts started to appear in the markup. After a few refresh the app reached it's final state and it was always correct from that point. I suspected first that Node's cached modules are the reason, tried to require all lazy modules on server side to pre-cache them, it didn't work.\r\n\r\nThen I checked the source code of `renderToString` where I saw that lazy is actually caching the resolved values for later use.\r\n\r\nI simply patched the created lazy modules to make it look like it's initialized, and voila, my application became sync on server side, everything works.\r\n\r\n```\r\nmod._payload._status = 1\r\nmod._payload._result = require('pathToModule')\r\n```\r\n\r\nWith all this, I was wondering if there's room later to provide an API for this. It's not a big deal IMO, and it'd be incredibly helpful to all people relying on `renderToString`.\r\n\r\nFor example something like `lazy(() => import('./Search'), typeof global !== 'undefined')`, where the second params is `evalute`. I'd even make it evaluated by default on server side, because why not?! :)\r\n\r\n",
        "remove_template_description": "I'm using Apollo Client with SSR, streaming is not an option for me, but bundle-splitting was always a pain point. I decided to investigate a bit. After a few hacks/adjustments, I'm having a fully working SSR site of React 18, Lazy components + Bundle splitting, and Apollo Client.    Docs/publications are stating that it's not possible because during render it'll immediately return upon finding a Promise. This is what was called limited Suspense support. However, in my case, I only need Suspense for Lazy.    I started to experiment with React 18 + Apollo's `getDataFromTree` (what I used before with 17 until now). I had to switch from `renderToStaticMarkup` to `renderToString` to preserve the special markers React is using during hydration. This wasn't a problem, Apollo supports passing a custom `renderFunction` which allowed me to replace.    Testing this simple setup with lazy components led to some interesting results. SSR was working, but on each refresh always new parts started to appear in the markup. After a few refresh the app reached it's final state and it was always correct from that point. I suspected first that Node's cached modules are the reason, tried to require all lazy modules on server side to pre-cache them, it didn't work.    Then I checked the source code of `renderToString` where I saw that lazy is actually caching the resolved values for later use.    I simply patched the created lazy modules to make it look like it's initialized, and voila, my application became sync on server side, everything works.    ```  mod._payload._status = 1  mod._payload._result = require('pathToModule')  ```    With all this, I was wondering if there's room later to provide an API for this. It's not a big deal IMO, and it'd be incredibly helpful to all people relying on `renderToString`.    For example something like `lazy(() => import('./Search'), typeof global !== 'undefined')`, where the second params is `evalute`. I'd even make it evaluated by default on server side, because why not?! :)",
        "human_words": "I'm using Apollo Client with SSR, streaming is not an option for me, but bundle-splitting was always a pain point. I decided to investigate a bit. After a few hacks/adjustments, I'm having a fully working SSR site of React 18, Lazy components + Bundle splitting, and Apollo Client.    Docs/publications are stating that it's not possible because during render it'll immediately return upon finding a Promise. This is what was called limited Suspense support. However, in my case, I only need Suspense for Lazy.    I started to experiment with React 18 + Apollo's `getDataFromTree` (what I used before with 17 until now). I had to switch from `renderToStaticMarkup` to `renderToString` to preserve the special markers React is using during hydration. This wasn't a problem, Apollo supports passing a custom `renderFunction` which allowed me to replace.    Testing this simple setup with lazy components led to some interesting results. SSR was working, but on each refresh always new parts started to appear in the markup. After a few refresh the app reached it's final state and it was always correct from that point. I suspected first that Node's cached modules are the reason, tried to require all lazy modules on server side to pre-cache them, it didn't work.    Then I checked the source code of `renderToString` where I saw that lazy is actually caching the resolved values for later use.    I simply patched the created lazy modules to make it look like it's initialized, and voila, my application became sync on server side, everything works.        With all this, I was wondering if there's room later to provide an API for this. It's not a big deal IMO, and it'd be incredibly helpful to all people relying on `renderToString`.    For example something like `lazy(() => import('./Search'), typeof global !== 'undefined')`, where the second params is `evalute`. I'd even make it evaluated by default on server side, because why not?! :)",
        "human_words_regrex": "I'm using Apollo Client with SSR, streaming is not an option for me, but bundle-splitting was always a pain point. I decided to investigate a bit. After a few hacks/adjustments, I'm having a fully working SSR site of React 18, Lazy components + Bundle splitting, and Apollo Client. Docs/publications are stating that it's not possible because during render it'll immediately return upon finding a Promise. This is what was called limited Suspense support. However, in my case, I only need Suspense for Lazy. I started to experiment with React 18 + Apollo's `getDataFromTree` (what I used before with 17 until now). I had to switch from `renderToStaticMarkup` to `renderToString` to preserve the special markers React is using during hydration. This wasn't a problem, Apollo supports passing a custom `renderFunction` which allowed me to replace. Testing this simple setup with lazy components led to some interesting results. SSR was working, but on each refresh always new parts started to appear in the markup. After a few refresh the app reached it's final state and it was always correct from that point. I suspected first that Node's cached modules are the reason, tried to require all lazy modules on server side to pre-cache them, it didn't work. Then I checked the source code of `renderToString` where I saw that lazy is actually caching the resolved values for later use. I simply patched the created lazy modules to make it look like it's initialized, and voila, my application became sync on server side, everything works. With all this, I was wondering if there's room later to provide an API for this. It's not a big deal IMO, and it'd be incredibly helpful to all people relying on `renderToString`. For example something like `lazy(() => import('./Search'), typeof global !== 'undefined')`, where the second params is `evalute`. I'd even make it evaluated by default on server side, because why not?! :)",
        "human_words_stopwords_removal_lemmatization": "'m using apollo client ssr , streaming option , bundle-splitting always pain point . decided investigate bit . hacks/adjustments , 'm fully working ssr site react 18 , lazy component + bundle splitting , apollo client . docs/publications stating 's possible render 'll immediately return upon finding promise . called limited suspense support . however , case , need suspense lazy . started experiment react 18 + apollo 's ` getdatafromtree ` ( used 17 ) . switch ` rendertostaticmarkup ` ` rendertostring ` preserve special marker react using hydration . n't problem , apollo support passing custom ` renderfunction ` allowed replace . testing simple setup lazy component led interesting result . ssr working , refresh always new part started appear markup . refresh app reached 's final state always correct point . suspected first node 's cached module reason , tried require lazy module server side pre-cache , n't work . checked source code ` rendertostring ` saw lazy actually caching resolved value later use . simply patched created lazy module make look like 's initialized , voila , application became sync server side , everything work . , wondering 's room later provide api . 's big deal imo , 'd incredibly helpful people relying ` rendertostring ` . example something like ` lazy ( ( ) = > import ( './search ' ) , typeof global ! == 'undefined ' ) ` , second params ` evalute ` . 'd even make evaluated default server side , ? ! : )",
        "title_stopwords_removal_lemmatization": "react 18 - using ssr bundle splitting possible ` rendertostring `"
    },
    {
        "issue_id": 1125282830,
        "title": "Why `hydrateRoot` isn't showing the diff upon error?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-02-06T18:45:02Z",
        "status": "closed",
        "description": "Previously with `hydrate` I could see the difference. Now with `hydrateRoot` I simply get a general error only. How should debug and find what's causing the issue?\r\n\r\n```\r\nUncaught Error: An error occurred during hydration. The server HTML was replaced with client content.\r\n```",
        "remove_template_description": "Previously with `hydrate` I could see the difference. Now with `hydrateRoot` I simply get a general error only. How should debug and find what's causing the issue?    ```  Uncaught Error: An error occurred during hydration. The server HTML was replaced with client content.  ```",
        "human_words": "Previously with `hydrate` I could see the difference. Now with `hydrateRoot` I simply get a general error only. How should debug and find what's causing the issue?    ",
        "human_words_regrex": "Previously with `hydrate` I could see the difference. Now with `hydrateRoot` I simply get a general error only. How should debug and find what's causing the issue? ",
        "human_words_stopwords_removal_lemmatization": "previously ` hydrate ` could see difference . ` hydrateroot ` simply get general error . debug find 's causing issue ?",
        "title_stopwords_removal_lemmatization": "` hydrateroot ` n't showing diff upon error ?"
    },
    {
        "issue_id": 1118521020,
        "title": "React 18 - `hydrateRoot` fails even on the most basic example when Suspense + Lazy is added",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-30T12:30:04Z",
        "status": "closed",
        "description": "I've created a simple repro here: https://codesandbox.io/s/broken-suspense-2ogh5\r\n\r\n![image](https://user-images.githubusercontent.com/963776/151699543-2e2943e2-0889-42d7-beb6-6ec3dfe77b88.png)\r\n\r\nI simply created a Lazy loaded component returning `Hello World!` and made the initial root content `Hello World!` as well.\r\n\r\nFeels like I'm missing something here. Is Lazy supposed to fail hydration?",
        "remove_template_description": "I've created a simple repro here: https://codesandbox.io/s/broken-suspense-2ogh5    ![image](https://user-images.githubusercontent.com/963776/151699543-2e2943e2-0889-42d7-beb6-6ec3dfe77b88.png)    I simply created a Lazy loaded component returning `Hello World!` and made the initial root content `Hello World!` as well.    Feels like I'm missing something here. Is Lazy supposed to fail hydration?",
        "human_words": "I've created a simple repro here: https://codesandbox.io/s/broken-suspense-2ogh5    ![image](https://user-images.githubusercontent.com/963776/151699543-2e2943e2-0889-42d7-beb6-6ec3dfe77b88.png)    I simply created a Lazy loaded component returning `Hello World!` and made the initial root content `Hello World!` as well.    Feels like I'm missing something here. Is Lazy supposed to fail hydration?",
        "human_words_regrex": "I've created a simple repro here:  ! I simply created a Lazy loaded component returning `Hello World!` and made the initial root content `Hello World!` as well. Feels like I'm missing something here. Is Lazy supposed to fail hydration?",
        "human_words_stopwords_removal_lemmatization": "'ve created simple repro : ! simply created lazy loaded component returning ` hello world ! ` made initial root content ` hello world ! ` well . feel like 'm missing something . lazy supposed fail hydration ?",
        "title_stopwords_removal_lemmatization": "react 18 - ` hydrateroot ` fails even basic example suspense + lazy added"
    },
    {
        "issue_id": 1116228461,
        "title": "Make \"not wrapped in act()\" warnings optional",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-27T13:40:46Z",
        "status": "closed",
        "description": "## Problem \r\n\r\nMy tests do not care about keeping track of every single update (i.e. setState) that happens in a **component tree**. My tests don't test **implementation details**. Surely, **when and how a component tree updates happen** is an implementation detail. In fact, it's sometimes impossible to consider all such implementation details in a relatively big component tree and when using 3rd party libraries. The fact is that majority of tests **don't care** when and how updates happen.\r\n\r\nIf a component does only synchronous state updates, it's perhaps not a big deal. You can wrap **everything** with `act` (as testing-library does) and move on (well, this statement is partially tongue in cheek).\r\n\r\nHowever, if there are asynchronous state updates, not only it is a hard problem to wrap them with act; sometimes it requires monkey patching the environment (fake timers, fake promises).\r\n\r\n## Solution\r\n\r\nProvide a way to opt-out of such warnings.",
        "remove_template_description": "## Problem     My tests do not care about keeping track of every single update (i.e. setState) that happens in a **component tree**. My tests don't test **implementation details**. Surely, **when and how a component tree updates happen** is an implementation detail. In fact, it's sometimes impossible to consider all such implementation details in a relatively big component tree and when using 3rd party libraries. The fact is that majority of tests **don't care** when and how updates happen.    If a component does only synchronous state updates, it's perhaps not a big deal. You can wrap **everything** with `act` (as testing-library does) and move on (well, this statement is partially tongue in cheek).    However, if there are asynchronous state updates, not only it is a hard problem to wrap them with act; sometimes it requires monkey patching the environment (fake timers, fake promises).    ## Solution    Provide a way to opt-out of such warnings.",
        "human_words": "## Problem     My tests do not care about keeping track of every single update (i.e. setState) that happens in a **component tree**. My tests don't test **implementation details**. Surely, **when and how a component tree updates happen** is an implementation detail. In fact, it's sometimes impossible to consider all such implementation details in a relatively big component tree and when using 3rd party libraries. The fact is that majority of tests **don't care** when and how updates happen.    If a component does only synchronous state updates, it's perhaps not a big deal. You can wrap **everything** with `act` (as testing-library does) and move on (well, this statement is partially tongue in cheek).    However, if there are asynchronous state updates, not only it is a hard problem to wrap them with act; sometimes it requires monkey patching the environment (fake timers, fake promises).    ## Solution    Provide a way to opt-out of such warnings.",
        "human_words_regrex": "## Problem My tests do not care about keeping track of every single update (i.e. setState) that happens in a **component tree**. My tests don't test **implementation details**. Surely, **when and how a component tree updates happen** is an implementation detail. In fact, it's sometimes impossible to consider all such implementation details in a relatively big component tree and when using 3rd party libraries. The fact is that majority of tests **don't care** when and how updates happen. If a component does only synchronous state updates, it's perhaps not a big deal. You can wrap **everything** with `act` (as testing-library does) and move on (well, this statement is partially tongue in cheek). However, if there are asynchronous state updates, not only it is a hard problem to wrap them with act; sometimes it requires monkey patching the environment (fake timers, fake promises). ## Solution Provide a way to opt-out of such warnings.",
        "human_words_stopwords_removal_lemmatization": "# # problem test care keeping track every single update ( i.e . setstate ) happens * * component tree * * . test n't test * * implementation detail * * . surely , * * component tree update happen * * implementation detail . fact , 's sometimes impossible consider implementation detail relatively big component tree using 3rd party library . fact majority test * * n't care * * update happen . component synchronous state update , 's perhaps big deal . wrap * * everything * * ` act ` ( testing-library ) move ( well , statement partially tongue cheek ) . however , asynchronous state update , hard problem wrap act ; sometimes requires monkey patching environment ( fake timer , fake promise ) . # # solution provide way opt-out warning .",
        "title_stopwords_removal_lemmatization": "make `` wrapped act ( ) '' warning optional"
    },
    {
        "issue_id": 1114840495,
        "title": "Server-side Error Boundaries in React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-26T10:07:17Z",
        "status": "closed",
        "description": "Hello!\r\n\r\nCan't find any information about Error Boundaries support for server-side rendering.\r\nMaybe core team have some plans or RFC for universal Error Boundaries implementation?\r\nInterested in the context of new [Suspense SSR Architecture](https://github.com/reactwg/react-18/discussions/37).\r\n\r\nKnow about trick with [dangerouslySetInnerHTML](https://gal.hagever.com/posts/react-error-boundaries-and-ssr), but really want to use more native alternative.",
        "remove_template_description": "Hello!    Can't find any information about Error Boundaries support for server-side rendering.  Maybe core team have some plans or RFC for universal Error Boundaries implementation?  Interested in the context of new [Suspense SSR Architecture](https://github.com/reactwg/react-18/discussions/37).    Know about trick with [dangerouslySetInnerHTML](https://gal.hagever.com/posts/react-error-boundaries-and-ssr), but really want to use more native alternative.",
        "human_words": "Hello!    Can't find any information about Error Boundaries support for server-side rendering.  Maybe core team have some plans or RFC for universal Error Boundaries implementation?  Interested in the context of new [Suspense SSR Architecture](https://github.com/reactwg/react-18/discussions/37).    Know about trick with [dangerouslySetInnerHTML](https://gal.hagever.com/posts/react-error-boundaries-and-ssr), but really want to use more native alternative.",
        "human_words_regrex": "Hello! Can't find any information about Error Boundaries support for server-side rendering. Maybe core team have some plans or RFC for universal Error Boundaries implementation? Interested in the context of new . Know about trick with , but really want to use more native alternative.",
        "human_words_stopwords_removal_lemmatization": "hello ! ca n't find information error boundary support server-side rendering . maybe core team plan rfc universal error boundary implementation ? interested context new . know trick , really want use native alternative .",
        "title_stopwords_removal_lemmatization": "server-side error boundary react 18"
    },
    {
        "issue_id": 1113321789,
        "title": "React 18's whole hydration mismatch business",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-25T01:32:00Z",
        "status": "closed",
        "description": "So yesterday I decided to try to use React 18 again after 2 or 3 weeks of returning to React 17 because React 18 crashed my whole app for some weird reason (an unknown hydration mismatch again), as React 17 was rendering weird stuff (I saw some broken components, which aren't broken somewhere else in the app) but then again React 18 loves to freeze the whole app to throw hydration mismatches errors and then Node comes right after with its \"process is not defined\" thing. So, can I know whether it is going to be possible to see what mismatched between the server-side rendered HTML and React? :)\r\n\r\nFor now, this is the behaviour: \r\nhttps://ibb.co/2NY4x1Y\r\n\r\nThese are the components:\r\n\r\n(renderToString API in server.js)\r\nhttps://ibb.co/6BPGb21\r\n\r\n(AppRoot in client.js)\r\nhttps://ibb.co/zPpM71M\r\n\r\n(hydrateRoot API)\r\nhttps://ibb.co/0VnZ0tL\r\nhttps://ibb.co/yVXVRtk\r\n\r\nThank you :) It's really confusing and I don't really know how to resolve, but I guess it's related to some conditional rendering within the app? I've figured out how to use renderToPipeableStream, so I hope I can resolve this as fast as possible :D",
        "remove_template_description": "So yesterday I decided to try to use React 18 again after 2 or 3 weeks of returning to React 17 because React 18 crashed my whole app for some weird reason (an unknown hydration mismatch again), as React 17 was rendering weird stuff (I saw some broken components, which aren't broken somewhere else in the app) but then again React 18 loves to freeze the whole app to throw hydration mismatches errors and then Node comes right after with its \"process is not defined\" thing. So, can I know whether it is going to be possible to see what mismatched between the server-side rendered HTML and React? :)    For now, this is the behaviour:   https://ibb.co/2NY4x1Y    These are the components:    (renderToString API in server.js)  https://ibb.co/6BPGb21    (AppRoot in client.js)  https://ibb.co/zPpM71M    (hydrateRoot API)  https://ibb.co/0VnZ0tL  https://ibb.co/yVXVRtk    Thank you :) It's really confusing and I don't really know how to resolve, but I guess it's related to some conditional rendering within the app? I've figured out how to use renderToPipeableStream, so I hope I can resolve this as fast as possible :D",
        "human_words": "So yesterday I decided to try to use React 18 again after 2 or 3 weeks of returning to React 17 because React 18 crashed my whole app for some weird reason (an unknown hydration mismatch again), as React 17 was rendering weird stuff (I saw some broken components, which aren't broken somewhere else in the app) but then again React 18 loves to freeze the whole app to throw hydration mismatches errors and then Node comes right after with its \"process is not defined\" thing. So, can I know whether it is going to be possible to see what mismatched between the server-side rendered HTML and React? :)    For now, this is the behaviour:   https://ibb.co/2NY4x1Y    These are the components:    (renderToString API in server.js)  https://ibb.co/6BPGb21    (AppRoot in client.js)  https://ibb.co/zPpM71M    (hydrateRoot API)  https://ibb.co/0VnZ0tL  https://ibb.co/yVXVRtk    Thank you :) It's really confusing and I don't really know how to resolve, but I guess it's related to some conditional rendering within the app? I've figured out how to use renderToPipeableStream, so I hope I can resolve this as fast as possible :D",
        "human_words_regrex": "So yesterday I decided to try to use React 18 again after 2 or 3 weeks of returning to React 17 because React 18 crashed my whole app for some weird reason (an unknown hydration mismatch again), as React 17 was rendering weird stuff (I saw some broken components, which aren't broken somewhere else in the app) but then again React 18 loves to freeze the whole app to throw hydration mismatches errors and then Node comes right after with its \"process is not defined\" thing. So, can I know whether it is going to be possible to see what mismatched between the server-side rendered HTML and React? :) For now, this is the behaviour:  These are the components: (renderToString API in server.js)  (AppRoot in client.js)  (hydrateRoot API)   Thank you :) It's really confusing and I don't really know how to resolve, but I guess it's related to some conditional rendering within the app? I've figured out how to use renderToPipeableStream, so I hope I can resolve this as fast as possible :D",
        "human_words_stopwords_removal_lemmatization": "yesterday decided try use react 18 2 3 week returning react 17 react 18 crashed whole app weird reason ( unknown hydration mismatch ) , react 17 rendering weird stuff ( saw broken component , n't broken somewhere else app ) react 18 love freeze whole app throw hydration mismatch error node come right `` process defined '' thing . , know whether going possible see mismatched server-side rendered html react ? : ) , behaviour : component : ( rendertostring api server.js ) ( approot client.js ) ( hydrateroot api ) thank : ) 's really confusing n't really know resolve , guess 's related conditional rendering within app ? 've figured use rendertopipeablestream , hope resolve fast possible :",
        "title_stopwords_removal_lemmatization": "react 18 's whole hydration mismatch business"
    },
    {
        "issue_id": 1112357554,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-24T09:06:52Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nTrial",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Trial",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Trial",
        "human_words_regrex": " Trial",
        "human_words_stopwords_removal_lemmatization": "trial",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1105069537,
        "title": "React 18",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-16T14:39:30Z",
        "status": "closed",
        "description": "<!--\n  Ask a question or share feedback about the React 18 release here.\n-->",
        "remove_template_description": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1105053999,
        "title": "React 18",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-16T13:34:40Z",
        "status": "closed",
        "description": "<!--\n  Ask a question or share feedback about the React 18 release here.\n-->",
        "remove_template_description": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1102821724,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-14T02:50:05Z",
        "status": "closed",
        "description": "This is a non-compliance issue\u3002\r\n\r\nI am referencing a third-party component, but there is an input whose value I cannot modify. By looking at the source code, we can see that the data of this component runs inside the component using useState.\r\n**But I can't modify the code of the third-party component\uff0cI can only modify the code of the parent component.**\r\n\r\nif input does not expose state or Ref, is there any black magic to get/modify the component's useState method?\r\n\r\n![image](https://user-images.githubusercontent.com/2993320/149443199-bbedf947-d68d-49e9-b9de-c65bd0146e83.png)\r\n",
        "remove_template_description": "This is a non-compliance issue\u3002    I am referencing a third-party component, but there is an input whose value I cannot modify. By looking at the source code, we can see that the data of this component runs inside the component using useState.  **But I can't modify the code of the third-party component\uff0cI can only modify the code of the parent component.**    if input does not expose state or Ref, is there any black magic to get/modify the component's useState method?    ![image](https://user-images.githubusercontent.com/2993320/149443199-bbedf947-d68d-49e9-b9de-c65bd0146e83.png)",
        "human_words": "This is a non-compliance issue\u3002    I am referencing a third-party component, but there is an input whose value I cannot modify. By looking at the source code, we can see that the data of this component runs inside the component using useState.  **But I can't modify the code of the third-party component\uff0cI can only modify the code of the parent component.**    if input does not expose state or Ref, is there any black magic to get/modify the component's useState method?    ![image](https://user-images.githubusercontent.com/2993320/149443199-bbedf947-d68d-49e9-b9de-c65bd0146e83.png)",
        "human_words_regrex": "This is a non-compliance issue\u3002 I am referencing a third-party component, but there is an input whose value I cannot modify. By looking at the source code, we can see that the data of this component runs inside the component using useState. **But I can't modify the code of the third-party component\uff0cI can only modify the code of the parent component.** if input does not expose state or Ref, is there any black magic to get/modify the component's useState method? !",
        "human_words_stopwords_removal_lemmatization": "non-compliance issue\u3002 referencing third-party component , input whose value modify . looking source code , see data component run inside component using usestate . * * ca n't modify code third-party component\uff0ci modify code parent component . * * input expose state ref , black magic get/modify component 's usestate method ? !",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1099960273,
        "title": "React 18 different behavior of ReactDom.createRoot and ReactDom.render",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-12T07:11:42Z",
        "status": "closed",
        "description": "  React 18.0.0-rc.0\r\n\r\n  I noticed a different behavior when using new ReactDom.createRoot feature comapared to the current ReactDom.render\r\n  \r\n  So I have this demo project [here](https://github.com/mkinfrared/react-18-issue-demo) to illustrate the problem.\r\n\r\n  The setup is pretty simple. The app component has a boolean state to open/close modal. The modal component calls a custom hook useOutsideClick whick adds a click event listener to the window and calls a callback passed to that hook if the click was triggered outside the ref element which is passed as arguments to that hook.\r\n\r\n  When I use the current ReactDom.render everything works fine as expected. You click the button, the modal opens, the window click event is added, then you click outside the ref object, the modal is closed. But when I switch to new ReactDom.createRoot which is reccomended when using React 18, I get a different behavior. When I click the button to open a modal, the addEventListener inside useEffect in useOutsideClick is called during the bubbling phase, the modal is mounted, then the click event bubbles up to the window which now has a click event registered, and as the click happened on the button which is outside ref object the modal is closed.\r\n\r\n  I am not really sure if that new behavior is a bug or a feature but I at least would like to hear some explanation on that.\r\n\r\n In indes.tsx file I left the code for createRoot commented out so you could easily switch between these two apis.\r\n",
        "remove_template_description": "React 18.0.0-rc.0      I noticed a different behavior when using new ReactDom.createRoot feature comapared to the current ReactDom.render        So I have this demo project [here](https://github.com/mkinfrared/react-18-issue-demo) to illustrate the problem.      The setup is pretty simple. The app component has a boolean state to open/close modal. The modal component calls a custom hook useOutsideClick whick adds a click event listener to the window and calls a callback passed to that hook if the click was triggered outside the ref element which is passed as arguments to that hook.      When I use the current ReactDom.render everything works fine as expected. You click the button, the modal opens, the window click event is added, then you click outside the ref object, the modal is closed. But when I switch to new ReactDom.createRoot which is reccomended when using React 18, I get a different behavior. When I click the button to open a modal, the addEventListener inside useEffect in useOutsideClick is called during the bubbling phase, the modal is mounted, then the click event bubbles up to the window which now has a click event registered, and as the click happened on the button which is outside ref object the modal is closed.      I am not really sure if that new behavior is a bug or a feature but I at least would like to hear some explanation on that.     In indes.tsx file I left the code for createRoot commented out so you could easily switch between these two apis.",
        "human_words": "React 18.0.0-rc.0      I noticed a different behavior when using new ReactDom.createRoot feature comapared to the current ReactDom.render        So I have this demo project [here](https://github.com/mkinfrared/react-18-issue-demo) to illustrate the problem.      The setup is pretty simple. The app component has a boolean state to open/close modal. The modal component calls a custom hook useOutsideClick whick adds a click event listener to the window and calls a callback passed to that hook if the click was triggered outside the ref element which is passed as arguments to that hook.      When I use the current ReactDom.render everything works fine as expected. You click the button, the modal opens, the window click event is added, then you click outside the ref object, the modal is closed. But when I switch to new ReactDom.createRoot which is reccomended when using React 18, I get a different behavior. When I click the button to open a modal, the addEventListener inside useEffect in useOutsideClick is called during the bubbling phase, the modal is mounted, then the click event bubbles up to the window which now has a click event registered, and as the click happened on the button which is outside ref object the modal is closed.      I am not really sure if that new behavior is a bug or a feature but I at least would like to hear some explanation on that.     In indes.tsx file I left the code for createRoot commented out so you could easily switch between these two apis.",
        "human_words_regrex": "React 18.0.0-rc.0 I noticed a different behavior when using new ReactDom.createRoot feature comapared to the current ReactDom.render So I have this demo project  to illustrate the problem. The setup is pretty simple. The app component has a boolean state to open/close modal. The modal component calls a custom hook useOutsideClick whick adds a click event listener to the window and calls a callback passed to that hook if the click was triggered outside the ref element which is passed as arguments to that hook. When I use the current ReactDom.render everything works fine as expected. You click the button, the modal opens, the window click event is added, then you click outside the ref object, the modal is closed. But when I switch to new ReactDom.createRoot which is reccomended when using React 18, I get a different behavior. When I click the button to open a modal, the addEventListener inside useEffect in useOutsideClick is called during the bubbling phase, the modal is mounted, then the click event bubbles up to the window which now has a click event registered, and as the click happened on the button which is outside ref object the modal is closed. I am not really sure if that new behavior is a bug or a feature but I at least would like to hear some explanation on that. In indes.tsx file I left the code for createRoot commented out so you could easily switch between these two apis.",
        "human_words_stopwords_removal_lemmatization": "react 18.0.0-rc.0 noticed different behavior using new reactdom.createroot feature comapared current reactdom.render demo project illustrate problem . setup pretty simple . app component boolean state open/close modal . modal component call custom hook useoutsideclick whick add click event listener window call callback passed hook click triggered outside ref element passed argument hook . use current reactdom.render everything work fine expected . click button , modal open , window click event added , click outside ref object , modal closed . switch new reactdom.createroot reccomended using react 18 , get different behavior . click button open modal , addeventlistener inside useeffect useoutsideclick called bubbling phase , modal mounted , click event bubble window click event registered , click happened button outside ref object modal closed . really sure new behavior bug feature least would like hear explanation . indes.tsx file left code createroot commented could easily switch two apis .",
        "title_stopwords_removal_lemmatization": "react 18 different behavior reactdom.createroot reactdom.render"
    },
    {
        "issue_id": 1098527631,
        "title": "React 18: useEffect different behaviour compare to v17 in specific cases",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-11T00:36:58Z",
        "status": "open",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nHi!\r\nIn [this](https://github.com/tannerlinsley/react-query/issues/2628) issue to react-query repo we found some strange useEffect behaviour.\r\n\r\nHere's examples:\r\n[react 17](https://codesandbox.io/s/react-or-react-query-bug-version-2-forked-fnebv?file=/src/example.js)\r\n[react 18 with old root api](https://codesandbox.io/s/react-bug-version-3-x8fs6?file=/src/example.js)\r\n\r\nJust click \"rerender\" button and see that there's no effect firing.\r\n\r\nBut in react 18 with the new root API it works fine:\r\n[codesandbox](https://codesandbox.io/s/react-bug-version-3-forked-8mxy2?file=/src/example.js)\r\n\r\nI tried to explain it like that:\r\n> So, in our case we have `dummy` and `forceRerender` state variables.\r\nAfter calling `rerender` function, `dummy` updates with the same value, and React bails out without rendering the children or firing effects. I suppose that somewhere here the effect should've been scheduled, but it didn't because of that react behaviour.\r\nBUT, the render function was actually called and useEffect received updated `value` in deps (you can see this by checking how many times console.log was called in render).\r\nAnd then on the next tick `forceRerender` causes another update, but this time it doesn't schedule the effect because it has the same deps (`value`) that were captured in the previous render function call.\r\n\r\nSo, is this right explanation for what is going on there?\r\nAnd I guess, the main question, why does this example work fine when the new root api is used?\r\nDoes it mean that with the new root api (and with concurrent mode) useEffect compare deps only with those from the last previous render that was committed to the DOM?\r\n\r\nThanks!",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Hi!  In [this](https://github.com/tannerlinsley/react-query/issues/2628) issue to react-query repo we found some strange useEffect behaviour.    Here's examples:  [react 17](https://codesandbox.io/s/react-or-react-query-bug-version-2-forked-fnebv?file=/src/example.js)  [react 18 with old root api](https://codesandbox.io/s/react-bug-version-3-x8fs6?file=/src/example.js)    Just click \"rerender\" button and see that there's no effect firing.    But in react 18 with the new root API it works fine:  [codesandbox](https://codesandbox.io/s/react-bug-version-3-forked-8mxy2?file=/src/example.js)    I tried to explain it like that:  > So, in our case we have `dummy` and `forceRerender` state variables.  After calling `rerender` function, `dummy` updates with the same value, and React bails out without rendering the children or firing effects. I suppose that somewhere here the effect should've been scheduled, but it didn't because of that react behaviour.  BUT, the render function was actually called and useEffect received updated `value` in deps (you can see this by checking how many times console.log was called in render).  And then on the next tick `forceRerender` causes another update, but this time it doesn't schedule the effect because it has the same deps (`value`) that were captured in the previous render function call.    So, is this right explanation for what is going on there?  And I guess, the main question, why does this example work fine when the new root api is used?  Does it mean that with the new root api (and with concurrent mode) useEffect compare deps only with those from the last previous render that was committed to the DOM?    Thanks!",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  Hi!  In [this](https://github.com/tannerlinsley/react-query/issues/2628) issue to react-query repo we found some strange useEffect behaviour.    Here's examples:  [react 17](https://codesandbox.io/s/react-or-react-query-bug-version-2-forked-fnebv?file=/src/example.js)  [react 18 with old root api](https://codesandbox.io/s/react-bug-version-3-x8fs6?file=/src/example.js)    Just click \"rerender\" button and see that there's no effect firing.    But in react 18 with the new root API it works fine:  [codesandbox](https://codesandbox.io/s/react-bug-version-3-forked-8mxy2?file=/src/example.js)    I tried to explain it like that:  > So, in our case we have `dummy` and `forceRerender` state variables.  After calling `rerender` function, `dummy` updates with the same value, and React bails out without rendering the children or firing effects. I suppose that somewhere here the effect should've been scheduled, but it didn't because of that react behaviour.  BUT, the render function was actually called and useEffect received updated `value` in deps (you can see this by checking how many times console.log was called in render).  And then on the next tick `forceRerender` causes another update, but this time it doesn't schedule the effect because it has the same deps (`value`) that were captured in the previous render function call.    So, is this right explanation for what is going on there?  And I guess, the main question, why does this example work fine when the new root api is used?  Does it mean that with the new root api (and with concurrent mode) useEffect compare deps only with those from the last previous render that was committed to the DOM?    Thanks!",
        "human_words_regrex": " Hi! In  issue to react-query repo we found some strange useEffect behaviour. Here's examples:   Just click \"rerender\" button and see that there's no effect firing. But in react 18 with the new root API it works fine:  I tried to explain it like that: > So, in our case we have `dummy` and `forceRerender` state variables. After calling `rerender` function, `dummy` updates with the same value, and React bails out without rendering the children or firing effects. I suppose that somewhere here the effect should've been scheduled, but it didn't because of that react behaviour. BUT, the render function was actually called and useEffect received updated `value` in deps (you can see this by checking how many times console.log was called in render). And then on the next tick `forceRerender` causes another update, but this time it doesn't schedule the effect because it has the same deps (`value`) that were captured in the previous render function call. So, is this right explanation for what is going on there? And I guess, the main question, why does this example work fine when the new root api is used? Does it mean that with the new root api (and with concurrent mode) useEffect compare deps only with those from the last previous render that was committed to the DOM? Thanks!",
        "human_words_stopwords_removal_lemmatization": "hi ! issue react-query repo found strange useeffect behaviour . 's example : click `` rerender '' button see 's effect firing . react 18 new root api work fine : tried explain like : > , case ` dummy ` ` forcererender ` state variable . calling ` rerender ` function , ` dummy ` update value , react bail without rendering child firing effect . suppose somewhere effect 've scheduled , n't react behaviour . , render function actually called useeffect received updated ` value ` deps ( see checking many time console.log called render ) . next tick ` forcererender ` cause another update , time n't schedule effect deps ( ` value ` ) captured previous render function call . , right explanation going ? guess , main question , example work fine new root api used ? mean new root api ( concurrent mode ) useeffect compare deps last previous render committed dom ? thanks !",
        "title_stopwords_removal_lemmatization": "react 18 : useeffect different behaviour compare v17 specific case"
    },
    {
        "issue_id": 1097003802,
        "title": "What's the big problem with (careful) side effects in useMemo?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-08T18:28:22Z",
        "status": "closed",
        "description": "We have a component that's structured roughly like this:\r\n\r\n```ts\r\nfunction Chart() {\r\n  const { rawData, pauseData } = useDataSource(); // communicate with external data source\r\n  const resumeDataRef = useRef();\r\n\r\n  // Pause the data source as we begin processing/displaying data\r\n  const preprocessedData = useMemo(() => {\r\n    if (resumeDataRef.current) {\r\n      resumeDataRef.current();  // force-resume if previously paused\r\n    }\r\n    resumeDataRef.current = pauseData();\r\n    return preprocess(data);\r\n  }, [rawData, pauseData]);\r\n\r\n  // Resume the data source when our (potentially slow, async) render has completed\r\n  const onRendered = useCallback(() => {\r\n    if (resumeDataRef.current) {\r\n      resumeDataRef.current();\r\n    }\r\n    resumeDataRef.current = undefined;\r\n  }, []);\r\n\r\n  // not shown: extra code to ensure we resume when the component is unmounted\r\n\r\n  return <SlowAsyncRenderer data={preprocessedData} onRendered={onRendered} />\r\n}\r\n```\r\n\r\nThe useMemo body does have side effects (it runs a \"pause\" which will be eventually followed by a \"resume\" when the render has completed) \u2014 but it tracks them carefully with a ref to ensure that any outstanding resume is called before the next pause. Running it twice might result in an extra resume/pause, but there's nothing inherently wrong with that.\r\n\r\nWith Strict Mode on, however, when the useMemo body runs twice during initial mount, **`resumeDataRef.current` does not persist from the first to the second execution**. This means our `if (resumeDataRef.current) resumeDataRef.current()` does not run, which leaves a dangling pause when the component is mounted.\r\n\r\nI've put together a more complete example at: https://codesandbox.io/s/vigorous-raman-mijws\r\nOpen up the console and notice that `pause` and `resume` calls are always matched, even as the data changes, **except the very first pause** has no associated resume.\r\n\r\nI understand that the general requirement is \"no side effects in render / useMemo\", but I thought I was being careful with the useRef to ensure proper cleanup. **Is there a real bug here that could happen with concurrent rendering?** What is Strict Mode trying to teach me? ",
        "remove_template_description": "We have a component that's structured roughly like this:    ```ts  function Chart() {    const { rawData, pauseData } = useDataSource(); // communicate with external data source    const resumeDataRef = useRef();      // Pause the data source as we begin processing/displaying data    const preprocessedData = useMemo(() => {      if (resumeDataRef.current) {        resumeDataRef.current();  // force-resume if previously paused      }      resumeDataRef.current = pauseData();      return preprocess(data);    }, [rawData, pauseData]);      // Resume the data source when our (potentially slow, async) render has completed    const onRendered = useCallback(() => {      if (resumeDataRef.current) {        resumeDataRef.current();      }      resumeDataRef.current = undefined;    }, []);      // not shown: extra code to ensure we resume when the component is unmounted      return <SlowAsyncRenderer data={preprocessedData} onRendered={onRendered} />  }  ```    The useMemo body does have side effects (it runs a \"pause\" which will be eventually followed by a \"resume\" when the render has completed) \u2014 but it tracks them carefully with a ref to ensure that any outstanding resume is called before the next pause. Running it twice might result in an extra resume/pause, but there's nothing inherently wrong with that.    With Strict Mode on, however, when the useMemo body runs twice during initial mount, **`resumeDataRef.current` does not persist from the first to the second execution**. This means our `if (resumeDataRef.current) resumeDataRef.current()` does not run, which leaves a dangling pause when the component is mounted.    I've put together a more complete example at: https://codesandbox.io/s/vigorous-raman-mijws  Open up the console and notice that `pause` and `resume` calls are always matched, even as the data changes, **except the very first pause** has no associated resume.    I understand that the general requirement is \"no side effects in render / useMemo\", but I thought I was being careful with the useRef to ensure proper cleanup. **Is there a real bug here that could happen with concurrent rendering?** What is Strict Mode trying to teach me?",
        "human_words": "We have a component that's structured roughly like this:        The useMemo body does have side effects (it runs a \"pause\" which will be eventually followed by a \"resume\" when the render has completed) \u2014 but it tracks them carefully with a ref to ensure that any outstanding resume is called before the next pause. Running it twice might result in an extra resume/pause, but there's nothing inherently wrong with that.    With Strict Mode on, however, when the useMemo body runs twice during initial mount, **`resumeDataRef.current` does not persist from the first to the second execution**. This means our `if (resumeDataRef.current) resumeDataRef.current()` does not run, which leaves a dangling pause when the component is mounted.    I've put together a more complete example at: https://codesandbox.io/s/vigorous-raman-mijws  Open up the console and notice that `pause` and `resume` calls are always matched, even as the data changes, **except the very first pause** has no associated resume.    I understand that the general requirement is \"no side effects in render / useMemo\", but I thought I was being careful with the useRef to ensure proper cleanup. **Is there a real bug here that could happen with concurrent rendering?** What is Strict Mode trying to teach me?",
        "human_words_regrex": "We have a component that's structured roughly like this: The useMemo body does have side effects (it runs a \"pause\" which will be eventually followed by a \"resume\" when the render has completed) \u2014 but it tracks them carefully with a ref to ensure that any outstanding resume is called before the next pause. Running it twice might result in an extra resume/pause, but there's nothing inherently wrong with that. With Strict Mode on, however, when the useMemo body runs twice during initial mount, **`resumeDataRef.current` does not persist from the first to the second execution**. This means our `if (resumeDataRef.current) resumeDataRef.current()` does not run, which leaves a dangling pause when the component is mounted. I've put together a more complete example at:  Open up the console and notice that `pause` and `resume` calls are always matched, even as the data changes, **except the very first pause** has no associated resume. I understand that the general requirement is \"no side effects in render / useMemo\", but I thought I was being careful with the useRef to ensure proper cleanup. **Is there a real bug here that could happen with concurrent rendering?** What is Strict Mode trying to teach me?",
        "human_words_stopwords_removal_lemmatization": "component 's structured roughly like : usememo body side effect ( run `` pause '' eventually followed `` resume '' render completed ) \u2014 track carefully ref ensure outstanding resume called next pause . running twice might result extra resume/pause , 's nothing inherently wrong . strict mode , however , usememo body run twice initial mount , * * ` resumedataref.current ` persist first second execution * * . mean ` ( resumedataref.current ) resumedataref.current ( ) ` run , leaf dangling pause component mounted . 've put together complete example : open console notice ` pause ` ` resume ` call always matched , even data change , * * except first pause * * associated resume . understand general requirement `` side effect render / usememo '' , thought careful useref ensure proper cleanup . * * real bug could happen concurrent rendering ? * * strict mode trying teach ?",
        "title_stopwords_removal_lemmatization": "'s big problem ( careful ) side effect usememo ?"
    },
    {
        "issue_id": 1094210252,
        "title": "React 18 - Avoiding hydration errors, but initialize client-only state directly if possible",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-05T10:37:26Z",
        "status": "open",
        "description": "This question is about hydration errors and workarounds that are future-proof for React 18 partial hydration and concurrent mode.\r\n\r\nReact hydration rules say that the server rendered html needs to match the client rendered dom that is rendered during the initial render in `hydrate()`. Mismatches (=slight differences in dom output) can cause all kinds of weird behavior because React's virtual dom does not match the real dom. Such mismatches can happen when rendering based on information that is only available on the client side, but not on the server side, e.g. conditional rendering based on `typeof window !== 'undefined'`, or rendering based on data from `localStorage`.\r\n\r\nSo this component will cause a hydration error if it is contained in the initial sever-rendered html (case 1), but it would not cause a hydration error if it only appeared later after hydration (case 2):\r\n\r\n```\r\nconst MyComponent1 = () => {\r\n    const [viewState, setViewState] = useState(() => getViewStateFromLocalStorage())\r\n    return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>\r\n}\r\n```\r\n\r\nA common workaround is to use `useEffect` to apply client data only after hydration:\r\n\r\n```\r\nconst MyComponent2 = () => {\r\n    const [viewState, setViewState] = useState('A')\r\n\r\n    useEffect(()=>{\r\n        setViewState(getViewStateFromLocalStorage())\r\n    },[])\r\n\r\n    return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>\r\n}\r\n```\r\n\r\nThis workaround comes with a downside: for case 2 where the component only appears later after hydration, it would still flash from showing `\"A\"` first, and then the view state from `localStorage`. To make the component directly show the view state from `localStorage`, the code in `MyComponent1` would need to be used, but then the component can not be used in initial server renderings. So the component itself needs knowledge in which contexts it will be used, which is not ideal for modularity.\r\n\r\nI currently know of no way to make the component work for both case 1 and case 2 and show the view state from `localStorage` directly in the initial render for case 2 without giving the component knowledge of its outer context.\r\n\r\nI see 2 different theoretical approaches to solve this issue which are not yet possible in React AFAIK:\r\n\r\n1. Signal to React that the component could cause hydration errors to make it compare the dom exactly and fix it accordingly:\r\n\r\n```\r\nconst MyComponent: FunctionComponent = () => {\r\n    const [viewState, setViewState] = useState(() => getViewStateFromLocalStorage())\r\n    return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>\r\n}\r\n\r\nMyComponent.gracefulHydrationErrors = true\r\n```\r\n\r\n2. Get the info from React if the current render of the component is currently rendering as part of the initial render during `hydrate()`:\r\n\r\n```\r\nconst MyComponent = () => {\r\n    const isHydrating = useIsHydrating()\r\n    const [viewState, setViewState] = useState(() => isHydrating ? 'A' : getViewStateFromLocalStorage())\r\n\r\n    useEffect(()=>{\r\n        setViewState(getViewStateFromLocalStorage())\r\n    },[])\r\n\r\n    return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>\r\n}\r\n```\r\n\r\nIs there already a way to solve this issue properly with available apis? The solution also needs to work with React 18 partial hydration and concurrent mode.\r\n",
        "remove_template_description": "This question is about hydration errors and workarounds that are future-proof for React 18 partial hydration and concurrent mode.    React hydration rules say that the server rendered html needs to match the client rendered dom that is rendered during the initial render in `hydrate()`. Mismatches (=slight differences in dom output) can cause all kinds of weird behavior because React's virtual dom does not match the real dom. Such mismatches can happen when rendering based on information that is only available on the client side, but not on the server side, e.g. conditional rendering based on `typeof window !== 'undefined'`, or rendering based on data from `localStorage`.    So this component will cause a hydration error if it is contained in the initial sever-rendered html (case 1), but it would not cause a hydration error if it only appeared later after hydration (case 2):    ```  const MyComponent1 = () => {      const [viewState, setViewState] = useState(() => getViewStateFromLocalStorage())      return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>  }  ```    A common workaround is to use `useEffect` to apply client data only after hydration:    ```  const MyComponent2 = () => {      const [viewState, setViewState] = useState('A')        useEffect(()=>{          setViewState(getViewStateFromLocalStorage())      },[])        return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>  }  ```    This workaround comes with a downside: for case 2 where the component only appears later after hydration, it would still flash from showing `\"A\"` first, and then the view state from `localStorage`. To make the component directly show the view state from `localStorage`, the code in `MyComponent1` would need to be used, but then the component can not be used in initial server renderings. So the component itself needs knowledge in which contexts it will be used, which is not ideal for modularity.    I currently know of no way to make the component work for both case 1 and case 2 and show the view state from `localStorage` directly in the initial render for case 2 without giving the component knowledge of its outer context.    I see 2 different theoretical approaches to solve this issue which are not yet possible in React AFAIK:    1. Signal to React that the component could cause hydration errors to make it compare the dom exactly and fix it accordingly:    ```  const MyComponent: FunctionComponent = () => {      const [viewState, setViewState] = useState(() => getViewStateFromLocalStorage())      return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>  }    MyComponent.gracefulHydrationErrors = true  ```    2. Get the info from React if the current render of the component is currently rendering as part of the initial render during `hydrate()`:    ```  const MyComponent = () => {      const isHydrating = useIsHydrating()      const [viewState, setViewState] = useState(() => isHydrating ? 'A' : getViewStateFromLocalStorage())        useEffect(()=>{          setViewState(getViewStateFromLocalStorage())      },[])        return <button onClick={() => setViewState(oldViewState => toggledViewState(oldViewState))>{viewState}</button>  }  ```    Is there already a way to solve this issue properly with available apis? The solution also needs to work with React 18 partial hydration and concurrent mode.",
        "human_words": "This question is about hydration errors and workarounds that are future-proof for React 18 partial hydration and concurrent mode.    React hydration rules say that the server rendered html needs to match the client rendered dom that is rendered during the initial render in `hydrate()`. Mismatches (=slight differences in dom output) can cause all kinds of weird behavior because React's virtual dom does not match the real dom. Such mismatches can happen when rendering based on information that is only available on the client side, but not on the server side, e.g. conditional rendering based on `typeof window !== 'undefined'`, or rendering based on data from `localStorage`.    So this component will cause a hydration error if it is contained in the initial sever-rendered html (case 1), but it would not cause a hydration error if it only appeared later after hydration (case 2):        A common workaround is to use `useEffect` to apply client data only after hydration:        This workaround comes with a downside: for case 2 where the component only appears later after hydration, it would still flash from showing `\"A\"` first, and then the view state from `localStorage`. To make the component directly show the view state from `localStorage`, the code in `MyComponent1` would need to be used, but then the component can not be used in initial server renderings. So the component itself needs knowledge in which contexts it will be used, which is not ideal for modularity.    I currently know of no way to make the component work for both case 1 and case 2 and show the view state from `localStorage` directly in the initial render for case 2 without giving the component knowledge of its outer context.    I see 2 different theoretical approaches to solve this issue which are not yet possible in React AFAIK:    1. Signal to React that the component could cause hydration errors to make it compare the dom exactly and fix it accordingly:        2. Get the info from React if the current render of the component is currently rendering as part of the initial render during `hydrate()`:        Is there already a way to solve this issue properly with available apis? The solution also needs to work with React 18 partial hydration and concurrent mode.",
        "human_words_regrex": "This question is about hydration errors and workarounds that are future-proof for React 18 partial hydration and concurrent mode. React hydration rules say that the server rendered html needs to match the client rendered dom that is rendered during the initial render in `hydrate()`. Mismatches (=slight differences in dom output) can cause all kinds of weird behavior because React's virtual dom does not match the real dom. Such mismatches can happen when rendering based on information that is only available on the client side, but not on the server side, e.g. conditional rendering based on `typeof window !== 'undefined'`, or rendering based on data from `localStorage`. So this component will cause a hydration error if it is contained in the initial sever-rendered html (case 1), but it would not cause a hydration error if it only appeared later after hydration (case 2): A common workaround is to use `useEffect` to apply client data only after hydration: This workaround comes with a downside: for case 2 where the component only appears later after hydration, it would still flash from showing `\"A\"` first, and then the view state from `localStorage`. To make the component directly show the view state from `localStorage`, the code in `MyComponent1` would need to be used, but then the component can not be used in initial server renderings. So the component itself needs knowledge in which contexts it will be used, which is not ideal for modularity. I currently know of no way to make the component work for both case 1 and case 2 and show the view state from `localStorage` directly in the initial render for case 2 without giving the component knowledge of its outer context. I see 2 different theoretical approaches to solve this issue which are not yet possible in React AFAIK: 1. Signal to React that the component could cause hydration errors to make it compare the dom exactly and fix it accordingly: 2. Get the info from React if the current render of the component is currently rendering as part of the initial render during `hydrate()`: Is there already a way to solve this issue properly with available apis? The solution also needs to work with React 18 partial hydration and concurrent mode.",
        "human_words_stopwords_removal_lemmatization": "question hydration error workarounds future-proof react 18 partial hydration concurrent mode . react hydration rule say server rendered html need match client rendered dom rendered initial render ` hydrate ( ) ` . mismatch ( =slight difference dom output ) cause kind weird behavior react 's virtual dom match real dom . mismatch happen rendering based information available client side , server side , e.g . conditional rendering based ` typeof window ! == 'undefined ' ` , rendering based data ` localstorage ` . component cause hydration error contained initial sever-rendered html ( case 1 ) , would cause hydration error appeared later hydration ( case 2 ) : common workaround use ` useeffect ` apply client data hydration : workaround come downside : case 2 component appears later hydration , would still flash showing ` `` '' ` first , view state ` localstorage ` . make component directly show view state ` localstorage ` , code ` mycomponent1 ` would need used , component used initial server rendering . component need knowledge context used , ideal modularity . currently know way make component work case 1 case 2 show view state ` localstorage ` directly initial render case 2 without giving component knowledge outer context . see 2 different theoretical approach solve issue yet possible react afaik : 1. signal react component could cause hydration error make compare dom exactly fix accordingly : 2. get info react current render component currently rendering part initial render ` hydrate ( ) ` : already way solve issue properly available apis ? solution also need work react 18 partial hydration concurrent mode .",
        "title_stopwords_removal_lemmatization": "react 18 - avoiding hydration error , initialize client-only state directly possible"
    },
    {
        "issue_id": 1092802273,
        "title": "React 18: bootstrapScriptContent escapes HTML so quotes can\u2019t be used",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-03T20:36:40Z",
        "status": "closed",
        "description": "If you use the `bootstrapScriptContent` option of `renderToPipeableStream()` to provide hydration data (as [recommended in the <script> upgrade guide](https://github.com/reactwg/react-18/discussions/114)) with `JSON.stringify()` it doesn\u2019t work because React escapes HTML characters in `bootstrapScriptContent` like quotes. I\u2019ve worked around this by using backticks to deliniate strings.\r\n\r\nWhat\u2019s the correct thing to do here?\r\n\r\nhttps://github.com/facebook/react/blob/cdb8a1d19d0c0d43a72c3f0fe739b04da247c360/packages/react-dom/src/server/ReactDOMServerFormatConfig.js#L99-L105",
        "remove_template_description": "If you use the `bootstrapScriptContent` option of `renderToPipeableStream()` to provide hydration data (as [recommended in the <script> upgrade guide](https://github.com/reactwg/react-18/discussions/114)) with `JSON.stringify()` it doesn\u2019t work because React escapes HTML characters in `bootstrapScriptContent` like quotes. I\u2019ve worked around this by using backticks to deliniate strings.    What\u2019s the correct thing to do here?    https://github.com/facebook/react/blob/cdb8a1d19d0c0d43a72c3f0fe739b04da247c360/packages/react-dom/src/server/ReactDOMServerFormatConfig.js#L99-L105",
        "human_words": "If you use the `bootstrapScriptContent` option of `renderToPipeableStream()` to provide hydration data (as [recommended in the <script> upgrade guide](https://github.com/reactwg/react-18/discussions/114)) with `JSON.stringify()` it doesn\u2019t work because React escapes HTML characters in `bootstrapScriptContent` like quotes. I\u2019ve worked around this by using backticks to deliniate strings.    What\u2019s the correct thing to do here?    https://github.com/facebook/react/blob/cdb8a1d19d0c0d43a72c3f0fe739b04da247c360/packages/react-dom/src/server/ReactDOMServerFormatConfig.js#L99-L105",
        "human_words_regrex": "If you use the `bootstrapScriptContent` option of `renderToPipeableStream()` to provide hydration data (as ) with `JSON.stringify()` it doesn\u2019t work because React escapes HTML characters in `bootstrapScriptContent` like quotes. I\u2019ve worked around this by using backticks to deliniate strings. What\u2019s the correct thing to do here? ",
        "human_words_stopwords_removal_lemmatization": "use ` bootstrapscriptcontent ` option ` rendertopipeablestream ( ) ` provide hydration data ( ) ` json.stringify ( ) ` \u2019 work react escape html character ` bootstrapscriptcontent ` like quote . \u2019 worked around using backticks deliniate string . \u2019 correct thing ?",
        "title_stopwords_removal_lemmatization": "react 18 : bootstrapscriptcontent escape html quote \u2019 used"
    },
    {
        "issue_id": 1092641956,
        "title": "React 18 ",
        "label": [
            "Resolution: Duplicate",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-03T16:20:09Z",
        "status": "closed",
        "description": "When is the new release coming?",
        "remove_template_description": "When is the new release coming?",
        "human_words": "When is the new release coming?",
        "human_words_regrex": "When is the new release coming?",
        "human_words_stopwords_removal_lemmatization": "new release coming ?",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1092093008,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-02T20:16:56Z",
        "status": "closed",
        "description": "\r\nwhen is the new release coming?\r\n\r\n",
        "remove_template_description": "when is the new release coming?",
        "human_words": "when is the new release coming?",
        "human_words_regrex": "when is the new release coming?",
        "human_words_stopwords_removal_lemmatization": "new release coming ?",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1092036123,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2022-01-02T14:54:53Z",
        "status": "closed",
        "description": "<!--\n  Ask a question or share feedback about the React 18 release here.\n-->\n",
        "remove_template_description": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1090853134,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-30T03:30:25Z",
        "status": "closed",
        "description": "<!--\n  Ask a question or share feedback about the React 18 release here.\n-->\n",
        "remove_template_description": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words": "<!--   Ask a question or share feedback about the React 18 release here. -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1090799316,
        "title": "React 18 Suspense unable to track when a promise completes causing SWR failure",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-29T23:48:09Z",
        "status": "open",
        "description": "When working with [SWR](https://swr.vercel.app/)  with `React 17`, you could pass to `useSwr` on `onSuccess` parameter which would assign a completion function so that when an async call finished, you could take some action (for example, when not using Relay, you can trigger another component to begin loading data based on the returned data from `useSwr`.\r\n\r\nAfter [this lengthy issue](https://github.com/vercel/swr/issues/1733) with @promer94, one of the devs on SWR, we found an ugly workaround with `useEffect` and some negative logic, but it is not satisfactory and will always be hard to reason about as well as do so similar things without introducing bugs. To quote @promer94, `i think we need more time to understand concurrent mode before we change current api design`.  This feels to me like either we don't understand how Suspense works, or there is a serious usability issue if not using Relay.\r\n\r\nIt's summarized best here:  https://github.com/vercel/swr/issues/1733#issuecomment-1001391484 .  Assuming this is correct, there is no determinant way to know when components suspense promise completes, and no way to act on that which would be required in multi-component scenarios.\r\n\r\nThe issue mentioned above https://github.com/vercel/swr/issues/1733 explains in more detail the problem, and the example code that demonstrates it by having to do the ugly workaround for not having `onSuccess` is in this repo:  https://github.com/pkellner/pluralsight-react-18-suspense-swr-problem/blob/master/src/components/CityListItems.js\r\n\r\nIf you want to see the program working you can view it on this link. Notice that after the city list loads, the first city becomes selected.  That was trivial using React 17 with SWR and really hard with React 18 and Suspense enabled.\r\n\r\nhttps://pluralsight-react-18-first-look.peterkellner.net/#\r\n\r\nThe source for the app with Suspense is here:  https://github.com/pkellner/airquality\r\n\r\n\r\n\r\n\r\n",
        "remove_template_description": "When working with [SWR](https://swr.vercel.app/)  with `React 17`, you could pass to `useSwr` on `onSuccess` parameter which would assign a completion function so that when an async call finished, you could take some action (for example, when not using Relay, you can trigger another component to begin loading data based on the returned data from `useSwr`.    After [this lengthy issue](https://github.com/vercel/swr/issues/1733) with @promer94, one of the devs on SWR, we found an ugly workaround with `useEffect` and some negative logic, but it is not satisfactory and will always be hard to reason about as well as do so similar things without introducing bugs. To quote @promer94, `i think we need more time to understand concurrent mode before we change current api design`.  This feels to me like either we don't understand how Suspense works, or there is a serious usability issue if not using Relay.    It's summarized best here:  https://github.com/vercel/swr/issues/1733#issuecomment-1001391484 .  Assuming this is correct, there is no determinant way to know when components suspense promise completes, and no way to act on that which would be required in multi-component scenarios.    The issue mentioned above https://github.com/vercel/swr/issues/1733 explains in more detail the problem, and the example code that demonstrates it by having to do the ugly workaround for not having `onSuccess` is in this repo:  https://github.com/pkellner/pluralsight-react-18-suspense-swr-problem/blob/master/src/components/CityListItems.js    If you want to see the program working you can view it on this link. Notice that after the city list loads, the first city becomes selected.  That was trivial using React 17 with SWR and really hard with React 18 and Suspense enabled.    https://pluralsight-react-18-first-look.peterkellner.net/#    The source for the app with Suspense is here:  https://github.com/pkellner/airquality",
        "human_words": "When working with [SWR](https://swr.vercel.app/)  with `React 17`, you could pass to `useSwr` on `onSuccess` parameter which would assign a completion function so that when an async call finished, you could take some action (for example, when not using Relay, you can trigger another component to begin loading data based on the returned data from `useSwr`.    After [this lengthy issue](https://github.com/vercel/swr/issues/1733) with @promer94, one of the devs on SWR, we found an ugly workaround with `useEffect` and some negative logic, but it is not satisfactory and will always be hard to reason about as well as do so similar things without introducing bugs. To quote @promer94, `i think we need more time to understand concurrent mode before we change current api design`.  This feels to me like either we don't understand how Suspense works, or there is a serious usability issue if not using Relay.    It's summarized best here:  https://github.com/vercel/swr/issues/1733#issuecomment-1001391484 .  Assuming this is correct, there is no determinant way to know when components suspense promise completes, and no way to act on that which would be required in multi-component scenarios.    The issue mentioned above https://github.com/vercel/swr/issues/1733 explains in more detail the problem, and the example code that demonstrates it by having to do the ugly workaround for not having `onSuccess` is in this repo:  https://github.com/pkellner/pluralsight-react-18-suspense-swr-problem/blob/master/src/components/CityListItems.js    If you want to see the program working you can view it on this link. Notice that after the city list loads, the first city becomes selected.  That was trivial using React 17 with SWR and really hard with React 18 and Suspense enabled.    https://pluralsight-react-18-first-look.peterkellner.net/#    The source for the app with Suspense is here:  https://github.com/pkellner/airquality",
        "human_words_regrex": "When working with  with `React 17`, you could pass to `useSwr` on `onSuccess` parameter which would assign a completion function so that when an async call finished, you could take some action (for example, when not using Relay, you can trigger another component to begin loading data based on the returned data from `useSwr`. After  with @promer94, one of the devs on SWR, we found an ugly workaround with `useEffect` and some negative logic, but it is not satisfactory and will always be hard to reason about as well as do so similar things without introducing bugs. To quote @promer94, `i think we need more time to understand concurrent mode before we change current api design`. This feels to me like either we don't understand how Suspense works, or there is a serious usability issue if not using Relay. It's summarized best here:  . Assuming this is correct, there is no determinant way to know when components suspense promise completes, and no way to act on that which would be required in multi-component scenarios. The issue mentioned above  explains in more detail the problem, and the example code that demonstrates it by having to do the ugly workaround for not having `onSuccess` is in this repo:  If you want to see the program working you can view it on this link. Notice that after the city list loads, the first city becomes selected. That was trivial using React 17 with SWR and really hard with React 18 and Suspense enabled.  The source for the app with Suspense is here: ",
        "human_words_stopwords_removal_lemmatization": "working ` react 17 ` , could pas ` useswr ` ` onsuccess ` parameter would assign completion function async call finished , could take action ( example , using relay , trigger another component begin loading data based returned data ` useswr ` . @ promer94 , one devs swr , found ugly workaround ` useeffect ` negative logic , satisfactory always hard reason well similar thing without introducing bug . quote @ promer94 , ` think need time understand concurrent mode change current api design ` . feel like either n't understand suspense work , serious usability issue using relay . 's summarized best : . assuming correct , determinant way know component suspense promise completes , way act would required multi-component scenario . issue mentioned explains detail problem , example code demonstrates ugly workaround ` onsuccess ` repo : want see program working view link . notice city list load , first city becomes selected . trivial using react 17 swr really hard react 18 suspense enabled . source app suspense :",
        "title_stopwords_removal_lemmatization": "react 18 suspense unable track promise completes causing swr failure"
    },
    {
        "issue_id": 1089478622,
        "title": "React 18 SuspenseList seems broken including with very simple examples",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-27T21:20:24Z",
        "status": "closed",
        "description": "I'm trying to get React 18 SuspenseList to work in its simplest form. I've downloaded several GitHub repo's that have sample code and they all fail with the same error (pasted below).  I forked a simple sandbox that I assume was working, updated it to the latest React RC-0 and it fails.\r\n\r\nHere is a link to the sandbox:  https://codesandbox.io/s/suspense-list-forked-g6tby\r\n\r\nThis is the relevant code:\r\n\r\n```\r\nimport React, {\r\n  SuspenseList,\r\n  Suspense\r\n} from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"./styles.css\";\r\nimport { fetchProfileData } from \"./fakeApi\";\r\n\r\nconst initialResource = fetchProfileData(0);\r\n\r\nfunction App() {\r\n  return (\r\n    <Suspense fallback={<h1>Loading...</h1>}>\r\n      <ProfilePage resource={initialResource} />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\nfunction ProfilePage({ resource }) {\r\n  return (\r\n    <SuspenseList revealOrder=\"forwards\">\r\n      <ProfileDetails resource={resource} />\r\n      <Suspense\r\n        fallback={<h2>Loading posts...</h2>}\r\n      >\r\n        <ProfileTimeline resource={resource} />\r\n      </Suspense>\r\n      <Suspense\r\n        fallback={<h2>Loading fun facts...</h2>}\r\n      >\r\n        <ProfileTrivia resource={resource} />\r\n      </Suspense>\r\n    </SuspenseList>\r\n  );\r\n}\r\n\r\nfunction ProfileDetails({ resource }) {\r\n  const user = resource.user.read();\r\n  return <h1>{user.name}</h1>;\r\n}\r\n\r\nfunction ProfileTimeline({ resource }) {\r\n  const posts = resource.posts.read();\r\n  return (\r\n    <ul>\r\n      {posts.map(post => (\r\n        <li key={post.id}>{post.text}</li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\nfunction ProfileTrivia({ resource }) {\r\n  const trivia = resource.trivia.read();\r\n  return (\r\n    <>\r\n      <h2>Fun Facts</h2>\r\n      <ul>\r\n        {trivia.map(fact => (\r\n          <li key={fact.id}>{fact.text}</li>\r\n        ))}\r\n      </ul>\r\n    </>\r\n  );\r\n}\r\n\r\nconst rootElement = document.getElementById(\r\n  \"root\"\r\n);\r\nReactDOM.createRoot(rootElement).render(<App />);\r\n```\r\n\r\nAnd the error:\r\n\r\n```\r\nElement type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\r\n\r\nCheck the render method of `ProfilePage`.\r\n```\r\n\r\n\r\n",
        "remove_template_description": "I'm trying to get React 18 SuspenseList to work in its simplest form. I've downloaded several GitHub repo's that have sample code and they all fail with the same error (pasted below).  I forked a simple sandbox that I assume was working, updated it to the latest React RC-0 and it fails.    Here is a link to the sandbox:  https://codesandbox.io/s/suspense-list-forked-g6tby    This is the relevant code:    ```  import React, {    SuspenseList,    Suspense  } from \"react\";  import ReactDOM from \"react-dom\";    import \"./styles.css\";  import { fetchProfileData } from \"./fakeApi\";    const initialResource = fetchProfileData(0);    function App() {    return (      <Suspense fallback={<h1>Loading...</h1>}>        <ProfilePage resource={initialResource} />      </Suspense>    );  }    function ProfilePage({ resource }) {    return (      <SuspenseList revealOrder=\"forwards\">        <ProfileDetails resource={resource} />        <Suspense          fallback={<h2>Loading posts...</h2>}        >          <ProfileTimeline resource={resource} />        </Suspense>        <Suspense          fallback={<h2>Loading fun facts...</h2>}        >          <ProfileTrivia resource={resource} />        </Suspense>      </SuspenseList>    );  }    function ProfileDetails({ resource }) {    const user = resource.user.read();    return <h1>{user.name}</h1>;  }    function ProfileTimeline({ resource }) {    const posts = resource.posts.read();    return (      <ul>        {posts.map(post => (          <li key={post.id}>{post.text}</li>        ))}      </ul>    );  }    function ProfileTrivia({ resource }) {    const trivia = resource.trivia.read();    return (      <>        <h2>Fun Facts</h2>        <ul>          {trivia.map(fact => (            <li key={fact.id}>{fact.text}</li>          ))}        </ul>      </>    );  }    const rootElement = document.getElementById(    \"root\"  );  ReactDOM.createRoot(rootElement).render(<App />);  ```    And the error:    ```  Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.    Check the render method of `ProfilePage`.  ```",
        "human_words": "I'm trying to get React 18 SuspenseList to work in its simplest form. I've downloaded several GitHub repo's that have sample code and they all fail with the same error (pasted below).  I forked a simple sandbox that I assume was working, updated it to the latest React RC-0 and it fails.    Here is a link to the sandbox:  https://codesandbox.io/s/suspense-list-forked-g6tby    This is the relevant code:        And the error:    ",
        "human_words_regrex": "I'm trying to get React 18 SuspenseList to work in its simplest form. I've downloaded several GitHub repo's that have sample code and they all fail with the same error (pasted below). I forked a simple sandbox that I assume was working, updated it to the latest React RC-0 and it fails. Here is a link to the sandbox:  This is the relevant code: And the error: ",
        "human_words_stopwords_removal_lemmatization": "'m trying get react 18 suspenselist work simplest form . 've downloaded several github repo 's sample code fail error ( pasted ) . forked simple sandbox assume working , updated latest react rc-0 fails . link sandbox : relevant code : error :",
        "title_stopwords_removal_lemmatization": "react 18 suspenselist seems broken including simple example"
    },
    {
        "issue_id": 1089002941,
        "title": "Question\uff1aDeprecate defaultProps on function components\uff1f",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-27T06:32:01Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n\r\nThere has always been a question. In my impression, the proposal for the defaultProps of obsolete function components has appeared for a long time, but it is still effective until the React 17 version. Is there any latest plan for this proposal, or can I still Continue to use it?\r\n\r\n[RFC](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components)\r\n\r\nOr, is there any better recommendation?",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->    There has always been a question. In my impression, the proposal for the defaultProps of obsolete function components has appeared for a long time, but it is still effective until the React 17 version. Is there any latest plan for this proposal, or can I still Continue to use it?    [RFC](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components)    Or, is there any better recommendation?",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->    There has always been a question. In my impression, the proposal for the defaultProps of obsolete function components has appeared for a long time, but it is still effective until the React 17 version. Is there any latest plan for this proposal, or can I still Continue to use it?    [RFC](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components)    Or, is there any better recommendation?",
        "human_words_regrex": " There has always been a question. In my impression, the proposal for the defaultProps of obsolete function components has appeared for a long time, but it is still effective until the React 17 version. Is there any latest plan for this proposal, or can I still Continue to use it?  Or, is there any better recommendation?",
        "human_words_stopwords_removal_lemmatization": "always question . impression , proposal defaultprops obsolete function component appeared long time , still effective react 17 version . latest plan proposal , still continue use ? , better recommendation ?",
        "title_stopwords_removal_lemmatization": "question\uff1adeprecate defaultprops function components\uff1f"
    },
    {
        "issue_id": 1089001239,
        "title": "Discuss",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-27T06:27:56Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "discus"
    },
    {
        "issue_id": 1086423189,
        "title": "In Strict Mode, function component and class component are inconsistent with scenes that produce side effects",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-12-22T03:53:21Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version:\r\n\r\n17.0.2\r\n\r\n## Steps To Reproduce\r\n\r\n```js\r\nimport React from 'react';\r\n\r\nconst TestFunc = () => {\r\n  debugger\r\n  const myRef = React.useRef(true)\r\n  if (myRef.current) {\r\n    myRef.current = false\r\n  }\r\n\r\n  return <div>666</div>\r\n}\r\n\r\nclass TestClass extends React.Component {\r\n  myRef = React.createRef()\r\n  constructor(props) {\r\n    super(props);\r\n    this.myRef.current = true\r\n  }\r\n\r\n  render() {\r\n    debugger\r\n    if (this.myRef.current) {\r\n      this.myRef.current = false\r\n    }\r\n    return <div>888</div>\r\n  }\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <React.StrictMode>\r\n      <TestFunc />\r\n      <TestClass />\r\n    </React.StrictMode>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n1. Use strict mode\r\n2. Observe the changes of the myRef.current variable when the two components are rendered for the second time\r\n3. In the function component, the value of the myRef.current variable is \"true\" in the two renders before and after, so the two renders will go to the \"myRef.current = false\" logic. But in the class component, when rendering twice, the myRef.current variable is \"true\" in the first rendering, but the \"false\" that was modified in the first rendering is retained in the second rendering.\r\n\r\n\r\n\r\nReason:\r\nI looked at the source code and found that for the function component, although renderWithHooks was called twice before and after and the same workInProgress was used, but every time in the \"renderWithHooks\" method, the value of \"workInProgress.memoizedState\" is set to null, and in the useRef function of the mounting phase, the \"workInProgress.memoizedState\" property on \"alternate\" will not be reused, therefore, in the mounting phase in strict mode, during the second rendering, the state saved by ref during the first rendering cannot be obtained in the function component.\r\n![4641640144553_ pic](https://user-images.githubusercontent.com/28889103/147032139-9a08127e-0ca5-411e-8c84-8d4cb79904db.jpg)\r\n\r\nBut in the scenario of the class component, the same \"instance\" is used when the render method is called twice before and after, so the \"this\" in the render method two times before and after all points to the same one \"instance\".\r\n![4651640144635_ pic](https://user-images.githubusercontent.com/28889103/147032156-063e3a2c-9c0f-4e59-8f0f-5948d0fde6c0.jpg)\r\n\r\n\r\nExpected:\r\nI think that since the role of strict mode is to make multiple calls so that developers can find that using side effects in some life cycles may cause some problems, should the phenomenon of the class component be consistent with the phenomenon of the function component?\r\n\r\nThanks~:pray::pray::pray:\r\n\r\n\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:    17.0.2        ```js  import React from 'react';    const TestFunc = () => {    debugger    const myRef = React.useRef(true)    if (myRef.current) {      myRef.current = false    }      return <div>666</div>  }    class TestClass extends React.Component {    myRef = React.createRef()    constructor(props) {      super(props);      this.myRef.current = true    }      render() {      debugger      if (this.myRef.current) {        this.myRef.current = false      }      return <div>888</div>    }  }    function App() {    return (      <React.StrictMode>        <TestFunc />        <TestClass />      </React.StrictMode>    );  }    export default App;  ```    1. Use strict mode  2. Observe the changes of the myRef.current variable when the two components are rendered for the second time  3. In the function component, the value of the myRef.current variable is \"true\" in the two renders before and after, so the two renders will go to the \"myRef.current = false\" logic. But in the class component, when rendering twice, the myRef.current variable is \"true\" in the first rendering, but the \"false\" that was modified in the first rendering is retained in the second rendering.        Reason:  I looked at the source code and found that for the function component, although renderWithHooks was called twice before and after and the same workInProgress was used, but every time in the \"renderWithHooks\" method, the value of \"workInProgress.memoizedState\" is set to null, and in the useRef function of the mounting phase, the \"workInProgress.memoizedState\" property on \"alternate\" will not be reused, therefore, in the mounting phase in strict mode, during the second rendering, the state saved by ref during the first rendering cannot be obtained in the function component.  ![4641640144553_ pic](https://user-images.githubusercontent.com/28889103/147032139-9a08127e-0ca5-411e-8c84-8d4cb79904db.jpg)    But in the scenario of the class component, the same \"instance\" is used when the render method is called twice before and after, so the \"this\" in the render method two times before and after all points to the same one \"instance\".  ![4651640144635_ pic](https://user-images.githubusercontent.com/28889103/147032156-063e3a2c-9c0f-4e59-8f0f-5948d0fde6c0.jpg)      Expected:  I think that since the role of strict mode is to make multiple calls so that developers can find that using side effects in some life cycles may cause some problems, should the phenomenon of the class component be consistent with the phenomenon of the function component?    Thanks~:pray::pray::pray:",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:    17.0.2            1. Use strict mode  2. Observe the changes of the myRef.current variable when the two components are rendered for the second time  3. In the function component, the value of the myRef.current variable is \"true\" in the two renders before and after, so the two renders will go to the \"myRef.current = false\" logic. But in the class component, when rendering twice, the myRef.current variable is \"true\" in the first rendering, but the \"false\" that was modified in the first rendering is retained in the second rendering.        Reason:  I looked at the source code and found that for the function component, although renderWithHooks was called twice before and after and the same workInProgress was used, but every time in the \"renderWithHooks\" method, the value of \"workInProgress.memoizedState\" is set to null, and in the useRef function of the mounting phase, the \"workInProgress.memoizedState\" property on \"alternate\" will not be reused, therefore, in the mounting phase in strict mode, during the second rendering, the state saved by ref during the first rendering cannot be obtained in the function component.  ![4641640144553_ pic](https://user-images.githubusercontent.com/28889103/147032139-9a08127e-0ca5-411e-8c84-8d4cb79904db.jpg)    But in the scenario of the class component, the same \"instance\" is used when the render method is called twice before and after, so the \"this\" in the render method two times before and after all points to the same one \"instance\".  ![4651640144635_ pic](https://user-images.githubusercontent.com/28889103/147032156-063e3a2c-9c0f-4e59-8f0f-5948d0fde6c0.jpg)      Expected:  I think that since the role of strict mode is to make multiple calls so that developers can find that using side effects in some life cycles may cause some problems, should the phenomenon of the class component be consistent with the phenomenon of the function component?    Thanks~:pray::pray::pray:",
        "human_words_regrex": " React version: 17.0.2 1. Use strict mode 2. Observe the changes of the myRef.current variable when the two components are rendered for the second time 3. In the function component, the value of the myRef.current variable is \"true\" in the two renders before and after, so the two renders will go to the \"myRef.current = false\" logic. But in the class component, when rendering twice, the myRef.current variable is \"true\" in the first rendering, but the \"false\" that was modified in the first rendering is retained in the second rendering. Reason: I looked at the source code and found that for the function component, although renderWithHooks was called twice before and after and the same workInProgress was used, but every time in the \"renderWithHooks\" method, the value of \"workInProgress.memoizedState\" is set to null, and in the useRef function of the mounting phase, the \"workInProgress.memoizedState\" property on \"alternate\" will not be reused, therefore, in the mounting phase in strict mode, during the second rendering, the state saved by ref during the first rendering cannot be obtained in the function component. ! But in the scenario of the class component, the same \"instance\" is used when the render method is called twice before and after, so the \"this\" in the render method two times before and after all points to the same one \"instance\". ! Expected: I think that since the role of strict mode is to make multiple calls so that developers can find that using side effects in some life cycles may cause some problems, should the phenomenon of the class component be consistent with the phenomenon of the function component? Thanks~:pray::pray::pray:",
        "human_words_stopwords_removal_lemmatization": "react version : 17.0.2 1. use strict mode 2. observe change myref.current variable two component rendered second time 3. function component , value myref.current variable `` true '' two render , two render go `` myref.current = false '' logic . class component , rendering twice , myref.current variable `` true '' first rendering , `` false '' modified first rendering retained second rendering . reason : looked source code found function component , although renderwithhooks called twice workinprogress used , every time `` renderwithhooks '' method , value `` workinprogress.memoizedstate '' set null , useref function mounting phase , `` workinprogress.memoizedstate '' property `` alternate '' reused , therefore , mounting phase strict mode , second rendering , state saved ref first rendering obtained function component . ! scenario class component , `` instance '' used render method called twice , `` '' render method two time point one `` instance '' . ! expected : think since role strict mode make multiple call developer find using side effect life cycle may cause problem , phenomenon class component consistent phenomenon function component ? thanks~ : pray : :pray : :pray :",
        "title_stopwords_removal_lemmatization": "strict mode , function component class component inconsistent scene produce side effect"
    },
    {
        "issue_id": 1085350347,
        "title": "React 18 - HeadlessUI dialog and transitions stopped working ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-21T01:39:16Z",
        "status": "closed",
        "description": "Hello there. \r\nThis is more an issue of headlessUI than react 18, but it may help you understand the effect of the upgrade from react 17 to react 18.\r\n\r\nI can't realize why headlessUI components require some code update, and i guess it's already obvious for you guys, but if it is not the case maybe it would be interesting to understand why it breaks this package and then add some extra instructions to the upgrade guide.\r\n\r\nhttps://github.com/tailwindlabs/headlessui/issues/997\r\n\r\nHope it helps,\r\nThanks!",
        "remove_template_description": "Hello there.   This is more an issue of headlessUI than react 18, but it may help you understand the effect of the upgrade from react 17 to react 18.    I can't realize why headlessUI components require some code update, and i guess it's already obvious for you guys, but if it is not the case maybe it would be interesting to understand why it breaks this package and then add some extra instructions to the upgrade guide.    https://github.com/tailwindlabs/headlessui/issues/997    Hope it helps,  Thanks!",
        "human_words": "Hello there.   This is more an issue of headlessUI than react 18, but it may help you understand the effect of the upgrade from react 17 to react 18.    I can't realize why headlessUI components require some code update, and i guess it's already obvious for you guys, but if it is not the case maybe it would be interesting to understand why it breaks this package and then add some extra instructions to the upgrade guide.    https://github.com/tailwindlabs/headlessui/issues/997    Hope it helps,  Thanks!",
        "human_words_regrex": "Hello there. This is more an issue of headlessUI than react 18, but it may help you understand the effect of the upgrade from react 17 to react 18. I can't realize why headlessUI components require some code update, and i guess it's already obvious for you guys, but if it is not the case maybe it would be interesting to understand why it breaks this package and then add some extra instructions to the upgrade guide.  Hope it helps, Thanks!",
        "human_words_stopwords_removal_lemmatization": "hello . issue headlessui react 18 , may help understand effect upgrade react 17 react 18. ca n't realize headlessui component require code update , guess 's already obvious guy , case maybe would interesting understand break package add extra instruction upgrade guide . hope help , thanks !",
        "title_stopwords_removal_lemmatization": "react 18 - headlessui dialog transition stopped working"
    },
    {
        "issue_id": 1084671799,
        "title": "Feature Request: Provide an optional ref in useState to combat stale state issues",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-20T11:22:08Z",
        "status": "closed",
        "description": "In React, there is a very common issue of needing the most up-to-date version of state from inside a `useEffect`, timeout, callback, asynchronous function, etc. It seems the easiest solution is to use a ref, as encouraged by React's own documentation [here](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function):\r\n\r\n> If you intentionally want to read the latest state from some asynchronous callback, you could keep it in a ref, mutate it, and read from it.\r\n\r\nTypically, the pattern I use for this is as follows:\r\n\r\n```\r\nconst [value, setValue] = useState('some-initial-value');\r\nconst valueRef = useRef(value);\r\nvalueRef.current = value;\r\n```\r\n\r\nThis ensure that on every render we update the ref to contain the latest version of the `value` state. This works fine, but it's messy - 3 lines of code instead of 1 for every state we need the latest version of. For components with a lot of `useState` calls this gets really ugly really fast for something that's remarkably simple and doesn't affect performance.\r\n\r\nMy feature request is this: can we just get a ref that points back to the most recent value of state as part of the `useState` call? I'd love to be able to do this:\r\n\r\n```\r\nconst [value, setValue, valueRef] = useState('some-initial-value');\r\n```\r\n\r\nAnd then just reference `valueRef.current` from within effects, timeouts, intervals, event listener functions, etc. The amount of times I have to use the messy ref workaround is frustrating, and this looks like something React would be able to do so easily just by sticking the latest value in the ref on every render. People could then use it if they want it or continue to call useState() as normal otherwise. \r\n\r\nWould certainly clean up my company's codebase markedly. Are there any potential downsides to providing this optional ref that I am missing?",
        "remove_template_description": "In React, there is a very common issue of needing the most up-to-date version of state from inside a `useEffect`, timeout, callback, asynchronous function, etc. It seems the easiest solution is to use a ref, as encouraged by React's own documentation [here](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function):    > If you intentionally want to read the latest state from some asynchronous callback, you could keep it in a ref, mutate it, and read from it.    Typically, the pattern I use for this is as follows:    ```  const [value, setValue] = useState('some-initial-value');  const valueRef = useRef(value);  valueRef.current = value;  ```    This ensure that on every render we update the ref to contain the latest version of the `value` state. This works fine, but it's messy - 3 lines of code instead of 1 for every state we need the latest version of. For components with a lot of `useState` calls this gets really ugly really fast for something that's remarkably simple and doesn't affect performance.    My feature request is this: can we just get a ref that points back to the most recent value of state as part of the `useState` call? I'd love to be able to do this:    ```  const [value, setValue, valueRef] = useState('some-initial-value');  ```    And then just reference `valueRef.current` from within effects, timeouts, intervals, event listener functions, etc. The amount of times I have to use the messy ref workaround is frustrating, and this looks like something React would be able to do so easily just by sticking the latest value in the ref on every render. People could then use it if they want it or continue to call useState() as normal otherwise.     Would certainly clean up my company's codebase markedly. Are there any potential downsides to providing this optional ref that I am missing?",
        "human_words": "In React, there is a very common issue of needing the most up-to-date version of state from inside a `useEffect`, timeout, callback, asynchronous function, etc. It seems the easiest solution is to use a ref, as encouraged by React's own documentation [here](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function):    > If you intentionally want to read the latest state from some asynchronous callback, you could keep it in a ref, mutate it, and read from it.    Typically, the pattern I use for this is as follows:        This ensure that on every render we update the ref to contain the latest version of the `value` state. This works fine, but it's messy - 3 lines of code instead of 1 for every state we need the latest version of. For components with a lot of `useState` calls this gets really ugly really fast for something that's remarkably simple and doesn't affect performance.    My feature request is this: can we just get a ref that points back to the most recent value of state as part of the `useState` call? I'd love to be able to do this:        And then just reference `valueRef.current` from within effects, timeouts, intervals, event listener functions, etc. The amount of times I have to use the messy ref workaround is frustrating, and this looks like something React would be able to do so easily just by sticking the latest value in the ref on every render. People could then use it if they want it or continue to call useState() as normal otherwise.     Would certainly clean up my company's codebase markedly. Are there any potential downsides to providing this optional ref that I am missing?",
        "human_words_regrex": "In React, there is a very common issue of needing the most up-to-date version of state from inside a `useEffect`, timeout, callback, asynchronous function, etc. It seems the easiest solution is to use a ref, as encouraged by React's own documentation : > If you intentionally want to read the latest state from some asynchronous callback, you could keep it in a ref, mutate it, and read from it. Typically, the pattern I use for this is as follows: This ensure that on every render we update the ref to contain the latest version of the `value` state. This works fine, but it's messy - 3 lines of code instead of 1 for every state we need the latest version of. For components with a lot of `useState` calls this gets really ugly really fast for something that's remarkably simple and doesn't affect performance. My feature request is this: can we just get a ref that points back to the most recent value of state as part of the `useState` call? I'd love to be able to do this: And then just reference `valueRef.current` from within effects, timeouts, intervals, event listener functions, etc. The amount of times I have to use the messy ref workaround is frustrating, and this looks like something React would be able to do so easily just by sticking the latest value in the ref on every render. People could then use it if they want it or continue to call useState() as normal otherwise. Would certainly clean up my company's codebase markedly. Are there any potential downsides to providing this optional ref that I am missing?",
        "human_words_stopwords_removal_lemmatization": "react , common issue needing up-to-date version state inside ` useeffect ` , timeout , callback , asynchronous function , etc . seems easiest solution use ref , encouraged react 's documentation : > intentionally want read latest state asynchronous callback , could keep ref , mutate , read . typically , pattern use follows : ensure every render update ref contain latest version ` value ` state . work fine , 's messy - 3 line code instead 1 every state need latest version . component lot ` usestate ` call get really ugly really fast something 's remarkably simple n't affect performance . feature request : get ref point back recent value state part ` usestate ` call ? 'd love able : reference ` valueref.current ` within effect , timeouts , interval , event listener function , etc . amount time use messy ref workaround frustrating , look like something react would able easily sticking latest value ref every render . people could use want continue call usestate ( ) normal otherwise . would certainly clean company 's codebase markedly . potential downside providing optional ref missing ?",
        "title_stopwords_removal_lemmatization": "feature request : provide optional ref usestate combat stale state issue"
    },
    {
        "issue_id": 1080403149,
        "title": "DevTools: Consider replacing postMessage with BroadcastChannel",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-12-14T23:44:23Z",
        "status": "open",
        "description": "We could build on the changes made in #22949 to update the DevTools _extension_ to use [`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) for communication rather than [`Window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage). This might improve performance but we would need to investigate.\r\n\r\n`BroadcastChannel` can also be explicitly _closed_ which might simplify cleanup.",
        "remove_template_description": "We could build on the changes made in #22949 to update the DevTools _extension_ to use [`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) for communication rather than [`Window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage). This might improve performance but we would need to investigate.    `BroadcastChannel` can also be explicitly _closed_ which might simplify cleanup.",
        "human_words": "We could build on the changes made in #22949 to update the DevTools _extension_ to use [`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) for communication rather than [`Window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage). This might improve performance but we would need to investigate.    `BroadcastChannel` can also be explicitly _closed_ which might simplify cleanup.",
        "human_words_regrex": "We could build on the changes made in #22949 to update the DevTools _extension_ to use  for communication rather than . This might improve performance but we would need to investigate. `BroadcastChannel` can also be explicitly _closed_ which might simplify cleanup.",
        "human_words_stopwords_removal_lemmatization": "could build change made # 22949 update devtools _extension_ use communication rather . might improve performance would need investigate . ` broadcastchannel ` also explicitly _closed_ might simplify cleanup .",
        "title_stopwords_removal_lemmatization": "devtools : consider replacing postmessage broadcastchannel"
    },
    {
        "issue_id": 1077521517,
        "title": "React 18-rc typescript definitions",
        "label": [
            "Type: Discussion",
            "Resolution: Support Redirect",
            "React 18"
        ],
        "date": "2021-12-11T12:18:04Z",
        "status": "closed",
        "description": "I wanted to know whether typescript definitions for react 18-rc is available yet. I wanted to start migrating my typescript project from react 17 to react 18(rc), but I couldn't find any information regarding typescript integration online. On the definitely typed repo there I can see `@types/react/next.d.ts` but it contains alpha version definitions as of now.\r\n",
        "remove_template_description": "I wanted to know whether typescript definitions for react 18-rc is available yet. I wanted to start migrating my typescript project from react 17 to react 18(rc), but I couldn't find any information regarding typescript integration online. On the definitely typed repo there I can see `@types/react/next.d.ts` but it contains alpha version definitions as of now.",
        "human_words": "I wanted to know whether typescript definitions for react 18-rc is available yet. I wanted to start migrating my typescript project from react 17 to react 18(rc), but I couldn't find any information regarding typescript integration online. On the definitely typed repo there I can see `@types/react/next.d.ts` but it contains alpha version definitions as of now.",
        "human_words_regrex": "I wanted to know whether typescript definitions for react 18-rc is available yet. I wanted to start migrating my typescript project from react 17 to react 18(rc), but I couldn't find any information regarding typescript integration online. On the definitely typed repo there I can see `@types/react/next.d.ts` but it contains alpha version definitions as of now.",
        "human_words_stopwords_removal_lemmatization": "wanted know whether typescript definition react 18-rc available yet . wanted start migrating typescript project react 17 react 18 ( rc ) , could n't find information regarding typescript integration online . definitely typed repo see ` @ types/react/next.d.ts ` contains alpha version definition .",
        "title_stopwords_removal_lemmatization": "react 18-rc typescript definition"
    },
    {
        "issue_id": 1073709776,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-07T19:57:40Z",
        "status": "closed",
        "description": "When using \r\n\r\n```\r\n    \"react\": \"^0.0.0-experimental-12bffc78d-20211206\",\r\n    \"react-dom\": \"^0.0.0-experimental-12bffc78d-20211206\",\r\n```\r\n\r\nI can use **SuspenseList**  successfully. \r\n\r\n_App.js_\r\n\r\n```\r\nimport React, { lazy, Suspense, SuspenseList } from \"react\";\r\nimport \"./App.css\";\r\nimport { createResource } from \"./PersonApi\";\r\n\r\nconst Upper = lazy(() => import(\"./upper\"));\r\nconst Lower = lazy(() => import(\"./lower\"));\r\n\r\nfunction App() {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: \"flex\",\r\n        flex: \"1\",\r\n        flexDirection: \"column\",\r\n        height: \"100vh\",\r\n      }}\r\n    >\r\n      <SuspenseList revealOrder=\"backwards\" tail=\"collapsed\">\r\n        <Suspense fallback={<>Loading upper...</>}>\r\n          <Upper />\r\n        </Suspense>\r\n        <Suspense fallback={<>Loading lower...</>}>\r\n          <Lower resource={createResource()} />\r\n        </Suspense>\r\n      </SuspenseList>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n_index.js_\r\n\r\n```\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport reportWebVitals from \"./reportWebVitals\";\r\n\r\nReactDOM.createRoot(document.getElementById(\"root\")).render(<App />);\r\n\r\nreportWebVitals();\r\n```\r\n\r\nHowever, when I change to  react 18 beta as below,\r\n\r\n```\r\n    \"react\": \"^18.0.0-beta-c7917fe76-20211206\",\r\n    \"react-dom\": \"^18.0.0-beta-c7917fe76-20211206\",\r\n```\r\n\r\nreceiving below error;\r\n\r\n![image](https://user-images.githubusercontent.com/6085821/145097343-e3a81dfa-8a8c-45f4-84ea-253596ab3747.png)\r\n",
        "remove_template_description": "When using     ```      \"react\": \"^0.0.0-experimental-12bffc78d-20211206\",      \"react-dom\": \"^0.0.0-experimental-12bffc78d-20211206\",  ```    I can use **SuspenseList**  successfully.     _App.js_    ```  import React, { lazy, Suspense, SuspenseList } from \"react\";  import \"./App.css\";  import { createResource } from \"./PersonApi\";    const Upper = lazy(() => import(\"./upper\"));  const Lower = lazy(() => import(\"./lower\"));    function App() {    return (      <div        style={{          display: \"flex\",          flex: \"1\",          flexDirection: \"column\",          height: \"100vh\",        }}      >        <SuspenseList revealOrder=\"backwards\" tail=\"collapsed\">          <Suspense fallback={<>Loading upper...</>}>            <Upper />          </Suspense>          <Suspense fallback={<>Loading lower...</>}>            <Lower resource={createResource()} />          </Suspense>        </SuspenseList>      </div>    );  }    export default App;  ```    _index.js_    ```  import React from \"react\";  import ReactDOM from \"react-dom\";  import \"./index.css\";  import App from \"./App\";  import reportWebVitals from \"./reportWebVitals\";    ReactDOM.createRoot(document.getElementById(\"root\")).render(<App />);    reportWebVitals();  ```    However, when I change to  react 18 beta as below,    ```      \"react\": \"^18.0.0-beta-c7917fe76-20211206\",      \"react-dom\": \"^18.0.0-beta-c7917fe76-20211206\",  ```    receiving below error;    ![image](https://user-images.githubusercontent.com/6085821/145097343-e3a81dfa-8a8c-45f4-84ea-253596ab3747.png)",
        "human_words": "When using         I can use **SuspenseList**  successfully.     _App.js_        _index.js_        However, when I change to  react 18 beta as below,        receiving below error;    ![image](https://user-images.githubusercontent.com/6085821/145097343-e3a81dfa-8a8c-45f4-84ea-253596ab3747.png)",
        "human_words_regrex": "When using I can use **SuspenseList** successfully. _App.js_ _index.js_ However, when I change to react 18 beta as below, receiving below error; !",
        "human_words_stopwords_removal_lemmatization": "using use * * suspenselist * * successfully . _app.js_ _index.js_ however , change react 18 beta , receiving error ; !",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 1071544216,
        "title": "Why React change keys with dot dollar ? \".$\"",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-05T20:01:17Z",
        "status": "closed",
        "description": "Can we get explanation why all keys are mutate with `.$` by react ?\r\n![image](https://user-images.githubusercontent.com/24865815/144761791-b955ce8a-a3f2-483b-9a6a-93170f22b88d.png)\r\n\r\nso we always need a hack like this to extract key ?!\r\n```ts\r\nconst { key, type, props } = childnode;\r\nconst keyid = ( key as string ).split( '.$' )[1];\r\n```\r\n",
        "remove_template_description": "Can we get explanation why all keys are mutate with `.$` by react ?  ![image](https://user-images.githubusercontent.com/24865815/144761791-b955ce8a-a3f2-483b-9a6a-93170f22b88d.png)    so we always need a hack like this to extract key ?!  ```ts  const { key, type, props } = childnode;  const keyid = ( key as string ).split( '.$' )[1];  ```",
        "human_words": "Can we get explanation why all keys are mutate with `.$` by react ?  ![image](https://user-images.githubusercontent.com/24865815/144761791-b955ce8a-a3f2-483b-9a6a-93170f22b88d.png)    so we always need a hack like this to extract key ?!  ",
        "human_words_regrex": "Can we get explanation why all keys are mutate with `.$` by react ? ! so we always need a hack like this to extract key ?! ",
        "human_words_stopwords_removal_lemmatization": "get explanation key mutate ` . $ ` react ? ! always need hack like extract key ? !",
        "title_stopwords_removal_lemmatization": "react change key dot dollar ? `` . $ ''"
    },
    {
        "issue_id": 1069745589,
        "title": "req.body is showing me object in reverse order.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-12-02T16:26:47Z",
        "status": "closed",
        "description": "Hey,\r\n\r\nI was building a To-do list web app using mern stack with redux. I created a simple form to enter the data but while sending post data to the backend I'm facing difficulty. My form textfield area name is 'task' (E.g. ) and I'm passing let's say 'jonas' as the value. Everythin on the front-end is working fine but in the backend when I console the req.body in post method callback function, I do get {jonas: ' '} as the value. Why is this happening? I mean it should have been {task: 'jonas'}, right? Do you think is there something wrong with passing data from the front-end? I debugged it but it can't be helped. No stack overflow pages have its answers anyway. :(\r\n\r\nPlease someone help me with this thing. I'm stuck on this problem for last two days. I could have shared the code screenshots but the codebase is really huge.\r\n\r\n\r\n",
        "remove_template_description": "Hey,    I was building a To-do list web app using mern stack with redux. I created a simple form to enter the data but while sending post data to the backend I'm facing difficulty. My form textfield area name is 'task' (E.g. ) and I'm passing let's say 'jonas' as the value. Everythin on the front-end is working fine but in the backend when I console the req.body in post method callback function, I do get {jonas: ' '} as the value. Why is this happening? I mean it should have been {task: 'jonas'}, right? Do you think is there something wrong with passing data from the front-end? I debugged it but it can't be helped. No stack overflow pages have its answers anyway. :(    Please someone help me with this thing. I'm stuck on this problem for last two days. I could have shared the code screenshots but the codebase is really huge.",
        "human_words": "Hey,    I was building a To-do list web app using mern stack with redux. I created a simple form to enter the data but while sending post data to the backend I'm facing difficulty. My form textfield area name is 'task' (E.g. ) and I'm passing let's say 'jonas' as the value. Everythin on the front-end is working fine but in the backend when I console the req.body in post method callback function, I do get {jonas: ' '} as the value. Why is this happening? I mean it should have been {task: 'jonas'}, right? Do you think is there something wrong with passing data from the front-end? I debugged it but it can't be helped. No stack overflow pages have its answers anyway. :(    Please someone help me with this thing. I'm stuck on this problem for last two days. I could have shared the code screenshots but the codebase is really huge.",
        "human_words_regrex": "Hey, I was building a To-do list web app using mern stack with redux. I created a simple form to enter the data but while sending post data to the backend I'm facing difficulty. My form textfield area name is 'task' (E.g. ) and I'm passing let's say 'jonas' as the value. Everythin on the front-end is working fine but in the backend when I console the req.body in post method callback function, I do get {jonas: ' '} as the value. Why is this happening? I mean it should have been {task: 'jonas'}, right? Do you think is there something wrong with passing data from the front-end? I debugged it but it can't be helped. No stack overflow pages have its answers anyway. :( Please someone help me with this thing. I'm stuck on this problem for last two days. I could have shared the code screenshots but the codebase is really huge.",
        "human_words_stopwords_removal_lemmatization": "hey , building to-do list web app using mern stack redux . created simple form enter data sending post data backend 'm facing difficulty . form textfield area name 'task ' ( e.g . ) 'm passing let 's say 'jonas ' value . everythin front-end working fine backend console req.body post method callback function , get { jonas : ' ' } value . happening ? mean { task : 'jonas ' } , right ? think something wrong passing data front-end ? debugged ca n't helped . stack overflow page answer anyway . : ( please someone help thing . 'm stuck problem last two day . could shared code screenshots codebase really huge .",
        "title_stopwords_removal_lemmatization": "req.body showing object reverse order ."
    },
    {
        "issue_id": 1065100791,
        "title": "`Object.prototype` builtins should not be used directly",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-11-27T18:11:58Z",
        "status": "open",
        "description": "It is preferable to call certain Object.prototype methods through Object on object instances instead of using the builtins directly.\r\n\r\nObjects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities.\r\n\r\n\r\nIt's better to always call these methods from ``Object.prototype``. For example, ``obj.hasOwnProperty(\"bar\")`` should be replaced with ``Object.prototype.hasOwnProperty.call(obj, \"bar\")``.\r\n\r\n\r\nBelow is an example of  a bad practice \ud83d\udc47\r\n\r\n```       \r\nlet hasBarProperty = obj.hasOwnProperty(\"property\");\r\n\r\nlet isPrototypeOfBar = obj.isPrototypeOf(property);\r\n\r\nlet barIsEnumerable = obj.propertyIsEnumerable(\"property\");\r\n\r\n ```\r\n\r\nBelow is an example of a good practice\r\n\r\n```\r\nlet hasBarProperty = Object.prototype.hasOwnProperty.call(obj, \"property\");\r\n\r\nlet isPrototypeOfBar = Object.prototype.isPrototypeOf.call(obj, property);\r\n\r\nlet barIsEnumerable = {}.propertyIsEnumerable.call(obj, \"property\");\r\n\r\n```\r\n\r\nI have been able to find the same occurences in some files will go ahead and pull a PR only if its worthful. ",
        "remove_template_description": "It is preferable to call certain Object.prototype methods through Object on object instances instead of using the builtins directly.    Objects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities.      It's better to always call these methods from ``Object.prototype``. For example, ``obj.hasOwnProperty(\"bar\")`` should be replaced with ``Object.prototype.hasOwnProperty.call(obj, \"bar\")``.      Below is an example of  a bad practice \ud83d\udc47    ```         let hasBarProperty = obj.hasOwnProperty(\"property\");    let isPrototypeOfBar = obj.isPrototypeOf(property);    let barIsEnumerable = obj.propertyIsEnumerable(\"property\");     ```    Below is an example of a good practice    ```  let hasBarProperty = Object.prototype.hasOwnProperty.call(obj, \"property\");    let isPrototypeOfBar = Object.prototype.isPrototypeOf.call(obj, property);    let barIsEnumerable = {}.propertyIsEnumerable.call(obj, \"property\");    ```    I have been able to find the same occurences in some files will go ahead and pull a PR only if its worthful.",
        "human_words": "It is preferable to call certain Object.prototype methods through Object on object instances instead of using the builtins directly.    Objects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities.      It's better to always call these methods from ``Object.prototype``. For example, ``obj.hasOwnProperty(\"bar\")`` should be replaced with ``Object.prototype.hasOwnProperty.call(obj, \"bar\")``.      Below is an example of  a bad practice \ud83d\udc47        Below is an example of a good practice        I have been able to find the same occurences in some files will go ahead and pull a PR only if its worthful.",
        "human_words_regrex": "It is preferable to call certain Object.prototype methods through Object on object instances instead of using the builtins directly. Objects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities. It's better to always call these methods from ``Object.prototype``. For example, ``obj.hasOwnProperty(\"bar\")`` should be replaced with ``Object.prototype.hasOwnProperty.call(obj, \"bar\")``. Below is an example of a bad practice \ud83d\udc47 Below is an example of a good practice I have been able to find the same occurences in some files will go ahead and pull a PR only if its worthful.",
        "human_words_stopwords_removal_lemmatization": "preferable call certain object.prototype method object object instance instead using builtins directly . object property shadow builtins object.prototype , potentially causing unintended behavior denial-of-service security vulnerability . 's better always call method `` object.prototype `` . example , `` obj.hasownproperty ( `` bar '' ) `` replaced `` object.prototype.hasownproperty.call ( obj , `` bar '' ) `` . example bad practice \ud83d\udc47 example good practice able find occurences file go ahead pull pr worthful .",
        "title_stopwords_removal_lemmatization": "` object.prototype ` builtins used directly"
    },
    {
        "issue_id": 1064979807,
        "title": "React 18: Unexpected component unmounting in Strict Mode",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-27T11:05:30Z",
        "status": "closed",
        "description": "This is an issue I've come across when trying to upgrade react-query to v18.\r\n\r\nA minimal reproduction would be [this codesandbox](https://codesandbox.io/s/unmount-issue-2fec5?file=/src/App.js)\r\n\r\n**Expected behavior**\r\n\r\nThe component should mount, render with `count 1`, then after one second update to `count 2`\r\n\r\n**Actual behavior**\r\n\r\nThe component mounts, renders with `count 1`, then after one second update to `count 3`. You can also observe that the component unmounts in between (the cleanup function of the useEffect runs, see the console log) and then mounts again (the effect runs again).\r\n\r\n**Context**\r\n\r\nreact-query subscribes / unsubscribes observers when components mount, and this behavior can lead to bugs, like retries being cancelled if the observer unmounts in between. I could reproduce this with either the latest v3 version of react-query, where we subscribe / unsubscribe in a useEffect, as well as with the version that attempts to upgrade to `useSyncExternalStorage`.\r\n\r\n**Workarounds**\r\n\r\nIssue does _not_ show up if:\r\n\r\n- you use `ReactDOM.render` instead of `createRoot`\r\n- you remove `<React.StrictMode>` from the sandbox\r\n\r\n\r\n**Related**\r\n\r\nnot sure if this issue is really related, but I found it before opening this issue. It doesn't have much information in it though:\r\n- https://github.com/facebook/react/issues/21674",
        "remove_template_description": "This is an issue I've come across when trying to upgrade react-query to v18.    A minimal reproduction would be [this codesandbox](https://codesandbox.io/s/unmount-issue-2fec5?file=/src/App.js)    **Expected behavior**    The component should mount, render with `count 1`, then after one second update to `count 2`    **Actual behavior**    The component mounts, renders with `count 1`, then after one second update to `count 3`. You can also observe that the component unmounts in between (the cleanup function of the useEffect runs, see the console log) and then mounts again (the effect runs again).    **Context**    react-query subscribes / unsubscribes observers when components mount, and this behavior can lead to bugs, like retries being cancelled if the observer unmounts in between. I could reproduce this with either the latest v3 version of react-query, where we subscribe / unsubscribe in a useEffect, as well as with the version that attempts to upgrade to `useSyncExternalStorage`.    **Workarounds**    Issue does _not_ show up if:    - you use `ReactDOM.render` instead of `createRoot`  - you remove `<React.StrictMode>` from the sandbox      **Related**    not sure if this issue is really related, but I found it before opening this issue. It doesn't have much information in it though:  - https://github.com/facebook/react/issues/21674",
        "human_words": "This is an issue I've come across when trying to upgrade react-query to v18.    A minimal reproduction would be [this codesandbox](https://codesandbox.io/s/unmount-issue-2fec5?file=/src/App.js)    **Expected behavior**    The component should mount, render with `count 1`, then after one second update to `count 2`    **Actual behavior**    The component mounts, renders with `count 1`, then after one second update to `count 3`. You can also observe that the component unmounts in between (the cleanup function of the useEffect runs, see the console log) and then mounts again (the effect runs again).    **Context**    react-query subscribes / unsubscribes observers when components mount, and this behavior can lead to bugs, like retries being cancelled if the observer unmounts in between. I could reproduce this with either the latest v3 version of react-query, where we subscribe / unsubscribe in a useEffect, as well as with the version that attempts to upgrade to `useSyncExternalStorage`.    **Workarounds**    Issue does _not_ show up if:    - you use `ReactDOM.render` instead of `createRoot`  - you remove `<React.StrictMode>` from the sandbox      **Related**    not sure if this issue is really related, but I found it before opening this issue. It doesn't have much information in it though:  - https://github.com/facebook/react/issues/21674",
        "human_words_regrex": "This is an issue I've come across when trying to upgrade react-query to v18. A minimal reproduction would be  **Expected behavior** The component should mount, render with `count 1`, then after one second update to `count 2` **Actual behavior** The component mounts, renders with `count 1`, then after one second update to `count 3`. You can also observe that the component unmounts in between (the cleanup function of the useEffect runs, see the console log) and then mounts again (the effect runs again). **Context** react-query subscribes / unsubscribes observers when components mount, and this behavior can lead to bugs, like retries being cancelled if the observer unmounts in between. I could reproduce this with either the latest v3 version of react-query, where we subscribe / unsubscribe in a useEffect, as well as with the version that attempts to upgrade to `useSyncExternalStorage`. **Workarounds** Issue does _not_ show up if: - you use `ReactDOM.render` instead of `createRoot` - you remove `` from the sandbox **Related** not sure if this issue is really related, but I found it before opening this issue. It doesn't have much information in it though: - ",
        "human_words_stopwords_removal_lemmatization": "issue 've come across trying upgrade react-query v18 . minimal reproduction would * * expected behavior * * component mount , render ` count 1 ` , one second update ` count 2 ` * * actual behavior * * component mount , render ` count 1 ` , one second update ` count 3 ` . also observe component unmounts ( cleanup function useeffect run , see console log ) mount ( effect run ) . * * context * * react-query subscribes / unsubscribes observer component mount , behavior lead bug , like retries cancelled observer unmounts . could reproduce either latest v3 version react-query , subscribe / unsubscribe useeffect , well version attempt upgrade ` usesyncexternalstorage ` . * * workarounds * * issue _not_ show : - use ` reactdom.render ` instead ` createroot ` - remove `` sandbox * * related * * sure issue really related , found opening issue . n't much information though : -",
        "title_stopwords_removal_lemmatization": "react 18 : unexpected component unmounting strict mode"
    },
    {
        "issue_id": 1064884867,
        "title": "React 18: How to \"wait\" for concurrent mode",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-27T02:32:56Z",
        "status": "closed",
        "description": "The question is driven by:\r\n- need to unit test SSR->CSR for https://github.com/facebook/react/issues/22733, based on [nextjs](https://github.com/vercel/next.js/pull/31102/files#diff-ad3bf93a303ca55f5265b25001f7f60303cbf3b0315f548bed913f8e0ff3f300R33-R40) code, but using React API directly(in Jest), not webdriver/browser.\r\n- current advice for `Render Callbacks` at https://github.com/reactwg/react-18/discussions/5\r\n\r\n```tsx\r\nfunction App({ callback }) {\r\n  // Callback will be called when the div is first created.\r\n  return (\r\n    <div ref={callback}>\r\n      <h1>Hello World</h1>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\n\r\nconst root = ReactDOM.createRoot(rootElement);\r\nroot.render(<App callback={() => console.log(\"renderered\")} />);\r\n```\r\n\r\nGiven advice is working as expected, and waiting for callback results the expected HTML to be presented in DOM, except:\r\n- it does not wait for any `useEffect`\r\n- it does not guarantee that everything else is rendered, because Concurrent Mode does not guarantee this by default.\r\n- it cannot handle updates\r\n\r\nWondering, is there any way to:\r\n- await for all currently scheduled work to be executed\r\n- synchronously flush all unfinished work\r\n\r\nIt's also worth clarifying that in the given example React is working in a little synthetic environment, which is neither real browser nor a unit test. The existence of such a test should be questioned in the first place.\r\n",
        "remove_template_description": "The question is driven by:  - need to unit test SSR->CSR for https://github.com/facebook/react/issues/22733, based on [nextjs](https://github.com/vercel/next.js/pull/31102/files#diff-ad3bf93a303ca55f5265b25001f7f60303cbf3b0315f548bed913f8e0ff3f300R33-R40) code, but using React API directly(in Jest), not webdriver/browser.  - current advice for `Render Callbacks` at https://github.com/reactwg/react-18/discussions/5    ```tsx  function App({ callback }) {    // Callback will be called when the div is first created.    return (      <div ref={callback}>        <h1>Hello World</h1>      </div>    );  }    const rootElement = document.getElementById(\"root\");    const root = ReactDOM.createRoot(rootElement);  root.render(<App callback={() => console.log(\"renderered\")} />);  ```    Given advice is working as expected, and waiting for callback results the expected HTML to be presented in DOM, except:  - it does not wait for any `useEffect`  - it does not guarantee that everything else is rendered, because Concurrent Mode does not guarantee this by default.  - it cannot handle updates    Wondering, is there any way to:  - await for all currently scheduled work to be executed  - synchronously flush all unfinished work    It's also worth clarifying that in the given example React is working in a little synthetic environment, which is neither real browser nor a unit test. The existence of such a test should be questioned in the first place.",
        "human_words": "The question is driven by:  - need to unit test SSR->CSR for https://github.com/facebook/react/issues/22733, based on [nextjs](https://github.com/vercel/next.js/pull/31102/files#diff-ad3bf93a303ca55f5265b25001f7f60303cbf3b0315f548bed913f8e0ff3f300R33-R40) code, but using React API directly(in Jest), not webdriver/browser.  - current advice for `Render Callbacks` at https://github.com/reactwg/react-18/discussions/5        Given advice is working as expected, and waiting for callback results the expected HTML to be presented in DOM, except:  - it does not wait for any `useEffect`  - it does not guarantee that everything else is rendered, because Concurrent Mode does not guarantee this by default.  - it cannot handle updates    Wondering, is there any way to:  - await for all currently scheduled work to be executed  - synchronously flush all unfinished work    It's also worth clarifying that in the given example React is working in a little synthetic environment, which is neither real browser nor a unit test. The existence of such a test should be questioned in the first place.",
        "human_words_regrex": "The question is driven by: - need to unit test SSR->CSR for  based on  code, but using React API directly(in Jest), not webdriver/browser. - current advice for `Render Callbacks` at  Given advice is working as expected, and waiting for callback results the expected HTML to be presented in DOM, except: - it does not wait for any `useEffect` - it does not guarantee that everything else is rendered, because Concurrent Mode does not guarantee this by default. - it cannot handle updates Wondering, is there any way to: - await for all currently scheduled work to be executed - synchronously flush all unfinished work It's also worth clarifying that in the given example React is working in a little synthetic environment, which is neither real browser nor a unit test. The existence of such a test should be questioned in the first place.",
        "human_words_stopwords_removal_lemmatization": "question driven : - need unit test ssr- > csr based code , using react api directly ( jest ) , webdriver/browser . - current advice ` render callback ` given advice working expected , waiting callback result expected html presented dom , except : - wait ` useeffect ` - guarantee everything else rendered , concurrent mode guarantee default . - handle update wondering , way : - await currently scheduled work executed - synchronously flush unfinished work 's also worth clarifying given example react working little synthetic environment , neither real browser unit test . existence test questioned first place .",
        "title_stopwords_removal_lemmatization": "react 18 : `` wait '' concurrent mode"
    },
    {
        "issue_id": 1063962061,
        "title": "React 18: Non-recoverable hydration mismatch if mismatch occurs in the same boundary as main script",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-25T23:16:17Z",
        "status": "closed",
        "description": "React version: 18.0.0-rc.1-next-cb1e7b1c6-20220303\r\n\r\n## Steps To Reproduce\r\n\r\n1. Cause a hydration mismatch in the same boundary as `<script />` for main entrypoint\r\n2. Attempt to hydrate\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example: https://codesandbox.io/s/react-18-hydration-mismatch-in-document-6buos (based on https://codesandbox.io/s/kind-sammet-j56ro?file=/server/render.js:1054-1614 from https://github.com/reactwg/react-18/discussions/22)\r\n\r\n```jsx\r\n{/* forced hydration mismatch */}\r\n{typeof window === \"undefined\" ? <div>Server</div> : <span>Client</span>}\r\n{/* main.js is the entrypoint for hydrateRoot */}\r\n<script src={assets[\"main.js\"]} />\r\n```\r\n\r\nThe original issue was caused by a wrong usage of the Remix starter template:\r\n```jsx\r\n<html lang=\"en\">\r\n\t<head>\r\n\t\t<meta charSet=\"utf-8\" />\r\n\t\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\r\n\t\t{title ? <title>{title}</title> : null}\r\n\t\t<Meta />\r\n\t\t<Links />\r\n\t</head>\r\n\t<body>\r\n\t\t{children}\r\n\t\t<Scripts />\r\n\t\t{process.env.NODE_ENV === \"development\" && <LiveReload />}\r\n\t</body>\r\n</html>\r\n```\r\nThe hydration mismatch happened due to a mismatch of `process.env.NODE_ENV` between client and server.\r\n\r\n## The current behavior\r\n\r\nWhole UI is unmounted (i.e. no recovery via client-side only rendering) and the following errors are logged:\r\n<details>\r\n<summary>Errors when landing on the page</summary>\r\n\r\n```bash\r\nreact-dom.development.js:14452 Uncaught Error: An error occurred during hydration. The server HTML was replaced with client content\r\n    at throwOnHydrationMismatchIfConcurrentMode (react-dom.development.js:14452)\r\n    at tryToClaimNextHydratableInstance (react-dom.development.js:14475)\r\n    at updateHostComponent$1 (react-dom.development.js:20608)\r\n    at beginWork (react-dom.development.js:22350)\r\n    at HTMLUnknownElement.callCallback (react-dom.development.js:4128)\r\n    at Object.invokeGuardedCallbackDev (react-dom.development.js:4177)\r\n    at invokeGuardedCallback (react-dom.development.js:4241)\r\n    at beginWork$1 (react-dom.development.js:27125)\r\n    at performUnitOfWork (react-dom.development.js:26290)\r\n    at workLoopSync (react-dom.development.js:26200)\r\nthrowOnHydrationMismatchIfConcurrentMode @ react-dom.development.js:14452\r\ntryToClaimNextHydratableInstance @ react-dom.development.js:14475\r\nupdateHostComponent$1 @ react-dom.development.js:20608\r\nbeginWork @ react-dom.development.js:22350\r\ncallCallback @ react-dom.development.js:4128\r\ninvokeGuardedCallbackDev @ react-dom.development.js:4177\r\ninvokeGuardedCallback @ react-dom.development.js:4241\r\nbeginWork$1 @ react-dom.development.js:27125\r\nperformUnitOfWork @ react-dom.development.js:26290\r\nworkLoopSync @ react-dom.development.js:26200\r\nrenderRootSync @ react-dom.development.js:26168\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25514\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nclient-hook-6.js:1 Warning: An error occurred during hydration. The server HTML was replaced with client content in <#document>.\r\nr.<computed> @ client-hook-6.js:1\r\nprintWarning @ react-dom.development.js:86\r\nerror @ react-dom.development.js:60\r\nerrorHydratingContainer @ react-dom.development.js:11234\r\nrecoverFromConcurrentError @ react-dom.development.js:25597\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25526\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nreact-dom.development.js:22649 Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.\r\n    at appendChildToContainer (https://6buos.sse.codesandbox.io/main.js:11262:16)\r\n    at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24195:7)\r\n    at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24201:7)\r\n    at commitPlacement (https://6buos.sse.codesandbox.io/main.js:24179:5)\r\n    at commitMutationEffectsOnFiber (https://6buos.sse.codesandbox.io/main.js:24693:9)\r\n    at commitMutationEffects_complete (https://6buos.sse.codesandbox.io/main.js:24586:7)\r\n    at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24575:7)\r\n    at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)\r\n    at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)\r\n(anonymous) @ react-dom.development.js:22649\r\ncallCallback @ react-dom.development.js:4128\r\ninvokeGuardedCallbackDev @ react-dom.development.js:4177\r\ninvokeGuardedCallback @ react-dom.development.js:4241\r\nreportUncaughtErrorInDEV @ react-dom.development.js:22648\r\ncommitMutationEffects_complete @ react-dom.development.js:24200\r\ncommitMutationEffects_begin @ react-dom.development.js:24187\r\ncommitMutationEffects @ react-dom.development.js:24157\r\ncommitRootImpl @ react-dom.development.js:26531\r\ncommitRoot @ react-dom.development.js:26410\r\nfinishConcurrentRender @ react-dom.development.js:25728\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25574\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nreact-dom.development.js:22649 Uncaught DOMException: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.\r\n    at removeChildFromContainer (https://6buos.sse.codesandbox.io/main.js:11298:15)\r\n    at unmountHostComponents (https://6buos.sse.codesandbox.io/main.js:24289:9)\r\n    at commitDeletion (https://6buos.sse.codesandbox.io/main.js:24350:5)\r\n    at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24561:11)\r\n    at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)\r\n    at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)\r\n    at performSyncWorkOnRoot (https://6buos.sse.codesandbox.io/main.js:26248:3)\r\n    at flushSyncCallbacks (https://6buos.sse.codesandbox.io/main.js:12196:22)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:27046:3)\r\n(anonymous) @ react-dom.development.js:22649\r\ncallCallback @ react-dom.development.js:4128\r\ninvokeGuardedCallbackDev @ react-dom.development.js:4177\r\ninvokeGuardedCallback @ react-dom.development.js:4241\r\nreportUncaughtErrorInDEV @ react-dom.development.js:22648\r\ncommitMutationEffects_begin @ react-dom.development.js:24175\r\ncommitMutationEffects @ react-dom.development.js:24157\r\ncommitRootImpl @ react-dom.development.js:26531\r\ncommitRoot @ react-dom.development.js:26410\r\nperformSyncWorkOnRoot @ react-dom.development.js:25860\r\nflushSyncCallbacks @ react-dom.development.js:11803\r\ncommitRootImpl @ react-dom.development.js:26658\r\ncommitRoot @ react-dom.development.js:26410\r\nfinishConcurrentRender @ react-dom.development.js:25728\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25574\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nclient-hook-6.js:1 The above error occurred in the <App> component:\r\n\r\n    at App (https://6buos.sse.codesandbox.io/main.js:34968:21)\r\n\r\nConsider adding an error boundary to your tree to customize error handling behavior.\r\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\r\nr.<computed> @ client-hook-6.js:1\r\nlogCapturedError @ react-dom.development.js:18588\r\nupdate.callback @ react-dom.development.js:18621\r\ncallCallback @ react-dom.development.js:13229\r\ncommitUpdateQueue @ react-dom.development.js:13250\r\ncommitLayoutEffectOnFiber @ react-dom.development.js:23177\r\ncommitLayoutMountEffects_complete @ react-dom.development.js:24431\r\ncommitLayoutEffects_begin @ react-dom.development.js:24417\r\ncommitLayoutEffects @ react-dom.development.js:24355\r\ncommitRootImpl @ react-dom.development.js:26544\r\ncommitRoot @ react-dom.development.js:26410\r\nperformSyncWorkOnRoot @ react-dom.development.js:25860\r\nflushSyncCallbacks @ react-dom.development.js:11803\r\ncommitRootImpl @ react-dom.development.js:26658\r\ncommitRoot @ react-dom.development.js:26410\r\nfinishConcurrentRender @ react-dom.development.js:25728\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25574\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nreact-dom.development.js:11817 Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.\r\n    at appendChildToContainer (https://6buos.sse.codesandbox.io/main.js:11262:16)\r\n    at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24195:7)\r\n    at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24201:7)\r\n    at commitPlacement (https://6buos.sse.codesandbox.io/main.js:24179:5)\r\n    at commitMutationEffectsOnFiber (https://6buos.sse.codesandbox.io/main.js:24693:9)\r\n    at commitMutationEffects_complete (https://6buos.sse.codesandbox.io/main.js:24586:7)\r\n    at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24575:7)\r\n    at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)\r\n    at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)\r\nflushSyncCallbacks @ react-dom.development.js:11817\r\ncommitRootImpl @ react-dom.development.js:26658\r\ncommitRoot @ react-dom.development.js:26410\r\nfinishConcurrentRender @ react-dom.development.js:25728\r\nperformConcurrentWorkOnRoot @ react-dom.development.js:25574\r\nworkLoop @ scheduler.development.js:265\r\nflushWork @ scheduler.development.js:238\r\nperformWorkUntilDeadline @ scheduler.development.js:532\r\nrun @ setImmediate.js:40\r\nrunIfPresent @ setImmediate.js:69\r\nonGlobalMessage @ setImmediate.js:109\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nclient-hook-6.js:1 The above error occurred in the <App> component:\r\n\r\n    at App (https://6buos.sse.codesandbox.io/main.js:34968:21)\r\n\r\nConsider adding an error boundary to your tree to customize error handling behavior.\r\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\r\nr.<computed> @ client-hook-6.js:1\r\nlogCapturedError @ react-dom.development.js:18588\r\nupdate.callback @ react-dom.development.js:18621\r\ncallCallback @ react-dom.development.js:13229\r\ncommitUpdateQueue @ react-dom.development.js:13250\r\ncommitLayoutEffectOnFiber @ react-dom.development.js:23177\r\ncommitLayoutMountEffects_complete @ react-dom.development.js:24431\r\ncommitLayoutEffects_begin @ react-dom.development.js:24417\r\ncommitLayoutEffects @ react-dom.development.js:24355\r\ncommitRootImpl @ react-dom.development.js:26544\r\ncommitRoot @ react-dom.development.js:26410\r\nperformSyncWorkOnRoot @ react-dom.development.js:25860\r\nflushSyncCallbacks @ react-dom.development.js:11803\r\npostMessage (async)\r\nregisterImmediate @ setImmediate.js:120\r\nsetImmediate @ setImmediate.js:27\r\nschedulePerformWorkUntilDeadline @ scheduler.development.js:563\r\nrequestHostCallback @ scheduler.development.js:587\r\nunstable_scheduleCallback @ scheduler.development.js:440\r\nscheduleCallback$1 @ react-dom.development.js:27211\r\nensureRootIsScheduled @ react-dom.development.js:25459\r\nscheduleUpdateOnFiber @ react-dom.development.js:25278\r\nupdateContainer @ react-dom.development.js:28483\r\nhydrateRoot @ react-dom.development.js:28991\r\n./src/index.js @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n0 @ index.js:12\r\n__webpack_require__ @ bootstrap:19\r\n(anonymous) @ bootstrap:83\r\n(anonymous) @ bootstrap:83\r\nreact-dom.development.js:11817 Uncaught DOMException: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.\r\n    at removeChildFromContainer (https://6buos.sse.codesandbox.io/main.js:11298:15)\r\n    at unmountHostComponents (https://6buos.sse.codesandbox.io/main.js:24289:9)\r\n    at commitDeletion (https://6buos.sse.codesandbox.io/main.js:24350:5)\r\n    at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24561:11)\r\n    at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)\r\n    at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)\r\n    at performSyncWorkOnRoot (https://6buos.sse.codesandbox.io/main.js:26248:3)\r\n    at flushSyncCallbacks (https://6buos.sse.codesandbox.io/main.js:12196:22)\r\n    at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:27046:3)\r\n```\r\n</details>\r\n\r\n\r\n## The expected behavior\r\n\r\nNot sure since I wouldn't be surprised if React couldn't do anything about it considering it probably unmounts its own `script` tag?\r\n\r\nReact 17 behavior: https://codesandbox.io/s/react-17-hydration-mismatch-in-document-m22vv\r\n\r\nThe good thing is that frameworks can guard against author error by wrapping user code in Suspense boundaries so that any hydration mismatch from user code does not result in throwing away the main script (or too much in general). But that might require a lot of otherwise unnecessary Suspense boundaries (is that a problem?)\r\n",
        "remove_template_description": "React version: 18.0.0-rc.1-next-cb1e7b1c6-20220303        1. Cause a hydration mismatch in the same boundary as `<script />` for main entrypoint  2. Attempt to hydrate    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/react-18-hydration-mismatch-in-document-6buos (based on https://codesandbox.io/s/kind-sammet-j56ro?file=/server/render.js:1054-1614 from https://github.com/reactwg/react-18/discussions/22)    ```jsx  {/* forced hydration mismatch */}  {typeof window === \"undefined\" ? <div>Server</div> : <span>Client</span>}  {/* main.js is the entrypoint for hydrateRoot */}  <script src={assets[\"main.js\"]} />  ```    The original issue was caused by a wrong usage of the Remix starter template:  ```jsx  <html lang=\"en\">  \t<head>  \t\t<meta charSet=\"utf-8\" />  \t\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />  \t\t{title ? <title>{title}</title> : null}  \t\t<Meta />  \t\t<Links />  \t</head>  \t<body>  \t\t{children}  \t\t<Scripts />  \t\t{process.env.NODE_ENV === \"development\" && <LiveReload />}  \t</body>  </html>  ```  The hydration mismatch happened due to a mismatch of `process.env.NODE_ENV` between client and server.        Whole UI is unmounted (i.e. no recovery via client-side only rendering) and the following errors are logged:  <details>  <summary>Errors when landing on the page</summary>    ```bash  react-dom.development.js:14452 Uncaught Error: An error occurred during hydration. The server HTML was replaced with client content      at throwOnHydrationMismatchIfConcurrentMode (react-dom.development.js:14452)      at tryToClaimNextHydratableInstance (react-dom.development.js:14475)      at updateHostComponent$1 (react-dom.development.js:20608)      at beginWork (react-dom.development.js:22350)      at HTMLUnknownElement.callCallback (react-dom.development.js:4128)      at Object.invokeGuardedCallbackDev (react-dom.development.js:4177)      at invokeGuardedCallback (react-dom.development.js:4241)      at beginWork$1 (react-dom.development.js:27125)      at performUnitOfWork (react-dom.development.js:26290)      at workLoopSync (react-dom.development.js:26200)  throwOnHydrationMismatchIfConcurrentMode @ react-dom.development.js:14452  tryToClaimNextHydratableInstance @ react-dom.development.js:14475  updateHostComponent$1 @ react-dom.development.js:20608  beginWork @ react-dom.development.js:22350  callCallback @ react-dom.development.js:4128  invokeGuardedCallbackDev @ react-dom.development.js:4177  invokeGuardedCallback @ react-dom.development.js:4241  beginWork$1 @ react-dom.development.js:27125  performUnitOfWork @ react-dom.development.js:26290  workLoopSync @ react-dom.development.js:26200  renderRootSync @ react-dom.development.js:26168  performConcurrentWorkOnRoot @ react-dom.development.js:25514  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  client-hook-6.js:1 Warning: An error occurred during hydration. The server HTML was replaced with client content in <#document>.  r.<computed> @ client-hook-6.js:1  printWarning @ react-dom.development.js:86  error @ react-dom.development.js:60  errorHydratingContainer @ react-dom.development.js:11234  recoverFromConcurrentError @ react-dom.development.js:25597  performConcurrentWorkOnRoot @ react-dom.development.js:25526  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  react-dom.development.js:22649 Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.      at appendChildToContainer (https://6buos.sse.codesandbox.io/main.js:11262:16)      at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24195:7)      at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24201:7)      at commitPlacement (https://6buos.sse.codesandbox.io/main.js:24179:5)      at commitMutationEffectsOnFiber (https://6buos.sse.codesandbox.io/main.js:24693:9)      at commitMutationEffects_complete (https://6buos.sse.codesandbox.io/main.js:24586:7)      at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24575:7)      at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)      at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)  (anonymous) @ react-dom.development.js:22649  callCallback @ react-dom.development.js:4128  invokeGuardedCallbackDev @ react-dom.development.js:4177  invokeGuardedCallback @ react-dom.development.js:4241  reportUncaughtErrorInDEV @ react-dom.development.js:22648  commitMutationEffects_complete @ react-dom.development.js:24200  commitMutationEffects_begin @ react-dom.development.js:24187  commitMutationEffects @ react-dom.development.js:24157  commitRootImpl @ react-dom.development.js:26531  commitRoot @ react-dom.development.js:26410  finishConcurrentRender @ react-dom.development.js:25728  performConcurrentWorkOnRoot @ react-dom.development.js:25574  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  react-dom.development.js:22649 Uncaught DOMException: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.      at removeChildFromContainer (https://6buos.sse.codesandbox.io/main.js:11298:15)      at unmountHostComponents (https://6buos.sse.codesandbox.io/main.js:24289:9)      at commitDeletion (https://6buos.sse.codesandbox.io/main.js:24350:5)      at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24561:11)      at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)      at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)      at performSyncWorkOnRoot (https://6buos.sse.codesandbox.io/main.js:26248:3)      at flushSyncCallbacks (https://6buos.sse.codesandbox.io/main.js:12196:22)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:27046:3)  (anonymous) @ react-dom.development.js:22649  callCallback @ react-dom.development.js:4128  invokeGuardedCallbackDev @ react-dom.development.js:4177  invokeGuardedCallback @ react-dom.development.js:4241  reportUncaughtErrorInDEV @ react-dom.development.js:22648  commitMutationEffects_begin @ react-dom.development.js:24175  commitMutationEffects @ react-dom.development.js:24157  commitRootImpl @ react-dom.development.js:26531  commitRoot @ react-dom.development.js:26410  performSyncWorkOnRoot @ react-dom.development.js:25860  flushSyncCallbacks @ react-dom.development.js:11803  commitRootImpl @ react-dom.development.js:26658  commitRoot @ react-dom.development.js:26410  finishConcurrentRender @ react-dom.development.js:25728  performConcurrentWorkOnRoot @ react-dom.development.js:25574  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  client-hook-6.js:1 The above error occurred in the <App> component:        at App (https://6buos.sse.codesandbox.io/main.js:34968:21)    Consider adding an error boundary to your tree to customize error handling behavior.  Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.  r.<computed> @ client-hook-6.js:1  logCapturedError @ react-dom.development.js:18588  update.callback @ react-dom.development.js:18621  callCallback @ react-dom.development.js:13229  commitUpdateQueue @ react-dom.development.js:13250  commitLayoutEffectOnFiber @ react-dom.development.js:23177  commitLayoutMountEffects_complete @ react-dom.development.js:24431  commitLayoutEffects_begin @ react-dom.development.js:24417  commitLayoutEffects @ react-dom.development.js:24355  commitRootImpl @ react-dom.development.js:26544  commitRoot @ react-dom.development.js:26410  performSyncWorkOnRoot @ react-dom.development.js:25860  flushSyncCallbacks @ react-dom.development.js:11803  commitRootImpl @ react-dom.development.js:26658  commitRoot @ react-dom.development.js:26410  finishConcurrentRender @ react-dom.development.js:25728  performConcurrentWorkOnRoot @ react-dom.development.js:25574  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  react-dom.development.js:11817 Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.      at appendChildToContainer (https://6buos.sse.codesandbox.io/main.js:11262:16)      at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24195:7)      at insertOrAppendPlacementNodeIntoContainer (https://6buos.sse.codesandbox.io/main.js:24201:7)      at commitPlacement (https://6buos.sse.codesandbox.io/main.js:24179:5)      at commitMutationEffectsOnFiber (https://6buos.sse.codesandbox.io/main.js:24693:9)      at commitMutationEffects_complete (https://6buos.sse.codesandbox.io/main.js:24586:7)      at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24575:7)      at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)      at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)  flushSyncCallbacks @ react-dom.development.js:11817  commitRootImpl @ react-dom.development.js:26658  commitRoot @ react-dom.development.js:26410  finishConcurrentRender @ react-dom.development.js:25728  performConcurrentWorkOnRoot @ react-dom.development.js:25574  workLoop @ scheduler.development.js:265  flushWork @ scheduler.development.js:238  performWorkUntilDeadline @ scheduler.development.js:532  run @ setImmediate.js:40  runIfPresent @ setImmediate.js:69  onGlobalMessage @ setImmediate.js:109  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  client-hook-6.js:1 The above error occurred in the <App> component:        at App (https://6buos.sse.codesandbox.io/main.js:34968:21)    Consider adding an error boundary to your tree to customize error handling behavior.  Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.  r.<computed> @ client-hook-6.js:1  logCapturedError @ react-dom.development.js:18588  update.callback @ react-dom.development.js:18621  callCallback @ react-dom.development.js:13229  commitUpdateQueue @ react-dom.development.js:13250  commitLayoutEffectOnFiber @ react-dom.development.js:23177  commitLayoutMountEffects_complete @ react-dom.development.js:24431  commitLayoutEffects_begin @ react-dom.development.js:24417  commitLayoutEffects @ react-dom.development.js:24355  commitRootImpl @ react-dom.development.js:26544  commitRoot @ react-dom.development.js:26410  performSyncWorkOnRoot @ react-dom.development.js:25860  flushSyncCallbacks @ react-dom.development.js:11803  postMessage (async)  registerImmediate @ setImmediate.js:120  setImmediate @ setImmediate.js:27  schedulePerformWorkUntilDeadline @ scheduler.development.js:563  requestHostCallback @ scheduler.development.js:587  unstable_scheduleCallback @ scheduler.development.js:440  scheduleCallback$1 @ react-dom.development.js:27211  ensureRootIsScheduled @ react-dom.development.js:25459  scheduleUpdateOnFiber @ react-dom.development.js:25278  updateContainer @ react-dom.development.js:28483  hydrateRoot @ react-dom.development.js:28991  ./src/index.js @ index.js:12  __webpack_require__ @ bootstrap:19  0 @ index.js:12  __webpack_require__ @ bootstrap:19  (anonymous) @ bootstrap:83  (anonymous) @ bootstrap:83  react-dom.development.js:11817 Uncaught DOMException: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.      at removeChildFromContainer (https://6buos.sse.codesandbox.io/main.js:11298:15)      at unmountHostComponents (https://6buos.sse.codesandbox.io/main.js:24289:9)      at commitDeletion (https://6buos.sse.codesandbox.io/main.js:24350:5)      at commitMutationEffects_begin (https://6buos.sse.codesandbox.io/main.js:24561:11)      at commitMutationEffects (https://6buos.sse.codesandbox.io/main.js:24545:3)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:26919:5)      at commitRoot (https://6buos.sse.codesandbox.io/main.js:26798:5)      at performSyncWorkOnRoot (https://6buos.sse.codesandbox.io/main.js:26248:3)      at flushSyncCallbacks (https://6buos.sse.codesandbox.io/main.js:12196:22)      at commitRootImpl (https://6buos.sse.codesandbox.io/main.js:27046:3)  ```  </details>          Not sure since I wouldn't be surprised if React couldn't do anything about it considering it probably unmounts its own `script` tag?    React 17 behavior: https://codesandbox.io/s/react-17-hydration-mismatch-in-document-m22vv    The good thing is that frameworks can guard against author error by wrapping user code in Suspense boundaries so that any hydration mismatch from user code does not result in throwing away the main script (or too much in general). But that might require a lot of otherwise unnecessary Suspense boundaries (is that a problem?)",
        "human_words": "React version: 18.0.0-rc.1-next-cb1e7b1c6-20220303        1. Cause a hydration mismatch in the same boundary as `<script />` for main entrypoint  2. Attempt to hydrate    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/react-18-hydration-mismatch-in-document-6buos (based on https://codesandbox.io/s/kind-sammet-j56ro?file=/server/render.js:1054-1614 from https://github.com/reactwg/react-18/discussions/22)        The original issue was caused by a wrong usage of the Remix starter template:    The hydration mismatch happened due to a mismatch of `process.env.NODE_ENV` between client and server.        Whole UI is unmounted (i.e. no recovery via client-side only rendering) and the following errors are logged:  <details>  <summary>Errors when landing on the page</summary>      </details>          Not sure since I wouldn't be surprised if React couldn't do anything about it considering it probably unmounts its own `script` tag?    React 17 behavior: https://codesandbox.io/s/react-17-hydration-mismatch-in-document-m22vv    The good thing is that frameworks can guard against author error by wrapping user code in Suspense boundaries so that any hydration mismatch from user code does not result in throwing away the main script (or too much in general). But that might require a lot of otherwise unnecessary Suspense boundaries (is that a problem?)",
        "human_words_regrex": "React version: 18.0.0-rc.1-next-cb1e7b1c6-20220303 1. Cause a hydration mismatch in the same boundary as `` for main entrypoint 2. Attempt to hydrate  Link to code example:  (based on  from  The original issue was caused by a wrong usage of the Remix starter template: The hydration mismatch happened due to a mismatch of `process.env.NODE_ENV` between client and server. Whole UI is unmounted (i.e. no recovery via client-side only rendering) and the following errors are logged:  Errors when landing on the page  Not sure since I wouldn't be surprised if React couldn't do anything about it considering it probably unmounts its own `script` tag? React 17 behavior:  The good thing is that frameworks can guard against author error by wrapping user code in Suspense boundaries so that any hydration mismatch from user code does not result in throwing away the main script (or too much in general). But that might require a lot of otherwise unnecessary Suspense boundaries (is that a problem?)",
        "human_words_stopwords_removal_lemmatization": "react version : 18.0.0-rc.1-next-cb1e7b1c6-20220303 1. cause hydration mismatch boundary `` main entrypoint 2. attempt hydrate link code example : ( based original issue caused wrong usage remix starter template : hydration mismatch happened due mismatch ` process.env.node_env ` client server . whole ui unmounted ( i.e . recovery via client-side rendering ) following error logged : error landing page sure since would n't surprised react could n't anything considering probably unmounts ` script ` tag ? react 17 behavior : good thing framework guard author error wrapping user code suspense boundary hydration mismatch user code result throwing away main script ( much general ) . might require lot otherwise unnecessary suspense boundary ( problem ? )",
        "title_stopwords_removal_lemmatization": "react 18 : non-recoverable hydration mismatch mismatch occurs boundary main script"
    },
    {
        "issue_id": 1062007067,
        "title": "Can't edit a editable div in facebook post field(Keys not working)",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-11-24T05:04:55Z",
        "status": "closed",
        "description": "I am trying to make a extension like grammarly.When i want to make it work on facebook and twitter post field it doesn't work.When i write something in facebook post field and want to replace a suggestion of a existing wrong word by DOM modification using javascript,replacing suggestion does occur nicely.But after that no key including backspace,delete seems to stop working.This happens only in case of facebook and twitter.I wonder how grammarly manage this.Can anyone show me the path to solve this?\r\n\r\nI think react dom of facebook does not permit these type of dom manipulation.What could be the ways to solve this problem from facebook react side.\r\n`document.activeElement.innerText=\"hello, world\"`",
        "remove_template_description": "I am trying to make a extension like grammarly.When i want to make it work on facebook and twitter post field it doesn't work.When i write something in facebook post field and want to replace a suggestion of a existing wrong word by DOM modification using javascript,replacing suggestion does occur nicely.But after that no key including backspace,delete seems to stop working.This happens only in case of facebook and twitter.I wonder how grammarly manage this.Can anyone show me the path to solve this?    I think react dom of facebook does not permit these type of dom manipulation.What could be the ways to solve this problem from facebook react side.  `document.activeElement.innerText=\"hello, world\"`",
        "human_words": "I am trying to make a extension like grammarly.When i want to make it work on facebook and twitter post field it doesn't work.When i write something in facebook post field and want to replace a suggestion of a existing wrong word by DOM modification using javascript,replacing suggestion does occur nicely.But after that no key including backspace,delete seems to stop working.This happens only in case of facebook and twitter.I wonder how grammarly manage this.Can anyone show me the path to solve this?    I think react dom of facebook does not permit these type of dom manipulation.What could be the ways to solve this problem from facebook react side.  `document.activeElement.innerText=\"hello, world\"`",
        "human_words_regrex": "I am trying to make a extension like grammarly.When i want to make it work on facebook and twitter post field it doesn't work.When i write something in facebook post field and want to replace a suggestion of a existing wrong word by DOM modification using javascript,replacing suggestion does occur nicely.But after that no key including backspace,delete seems to stop working.This happens only in case of facebook and twitter.I wonder how grammarly manage this.Can anyone show me the path to solve this? I think react dom of facebook does not permit these type of dom manipulation.What could be the ways to solve this problem from facebook react side. `document.activeElement.innerText=\"hello, world\"`",
        "human_words_stopwords_removal_lemmatization": "trying make extension like grammarly.when want make work facebook twitter post field n't work.when write something facebook post field want replace suggestion existing wrong word dom modification using javascript , replacing suggestion occur nicely.but key including backspace , delete seems stop working.this happens case facebook twitter.i wonder grammarly manage this.can anyone show path solve ? think react dom facebook permit type dom manipulation.what could way solve problem facebook react side . ` document.activeelement.innertext= '' hello , world '' `",
        "title_stopwords_removal_lemmatization": "ca n't edit editable div facebook post field ( key working )"
    },
    {
        "issue_id": 1060784143,
        "title": "React 18 It possible that automatic batching work when using await that like `await false`?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-23T02:50:59Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n\r\nWe often use `async` to implement asynchronous operations. But automatic batching dont work when using await that like `await false` .\r\n\r\n[example](https://codesandbox.io/s/pedantic-hodgkin-3l47z?file=/src/index.js)\r\n\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->    We often use `async` to implement asynchronous operations. But automatic batching dont work when using await that like `await false` .    [example](https://codesandbox.io/s/pedantic-hodgkin-3l47z?file=/src/index.js)",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->    We often use `async` to implement asynchronous operations. But automatic batching dont work when using await that like `await false` .    [example](https://codesandbox.io/s/pedantic-hodgkin-3l47z?file=/src/index.js)",
        "human_words_regrex": " We often use `async` to implement asynchronous operations. But automatic batching dont work when using await that like `await false` . ",
        "human_words_stopwords_removal_lemmatization": "often use ` async ` implement asynchronous operation . automatic batching dont work using await like ` await false ` .",
        "title_stopwords_removal_lemmatization": "react 18 possible automatic batching work using await like ` await false ` ?"
    },
    {
        "issue_id": 1059019482,
        "title": "Library compatible since hooks, should it be `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` or `\">=16.8\"`?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-20T00:54:02Z",
        "status": "closed",
        "description": "In React 16.x, which was fairly long lived and had breaking changes with previous versions, it used to be common to declare the React dependency (e.g. for a hooks library) like this to support all 16.x versions:\r\n\r\n```\r\n\"peerDependencies\": {\r\n  \"react\": \"^16.8.0\"\r\n}\r\n```\r\n\r\nWhen React 17 came up, I've had to update all my React libraries and republish them like this:\r\n\r\n```\r\n\"peerDependencies\": {\r\n  \"react\": \"^16.8.0 || ^17.0.0\"\r\n}\r\n```\r\n\r\nIt seems like React is accelerating the major versioning release rate without actually breaking the API, so is there a recommended way that we define our versioning in the future? I maintain over half a dozen React libraries, and needing to re-publish them adding `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` (once again, when there were virtually no other changes for 1~2 years in those libraries) seems like unnecessary work when I'm using very mainstream APIs and none of the experimental ones. I'm tempted to do this but I understand if React at some point does break the main APIs it'd be bad:\r\n\r\n```\r\n\"peerDependencies\": {\r\n  \"react\": \">=16.8.0\"\r\n}\r\n```\r\n\r\nSo, if I publish a React library that supports hooks and everything since then, including React 17 and 18, **what does Facebook React team recommend? Using `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` or `\">=16.8.0\"`?** Within the context of someone supporting many small React libraries.",
        "remove_template_description": "In React 16.x, which was fairly long lived and had breaking changes with previous versions, it used to be common to declare the React dependency (e.g. for a hooks library) like this to support all 16.x versions:    ```  \"peerDependencies\": {    \"react\": \"^16.8.0\"  }  ```    When React 17 came up, I've had to update all my React libraries and republish them like this:    ```  \"peerDependencies\": {    \"react\": \"^16.8.0 || ^17.0.0\"  }  ```    It seems like React is accelerating the major versioning release rate without actually breaking the API, so is there a recommended way that we define our versioning in the future? I maintain over half a dozen React libraries, and needing to re-publish them adding `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` (once again, when there were virtually no other changes for 1~2 years in those libraries) seems like unnecessary work when I'm using very mainstream APIs and none of the experimental ones. I'm tempted to do this but I understand if React at some point does break the main APIs it'd be bad:    ```  \"peerDependencies\": {    \"react\": \">=16.8.0\"  }  ```    So, if I publish a React library that supports hooks and everything since then, including React 17 and 18, **what does Facebook React team recommend? Using `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` or `\">=16.8.0\"`?** Within the context of someone supporting many small React libraries.",
        "human_words": "In React 16.x, which was fairly long lived and had breaking changes with previous versions, it used to be common to declare the React dependency (e.g. for a hooks library) like this to support all 16.x versions:        When React 17 came up, I've had to update all my React libraries and republish them like this:        It seems like React is accelerating the major versioning release rate without actually breaking the API, so is there a recommended way that we define our versioning in the future? I maintain over half a dozen React libraries, and needing to re-publish them adding `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` (once again, when there were virtually no other changes for 1~2 years in those libraries) seems like unnecessary work when I'm using very mainstream APIs and none of the experimental ones. I'm tempted to do this but I understand if React at some point does break the main APIs it'd be bad:        So, if I publish a React library that supports hooks and everything since then, including React 17 and 18, **what does Facebook React team recommend? Using `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` or `\">=16.8.0\"`?** Within the context of someone supporting many small React libraries.",
        "human_words_regrex": "In React 16.x, which was fairly long lived and had breaking changes with previous versions, it used to be common to declare the React dependency (e.g. for a hooks library) like this to support all 16.x versions: When React 17 came up, I've had to update all my React libraries and republish them like this: It seems like React is accelerating the major versioning release rate without actually breaking the API, so is there a recommended way that we define our versioning in the future? I maintain over half a dozen React libraries, and needing to re-publish them adding `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` (once again, when there were virtually no other changes for 1~2 years in those libraries) seems like unnecessary work when I'm using very mainstream APIs and none of the experimental ones. I'm tempted to do this but I understand if React at some point does break the main APIs it'd be bad: So, if I publish a React library that supports hooks and everything since then, including React 17 and 18, **what does Facebook React team recommend? Using `\"^16.8.0 || ^17.0.0 || ^18.0.0\"` or `\">=16.8.0\"`?** Within the context of someone supporting many small React libraries.",
        "human_words_stopwords_removal_lemmatization": "react 16.x , fairly long lived breaking change previous version , used common declare react dependency ( e.g . hook library ) like support 16.x version : react 17 came , 've update react library republish like : seems like react accelerating major versioning release rate without actually breaking api , recommended way define versioning future ? maintain half dozen react library , needing re-publish adding ` `` ^16.8.0 || ^17.0.0 || ^18.0.0 '' ` ( , virtually change 1~2 year library ) seems like unnecessary work 'm using mainstream apis none experimental one . 'm tempted understand react point break main apis 'd bad : , publish react library support hook everything since , including react 17 18 , * * facebook react team recommend ? using ` `` ^16.8.0 || ^17.0.0 || ^18.0.0 '' ` ` `` > =16.8.0 '' ` ? * * within context someone supporting many small react library .",
        "title_stopwords_removal_lemmatization": "library compatible since hook , ` `` ^16.8.0 || ^17.0.0 || ^18.0.0 '' ` ` `` > =16.8 '' ` ?"
    },
    {
        "issue_id": 1058801988,
        "title": "React 18 not passive wheel / touch event listeners support",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-19T18:26:12Z",
        "status": "open",
        "description": "Hi all, is there any chances React 18 will support not passive wheel / touch event listeners?\r\nIn React 17 they are passive so no way to preventDefault and I had to add active listeners manually by ref.\r\nSo maybe in v18 there will be some option to make them not passive in react?\r\n\r\nI just tested my code with React 18 beta and found some internal order of useEffect calls was changed, so my approach is failing because of desync of changes made in active listener vs other props changes.\r\n\r\n",
        "remove_template_description": "Hi all, is there any chances React 18 will support not passive wheel / touch event listeners?  In React 17 they are passive so no way to preventDefault and I had to add active listeners manually by ref.  So maybe in v18 there will be some option to make them not passive in react?    I just tested my code with React 18 beta and found some internal order of useEffect calls was changed, so my approach is failing because of desync of changes made in active listener vs other props changes.",
        "human_words": "Hi all, is there any chances React 18 will support not passive wheel / touch event listeners?  In React 17 they are passive so no way to preventDefault and I had to add active listeners manually by ref.  So maybe in v18 there will be some option to make them not passive in react?    I just tested my code with React 18 beta and found some internal order of useEffect calls was changed, so my approach is failing because of desync of changes made in active listener vs other props changes.",
        "human_words_regrex": "Hi all, is there any chances React 18 will support not passive wheel / touch event listeners? In React 17 they are passive so no way to preventDefault and I had to add active listeners manually by ref. So maybe in v18 there will be some option to make them not passive in react? I just tested my code with React 18 beta and found some internal order of useEffect calls was changed, so my approach is failing because of desync of changes made in active listener vs other props changes.",
        "human_words_stopwords_removal_lemmatization": "hi , chance react 18 support passive wheel / touch event listener ? react 17 passive way preventdefault add active listener manually ref . maybe v18 option make passive react ? tested code react 18 beta found internal order useeffect call changed , approach failing desync change made active listener v prop change .",
        "title_stopwords_removal_lemmatization": "react 18 passive wheel / touch event listener support"
    },
    {
        "issue_id": 1058609634,
        "title": "React 18 doesn't wait for long running suspended promises",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-19T14:47:07Z",
        "status": "open",
        "description": "At Shopify with Hydrogen, we are encountering a problem with long running requests and React Server Components. If a component within a suspense boundary makes a request to blackhole.webpagetest.org, `pipeToNodeWritable` doesn't stay open while the promise to blackhole is suspended.\r\n\r\nSteps:\r\n\r\n1. Request from the client\r\n2. Server starts `pipeToNodeWritable`\r\n3. One component in the tree makes a request to blackhole, which won't ever resolve (node-fetch eventually times out).\r\n4. React almost immediately calls `onCompleteAll`, even though the underlying promise has yet to resolve.\r\n5. `onError` is never called either\r\n6. This error is in the server console: `Warning: There was still abortable task at the root when we closed. This is a bug in React.`\r\n\r\nEventually the error from the request does timeout, and it shows up in the console, but it's too late to stream anything to the client because the response has been closed. But even catching that error is hard/difficult, because. it is just dumped to the console, and doesn't actually go through React's `pipeToNodeWritable` `onError` handler.\r\n\r\nSee the example here: https://stackblitz.com/edit/hydrogen-v3w1xm?file=src%2Fpages%2FIndex.server.jsx\r\n\r\nNote in Index.server.jsx:73 it's fetching data to blackhole. Note the warnings in the console:\r\n\r\n> Warning: There was still abortable task at the root when we closed. This is a bug in React.",
        "remove_template_description": "At Shopify with Hydrogen, we are encountering a problem with long running requests and React Server Components. If a component within a suspense boundary makes a request to blackhole.webpagetest.org, `pipeToNodeWritable` doesn't stay open while the promise to blackhole is suspended.    Steps:    1. Request from the client  2. Server starts `pipeToNodeWritable`  3. One component in the tree makes a request to blackhole, which won't ever resolve (node-fetch eventually times out).  4. React almost immediately calls `onCompleteAll`, even though the underlying promise has yet to resolve.  5. `onError` is never called either  6. This error is in the server console: `Warning: There was still abortable task at the root when we closed. This is a bug in React.`    Eventually the error from the request does timeout, and it shows up in the console, but it's too late to stream anything to the client because the response has been closed. But even catching that error is hard/difficult, because. it is just dumped to the console, and doesn't actually go through React's `pipeToNodeWritable` `onError` handler.    See the example here: https://stackblitz.com/edit/hydrogen-v3w1xm?file=src%2Fpages%2FIndex.server.jsx    Note in Index.server.jsx:73 it's fetching data to blackhole. Note the warnings in the console:    > Warning: There was still abortable task at the root when we closed. This is a bug in React.",
        "human_words": "At Shopify with Hydrogen, we are encountering a problem with long running requests and React Server Components. If a component within a suspense boundary makes a request to blackhole.webpagetest.org, `pipeToNodeWritable` doesn't stay open while the promise to blackhole is suspended.    Steps:    1. Request from the client  2. Server starts `pipeToNodeWritable`  3. One component in the tree makes a request to blackhole, which won't ever resolve (node-fetch eventually times out).  4. React almost immediately calls `onCompleteAll`, even though the underlying promise has yet to resolve.  5. `onError` is never called either  6. This error is in the server console: `Warning: There was still abortable task at the root when we closed. This is a bug in React.`    Eventually the error from the request does timeout, and it shows up in the console, but it's too late to stream anything to the client because the response has been closed. But even catching that error is hard/difficult, because. it is just dumped to the console, and doesn't actually go through React's `pipeToNodeWritable` `onError` handler.    See the example here: https://stackblitz.com/edit/hydrogen-v3w1xm?file=src%2Fpages%2FIndex.server.jsx    Note in Index.server.jsx:73 it's fetching data to blackhole. Note the warnings in the console:    > Warning: There was still abortable task at the root when we closed. This is a bug in React.",
        "human_words_regrex": "At Shopify with Hydrogen, we are encountering a problem with long running requests and React Server Components. If a component within a suspense boundary makes a request to blackhole.webpagetest.org, `pipeToNodeWritable` doesn't stay open while the promise to blackhole is suspended. Steps: 1. Request from the client 2. Server starts `pipeToNodeWritable` 3. One component in the tree makes a request to blackhole, which won't ever resolve (node-fetch eventually times out). 4. React almost immediately calls `onCompleteAll`, even though the underlying promise has yet to resolve. 5. `onError` is never called either 6. This error is in the server console: `Warning: There was still abortable task at the root when we closed. This is a bug in React.` Eventually the error from the request does timeout, and it shows up in the console, but it's too late to stream anything to the client because the response has been closed. But even catching that error is hard/difficult, because. it is just dumped to the console, and doesn't actually go through React's `pipeToNodeWritable` `onError` handler. See the example here:  Note in Index.server.jsx:73 it's fetching data to blackhole. Note the warnings in the console: > Warning: There was still abortable task at the root when we closed. This is a bug in React.",
        "human_words_stopwords_removal_lemmatization": "shopify hydrogen , encountering problem long running request react server component . component within suspense boundary make request blackhole.webpagetest.org , ` pipetonodewritable ` n't stay open promise blackhole suspended . step : 1. request client 2. server start ` pipetonodewritable ` 3. one component tree make request blackhole , wo n't ever resolve ( node-fetch eventually time ) . 4. react almost immediately call ` oncompleteall ` , even though underlying promise yet resolve . 5 . ` onerror ` never called either 6. error server console : ` warning : still abortable task root closed . bug react. ` eventually error request timeout , show console , 's late stream anything client response closed . even catching error hard/difficult , . dumped console , n't actually go react 's ` pipetonodewritable ` ` onerror ` handler . see example : note index.server.jsx:73 's fetching data blackhole . note warning console : > warning : still abortable task root closed . bug react .",
        "title_stopwords_removal_lemmatization": "react 18 n't wait long running suspended promise"
    },
    {
        "issue_id": 1054200931,
        "title": "React 18: \"The stream is not in a state that permits close\" in `renderToReadableStream`",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-15T22:45:59Z",
        "status": "closed",
        "description": "When using `renderToReadableStream` for e.g. Cloudflare Workers runtimes, I'm noticing this error on the server:\r\n\r\n```\r\nTypeError: The stream is not in a state that permits close\r\n    at ReadableStreamDefaultController.close (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts:72:13)\r\n    at Mc (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3636:145)\r\n    at Bc (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3457:33)\r\n    at ping (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3128:24)\r\nGET / 200 OK (2091.13ms)\r\n```\r\n\r\nI'm assuming this results in the following malformed chunk being sent to the stream:\r\n\r\n```\r\n<div hidden id=\"<div hidden id=\"S:1\">\r\n```\r\n\r\nWhich results in the client failing:\r\n\r\n```\r\nUncaught TypeError: Cannot read properties of null (reading 'parentNode')\r\n    at $RS (127.0.0.1/:11)\r\n    at 127.0.0.1/:11\r\n```\r\n\r\nI put together a reproduction here, powered by [Miniflare](https://miniflare.dev/) for the Workers runtime: https://github.com/jplhomer/vite-streaming-ssr-demo\r\n\r\n## Possible issues\r\n\r\n- Could this be related to the \"fundamentally flawed\" nature of Web Streams implementations in e.g. Cloudflare Workers runtime? https://github.com/reactwg/react-18/discussions/66#discussioncomment-944266\r\n- Is something going on with corking/uncorking, as per https://github.com/reactwg/react-18/discussions/91\r\n- Maybe something's wrong with Miniflare's polyfill and this is a non-issue, coming from `web-streams-polyfill`?\r\n- Finally, it's possible something is wrong with the Vite version of the example I've put together. I could try rebuilding with webpack if it's determined none of these items apply.",
        "remove_template_description": "When using `renderToReadableStream` for e.g. Cloudflare Workers runtimes, I'm noticing this error on the server:    ```  TypeError: The stream is not in a state that permits close      at ReadableStreamDefaultController.close (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts:72:13)      at Mc (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3636:145)      at Bc (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3457:33)      at ping (/Users/joshlarson/src/github.com/jplhomer/vite-streaming-ssr-demo/dist/worker/worker.js:3128:24)  GET / 200 OK (2091.13ms)  ```    I'm assuming this results in the following malformed chunk being sent to the stream:    ```  <div hidden id=\"<div hidden id=\"S:1\">  ```    Which results in the client failing:    ```  Uncaught TypeError: Cannot read properties of null (reading 'parentNode')      at $RS (127.0.0.1/:11)      at 127.0.0.1/:11  ```    I put together a reproduction here, powered by [Miniflare](https://miniflare.dev/) for the Workers runtime: https://github.com/jplhomer/vite-streaming-ssr-demo    ## Possible issues    - Could this be related to the \"fundamentally flawed\" nature of Web Streams implementations in e.g. Cloudflare Workers runtime? https://github.com/reactwg/react-18/discussions/66#discussioncomment-944266  - Is something going on with corking/uncorking, as per https://github.com/reactwg/react-18/discussions/91  - Maybe something's wrong with Miniflare's polyfill and this is a non-issue, coming from `web-streams-polyfill`?  - Finally, it's possible something is wrong with the Vite version of the example I've put together. I could try rebuilding with webpack if it's determined none of these items apply.",
        "human_words": "When using `renderToReadableStream` for e.g. Cloudflare Workers runtimes, I'm noticing this error on the server:        I'm assuming this results in the following malformed chunk being sent to the stream:        Which results in the client failing:        I put together a reproduction here, powered by [Miniflare](https://miniflare.dev/) for the Workers runtime: https://github.com/jplhomer/vite-streaming-ssr-demo    ## Possible issues    - Could this be related to the \"fundamentally flawed\" nature of Web Streams implementations in e.g. Cloudflare Workers runtime? https://github.com/reactwg/react-18/discussions/66#discussioncomment-944266  - Is something going on with corking/uncorking, as per https://github.com/reactwg/react-18/discussions/91  - Maybe something's wrong with Miniflare's polyfill and this is a non-issue, coming from `web-streams-polyfill`?  - Finally, it's possible something is wrong with the Vite version of the example I've put together. I could try rebuilding with webpack if it's determined none of these items apply.",
        "human_words_regrex": "When using `renderToReadableStream` for e.g. Cloudflare Workers runtimes, I'm noticing this error on the server: I'm assuming this results in the following malformed chunk being sent to the stream: Which results in the client failing: I put together a reproduction here, powered by  for the Workers runtime:  ## Possible issues - Could this be related to the \"fundamentally flawed\" nature of Web Streams implementations in e.g. Cloudflare Workers runtime?  - Is something going on with corking/uncorking, as per  - Maybe something's wrong with Miniflare's polyfill and this is a non-issue, coming from `web-streams-polyfill`? - Finally, it's possible something is wrong with the Vite version of the example I've put together. I could try rebuilding with webpack if it's determined none of these items apply.",
        "human_words_stopwords_removal_lemmatization": "using ` rendertoreadablestream ` e.g . cloudflare worker runtimes , 'm noticing error server : 'm assuming result following malformed chunk sent stream : result client failing : put together reproduction , powered worker runtime : # # possible issue - could related `` fundamentally flawed '' nature web stream implementation e.g . cloudflare worker runtime ? - something going corking/uncorking , per - maybe something 's wrong miniflare 's polyfill non-issue , coming ` web-streams-polyfill ` ? - finally , 's possible something wrong vite version example 've put together . could try rebuilding webpack 's determined none item apply .",
        "title_stopwords_removal_lemmatization": "react 18 : `` stream state permit close '' ` rendertoreadablestream `"
    },
    {
        "issue_id": 1054200876,
        "title": "React 18 - SuspenseList no longer exported in latest @next version (`18.0.0-beta-96ca8d915-20211115`)",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-15T22:45:56Z",
        "status": "closed",
        "description": "It appears `SuspenseList` is missing from the exports, is this intentional? These are the currently exposed `Object.keys(React)`:\r\n```js\r\n[\r\n  'Fragment',\r\n  'StrictMode',\r\n  'Profiler',\r\n  'Suspense',\r\n  'Children',\r\n  'Component',\r\n  'PureComponent',\r\n  '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED',\r\n  'cloneElement',\r\n  'createContext',\r\n  'createElement',\r\n  'createFactory',\r\n  'createRef',\r\n  'forwardRef',\r\n  'isValidElement',\r\n  'lazy',\r\n  'memo',\r\n  'startTransition',\r\n  'unstable_act',\r\n  'unstable_createMutableSource',\r\n  'useCallback',\r\n  'useContext',\r\n  'useDebugValue',\r\n  'useDeferredValue',\r\n  'useEffect',\r\n  'useId',\r\n  'useImperativeHandle',\r\n  'useInsertionEffect',\r\n  'useLayoutEffect',\r\n  'useMemo',\r\n  'useReducer',\r\n  'useRef',\r\n  'useState',\r\n  'useSyncExternalStore',\r\n  'useTransition',\r\n  'version'\r\n]\r\n```\r\n\r\nwhile _these_ were the keys in the latest alpha (`18.0.0-alpha-200415c91-20211115`):\r\n\r\n```js\r\n[\r\n  'Fragment',\r\n  'StrictMode',\r\n  'Profiler',\r\n  'Suspense',\r\n  'SuspenseList', <----\r\n  'Children',\r\n  'Component',\r\n  'PureComponent',\r\n  '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED',\r\n  'cloneElement',\r\n  'createContext',\r\n  'createElement',\r\n  'createFactory',\r\n  'createRef',\r\n  'forwardRef',\r\n  'isValidElement',\r\n  'lazy',\r\n  'memo',\r\n  'startTransition',\r\n  'unstable_act',\r\n  'unstable_createMutableSource',\r\n  'useCallback',\r\n  'useContext',\r\n  'useDebugValue',\r\n  'useDeferredValue',\r\n  'useEffect',\r\n  'useId',\r\n  'useImperativeHandle',\r\n  'useInsertionEffect',\r\n  'useLayoutEffect',\r\n  'useMemo',\r\n  'useReducer',\r\n  'useRef',\r\n  'useState',\r\n  'useSyncExternalStore',\r\n  'useTransition',\r\n  'version'\r\n]\r\n```\r\n\r\nand I saw nothing about SuspenseList being dropped or similar [in the Beta Announcement](https://github.com/reactwg/react-18/discussions/112).\r\n\r\nEdit: see [diff](https://app.renovatebot.com/package-diff?name=react&from=18.0.0-alpha-200415c91-20211115&to=18.0.0-beta-96ca8d915-20211115).\r\n\r\nThanks",
        "remove_template_description": "It appears `SuspenseList` is missing from the exports, is this intentional? These are the currently exposed `Object.keys(React)`:  ```js  [    'Fragment',    'StrictMode',    'Profiler',    'Suspense',    'Children',    'Component',    'PureComponent',    '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED',    'cloneElement',    'createContext',    'createElement',    'createFactory',    'createRef',    'forwardRef',    'isValidElement',    'lazy',    'memo',    'startTransition',    'unstable_act',    'unstable_createMutableSource',    'useCallback',    'useContext',    'useDebugValue',    'useDeferredValue',    'useEffect',    'useId',    'useImperativeHandle',    'useInsertionEffect',    'useLayoutEffect',    'useMemo',    'useReducer',    'useRef',    'useState',    'useSyncExternalStore',    'useTransition',    'version'  ]  ```    while _these_ were the keys in the latest alpha (`18.0.0-alpha-200415c91-20211115`):    ```js  [    'Fragment',    'StrictMode',    'Profiler',    'Suspense',    'SuspenseList', <----    'Children',    'Component',    'PureComponent',    '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED',    'cloneElement',    'createContext',    'createElement',    'createFactory',    'createRef',    'forwardRef',    'isValidElement',    'lazy',    'memo',    'startTransition',    'unstable_act',    'unstable_createMutableSource',    'useCallback',    'useContext',    'useDebugValue',    'useDeferredValue',    'useEffect',    'useId',    'useImperativeHandle',    'useInsertionEffect',    'useLayoutEffect',    'useMemo',    'useReducer',    'useRef',    'useState',    'useSyncExternalStore',    'useTransition',    'version'  ]  ```    and I saw nothing about SuspenseList being dropped or similar [in the Beta Announcement](https://github.com/reactwg/react-18/discussions/112).    Edit: see [diff](https://app.renovatebot.com/package-diff?name=react&from=18.0.0-alpha-200415c91-20211115&to=18.0.0-beta-96ca8d915-20211115).    Thanks",
        "human_words": "It appears `SuspenseList` is missing from the exports, is this intentional? These are the currently exposed `Object.keys(React)`:      while _these_ were the keys in the latest alpha (`18.0.0-alpha-200415c91-20211115`):        and I saw nothing about SuspenseList being dropped or similar [in the Beta Announcement](https://github.com/reactwg/react-18/discussions/112).    Edit: see [diff](https://app.renovatebot.com/package-diff?name=react&from=18.0.0-alpha-200415c91-20211115&to=18.0.0-beta-96ca8d915-20211115).    Thanks",
        "human_words_regrex": "It appears `SuspenseList` is missing from the exports, is this intentional? These are the currently exposed `Object.keys(React)`: while _these_ were the keys in the latest alpha (`18.0.0-alpha-200415c91-20211115`): and I saw nothing about SuspenseList being dropped or similar . Edit: see . Thanks",
        "human_words_stopwords_removal_lemmatization": "appears ` suspenselist ` missing export , intentional ? currently exposed ` object.keys ( react ) ` : _these_ key latest alpha ( ` 18.0.0-alpha-200415c91-20211115 ` ) : saw nothing suspenselist dropped similar . edit : see . thanks",
        "title_stopwords_removal_lemmatization": "react 18 - suspenselist longer exported latest @ next version ( ` 18.0.0-beta-96ca8d915-20211115 ` )"
    },
    {
        "issue_id": 1050007120,
        "title": "Consolidate component stack and (DEV only) element __source",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-11-10T15:51:30Z",
        "status": "open",
        "description": "There are currently two types of component \"location\" displayed and used in DevTools:\r\n* \"Native\" component stacks: These are detected by intentionally causing the component to throw an error (e.g. `null` props object, a hooks dispatcher that throws) so DevTools can figure out **where the function is defined**.\r\n* DEV source metadata that comes from plugins like [@babel/plugin-transform-react-jsx-source](https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-react-jsx-source/src/index.js) and describes **where the JSX element is defined** (e.g. where its props are passed).\r\n\r\nIn other words, for the `Greeting` component:\r\n```jsx\r\nfunction Example() {\r\n  return <Greeting name=\"brian\" />; // <- DEV source metadata\r\n}\r\n\r\nfunction Greeting({name}) { // <- component stack\r\n  return <div>Hi, {name}</div>;\r\n}\r\n```\r\nThe two locations have different use cases. Which one do you want when you click the \"open in editor\" button?\r\n\r\nI'm not sure. I can imagine cases for both of these. My gut is that the component stack location is actually slightly better for \"open in editor\" _but_ it would be a change in behavior.\r\n\r\nThat being said, it would be nice to pick one and stick with it, and the component stack location has the added benefit of working in production.",
        "remove_template_description": "There are currently two types of component \"location\" displayed and used in DevTools:  * \"Native\" component stacks: These are detected by intentionally causing the component to throw an error (e.g. `null` props object, a hooks dispatcher that throws) so DevTools can figure out **where the function is defined**.  * DEV source metadata that comes from plugins like [@babel/plugin-transform-react-jsx-source](https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-react-jsx-source/src/index.js) and describes **where the JSX element is defined** (e.g. where its props are passed).    In other words, for the `Greeting` component:  ```jsx  function Example() {    return <Greeting name=\"brian\" />; // <- DEV source metadata  }    function Greeting({name}) { // <- component stack    return <div>Hi, {name}</div>;  }  ```  The two locations have different use cases. Which one do you want when you click the \"open in editor\" button?    I'm not sure. I can imagine cases for both of these. My gut is that the component stack location is actually slightly better for \"open in editor\" _but_ it would be a change in behavior.    That being said, it would be nice to pick one and stick with it, and the component stack location has the added benefit of working in production.",
        "human_words": "There are currently two types of component \"location\" displayed and used in DevTools:  * \"Native\" component stacks: These are detected by intentionally causing the component to throw an error (e.g. `null` props object, a hooks dispatcher that throws) so DevTools can figure out **where the function is defined**.  * DEV source metadata that comes from plugins like [@babel/plugin-transform-react-jsx-source](https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-react-jsx-source/src/index.js) and describes **where the JSX element is defined** (e.g. where its props are passed).    In other words, for the `Greeting` component:    The two locations have different use cases. Which one do you want when you click the \"open in editor\" button?    I'm not sure. I can imagine cases for both of these. My gut is that the component stack location is actually slightly better for \"open in editor\" _but_ it would be a change in behavior.    That being said, it would be nice to pick one and stick with it, and the component stack location has the added benefit of working in production.",
        "human_words_regrex": "There are currently two types of component \"location\" displayed and used in DevTools: * \"Native\" component stacks: These are detected by intentionally causing the component to throw an error (e.g. `null` props object, a hooks dispatcher that throws) so DevTools can figure out **where the function is defined**. * DEV source metadata that comes from plugins like  and describes **where the JSX element is defined** (e.g. where its props are passed). In other words, for the `Greeting` component: The two locations have different use cases. Which one do you want when you click the \"open in editor\" button? I'm not sure. I can imagine cases for both of these. My gut is that the component stack location is actually slightly better for \"open in editor\" _but_ it would be a change in behavior. That being said, it would be nice to pick one and stick with it, and the component stack location has the added benefit of working in production.",
        "human_words_stopwords_removal_lemmatization": "currently two type component `` location '' displayed used devtools : * `` native '' component stack : detected intentionally causing component throw error ( e.g . ` null ` prop object , hook dispatcher throw ) devtools figure * * function defined * * . * dev source metadata come plugins like describes * * jsx element defined * * ( e.g . prop passed ) . word , ` greeting ` component : two location different use case . one want click `` open editor '' button ? 'm sure . imagine case . gut component stack location actually slightly better `` open editor '' _but_ would change behavior . said , would nice pick one stick , component stack location added benefit working production .",
        "title_stopwords_removal_lemmatization": "consolidate component stack ( dev ) element __source"
    },
    {
        "issue_id": 1049280671,
        "title": "React 18 requests similar component trees for the useId",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-10T00:56:11Z",
        "status": "open",
        "description": "- based on: https://github.com/reactwg/react-18/discussions/111\r\n- sandbox: https://codesandbox.io/s/admiring-oskar-mqwdm?file=/src/App.js\r\n\r\n## Origins\r\nHistorically SSR was requiring some extra components to create a special \"server\" environment. Usually the ServerApplication is expected to be wrapped with different `collectors` and `providers` in order to power code splitting, style extraction, media queries, and many other things, some part of which don't have to be used on the client side, or even cannot exists at all.\r\n\r\nClientSide in turn, might contain some elements not required for the Server\r\n\r\n## The problem\r\nAccording to my experiments for the proper use of `useId` one does not need ideally matching component trees - any number of \"wrappers\" are allowed, and only having \"more than one child\" is breaking id generation, however it does not cause any hydration id and cannot be detected without a context-aware test.\r\n\r\n```tsx\r\nconst ServerProvider = ({ children }) => (\r\n  <context.Provider value={\"server\"}>\r\n    <SugarComponent>{children}</SugarComponent>\r\n  </context.Provider>\r\n);\r\n\r\nexport const ServerApp = () => {\r\n  return (\r\n    <ServerProvider>\r\n      {/* this one is breaking */}\r\n      {/* <SugarComponent /> */} \ud83d\udc48 having this one will break id generation\r\n      <SugarComponent>\r\n        <App /> \ud83d\udc48 client will render only this\r\n      </SugarComponent>\r\n    </ServerProvider>\r\n  );\r\n```\r\n\r\n## The question\r\nWhat level of similarity is really required? What actually matters - the path(so internals of siblings do not matter), or everything \"before this point\"(probably not due to Selective Hydration)?\r\n\r\nHow one can understand are component trees are similar enough, or one should not try to do that, comparing the expected behavior (matching Ids) without relying on implementation details of `useId` (currently one has to)\r\n",
        "remove_template_description": "- based on: https://github.com/reactwg/react-18/discussions/111  - sandbox: https://codesandbox.io/s/admiring-oskar-mqwdm?file=/src/App.js    ## Origins  Historically SSR was requiring some extra components to create a special \"server\" environment. Usually the ServerApplication is expected to be wrapped with different `collectors` and `providers` in order to power code splitting, style extraction, media queries, and many other things, some part of which don't have to be used on the client side, or even cannot exists at all.    ClientSide in turn, might contain some elements not required for the Server    ## The problem  According to my experiments for the proper use of `useId` one does not need ideally matching component trees - any number of \"wrappers\" are allowed, and only having \"more than one child\" is breaking id generation, however it does not cause any hydration id and cannot be detected without a context-aware test.    ```tsx  const ServerProvider = ({ children }) => (    <context.Provider value={\"server\"}>      <SugarComponent>{children}</SugarComponent>    </context.Provider>  );    export const ServerApp = () => {    return (      <ServerProvider>        {/* this one is breaking */}        {/* <SugarComponent /> */} \ud83d\udc48 having this one will break id generation        <SugarComponent>          <App /> \ud83d\udc48 client will render only this        </SugarComponent>      </ServerProvider>    );  ```    ## The question  What level of similarity is really required? What actually matters - the path(so internals of siblings do not matter), or everything \"before this point\"(probably not due to Selective Hydration)?    How one can understand are component trees are similar enough, or one should not try to do that, comparing the expected behavior (matching Ids) without relying on implementation details of `useId` (currently one has to)",
        "human_words": "- based on: https://github.com/reactwg/react-18/discussions/111  - sandbox: https://codesandbox.io/s/admiring-oskar-mqwdm?file=/src/App.js    ## Origins  Historically SSR was requiring some extra components to create a special \"server\" environment. Usually the ServerApplication is expected to be wrapped with different `collectors` and `providers` in order to power code splitting, style extraction, media queries, and many other things, some part of which don't have to be used on the client side, or even cannot exists at all.    ClientSide in turn, might contain some elements not required for the Server    ## The problem  According to my experiments for the proper use of `useId` one does not need ideally matching component trees - any number of \"wrappers\" are allowed, and only having \"more than one child\" is breaking id generation, however it does not cause any hydration id and cannot be detected without a context-aware test.        ## The question  What level of similarity is really required? What actually matters - the path(so internals of siblings do not matter), or everything \"before this point\"(probably not due to Selective Hydration)?    How one can understand are component trees are similar enough, or one should not try to do that, comparing the expected behavior (matching Ids) without relying on implementation details of `useId` (currently one has to)",
        "human_words_regrex": "- based on:  - sandbox:  ## Origins Historically SSR was requiring some extra components to create a special \"server\" environment. Usually the ServerApplication is expected to be wrapped with different `collectors` and `providers` in order to power code splitting, style extraction, media queries, and many other things, some part of which don't have to be used on the client side, or even cannot exists at all. ClientSide in turn, might contain some elements not required for the Server ## The problem According to my experiments for the proper use of `useId` one does not need ideally matching component trees - any number of \"wrappers\" are allowed, and only having \"more than one child\" is breaking id generation, however it does not cause any hydration id and cannot be detected without a context-aware test. ## The question What level of similarity is really required? What actually matters - the path(so internals of siblings do not matter), or everything \"before this point\"(probably not due to Selective Hydration)? How one can understand are component trees are similar enough, or one should not try to do that, comparing the expected behavior (matching Ids) without relying on implementation details of `useId` (currently one has to)",
        "human_words_stopwords_removal_lemmatization": "- based : - sandbox : # # origin historically ssr requiring extra component create special `` server '' environment . usually serverapplication expected wrapped different ` collector ` ` provider ` order power code splitting , style extraction , medium query , many thing , part n't used client side , even exists . clientside turn , might contain element required server # # problem according experiment proper use ` useid ` one need ideally matching component tree - number `` wrapper '' allowed , `` one child '' breaking id generation , however cause hydration id detected without context-aware test . # # question level similarity really required ? actually matter - path ( internals sibling matter ) , everything `` point '' ( probably due selective hydration ) ? one understand component tree similar enough , one try , comparing expected behavior ( matching id ) without relying implementation detail ` useid ` ( currently one )",
        "title_stopwords_removal_lemmatization": "react 18 request similar component tree useid"
    },
    {
        "issue_id": 1047044928,
        "title": "How to resuse same component without remounting it and access anywhere in dom tree?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-08T05:49:03Z",
        "status": "open",
        "description": "i am creating a streaming app in react js my use case is this there is a camera component which is defined on the top level in App.js i want that component to be rendered at top level as well as inside any child component everywhere in dom which same component instance and state so that camera should not be remount and mount again in child component \r\n\r\ni have tried some solutions like react portals and react dom(deprecated can't use anymore)\r\n\r\nbut none of them work accoridngly\r\n\r\nthe camera component needs to mounted only one time in the APP.js so it wont rerender if i use in anywhere inside other component\r\n",
        "remove_template_description": "i am creating a streaming app in react js my use case is this there is a camera component which is defined on the top level in App.js i want that component to be rendered at top level as well as inside any child component everywhere in dom which same component instance and state so that camera should not be remount and mount again in child component     i have tried some solutions like react portals and react dom(deprecated can't use anymore)    but none of them work accoridngly    the camera component needs to mounted only one time in the APP.js so it wont rerender if i use in anywhere inside other component",
        "human_words": "i am creating a streaming app in react js my use case is this there is a camera component which is defined on the top level in App.js i want that component to be rendered at top level as well as inside any child component everywhere in dom which same component instance and state so that camera should not be remount and mount again in child component     i have tried some solutions like react portals and react dom(deprecated can't use anymore)    but none of them work accoridngly    the camera component needs to mounted only one time in the APP.js so it wont rerender if i use in anywhere inside other component",
        "human_words_regrex": "i am creating a streaming app in react js my use case is this there is a camera component which is defined on the top level in App.js i want that component to be rendered at top level as well as inside any child component everywhere in dom which same component instance and state so that camera should not be remount and mount again in child component i have tried some solutions like react portals and react dom(deprecated can't use anymore) but none of them work accoridngly the camera component needs to mounted only one time in the APP.js so it wont rerender if i use in anywhere inside other component",
        "human_words_stopwords_removal_lemmatization": "creating streaming app react j use case camera component defined top level app.js want component rendered top level well inside child component everywhere dom component instance state camera remount mount child component tried solution like react portal react dom ( deprecated ca n't use anymore ) none work accoridngly camera component need mounted one time app.js wont rerender use anywhere inside component",
        "title_stopwords_removal_lemmatization": "resuse component without remounting access anywhere dom tree ?"
    },
    {
        "issue_id": 1045063244,
        "title": "Use html native event handler <img> with React SSR.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-04T18:21:57Z",
        "status": "open",
        "description": "  Similar to this\r\n  https://github.com/facebook/react/issues/15446\r\n\r\n  I have react APP that will do server render first to create html markup then do client render on browser again.\r\n my app returns:\r\n`<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\"/>\r\n`\r\nI am trying to use onerror event handler to replace src with valid fallback src, and use onload handler to remove style=\"visibility:hidden\". I know React has onError and onLoad, but since i use server side render, the static html will be generated, I would like to use html native onerror and onload event handler because i do not want to wait client side react rendering with javascript, so that the image can be load as fast as possible.\r\n\r\nwhat I did is I manually add event handler in my html template using document.getElements.\r\n\r\n`<script>\r\n      var images = document.getElementsByClassName(\"classA\");\r\nfor (img of images) {\r\n    img.addEventListener(\"error\", function e() {\r\n        const i = this.getAttribute(\"fallbacksrc\");\r\n        i && (this.src = i), this.removeEventListener(\"error\", e)\r\n    }), img.addEventListener(\"load\", function e() {\r\n        console.log(\"onloading\", this.src), \"hidden\" === this.style.visibility && (this.style.visibility = null), img.removeEventListener(\"load\", e)\r\n    });\r\n}\r\n</script>\r\n`\r\n\r\nThis works fine except the load event executed after React render on client side(JS execution). I did the workaround to add a < div > wrapper to my < img >, the problem is solved, load event executed before client side JS execution. However, I would like to see if there is any solution that does not need to add extra wrapper.\r\n\r\nPS. wrapped with React.Fragment is not working as well\r\n\r\nWould like to know if there is a way to use native dom event handler ? onload, onerror? \r\n\r\ni can not inline add those event because the event handler will be removed by React \r\n`<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\" onerror=\"...\" onload=\"...\"/>`\r\n\r\n",
        "remove_template_description": "Similar to this    https://github.com/facebook/react/issues/15446      I have react APP that will do server render first to create html markup then do client render on browser again.   my app returns:  `<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\"/>  `  I am trying to use onerror event handler to replace src with valid fallback src, and use onload handler to remove style=\"visibility:hidden\". I know React has onError and onLoad, but since i use server side render, the static html will be generated, I would like to use html native onerror and onload event handler because i do not want to wait client side react rendering with javascript, so that the image can be load as fast as possible.    what I did is I manually add event handler in my html template using document.getElements.    `<script>        var images = document.getElementsByClassName(\"classA\");  for (img of images) {      img.addEventListener(\"error\", function e() {          const i = this.getAttribute(\"fallbacksrc\");          i && (this.src = i), this.removeEventListener(\"error\", e)      }), img.addEventListener(\"load\", function e() {          console.log(\"onloading\", this.src), \"hidden\" === this.style.visibility && (this.style.visibility = null), img.removeEventListener(\"load\", e)      });  }  </script>  `    This works fine except the load event executed after React render on client side(JS execution). I did the workaround to add a < div > wrapper to my < img >, the problem is solved, load event executed before client side JS execution. However, I would like to see if there is any solution that does not need to add extra wrapper.    PS. wrapped with React.Fragment is not working as well    Would like to know if there is a way to use native dom event handler ? onload, onerror?     i can not inline add those event because the event handler will be removed by React   `<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\" onerror=\"...\" onload=\"...\"/>`",
        "human_words": "Similar to this    https://github.com/facebook/react/issues/15446      I have react APP that will do server render first to create html markup then do client render on browser again.   my app returns:  `<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\"/>  `  I am trying to use onerror event handler to replace src with valid fallback src, and use onload handler to remove style=\"visibility:hidden\". I know React has onError and onLoad, but since i use server side render, the static html will be generated, I would like to use html native onerror and onload event handler because i do not want to wait client side react rendering with javascript, so that the image can be load as fast as possible.    what I did is I manually add event handler in my html template using document.getElements.    `<script>        var images = document.getElementsByClassName(\"classA\");  for (img of images) {      img.addEventListener(\"error\", function e() {          const i = this.getAttribute(\"fallbacksrc\");          i && (this.src = i), this.removeEventListener(\"error\", e)      }), img.addEventListener(\"load\", function e() {          console.log(\"onloading\", this.src), \"hidden\" === this.style.visibility && (this.style.visibility = null), img.removeEventListener(\"load\", e)      });  }  </script>  `    This works fine except the load event executed after React render on client side(JS execution). I did the workaround to add a < div > wrapper to my < img >, the problem is solved, load event executed before client side JS execution. However, I would like to see if there is any solution that does not need to add extra wrapper.    PS. wrapped with React.Fragment is not working as well    Would like to know if there is a way to use native dom event handler ? onload, onerror?     i can not inline add those event because the event handler will be removed by React   `<img classname=\"classA\" src=\"invalid-src\" fallbacksrc=\"valid-src\" style=\"visibility:hidden\" onerror=\"...\" onload=\"...\"/>`",
        "human_words_regrex": "Similar to this  I have react APP that will do server render first to create html markup then do client render on browser again. my app returns: ` ` I am trying to use onerror event handler to replace src with valid fallback src, and use onload handler to remove style=\"visibility:hidden\". I know React has onError and onLoad, but since i use server side render, the static html will be generated, I would like to use html native onerror and onload event handler because i do not want to wait client side react rendering with javascript, so that the image can be load as fast as possible. what I did is I manually add event handler in my html template using document.getElements. ` var images = document.getElementsByClassName(\"classA\"); for (img of images) { img.addEventListener(\"error\", function e() { const i = this.getAttribute(\"fallbacksrc\"); i && (this.src = i), this.removeEventListener(\"error\", e) }), img.addEventListener(\"load\", function e() { console.log(\"onloading\", this.src), \"hidden\" === this.style.visibility && (this.style.visibility = null), img.removeEventListener(\"load\", e) }); }  ` This works fine except the load event executed after React render on client side(JS execution). I did the workaround to add a  wrapper to my , the problem is solved, load event executed before client side JS execution. However, I would like to see if there is any solution that does not need to add extra wrapper. PS. wrapped with React.Fragment is not working as well Would like to know if there is a way to use native dom event handler ? onload, onerror? i can not inline add those event because the event handler will be removed by React ``",
        "human_words_stopwords_removal_lemmatization": "similar react app server render first create html markup client render browser . app return : ` ` trying use onerror event handler replace src valid fallback src , use onload handler remove style= '' visibility : hidden '' . know react onerror onload , since use server side render , static html generated , would like use html native onerror onload event handler want wait client side react rendering javascript , image load fast possible . manually add event handler html template using document.getelements . ` var image = document.getelementsbyclassname ( `` classa '' ) ; ( img image ) { img.addeventlistener ( `` error '' , function e ( ) { const = this.getattribute ( `` fallbacksrc '' ) ; & & ( this.src = ) , this.removeeventlistener ( `` error '' , e ) } ) , img.addeventlistener ( `` load '' , function e ( ) { console.log ( `` onloading '' , this.src ) , `` hidden '' === this.style.visibility & & ( this.style.visibility = null ) , img.removeeventlistener ( `` load '' , e ) } ) ; } ` work fine except load event executed react render client side ( j execution ) . workaround add wrapper , problem solved , load event executed client side j execution . however , would like see solution need add extra wrapper . p . wrapped react.fragment working well would like know way use native dom event handler ? onload , onerror ? inline add event event handler removed react ``",
        "title_stopwords_removal_lemmatization": "use html native event handler < img > react ssr ."
    },
    {
        "issue_id": 1044380796,
        "title": "[React 18] Selective Hydration fails hydration when using context api",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-11-04T05:34:09Z",
        "status": "open",
        "description": "Based on the selective hydration example provided by @gaearon ?? \r\n\r\nhttps://codesandbox.io/s/mystifying-haibt-39oed\r\n\r\nLook out for \ud83d\udc49\r\n![image](https://user-images.githubusercontent.com/599459/140265026-bc9f2b34-1489-4021-a592-89aa282bf561.png)\r\n\r\n\r\nOne can see that hydrating html does in fact fail when using Context API \u2014 or perhaps that's a red herring? The trees do in fact line up during render, and hydration, there's just an effect that sets state \u2014 but that is post hydration??\r\n\r\nCould be them related; in anycase \u2014 strictly speaking to that code sandbox, what am i doing wrongly?\r\n\r\n---\r\n\r\nInitially caught when `ImportedComponent` fails see https://github.com/theKashey/react-imported-component/blob/c290d76623693389a11cc514c92f47efadac47ba/src/ui/ImportedController.tsx#L29",
        "remove_template_description": "Based on the selective hydration example provided by @gaearon ??     https://codesandbox.io/s/mystifying-haibt-39oed    Look out for \ud83d\udc49  ![image](https://user-images.githubusercontent.com/599459/140265026-bc9f2b34-1489-4021-a592-89aa282bf561.png)      One can see that hydrating html does in fact fail when using Context API \u2014 or perhaps that's a red herring? The trees do in fact line up during render, and hydration, there's just an effect that sets state \u2014 but that is post hydration??    Could be them related; in anycase \u2014 strictly speaking to that code sandbox, what am i doing wrongly?    ---    Initially caught when `ImportedComponent` fails see https://github.com/theKashey/react-imported-component/blob/c290d76623693389a11cc514c92f47efadac47ba/src/ui/ImportedController.tsx#L29",
        "human_words": "Based on the selective hydration example provided by @gaearon ??     https://codesandbox.io/s/mystifying-haibt-39oed    Look out for \ud83d\udc49  ![image](https://user-images.githubusercontent.com/599459/140265026-bc9f2b34-1489-4021-a592-89aa282bf561.png)      One can see that hydrating html does in fact fail when using Context API \u2014 or perhaps that's a red herring? The trees do in fact line up during render, and hydration, there's just an effect that sets state \u2014 but that is post hydration??    Could be them related; in anycase \u2014 strictly speaking to that code sandbox, what am i doing wrongly?    ---    Initially caught when `ImportedComponent` fails see https://github.com/theKashey/react-imported-component/blob/c290d76623693389a11cc514c92f47efadac47ba/src/ui/ImportedController.tsx#L29",
        "human_words_regrex": "Based on the selective hydration example provided by @gaearon ??  Look out for \ud83d\udc49 ! One can see that hydrating html does in fact fail when using Context API \u2014 or perhaps that's a red herring? The trees do in fact line up during render, and hydration, there's just an effect that sets state \u2014 but that is post hydration?? Could be them related; in anycase \u2014 strictly speaking to that code sandbox, what am i doing wrongly? --- Initially caught when `ImportedComponent` fails see ",
        "human_words_stopwords_removal_lemmatization": "based selective hydration example provided @ gaearon ? ? look \ud83d\udc49 ! one see hydrating html fact fail using context api \u2014 perhaps 's red herring ? tree fact line render , hydration , 's effect set state \u2014 post hydration ? ? could related ; anycase \u2014 strictly speaking code sandbox , wrongly ? -- - initially caught ` importedcomponent ` fails see",
        "title_stopwords_removal_lemmatization": "[ react 18 ] selective hydration fails hydration using context api"
    },
    {
        "issue_id": 1039193851,
        "title": "removeEventListner is not working in useEffect return.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-29T05:51:44Z",
        "status": "closed",
        "description": "I'm removing an event in useEffect return function but I'm not seeing any message in console whenever component unmount. So after even unmounting component I'm seeing \"visible\" in console whenever I change my tab.\r\n\r\n`\r\n    useEffect(() => {\r\n\r\n    props.getTradesData();\r\n    let interval = setInterval(() => {\r\n      props.getTradesData();\r\n    }, 5000);\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (document.visibilityState === 'visible') {\r\n        console.log(\"visible\")\r\n        interval = setInterval(() => {\r\n          props.getTradesData();\r\n        }, 5000);\r\n      } else {\r\n        clearInterval(interval);\r\n      }\r\n    });\r\n    return () => {\r\n      document.removeEventListener('visibilitychange', () => {\r\n        console.log('event listner has been removed');\r\n      });\r\n      clearInterval(interval)\r\n    };\r\n    }, []);\r\n`",
        "remove_template_description": "I'm removing an event in useEffect return function but I'm not seeing any message in console whenever component unmount. So after even unmounting component I'm seeing \"visible\" in console whenever I change my tab.    `      useEffect(() => {        props.getTradesData();      let interval = setInterval(() => {        props.getTradesData();      }, 5000);      document.addEventListener('visibilitychange', () => {        if (document.visibilityState === 'visible') {          console.log(\"visible\")          interval = setInterval(() => {            props.getTradesData();          }, 5000);        } else {          clearInterval(interval);        }      });      return () => {        document.removeEventListener('visibilitychange', () => {          console.log('event listner has been removed');        });        clearInterval(interval)      };      }, []);  `",
        "human_words": "I'm removing an event in useEffect return function but I'm not seeing any message in console whenever component unmount. So after even unmounting component I'm seeing \"visible\" in console whenever I change my tab.    `      useEffect(() => {        props.getTradesData();      let interval = setInterval(() => {        props.getTradesData();      }, 5000);      document.addEventListener('visibilitychange', () => {        if (document.visibilityState === 'visible') {          console.log(\"visible\")          interval = setInterval(() => {            props.getTradesData();          }, 5000);        } else {          clearInterval(interval);        }      });      return () => {        document.removeEventListener('visibilitychange', () => {          console.log('event listner has been removed');        });        clearInterval(interval)      };      }, []);  `",
        "human_words_regrex": "I'm removing an event in useEffect return function but I'm not seeing any message in console whenever component unmount. So after even unmounting component I'm seeing \"visible\" in console whenever I change my tab. ` useEffect(() => { props.getTradesData(); let interval = setInterval(() => { props.getTradesData(); }, 5000); document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') { console.log(\"visible\") interval = setInterval(() => { props.getTradesData(); }, 5000); } else { clearInterval(interval); } }); return () => { document.removeEventListener('visibilitychange', () => { console.log('event listner has been removed'); }); clearInterval(interval) }; }, []); `",
        "human_words_stopwords_removal_lemmatization": "'m removing event useeffect return function 'm seeing message console whenever component unmount . even unmounting component 'm seeing `` visible '' console whenever change tab . ` useeffect ( ( ) = > { props.gettradesdata ( ) ; let interval = setinterval ( ( ) = > { props.gettradesdata ( ) ; } , 5000 ) ; document.addeventlistener ( 'visibilitychange ' , ( ) = > { ( document.visibilitystate === 'visible ' ) { console.log ( `` visible '' ) interval = setinterval ( ( ) = > { props.gettradesdata ( ) ; } , 5000 ) ; } else { clearinterval ( interval ) ; } } ) ; return ( ) = > { document.removeeventlistener ( 'visibilitychange ' , ( ) = > { console.log ( 'event listner removed ' ) ; } ) ; clearinterval ( interval ) } ; } , [ ] ) ; `",
        "title_stopwords_removal_lemmatization": "removeeventlistner working useeffect return ."
    },
    {
        "issue_id": 1038559348,
        "title": "React 18: hydrateRoot does not issue hydration warnings if initial children is missing",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-28T14:03:30Z",
        "status": "closed",
        "description": "I just realized that the way I was using the new `hydrateRoot` API was completely wrong. Unfortunately, React issued no warnings when omitting the initial children like so\r\n\r\n```jsx\r\nconst container = document.getElementById(\"root\");\r\ncontainer.innerHTML = renderToString(<input />);\r\n\r\nconst root = hydrateRoot(container);\r\nroot.render(<input />)\r\n```\r\n\r\nI was hoping for some kind of symetry between `createRoot` and `hydrateRoot` which was enforced by the fact that `hydratedRoot.render(ui)` would actually issue hydration warnings (on the `render()` call not during `hydrateRoot()`):\r\n\r\n\r\n```jsx\r\nconst container = document.getElementById(\"root\");\r\ncontainer.innerHTML = renderToString(<input />);\r\n\r\n// no hydration warning\r\nconst root = hydrateRoot(container);\r\n// now we do get a hydration warning\r\nroot.render(<h1 />)\r\n```\r\n\r\nMaybe this is me just being silly but I would've hoped for a hydration warning on `hydrateRoot`. Otherwise there's no apparent indication (in an untyped world) that `hydrateRoot(container).render(initialUI)` is most likely not what you wanted.\r\n\r\n \r\n\r\n",
        "remove_template_description": "I just realized that the way I was using the new `hydrateRoot` API was completely wrong. Unfortunately, React issued no warnings when omitting the initial children like so    ```jsx  const container = document.getElementById(\"root\");  container.innerHTML = renderToString(<input />);    const root = hydrateRoot(container);  root.render(<input />)  ```    I was hoping for some kind of symetry between `createRoot` and `hydrateRoot` which was enforced by the fact that `hydratedRoot.render(ui)` would actually issue hydration warnings (on the `render()` call not during `hydrateRoot()`):      ```jsx  const container = document.getElementById(\"root\");  container.innerHTML = renderToString(<input />);    // no hydration warning  const root = hydrateRoot(container);  // now we do get a hydration warning  root.render(<h1 />)  ```    Maybe this is me just being silly but I would've hoped for a hydration warning on `hydrateRoot`. Otherwise there's no apparent indication (in an untyped world) that `hydrateRoot(container).render(initialUI)` is most likely not what you wanted.",
        "human_words": "I just realized that the way I was using the new `hydrateRoot` API was completely wrong. Unfortunately, React issued no warnings when omitting the initial children like so        I was hoping for some kind of symetry between `createRoot` and `hydrateRoot` which was enforced by the fact that `hydratedRoot.render(ui)` would actually issue hydration warnings (on the `render()` call not during `hydrateRoot()`):          Maybe this is me just being silly but I would've hoped for a hydration warning on `hydrateRoot`. Otherwise there's no apparent indication (in an untyped world) that `hydrateRoot(container).render(initialUI)` is most likely not what you wanted.",
        "human_words_regrex": "I just realized that the way I was using the new `hydrateRoot` API was completely wrong. Unfortunately, React issued no warnings when omitting the initial children like so I was hoping for some kind of symetry between `createRoot` and `hydrateRoot` which was enforced by the fact that `hydratedRoot.render(ui)` would actually issue hydration warnings (on the `render()` call not during `hydrateRoot()`): Maybe this is me just being silly but I would've hoped for a hydration warning on `hydrateRoot`. Otherwise there's no apparent indication (in an untyped world) that `hydrateRoot(container).render(initialUI)` is most likely not what you wanted.",
        "human_words_stopwords_removal_lemmatization": "realized way using new ` hydrateroot ` api completely wrong . unfortunately , react issued warning omitting initial child like hoping kind symetry ` createroot ` ` hydrateroot ` enforced fact ` hydratedroot.render ( ui ) ` would actually issue hydration warning ( ` render ( ) ` call ` hydrateroot ( ) ` ) : maybe silly would 've hoped hydration warning ` hydrateroot ` . otherwise 's apparent indication ( untyped world ) ` hydrateroot ( container ) .render ( initialui ) ` likely wanted .",
        "title_stopwords_removal_lemmatization": "react 18 : hydrateroot issue hydration warning initial child missing"
    },
    {
        "issue_id": 1038007562,
        "title": "[react-is] The major versions of react and react-is must be peerDependencies related.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-28T02:05:16Z",
        "status": "open",
        "description": "(This is not directly related to React 18, but it is a discussion about breaking changes, so I'm proposing it as a topic for the next major release.)\r\nClearly react-is works on the assumption that it will be used with a matching version of react.\r\nTherefore, **react should be listed as a peerDependencies of react-is.**\r\n\r\nI brought this up from a discussion involving a package that depends on react-is downstream.",
        "remove_template_description": "(This is not directly related to React 18, but it is a discussion about breaking changes, so I'm proposing it as a topic for the next major release.)  Clearly react-is works on the assumption that it will be used with a matching version of react.  Therefore, **react should be listed as a peerDependencies of react-is.**    I brought this up from a discussion involving a package that depends on react-is downstream.",
        "human_words": "(This is not directly related to React 18, but it is a discussion about breaking changes, so I'm proposing it as a topic for the next major release.)  Clearly react-is works on the assumption that it will be used with a matching version of react.  Therefore, **react should be listed as a peerDependencies of react-is.**    I brought this up from a discussion involving a package that depends on react-is downstream.",
        "human_words_regrex": "(This is not directly related to React 18, but it is a discussion about breaking changes, so I'm proposing it as a topic for the next major release.) Clearly react-is works on the assumption that it will be used with a matching version of react. Therefore, **react should be listed as a peerDependencies of react-is.** I brought this up from a discussion involving a package that depends on react-is downstream.",
        "human_words_stopwords_removal_lemmatization": "( directly related react 18 , discussion breaking change , 'm proposing topic next major release . ) clearly react-is work assumption used matching version react . therefore , * * react listed peerdependencies react-is . * * brought discussion involving package depends react-is downstream .",
        "title_stopwords_removal_lemmatization": "[ react-is ] major version react react-is must peerdependencies related ."
    },
    {
        "issue_id": 1035758075,
        "title": "React 18 - waterfall suspensions re-trigger the Suspense boundary ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-26T02:36:18Z",
        "status": "open",
        "description": "I'm seeing some baffling behavior with React 18 in concurrent mode. The minimal repro is below. The tl;dr is this:\r\n\r\nI have a single Suspense boundary at the root of the application. The fallback turns the screen pink (so you know it's there).\r\n\r\n## Problem 1\r\n\r\nI load some data with a Suspense hook. When the data come back, and render, subsequent Suspensions will happen, since I have a SuspenseImg component which suspends while each image preloads. \r\n\r\n**Expected Behavior**\r\n\r\nThe fallback should show until the data come in, and all of the subsequent image preloads are done.\r\n\r\n**Actual Behavior**\r\n\r\nThe fallback shows, then the page renders briefly, without data, and then re-suspends while the images preload.\r\n\r\n---\r\n\r\n## Problem 2\r\n\r\nThere's a button which loads more data, using startTransition. The data load re-triggers the same suspension, and the new data cause the same suspensions when rendered, via the same SuspenseImg (I force it to suspend even though I'm loading the same 5 images over and over).\r\n\r\n**Expected Behavior**\r\n\r\nThe loading boolean from useTransition should show until the data are returned, and all of the images have pre-loaded\r\n\r\n**Actual Behavior**\r\n\r\nThe loading boolean shows while the data are loading, and then the main fallback shows while the images preload.\r\n\r\n---\r\n\r\nI'll assume this isn't a bug, and that I instead have misunderstood how this works. I had thought Suspense was supposed to make this stuff fire and forget, with React keeping the appropriate fallback / loading boolean set until the entire state has been set, and everything rendered without anything suspending. But it seems I've misunderstood something? \r\n\r\n---\r\n\r\nhttps://codesandbox.io/s/suspense-debug-pz5mz?file=/src/useQuery.js",
        "remove_template_description": "I'm seeing some baffling behavior with React 18 in concurrent mode. The minimal repro is below. The tl;dr is this:    I have a single Suspense boundary at the root of the application. The fallback turns the screen pink (so you know it's there).    ## Problem 1    I load some data with a Suspense hook. When the data come back, and render, subsequent Suspensions will happen, since I have a SuspenseImg component which suspends while each image preloads.     **Expected Behavior**    The fallback should show until the data come in, and all of the subsequent image preloads are done.    **Actual Behavior**    The fallback shows, then the page renders briefly, without data, and then re-suspends while the images preload.    ---    ## Problem 2    There's a button which loads more data, using startTransition. The data load re-triggers the same suspension, and the new data cause the same suspensions when rendered, via the same SuspenseImg (I force it to suspend even though I'm loading the same 5 images over and over).    **Expected Behavior**    The loading boolean from useTransition should show until the data are returned, and all of the images have pre-loaded    **Actual Behavior**    The loading boolean shows while the data are loading, and then the main fallback shows while the images preload.    ---    I'll assume this isn't a bug, and that I instead have misunderstood how this works. I had thought Suspense was supposed to make this stuff fire and forget, with React keeping the appropriate fallback / loading boolean set until the entire state has been set, and everything rendered without anything suspending. But it seems I've misunderstood something?     ---    https://codesandbox.io/s/suspense-debug-pz5mz?file=/src/useQuery.js",
        "human_words": "I'm seeing some baffling behavior with React 18 in concurrent mode. The minimal repro is below. The tl;dr is this:    I have a single Suspense boundary at the root of the application. The fallback turns the screen pink (so you know it's there).    ## Problem 1    I load some data with a Suspense hook. When the data come back, and render, subsequent Suspensions will happen, since I have a SuspenseImg component which suspends while each image preloads.     **Expected Behavior**    The fallback should show until the data come in, and all of the subsequent image preloads are done.    **Actual Behavior**    The fallback shows, then the page renders briefly, without data, and then re-suspends while the images preload.    ---    ## Problem 2    There's a button which loads more data, using startTransition. The data load re-triggers the same suspension, and the new data cause the same suspensions when rendered, via the same SuspenseImg (I force it to suspend even though I'm loading the same 5 images over and over).    **Expected Behavior**    The loading boolean from useTransition should show until the data are returned, and all of the images have pre-loaded    **Actual Behavior**    The loading boolean shows while the data are loading, and then the main fallback shows while the images preload.    ---    I'll assume this isn't a bug, and that I instead have misunderstood how this works. I had thought Suspense was supposed to make this stuff fire and forget, with React keeping the appropriate fallback / loading boolean set until the entire state has been set, and everything rendered without anything suspending. But it seems I've misunderstood something?     ---    https://codesandbox.io/s/suspense-debug-pz5mz?file=/src/useQuery.js",
        "human_words_regrex": "I'm seeing some baffling behavior with React 18 in concurrent mode. The minimal repro is below. The tl;dr is this: I have a single Suspense boundary at the root of the application. The fallback turns the screen pink (so you know it's there). ## Problem 1 I load some data with a Suspense hook. When the data come back, and render, subsequent Suspensions will happen, since I have a SuspenseImg component which suspends while each image preloads. **Expected Behavior** The fallback should show until the data come in, and all of the subsequent image preloads are done. **Actual Behavior** The fallback shows, then the page renders briefly, without data, and then re-suspends while the images preload. --- ## Problem 2 There's a button which loads more data, using startTransition. The data load re-triggers the same suspension, and the new data cause the same suspensions when rendered, via the same SuspenseImg (I force it to suspend even though I'm loading the same 5 images over and over). **Expected Behavior** The loading boolean from useTransition should show until the data are returned, and all of the images have pre-loaded **Actual Behavior** The loading boolean shows while the data are loading, and then the main fallback shows while the images preload. --- I'll assume this isn't a bug, and that I instead have misunderstood how this works. I had thought Suspense was supposed to make this stuff fire and forget, with React keeping the appropriate fallback / loading boolean set until the entire state has been set, and everything rendered without anything suspending. But it seems I've misunderstood something? --- ",
        "human_words_stopwords_removal_lemmatization": "'m seeing baffling behavior react 18 concurrent mode . minimal repro . tl ; dr : single suspense boundary root application . fallback turn screen pink ( know 's ) . # # problem 1 load data suspense hook . data come back , render , subsequent suspension happen , since suspenseimg component suspends image preloads . * * expected behavior * * fallback show data come , subsequent image preloads done . * * actual behavior * * fallback show , page render briefly , without data , re-suspends image preload . -- - # # problem 2 's button load data , using starttransition . data load re-triggers suspension , new data cause suspension rendered , via suspenseimg ( force suspend even though 'm loading 5 image ) . * * expected behavior * * loading boolean usetransition show data returned , image pre-loaded * * actual behavior * * loading boolean show data loading , main fallback show image preload . -- - 'll assume n't bug , instead misunderstood work . thought suspense supposed make stuff fire forget , react keeping appropriate fallback / loading boolean set entire state set , everything rendered without anything suspending . seems 've misunderstood something ? -- -",
        "title_stopwords_removal_lemmatization": "react 18 - waterfall suspension re-trigger suspense boundary"
    },
    {
        "issue_id": 1034880561,
        "title": "I have been learning react for quite some time and I just recently came across the term React.memo() that helps us to optimize our functional components thus increase our application's performance. I understood what's it for but one thing I don't understand is that when to use it? does it make sense to use it in our every primary child components besides App.js?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-25T09:13:58Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "learning react quite time recently came across term react.memo ( ) help u optimize functional component thus increase application 's performance . understood 's one thing n't understand use ? make sense use every primary child component besides app.js ?"
    },
    {
        "issue_id": 1031922669,
        "title": "Importing from one's own file results in localhost not loading and eventually crashing tab",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-20T23:56:50Z",
        "status": "closed",
        "description": "Not sure if this is a bug or not; It should be undefined behavior but was needlessly difficult to debug. \r\n\r\nImporting a react component (which doesn't exist) from its own file doesn't result in any sort of errors at compilation or runtime. It leaves localhost:3000 on loading until the tab runs out of memory and crashes. \r\n\r\nSteps to reproduce - \r\n\r\n1. Create a react app in an empty folder with `npx create-react-app demo`\r\n\r\n2. Delete all files in the `demo/src` folder\r\n\r\n3. Create the following files in the `demo/src` folder:\r\n\r\n`index.js`\r\n```js\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App/>, document.getElementById('root'));\r\n```\r\n<br/>\r\n\r\n`App.js`\r\n```js\r\nimport React from \"react\";\r\nimport Foo from \"./App\";\r\n\r\nclass App extends React.Component {\r\n    render() {\r\n        return (\r\n            <Foo/>\r\n        )\r\n    }\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n4. do `cd demo`\r\n5. do `npm start`\r\n6. Go to `localhost:3000`\r\n7. Wait for browser to crash and cry because you can't find the bug\r\n\r\nOne would assume this type of thing would be caught in compilation, or at least throw an error at runtime - but it does not. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "remove_template_description": "Not sure if this is a bug or not; It should be undefined behavior but was needlessly difficult to debug.     Importing a react component (which doesn't exist) from its own file doesn't result in any sort of errors at compilation or runtime. It leaves localhost:3000 on loading until the tab runs out of memory and crashes.     Steps to reproduce -     1. Create a react app in an empty folder with `npx create-react-app demo`    2. Delete all files in the `demo/src` folder    3. Create the following files in the `demo/src` folder:    `index.js`  ```js  import React from 'react';  import ReactDOM from 'react-dom';  import App from './App';    ReactDOM.render(<App/>, document.getElementById('root'));  ```  <br/>    `App.js`  ```js  import React from \"react\";  import Foo from \"./App\";    class App extends React.Component {      render() {          return (              <Foo/>          )      }  }    export default App;  ```    4. do `cd demo`  5. do `npm start`  6. Go to `localhost:3000`  7. Wait for browser to crash and cry because you can't find the bug    One would assume this type of thing would be caught in compilation, or at least throw an error at runtime - but it does not.",
        "human_words": "Not sure if this is a bug or not; It should be undefined behavior but was needlessly difficult to debug.     Importing a react component (which doesn't exist) from its own file doesn't result in any sort of errors at compilation or runtime. It leaves localhost:3000 on loading until the tab runs out of memory and crashes.     Steps to reproduce -     1. Create a react app in an empty folder with `npx create-react-app demo`    2. Delete all files in the `demo/src` folder    3. Create the following files in the `demo/src` folder:    `index.js`    <br/>    `App.js`      4. do `cd demo`  5. do `npm start`  6. Go to `localhost:3000`  7. Wait for browser to crash and cry because you can't find the bug    One would assume this type of thing would be caught in compilation, or at least throw an error at runtime - but it does not.",
        "human_words_regrex": "Not sure if this is a bug or not; It should be undefined behavior but was needlessly difficult to debug. Importing a react component (which doesn't exist) from its own file doesn't result in any sort of errors at compilation or runtime. It leaves localhost:3000 on loading until the tab runs out of memory and crashes. Steps to reproduce - 1. Create a react app in an empty folder with `npx create-react-app demo` 2. Delete all files in the `demo/src` folder 3. Create the following files in the `demo/src` folder: `index.js`  `App.js` 4. do `cd demo` 5. do `npm start` 6. Go to `localhost:3000` 7. Wait for browser to crash and cry because you can't find the bug One would assume this type of thing would be caught in compilation, or at least throw an error at runtime - but it does not.",
        "human_words_stopwords_removal_lemmatization": "sure bug ; undefined behavior needlessly difficult debug . importing react component ( n't exist ) file n't result sort error compilation runtime . leaf localhost:3000 loading tab run memory crash . step reproduce - 1. create react app empty folder ` npx create-react-app demo ` 2. delete file ` demo/src ` folder 3. create following file ` demo/src ` folder : ` index.js ` ` app.js ` 4. ` cd demo ` 5. ` npm start ` 6. go ` localhost:3000 ` 7. wait browser crash cry ca n't find bug one would assume type thing would caught compilation , least throw error runtime - .",
        "title_stopwords_removal_lemmatization": "importing one 's file result localhost loading eventually crashing tab"
    },
    {
        "issue_id": 1031708448,
        "title": "Feature request: react-hooks/exhaustive-deps option to require deps arg.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-20T18:25:42Z",
        "status": "open",
        "description": "Please add an option to the configuration for the `react-hooks/exhaustive-deps` eslint rule to require a `deps` argument for all hooks that can take it.\r\n\r\nThis new configuration option would throw a warning/error (don't care about default) for the code below:\r\n```\r\nconst Demo = ({ thing }) => {\r\n  useEffect(() => {\r\n    console.log(thing)\r\n  })\r\n}\r\n```\r\n\r\nI am aware that this already throws an error:\r\n```\r\nconst Demo = ({ thing }) => {\r\n  useEffect(() => {\r\n    console.log(thing)\r\n  }, [])\r\n}\r\n```\r\n\r\nThis request is specifically concerning the case where no second argument is passed to hooks like `useEffect`, `useCallback`, `useMemo`, etc.\r\n\r\nThe configuration would be used in a way similar to this:\r\n`'react-hooks/exhaustive-deps': ['warn', {alwaysRequireDeps: true }]`\r\n\r\nReasoning: \r\nI can't think of a scenario where firing the callback of `useEffect` on every render is desired. An intentional `eslint-disable-next-line` is acceptable if this scenario arises.\r\nA missing `deps` arg can cause sneaky bugs.\r\n",
        "remove_template_description": "Please add an option to the configuration for the `react-hooks/exhaustive-deps` eslint rule to require a `deps` argument for all hooks that can take it.    This new configuration option would throw a warning/error (don't care about default) for the code below:  ```  const Demo = ({ thing }) => {    useEffect(() => {      console.log(thing)    })  }  ```    I am aware that this already throws an error:  ```  const Demo = ({ thing }) => {    useEffect(() => {      console.log(thing)    }, [])  }  ```    This request is specifically concerning the case where no second argument is passed to hooks like `useEffect`, `useCallback`, `useMemo`, etc.    The configuration would be used in a way similar to this:  `'react-hooks/exhaustive-deps': ['warn', {alwaysRequireDeps: true }]`    Reasoning:   I can't think of a scenario where firing the callback of `useEffect` on every render is desired. An intentional `eslint-disable-next-line` is acceptable if this scenario arises.  A missing `deps` arg can cause sneaky bugs.",
        "human_words": "Please add an option to the configuration for the `react-hooks/exhaustive-deps` eslint rule to require a `deps` argument for all hooks that can take it.    This new configuration option would throw a warning/error (don't care about default) for the code below:      I am aware that this already throws an error:      This request is specifically concerning the case where no second argument is passed to hooks like `useEffect`, `useCallback`, `useMemo`, etc.    The configuration would be used in a way similar to this:  `'react-hooks/exhaustive-deps': ['warn', {alwaysRequireDeps: true }]`    Reasoning:   I can't think of a scenario where firing the callback of `useEffect` on every render is desired. An intentional `eslint-disable-next-line` is acceptable if this scenario arises.  A missing `deps` arg can cause sneaky bugs.",
        "human_words_regrex": "Please add an option to the configuration for the `react-hooks/exhaustive-deps` eslint rule to require a `deps` argument for all hooks that can take it. This new configuration option would throw a warning/error (don't care about default) for the code below: I am aware that this already throws an error: This request is specifically concerning the case where no second argument is passed to hooks like `useEffect`, `useCallback`, `useMemo`, etc. The configuration would be used in a way similar to this: `'react-hooks/exhaustive-deps': ['warn', {alwaysRequireDeps: true }]` Reasoning: I can't think of a scenario where firing the callback of `useEffect` on every render is desired. An intentional `eslint-disable-next-line` is acceptable if this scenario arises. A missing `deps` arg can cause sneaky bugs.",
        "human_words_stopwords_removal_lemmatization": "please add option configuration ` react-hooks/exhaustive-deps ` eslint rule require ` deps ` argument hook take . new configuration option would throw warning/error ( n't care default ) code : aware already throw error : request specifically concerning case second argument passed hook like ` useeffect ` , ` usecallback ` , ` usememo ` , etc . configuration would used way similar : ` 'react-hooks/exhaustive-deps ' : [ 'warn ' , { alwaysrequiredeps : true } ] ` reasoning : ca n't think scenario firing callback ` useeffect ` every render desired . intentional ` eslint-disable-next-line ` acceptable scenario arises . missing ` deps ` arg cause sneaky bug .",
        "title_stopwords_removal_lemmatization": "feature request : react-hooks/exhaustive-deps option require deps arg ."
    },
    {
        "issue_id": 1023133782,
        "title": "Custom React-specific metadata format",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Size: Large"
        ],
        "date": "2021-10-11T21:33:40Z",
        "status": "open",
        "description": "The recent DevTools [\"named hooks\" feature](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#display-hook-names-for-inspected-components) has been heavily optimized since its initial launch.  There are some additional optimizations that we _could_ consider (see the first comment below) but I believe the single biggest remaining bottleneck is downloading and parsing of large source map files. \r\n\r\nUsing Facebook as a case study, over 65% of the time spent parsing hook names is downloading the source-map files:\r\n![image](https://user-images.githubusercontent.com/29597/136857383-aa6af89e-5c84-4213-88c4-691d8729571a.png)\r\n\r\nA significant portion of this time is spent on the generating the source map on the server:\r\n![image](https://user-images.githubusercontent.com/29597/136857473-af833048-d07c-4066-9dad-1ea0a4aa084e.png)\r\n\r\nPerhaps this could be optimized further, but at some point- we'll still have to download and parse a potentially large file.\r\n\r\n### Can we avoid relying on the source map entirely?\r\n\r\nWe aren't using source maps in the typical way. (We aren't displaying the original source code.) So the majority of the data contained in the source-map is useless to us. We've experimented with [extending the source map](https://github.com/facebook/react/issues/21782#issuecomment-872599422) so that we didn't have to parse the original code, but the biggest bottleneck (based on testing) is actually _generating and downloading_ the source-map so this only helps a little.\r\n\r\nWhat if we pre-computed hooks metadata (during compilation) and wrote it to a separate file that gets bundled along like a source map. We could generate this metadata for the _compiled code_, rather than the _source code_, so we wouldn't need to map anything at runtime. I don't have exact figures on how much faster this would be, but I estimate it would reduce the source-map file size by an order of magnitude which could have a pretty large impact on the overall performance.\r\n\r\nIf this custom metadata file is successful, we could also store some additional (lightweight) information in it such as component display names.\r\n\r\nAdding additional metadata to this file/format should be done in a backwards-compatible way if at all possible. Still, the metadata format should be _versioned_ in the event that a backwards breaking change occurred.\r\n\r\n### What if this metadata was unavailable?\r\n\r\nThis would be entirely opt-in. DevTools would fall back to loading and parsing the complete source-map if this custom metadata was unavailable.",
        "remove_template_description": "The recent DevTools [\"named hooks\" feature](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#display-hook-names-for-inspected-components) has been heavily optimized since its initial launch.  There are some additional optimizations that we _could_ consider (see the first comment below) but I believe the single biggest remaining bottleneck is downloading and parsing of large source map files.     Using Facebook as a case study, over 65% of the time spent parsing hook names is downloading the source-map files:  ![image](https://user-images.githubusercontent.com/29597/136857383-aa6af89e-5c84-4213-88c4-691d8729571a.png)    A significant portion of this time is spent on the generating the source map on the server:  ![image](https://user-images.githubusercontent.com/29597/136857473-af833048-d07c-4066-9dad-1ea0a4aa084e.png)    Perhaps this could be optimized further, but at some point- we'll still have to download and parse a potentially large file.    ### Can we avoid relying on the source map entirely?    We aren't using source maps in the typical way. (We aren't displaying the original source code.) So the majority of the data contained in the source-map is useless to us. We've experimented with [extending the source map](https://github.com/facebook/react/issues/21782#issuecomment-872599422) so that we didn't have to parse the original code, but the biggest bottleneck (based on testing) is actually _generating and downloading_ the source-map so this only helps a little.    What if we pre-computed hooks metadata (during compilation) and wrote it to a separate file that gets bundled along like a source map. We could generate this metadata for the _compiled code_, rather than the _source code_, so we wouldn't need to map anything at runtime. I don't have exact figures on how much faster this would be, but I estimate it would reduce the source-map file size by an order of magnitude which could have a pretty large impact on the overall performance.    If this custom metadata file is successful, we could also store some additional (lightweight) information in it such as component display names.    Adding additional metadata to this file/format should be done in a backwards-compatible way if at all possible. Still, the metadata format should be _versioned_ in the event that a backwards breaking change occurred.    ### What if this metadata was unavailable?    This would be entirely opt-in. DevTools would fall back to loading and parsing the complete source-map if this custom metadata was unavailable.",
        "human_words": "The recent DevTools [\"named hooks\" feature](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#display-hook-names-for-inspected-components) has been heavily optimized since its initial launch.  There are some additional optimizations that we _could_ consider (see the first comment below) but I believe the single biggest remaining bottleneck is downloading and parsing of large source map files.     Using Facebook as a case study, over 65% of the time spent parsing hook names is downloading the source-map files:  ![image](https://user-images.githubusercontent.com/29597/136857383-aa6af89e-5c84-4213-88c4-691d8729571a.png)    A significant portion of this time is spent on the generating the source map on the server:  ![image](https://user-images.githubusercontent.com/29597/136857473-af833048-d07c-4066-9dad-1ea0a4aa084e.png)    Perhaps this could be optimized further, but at some point- we'll still have to download and parse a potentially large file.    ### Can we avoid relying on the source map entirely?    We aren't using source maps in the typical way. (We aren't displaying the original source code.) So the majority of the data contained in the source-map is useless to us. We've experimented with [extending the source map](https://github.com/facebook/react/issues/21782#issuecomment-872599422) so that we didn't have to parse the original code, but the biggest bottleneck (based on testing) is actually _generating and downloading_ the source-map so this only helps a little.    What if we pre-computed hooks metadata (during compilation) and wrote it to a separate file that gets bundled along like a source map. We could generate this metadata for the _compiled code_, rather than the _source code_, so we wouldn't need to map anything at runtime. I don't have exact figures on how much faster this would be, but I estimate it would reduce the source-map file size by an order of magnitude which could have a pretty large impact on the overall performance.    If this custom metadata file is successful, we could also store some additional (lightweight) information in it such as component display names.    Adding additional metadata to this file/format should be done in a backwards-compatible way if at all possible. Still, the metadata format should be _versioned_ in the event that a backwards breaking change occurred.    ### What if this metadata was unavailable?    This would be entirely opt-in. DevTools would fall back to loading and parsing the complete source-map if this custom metadata was unavailable.",
        "human_words_regrex": "The recent DevTools  has been heavily optimized since its initial launch. There are some additional optimizations that we _could_ consider (see the first comment below) but I believe the single biggest remaining bottleneck is downloading and parsing of large source map files. Using Facebook as a case study, over 65% of the time spent parsing hook names is downloading the source-map files: ! A significant portion of this time is spent on the generating the source map on the server: ! Perhaps this could be optimized further, but at some point- we'll still have to download and parse a potentially large file. ### Can we avoid relying on the source map entirely? We aren't using source maps in the typical way. (We aren't displaying the original source code.) So the majority of the data contained in the source-map is useless to us. We've experimented with  so that we didn't have to parse the original code, but the biggest bottleneck (based on testing) is actually _generating and downloading_ the source-map so this only helps a little. What if we pre-computed hooks metadata (during compilation) and wrote it to a separate file that gets bundled along like a source map. We could generate this metadata for the _compiled code_, rather than the _source code_, so we wouldn't need to map anything at runtime. I don't have exact figures on how much faster this would be, but I estimate it would reduce the source-map file size by an order of magnitude which could have a pretty large impact on the overall performance. If this custom metadata file is successful, we could also store some additional (lightweight) information in it such as component display names. Adding additional metadata to this file/format should be done in a backwards-compatible way if at all possible. Still, the metadata format should be _versioned_ in the event that a backwards breaking change occurred. ### What if this metadata was unavailable? This would be entirely opt-in. DevTools would fall back to loading and parsing the complete source-map if this custom metadata was unavailable.",
        "human_words_stopwords_removal_lemmatization": "recent devtools heavily optimized since initial launch . additional optimization _could_ consider ( see first comment ) believe single biggest remaining bottleneck downloading parsing large source map file . using facebook case study , 65 % time spent parsing hook name downloading source-map file : ! significant portion time spent generating source map server : ! perhaps could optimized , point- 'll still download parse potentially large file . # # # avoid relying source map entirely ? n't using source map typical way . ( n't displaying original source code . ) majority data contained source-map useless u . 've experimented n't parse original code , biggest bottleneck ( based testing ) actually _generating downloading_ source-map help little . pre-computed hook metadata ( compilation ) wrote separate file get bundled along like source map . could generate metadata _compiled code_ , rather _source code_ , would n't need map anything runtime . n't exact figure much faster would , estimate would reduce source-map file size order magnitude could pretty large impact overall performance . custom metadata file successful , could also store additional ( lightweight ) information component display name . adding additional metadata file/format done backwards-compatible way possible . still , metadata format _versioned_ event backwards breaking change occurred . # # # metadata unavailable ? would entirely opt-in . devtools would fall back loading parsing complete source-map custom metadata unavailable .",
        "title_stopwords_removal_lemmatization": "custom react-specific metadata format"
    },
    {
        "issue_id": 1022717363,
        "title": "Allow custom hooks to return stable results",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2021-10-11T13:35:54Z",
        "status": "closed",
        "description": "Right now only `useRef` and other first-party hooks are allowed to return a stable result that is not required to be listed in the dependencies array of other hooks.\r\n\r\nWe have the `react-hooks/exhaustive-deps`' `additionalHooks` option to specify additional hooks that take dependencies arrays, but we don't have a way to describe a hook that returns a stable result.\r\n\r\nAn example of such hook could be:\r\n\r\n```js\r\nconst useLatest = (value) => {\r\n  const ref = useRef(value);\r\n  ref.current = value;\r\n  return ref;\r\n};\r\n```\r\n\r\nIt would be extremely useful being able to define custom hooks like this with a rule that could look like the following:\r\n\r\n```\r\n\"react-hooks/exhaustive-deps\": [\r\n  \"warn\",\r\n  {\r\n    \"stableKnownHookValues\": \"(useLatest|useSomethingElse)\"\r\n  }\r\n]\r\n```\r\n\r\nI'd be willing to work on a PR if this idea is deemed useful.",
        "remove_template_description": "Right now only `useRef` and other first-party hooks are allowed to return a stable result that is not required to be listed in the dependencies array of other hooks.    We have the `react-hooks/exhaustive-deps`' `additionalHooks` option to specify additional hooks that take dependencies arrays, but we don't have a way to describe a hook that returns a stable result.    An example of such hook could be:    ```js  const useLatest = (value) => {    const ref = useRef(value);    ref.current = value;    return ref;  };  ```    It would be extremely useful being able to define custom hooks like this with a rule that could look like the following:    ```  \"react-hooks/exhaustive-deps\": [    \"warn\",    {      \"stableKnownHookValues\": \"(useLatest|useSomethingElse)\"    }  ]  ```    I'd be willing to work on a PR if this idea is deemed useful.",
        "human_words": "Right now only `useRef` and other first-party hooks are allowed to return a stable result that is not required to be listed in the dependencies array of other hooks.    We have the `react-hooks/exhaustive-deps`' `additionalHooks` option to specify additional hooks that take dependencies arrays, but we don't have a way to describe a hook that returns a stable result.    An example of such hook could be:        It would be extremely useful being able to define custom hooks like this with a rule that could look like the following:        I'd be willing to work on a PR if this idea is deemed useful.",
        "human_words_regrex": "Right now only `useRef` and other first-party hooks are allowed to return a stable result that is not required to be listed in the dependencies array of other hooks. We have the `react-hooks/exhaustive-deps`' `additionalHooks` option to specify additional hooks that take dependencies arrays, but we don't have a way to describe a hook that returns a stable result. An example of such hook could be: It would be extremely useful being able to define custom hooks like this with a rule that could look like the following: I'd be willing to work on a PR if this idea is deemed useful.",
        "human_words_stopwords_removal_lemmatization": "right ` useref ` first-party hook allowed return stable result required listed dependency array hook . ` react-hooks/exhaustive-deps ` ' ` additionalhooks ` option specify additional hook take dependency array , n't way describe hook return stable result . example hook could : would extremely useful able define custom hook like rule could look like following : 'd willing work pr idea deemed useful .",
        "title_stopwords_removal_lemmatization": "allow custom hook return stable result"
    },
    {
        "issue_id": 1022009761,
        "title": "React 18 - `useState` invisible for end users",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-10-10T15:09:20Z",
        "status": "closed",
        "description": "# Why not to make `useState` easier (invisible) for us? \r\n\r\nFrom this:\r\n```tsx\r\nfunction App() {\r\n    // Declare and use as a single variable\r\n    const $$count = 0;\r\n    return (<ThemeProvider>\r\n        <DefaultButton color=\"primary\" onClick={() => $$count++}>\r\n      \t\tHello Pedro, you hit this button { $$count } time\r\n        </DefaultButton>\r\n    </ThemeProvider>);\r\n}\r\nexport default App;\r\n```\r\n\r\nTo this:\r\n```tsx\r\nfunction App() {\r\n    const [$$countValue, $$setCountValue] = useState(0);\r\n    return (<ThemeProvider>\r\n        <DefaultButton color=\"primary\" onClick={() => $$setCountValue(() => $$countValue + 1)}>\r\n      \t\tHello Pedro, you hit this button {$$countValue} time\r\n        </DefaultButton>\r\n    </ThemeProvider>);\r\n}\r\nexport default App;\r\n```\r\n## AST sample _(I know it can be optimized)_\r\n```js\r\nexport default function (program) {\r\n\r\n  const checker = program.getTypeChecker();\r\n\r\n  return (context) => {\r\n\r\n    return (sourceFile) => {\r\n\r\n      const visitor = (node) => {\r\n\r\n        let factory = ts.factory;\r\n\r\n        if (ts.isVariableDeclaration(node) && node.name.escapedText.startsWith(\"$$\")) {\r\n          return factory.createVariableDeclaration(\r\n            factory.createArrayBindingPattern([\r\n              factory.createBindingElement(\r\n                undefined,\r\n                undefined,\r\n                factory.createIdentifier(node.name.escapedText + 'Value'),\r\n                undefined\r\n              ),\r\n              factory.createBindingElement(\r\n                undefined,\r\n                undefined,\r\n                factory.createIdentifier(\"$$set\" + node.name.escapedText.slice(2).replace(/^[\\w]/, m=>m.toUpperCase()) + 'Value'),\r\n                undefined\r\n              )\r\n            ]),\r\n            undefined,\r\n            undefined,\r\n            factory.createCallExpression(\r\n              factory.createIdentifier(\"useState\"),\r\n              undefined,\r\n              [node.initializer]\r\n            )\r\n          ));\r\n        }\r\n\r\n        if (ts.isPostfixUnaryExpression(node) && node.operand.escapedText.startsWith(\"$$\") && node.kind === 212) {\r\n          return (\r\n            factory.createCallExpression(\r\n              factory.createIdentifier(\"$$set\" + node.operand.escapedText.slice(2).replace(/^[\\w]/, m=>m.toUpperCase()) + 'Value'),\r\n              undefined,\r\n              [factory.createArrowFunction(\r\n                undefined,\r\n                undefined,\r\n                [],\r\n                undefined,\r\n                factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\r\n                factory.createBinaryExpression(\r\n                  factory.createIdentifier(node.operand.escapedText + 'Value'),\r\n                  factory.createToken(ts.SyntaxKind.PlusToken),\r\n                  factory.createNumericLiteral(\"1\")\r\n                )\r\n              )]\r\n            );\r\n\r\n            return resultNode;\r\n          }\r\n\r\n        if (ts.isPostfixUnaryExpression(node) && node.operand.escapedText.startsWith(\"$$\") && node.kind === 212) {\r\n          window.plusEqualNode = node;\r\n\r\n          let resultNode = factory.createCallExpression(\r\n            factory.createElementAccessExpression(\r\n              node.operand, \r\n              factory.createNumericLiteral(\"0\")),\r\n              undefined,\r\n              [\r\n                factory.createArrowFunction(\r\n                  undefined,\r\n                  undefined,\r\n                  [],\r\n                  undefined,\r\n                  factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\r\n                  factory.createBinaryExpression(\r\n                    factory.createElementAccessExpression(node.operand, factory.createNumericLiteral(\"1\")),\r\n                    factory.createToken(node.operator === 46 ? ts.SyntaxKind.MinusToken : ts.SyntaxKind.PlusToken),\r\n                    factory.createNumericLiteral(\"1\")\r\n                  )\r\n                )\r\n              ]\r\n            );\r\n        }\r\n\r\n        if (ts.isIdentifier(node) && node.text.startsWith(\"$$\") && ts.isJsxExpression(node.parent)) {\r\n          return factory.createIdentifier(node.escapedText + 'Value');\r\n        }\r\n\r\n        return ts.visitEachChild(node, visitor, context);\r\n      };\r\n\r\n      return ts.visitNode(sourceFile, visitor);\r\n    };\r\n  }\r\n}\r\n```\r\n",
        "remove_template_description": "# Why not to make `useState` easier (invisible) for us?     From this:  ```tsx  function App() {      // Declare and use as a single variable      const $$count = 0;      return (<ThemeProvider>          <DefaultButton color=\"primary\" onClick={() => $$count++}>        \t\tHello Pedro, you hit this button { $$count } time          </DefaultButton>      </ThemeProvider>);  }  export default App;  ```    To this:  ```tsx  function App() {      const [$$countValue, $$setCountValue] = useState(0);      return (<ThemeProvider>          <DefaultButton color=\"primary\" onClick={() => $$setCountValue(() => $$countValue + 1)}>        \t\tHello Pedro, you hit this button {$$countValue} time          </DefaultButton>      </ThemeProvider>);  }  export default App;  ```  ## AST sample _(I know it can be optimized)_  ```js  export default function (program) {      const checker = program.getTypeChecker();      return (context) => {        return (sourceFile) => {          const visitor = (node) => {            let factory = ts.factory;            if (ts.isVariableDeclaration(node) && node.name.escapedText.startsWith(\"$$\")) {            return factory.createVariableDeclaration(              factory.createArrayBindingPattern([                factory.createBindingElement(                  undefined,                  undefined,                  factory.createIdentifier(node.name.escapedText + 'Value'),                  undefined                ),                factory.createBindingElement(                  undefined,                  undefined,                  factory.createIdentifier(\"$$set\" + node.name.escapedText.slice(2).replace(/^[\\w]/, m=>m.toUpperCase()) + 'Value'),                  undefined                )              ]),              undefined,              undefined,              factory.createCallExpression(                factory.createIdentifier(\"useState\"),                undefined,                [node.initializer]              )            ));          }            if (ts.isPostfixUnaryExpression(node) && node.operand.escapedText.startsWith(\"$$\") && node.kind === 212) {            return (              factory.createCallExpression(                factory.createIdentifier(\"$$set\" + node.operand.escapedText.slice(2).replace(/^[\\w]/, m=>m.toUpperCase()) + 'Value'),                undefined,                [factory.createArrowFunction(                  undefined,                  undefined,                  [],                  undefined,                  factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),                  factory.createBinaryExpression(                    factory.createIdentifier(node.operand.escapedText + 'Value'),                    factory.createToken(ts.SyntaxKind.PlusToken),                    factory.createNumericLiteral(\"1\")                  )                )]              );                return resultNode;            }            if (ts.isPostfixUnaryExpression(node) && node.operand.escapedText.startsWith(\"$$\") && node.kind === 212) {            window.plusEqualNode = node;              let resultNode = factory.createCallExpression(              factory.createElementAccessExpression(                node.operand,                 factory.createNumericLiteral(\"0\")),                undefined,                [                  factory.createArrowFunction(                    undefined,                    undefined,                    [],                    undefined,                    factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),                    factory.createBinaryExpression(                      factory.createElementAccessExpression(node.operand, factory.createNumericLiteral(\"1\")),                      factory.createToken(node.operator === 46 ? ts.SyntaxKind.MinusToken : ts.SyntaxKind.PlusToken),                      factory.createNumericLiteral(\"1\")                    )                  )                ]              );          }            if (ts.isIdentifier(node) && node.text.startsWith(\"$$\") && ts.isJsxExpression(node.parent)) {            return factory.createIdentifier(node.escapedText + 'Value');          }            return ts.visitEachChild(node, visitor, context);        };          return ts.visitNode(sourceFile, visitor);      };    }  }  ```",
        "human_words": "# Why not to make `useState` easier (invisible) for us?     From this:      To this:    ## AST sample _(I know it can be optimized)_  ",
        "human_words_regrex": "# Why not to make `useState` easier (invisible) for us? From this: To this: ## AST sample _(I know it can be optimized)_ ",
        "human_words_stopwords_removal_lemmatization": "# make ` usestate ` easier ( invisible ) u ? : : # # ast sample _ ( know optimized ) _",
        "title_stopwords_removal_lemmatization": "react 18 - ` usestate ` invisible end user"
    },
    {
        "issue_id": 1021299959,
        "title": "Improve \"native\" component stacks host component frames",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Size: Small-Medium"
        ],
        "date": "2021-10-08T16:55:59Z",
        "status": "open",
        "description": "React and React DevTools generate [component stacks](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#component-stacks) in the same format as native Error stacks. For user components (class and function components) this is done by intentionally causing the component's render method to throw an Error, and then stitching the error stack frames together:\r\nhttps://github.com/facebook/react/blob/5fa4d79b00988f354073bc27313363dd5cce9cd3/packages/react-devtools-shared/src/backend/DevToolsComponentStackFrame.js#L62-L203\r\n\r\nThis results in a component stack like this:\r\n![image](https://user-images.githubusercontent.com/29597/136594272-3d290470-b0fb-48ac-b0a1-a32402448649.png)\r\n\r\nBut for \"host components\" (e.g. `HTMLDivElement` or `View`) when we have no source location to show, we fall back to showing just \"at div\" or \"at View\".\r\n\r\nWe could probably more closely mirror what JavaScript engines do by appending a \"location\" like `(native)` or `(unknown location)` (as the [v8 docs](https://v8.dev/docs/stack-trace-api#appendix%3A-stack-trace-format) suggest) or `(anonymous)` as v8 seems to actually do in testing.\r\n\r\nThe trick would be matching the specific browser/engine's behavior for this. For example, running the following code in Chrome or Node...\r\n\r\n```js\r\nJSON.stringify({}, () => console.log(new Error('')));\r\n```\r\n\r\n...will show the stack frame:\r\n```\r\n    at JSON.stringify (<anonymous>)\r\n```\r\nwhile Firefox will show:\r\n```\r\nError: \r\n    <anonymous> file:///path/to/script:7\r\n```\r\n\r\nImproving this format so that host components more closely mirror native Error stacks will help simplify things like React Native's error parsing.",
        "remove_template_description": "React and React DevTools generate [component stacks](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#component-stacks) in the same format as native Error stacks. For user components (class and function components) this is done by intentionally causing the component's render method to throw an Error, and then stitching the error stack frames together:  https://github.com/facebook/react/blob/5fa4d79b00988f354073bc27313363dd5cce9cd3/packages/react-devtools-shared/src/backend/DevToolsComponentStackFrame.js#L62-L203    This results in a component stack like this:  ![image](https://user-images.githubusercontent.com/29597/136594272-3d290470-b0fb-48ac-b0a1-a32402448649.png)    But for \"host components\" (e.g. `HTMLDivElement` or `View`) when we have no source location to show, we fall back to showing just \"at div\" or \"at View\".    We could probably more closely mirror what JavaScript engines do by appending a \"location\" like `(native)` or `(unknown location)` (as the [v8 docs](https://v8.dev/docs/stack-trace-api#appendix%3A-stack-trace-format) suggest) or `(anonymous)` as v8 seems to actually do in testing.    The trick would be matching the specific browser/engine's behavior for this. For example, running the following code in Chrome or Node...    ```js  JSON.stringify({}, () => console.log(new Error('')));  ```    ...will show the stack frame:  ```      at JSON.stringify (<anonymous>)  ```  while Firefox will show:  ```  Error:       <anonymous> file:///path/to/script:7  ```    Improving this format so that host components more closely mirror native Error stacks will help simplify things like React Native's error parsing.",
        "human_words": "React and React DevTools generate [component stacks](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#component-stacks) in the same format as native Error stacks. For user components (class and function components) this is done by intentionally causing the component's render method to throw an Error, and then stitching the error stack frames together:  https://github.com/facebook/react/blob/5fa4d79b00988f354073bc27313363dd5cce9cd3/packages/react-devtools-shared/src/backend/DevToolsComponentStackFrame.js#L62-L203    This results in a component stack like this:  ![image](https://user-images.githubusercontent.com/29597/136594272-3d290470-b0fb-48ac-b0a1-a32402448649.png)    But for \"host components\" (e.g. `HTMLDivElement` or `View`) when we have no source location to show, we fall back to showing just \"at div\" or \"at View\".    We could probably more closely mirror what JavaScript engines do by appending a \"location\" like `(native)` or `(unknown location)` (as the [v8 docs](https://v8.dev/docs/stack-trace-api#appendix%3A-stack-trace-format) suggest) or `(anonymous)` as v8 seems to actually do in testing.    The trick would be matching the specific browser/engine's behavior for this. For example, running the following code in Chrome or Node...        ...will show the stack frame:    while Firefox will show:      Improving this format so that host components more closely mirror native Error stacks will help simplify things like React Native's error parsing.",
        "human_words_regrex": "React and React DevTools generate  in the same format as native Error stacks. For user components (class and function components) this is done by intentionally causing the component's render method to throw an Error, and then stitching the error stack frames together:  This results in a component stack like this: ! But for \"host components\" (e.g. `HTMLDivElement` or `View`) when we have no source location to show, we fall back to showing just \"at div\" or \"at View\". We could probably more closely mirror what JavaScript engines do by appending a \"location\" like `(native)` or `(unknown location)` (as the  suggest) or `(anonymous)` as v8 seems to actually do in testing. The trick would be matching the specific browser/engine's behavior for this. For example, running the following code in Chrome or Node... ...will show the stack frame: while Firefox will show: Improving this format so that host components more closely mirror native Error stacks will help simplify things like React Native's error parsing.",
        "human_words_stopwords_removal_lemmatization": "react react devtools generate format native error stack . user component ( class function component ) done intentionally causing component 's render method throw error , stitching error stack frame together : result component stack like : ! `` host component '' ( e.g . ` htmldivelement ` ` view ` ) source location show , fall back showing `` div '' `` view '' . could probably closely mirror javascript engine appending `` location '' like ` ( native ) ` ` ( unknown location ) ` ( suggest ) ` ( anonymous ) ` v8 seems actually testing . trick would matching specific browser/engine 's behavior . example , running following code chrome node ... ... show stack frame : firefox show : improving format host component closely mirror native error stack help simplify thing like react native 's error parsing .",
        "title_stopwords_removal_lemmatization": "improve `` native '' component stack host component frame"
    },
    {
        "issue_id": 1021239226,
        "title": "Combine Profiler data sources",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Component: Scheduling Profiler",
            "Size: Large"
        ],
        "date": "2021-10-08T15:50:32Z",
        "status": "open",
        "description": "### Time sensitive API changes (ideally these should land before 18.0 release):\r\n- [x] Add DevTools API/hooks for collecting Timeline profiling data #23102, #23142, #23151\r\n- [x] React (DEV and profiling builds) should call the new Timeline hooks when present instead of logging User Timing data  #23102, #23142, #23151\r\n\r\n(DevTools will decide whether or not to store the data or log User Timing marks, since it knows when it's profiling.)\r\n\r\n### Additional, non-blocking changes:\r\nDevTools hook changes:\r\n- [x] Log sync marks (with session ID) periodically (e.g. during commit) when profiling is active #23137\r\n- [x] Mark internal module ranges (see [here](https://github.com/facebook/react/blob/9a7e6bf0d0cf08114b74c9fe45c06e60a5e496e4/packages/react-reconciler/src/SchedulingProfiler.js#L102-L123)) only if/when profiling is started. #23141\r\n- [x] ~~Generate a unique session ID when profiling is started. Log it with User Timing and also store it with the main profiling data. (This will be used to match them up later.)~~\r\n- [ ] Collect component stacks for (maybe lazily? maybe cache per Fiber in a WeakMap?)\r\n\r\nDevTools Timeline changes:\r\n- [x] Update pre-processing script to make use of the new React <-> DevTools data format #23185\r\n- [x] Support optional tracing data #23185\r\n  - [x] Verify logic for aligning data shared between React <-> DevTools with the optional performance mark data #23185\r\n  - [x] Create UI for separate, optional import (and update the preprocessor to handle this data) #23185\r\n\r\nFuture optimizations:\r\n- [ ] Consider merging logic between `profilingHooks` and `preprocessData` to remove redundancies. If the code was moved somewhere else, then `profilingHooks` could call it during rendering and `preprocessData` could call it too (as it processed each mark) and avoid having to build up the same in-memory representations.\r\n- [ ] Double check that `internalModuleSourceToRanges` is being initialized correctly for the in-memory profiler. (Technically this doesn't matter yet, since we don't have JavaScript samples for the in memory profiler\u2013 but still.)\r\n\r\n# Motivation\r\n\r\nThere are currently two React profilers: the \"legacy\" profiler (which reads data from Fibers during the commit phase) and the \"scheduling\" profiler (which reads data in the form of User Timing marks in a Chrome performance profile). This separation is confusing as both profilers live in the same extension/app but import/export different types of data.\r\n\r\nLet's take a step back and revisit how the scheduling profiler works...\r\n\r\nRecording a profile currently requires a user to do the following:\r\n1. Click \"record\" in Chrome\r\n2. Use the app\r\n3. Click \"stop\" in Chrome\r\n4. Export the profile JSON\r\n5. Import it into the React DevTools\r\n\r\nIt would be nice if DevTools could start/stop recording and import the data itself, but the only way to do this is using the Chrome DevTools Protocol which would _require_ the use of an extremely powerful permission that I don't think we would want to ask users for.\r\n\r\nThis approach also has the downside of not working with React Native (or non-Chrome browsers).\r\n\r\nSo why do we do it? We do it because the profile gives us a lot of nice extra data: CPU samples of the JavaScript stack, Network requests, screenshots (if enabled), user events (e.g. \"click\").\r\n\r\nBut we don't _need_ this data. The scheduling profiler could still be a useful tool even if included only the React specific marks.\r\n\r\nMy proposal then is that we consider doing this:\r\n* Replace the user timing API with a direct React-to-DevTools API (where these marks are logged to DevTools directly).\r\n* When profiling starts in React DevTools, generate a unique ID string\r\n* Log this unique ID to the User Profiling API along with each commit (e.g. `\"react-sync-marker-<uid>-<index>-<timestamp>\"`)\r\n* Allow users to export/import additional native profiling information (which can be aligned using the sync marks) _but is not required_.\r\n\r\nDoing this has a few benefits:\r\n* We could start _both_ profilers and join the commit and scheduling profiler data streams (huge benefit).\r\n* It would make the profiler easier to use in the simple case (if you didn't want/need native profiler info) since you could start/stop it from within React DevTools.\r\n* It would let us add component and call stacks without the extra serialization overhead.\r\n\r\nIt would have the following downside though:\r\n* Recording profiles with native information would be a little more complicated, since you'd need to start React DevTools _and then_ start the browser profiler. (We could show instructions for doing this in the DevTools profiler though.)\r\n\r\n## A note about component and call stacks\r\n\r\nThe scheduling profiler currently shows component _names_ for things like state-updates (e.g. \"state update scheduled by Foo\") but it does not include component or call stacks. These would both be useful because:\r\n* Component stack would help identify _which instance of foo_ was e.g. scheduling the update\r\n* Call stack would show e.g. which piece of state was being updated (and by what)\r\n\r\nThe reason we don't include this information is because we won't want to pay the cost of string serializing it all and logging it as a User Timing mark.",
        "remove_template_description": "### Time sensitive API changes (ideally these should land before 18.0 release):  - [x] Add DevTools API/hooks for collecting Timeline profiling data #23102, #23142, #23151  - [x] React (DEV and profiling builds) should call the new Timeline hooks when present instead of logging User Timing data  #23102, #23142, #23151    (DevTools will decide whether or not to store the data or log User Timing marks, since it knows when it's profiling.)    ### Additional, non-blocking changes:  DevTools hook changes:  - [x] Log sync marks (with session ID) periodically (e.g. during commit) when profiling is active #23137  - [x] Mark internal module ranges (see [here](https://github.com/facebook/react/blob/9a7e6bf0d0cf08114b74c9fe45c06e60a5e496e4/packages/react-reconciler/src/SchedulingProfiler.js#L102-L123)) only if/when profiling is started. #23141  - [x] ~~Generate a unique session ID when profiling is started. Log it with User Timing and also store it with the main profiling data. (This will be used to match them up later.)~~  - [ ] Collect component stacks for (maybe lazily? maybe cache per Fiber in a WeakMap?)    DevTools Timeline changes:  - [x] Update pre-processing script to make use of the new React <-> DevTools data format #23185  - [x] Support optional tracing data #23185    - [x] Verify logic for aligning data shared between React <-> DevTools with the optional performance mark data #23185    - [x] Create UI for separate, optional import (and update the preprocessor to handle this data) #23185    Future optimizations:  - [ ] Consider merging logic between `profilingHooks` and `preprocessData` to remove redundancies. If the code was moved somewhere else, then `profilingHooks` could call it during rendering and `preprocessData` could call it too (as it processed each mark) and avoid having to build up the same in-memory representations.  - [ ] Double check that `internalModuleSourceToRanges` is being initialized correctly for the in-memory profiler. (Technically this doesn't matter yet, since we don't have JavaScript samples for the in memory profiler\u2013 but still.)    # Motivation    There are currently two React profilers: the \"legacy\" profiler (which reads data from Fibers during the commit phase) and the \"scheduling\" profiler (which reads data in the form of User Timing marks in a Chrome performance profile). This separation is confusing as both profilers live in the same extension/app but import/export different types of data.    Let's take a step back and revisit how the scheduling profiler works...    Recording a profile currently requires a user to do the following:  1. Click \"record\" in Chrome  2. Use the app  3. Click \"stop\" in Chrome  4. Export the profile JSON  5. Import it into the React DevTools    It would be nice if DevTools could start/stop recording and import the data itself, but the only way to do this is using the Chrome DevTools Protocol which would _require_ the use of an extremely powerful permission that I don't think we would want to ask users for.    This approach also has the downside of not working with React Native (or non-Chrome browsers).    So why do we do it? We do it because the profile gives us a lot of nice extra data: CPU samples of the JavaScript stack, Network requests, screenshots (if enabled), user events (e.g. \"click\").    But we don't _need_ this data. The scheduling profiler could still be a useful tool even if included only the React specific marks.    My proposal then is that we consider doing this:  * Replace the user timing API with a direct React-to-DevTools API (where these marks are logged to DevTools directly).  * When profiling starts in React DevTools, generate a unique ID string  * Log this unique ID to the User Profiling API along with each commit (e.g. `\"react-sync-marker-<uid>-<index>-<timestamp>\"`)  * Allow users to export/import additional native profiling information (which can be aligned using the sync marks) _but is not required_.    Doing this has a few benefits:  * We could start _both_ profilers and join the commit and scheduling profiler data streams (huge benefit).  * It would make the profiler easier to use in the simple case (if you didn't want/need native profiler info) since you could start/stop it from within React DevTools.  * It would let us add component and call stacks without the extra serialization overhead.    It would have the following downside though:  * Recording profiles with native information would be a little more complicated, since you'd need to start React DevTools _and then_ start the browser profiler. (We could show instructions for doing this in the DevTools profiler though.)    ## A note about component and call stacks    The scheduling profiler currently shows component _names_ for things like state-updates (e.g. \"state update scheduled by Foo\") but it does not include component or call stacks. These would both be useful because:  * Component stack would help identify _which instance of foo_ was e.g. scheduling the update  * Call stack would show e.g. which piece of state was being updated (and by what)    The reason we don't include this information is because we won't want to pay the cost of string serializing it all and logging it as a User Timing mark.",
        "human_words": "### Time sensitive API changes (ideally these should land before 18.0 release):  - [x] Add DevTools API/hooks for collecting Timeline profiling data #23102, #23142, #23151  - [x] React (DEV and profiling builds) should call the new Timeline hooks when present instead of logging User Timing data  #23102, #23142, #23151    (DevTools will decide whether or not to store the data or log User Timing marks, since it knows when it's profiling.)    ### Additional, non-blocking changes:  DevTools hook changes:  - [x] Log sync marks (with session ID) periodically (e.g. during commit) when profiling is active #23137  - [x] Mark internal module ranges (see [here](https://github.com/facebook/react/blob/9a7e6bf0d0cf08114b74c9fe45c06e60a5e496e4/packages/react-reconciler/src/SchedulingProfiler.js#L102-L123)) only if/when profiling is started. #23141  - [x] ~~Generate a unique session ID when profiling is started. Log it with User Timing and also store it with the main profiling data. (This will be used to match them up later.)~~  - [ ] Collect component stacks for (maybe lazily? maybe cache per Fiber in a WeakMap?)    DevTools Timeline changes:  - [x] Update pre-processing script to make use of the new React <-> DevTools data format #23185  - [x] Support optional tracing data #23185    - [x] Verify logic for aligning data shared between React <-> DevTools with the optional performance mark data #23185    - [x] Create UI for separate, optional import (and update the preprocessor to handle this data) #23185    Future optimizations:  - [ ] Consider merging logic between `profilingHooks` and `preprocessData` to remove redundancies. If the code was moved somewhere else, then `profilingHooks` could call it during rendering and `preprocessData` could call it too (as it processed each mark) and avoid having to build up the same in-memory representations.  - [ ] Double check that `internalModuleSourceToRanges` is being initialized correctly for the in-memory profiler. (Technically this doesn't matter yet, since we don't have JavaScript samples for the in memory profiler\u2013 but still.)    # Motivation    There are currently two React profilers: the \"legacy\" profiler (which reads data from Fibers during the commit phase) and the \"scheduling\" profiler (which reads data in the form of User Timing marks in a Chrome performance profile). This separation is confusing as both profilers live in the same extension/app but import/export different types of data.    Let's take a step back and revisit how the scheduling profiler works...    Recording a profile currently requires a user to do the following:  1. Click \"record\" in Chrome  2. Use the app  3. Click \"stop\" in Chrome  4. Export the profile JSON  5. Import it into the React DevTools    It would be nice if DevTools could start/stop recording and import the data itself, but the only way to do this is using the Chrome DevTools Protocol which would _require_ the use of an extremely powerful permission that I don't think we would want to ask users for.    This approach also has the downside of not working with React Native (or non-Chrome browsers).    So why do we do it? We do it because the profile gives us a lot of nice extra data: CPU samples of the JavaScript stack, Network requests, screenshots (if enabled), user events (e.g. \"click\").    But we don't _need_ this data. The scheduling profiler could still be a useful tool even if included only the React specific marks.    My proposal then is that we consider doing this:  * Replace the user timing API with a direct React-to-DevTools API (where these marks are logged to DevTools directly).  * When profiling starts in React DevTools, generate a unique ID string  * Log this unique ID to the User Profiling API along with each commit (e.g. `\"react-sync-marker-<uid>-<index>-<timestamp>\"`)  * Allow users to export/import additional native profiling information (which can be aligned using the sync marks) _but is not required_.    Doing this has a few benefits:  * We could start _both_ profilers and join the commit and scheduling profiler data streams (huge benefit).  * It would make the profiler easier to use in the simple case (if you didn't want/need native profiler info) since you could start/stop it from within React DevTools.  * It would let us add component and call stacks without the extra serialization overhead.    It would have the following downside though:  * Recording profiles with native information would be a little more complicated, since you'd need to start React DevTools _and then_ start the browser profiler. (We could show instructions for doing this in the DevTools profiler though.)    ## A note about component and call stacks    The scheduling profiler currently shows component _names_ for things like state-updates (e.g. \"state update scheduled by Foo\") but it does not include component or call stacks. These would both be useful because:  * Component stack would help identify _which instance of foo_ was e.g. scheduling the update  * Call stack would show e.g. which piece of state was being updated (and by what)    The reason we don't include this information is because we won't want to pay the cost of string serializing it all and logging it as a User Timing mark.",
        "human_words_regrex": "### Time sensitive API changes (ideally these should land before 18.0 release): - ) only if/when profiling is started. #23141 - [x] ~~Generate a unique session ID when profiling is started. Log it with User Timing and also store it with the main profiling data. (This will be used to match them up later.)~~ - [ ] Collect component stacks for (maybe lazily? maybe cache per Fiber in a WeakMap?) DevTools Timeline changes: - [x] Update pre-processing script to make use of the new React  DevTools data format #23185 - [x] Support optional tracing data #23185 - [x] Verify logic for aligning data shared between React  DevTools with the optional performance mark data #23185 - [x] Create UI for separate, optional import (and update the preprocessor to handle this data) #23185 Future optimizations: - [ ] Consider merging logic between `profilingHooks` and `preprocessData` to remove redundancies. If the code was moved somewhere else, then `profilingHooks` could call it during rendering and `preprocessData` could call it too (as it processed each mark) and avoid having to build up the same in-memory representations. - [ ] Double check that `internalModuleSourceToRanges` is being initialized correctly for the in-memory profiler. (Technically this doesn't matter yet, since we don't have JavaScript samples for the in memory profiler\u2013 but still.) # Motivation There are currently two React profilers: the \"legacy\" profiler (which reads data from Fibers during the commit phase) and the \"scheduling\" profiler (which reads data in the form of User Timing marks in a Chrome performance profile). This separation is confusing as both profilers live in the same extension/app but import/export different types of data. Let's take a step back and revisit how the scheduling profiler works... Recording a profile currently requires a user to do the following: 1. Click \"record\" in Chrome 2. Use the app 3. Click \"stop\" in Chrome 4. Export the profile JSON 5. Import it into the React DevTools It would be nice if DevTools could start/stop recording and import the data itself, but the only way to do this is using the Chrome DevTools Protocol which would _require_ the use of an extremely powerful permission that I don't think we would want to ask users for. This approach also has the downside of not working with React Native (or non-Chrome browsers). So why do we do it? We do it because the profile gives us a lot of nice extra data: CPU samples of the JavaScript stack, Network requests, screenshots (if enabled), user events (e.g. \"click\"). But we don't _need_ this data. The scheduling profiler could still be a useful tool even if included only the React specific marks. My proposal then is that we consider doing this: * Replace the user timing API with a direct React-to-DevTools API (where these marks are logged to DevTools directly). * When profiling starts in React DevTools, generate a unique ID string * Log this unique ID to the User Profiling API along with each commit (e.g. `\"react-sync-marker---\"`) * Allow users to export/import additional native profiling information (which can be aligned using the sync marks) _but is not required_. Doing this has a few benefits: * We could start _both_ profilers and join the commit and scheduling profiler data streams (huge benefit). * It would make the profiler easier to use in the simple case (if you didn't want/need native profiler info) since you could start/stop it from within React DevTools. * It would let us add component and call stacks without the extra serialization overhead. It would have the following downside though: * Recording profiles with native information would be a little more complicated, since you'd need to start React DevTools _and then_ start the browser profiler. (We could show instructions for doing this in the DevTools profiler though.) ## A note about component and call stacks The scheduling profiler currently shows component _names_ for things like state-updates (e.g. \"state update scheduled by Foo\") but it does not include component or call stacks. These would both be useful because: * Component stack would help identify _which instance of foo_ was e.g. scheduling the update * Call stack would show e.g. which piece of state was being updated (and by what) The reason we don't include this information is because we won't want to pay the cost of string serializing it all and logging it as a User Timing mark.",
        "human_words_stopwords_removal_lemmatization": "# # # time sensitive api change ( ideally land 18.0 release ) : - ) if/when profiling started . # 23141 - [ x ] ~~generate unique session id profiling started . log user timing also store main profiling data . ( used match later . ) ~~ - [ ] collect component stack ( maybe lazily ? maybe cache per fiber weakmap ? ) devtools timeline change : - [ x ] update pre-processing script make use new react devtools data format # 23185 - [ x ] support optional tracing data # 23185 - [ x ] verify logic aligning data shared react devtools optional performance mark data # 23185 - [ x ] create ui separate , optional import ( update preprocessor handle data ) # 23185 future optimization : - [ ] consider merging logic ` profilinghooks ` ` preprocessdata ` remove redundancy . code moved somewhere else , ` profilinghooks ` could call rendering ` preprocessdata ` could call ( processed mark ) avoid build in-memory representation . - [ ] double check ` internalmodulesourcetoranges ` initialized correctly in-memory profiler . ( technically n't matter yet , since n't javascript sample memory profiler\u2013 still . ) # motivation currently two react profilers : `` legacy '' profiler ( read data fiber commit phase ) `` scheduling '' profiler ( read data form user timing mark chrome performance profile ) . separation confusing profilers live extension/app import/export different type data . let 's take step back revisit scheduling profiler work ... recording profile currently requires user following : 1. click `` record '' chrome 2. use app 3. click `` stop '' chrome 4. export profile json 5. import react devtools would nice devtools could start/stop recording import data , way using chrome devtools protocol would _require_ use extremely powerful permission n't think would want ask user . approach also downside working react native ( non-chrome browser ) . ? profile give u lot nice extra data : cpu sample javascript stack , network request , screenshots ( enabled ) , user event ( e.g . `` click '' ) . n't _need_ data . scheduling profiler could still useful tool even included react specific mark . proposal consider : * replace user timing api direct react-to-devtools api ( mark logged devtools directly ) . * profiling start react devtools , generate unique id string * log unique id user profiling api along commit ( e.g . ` `` react-sync-marker -- - '' ` ) * allow user export/import additional native profiling information ( aligned using sync mark ) _but required_ . benefit : * could start _both_ profilers join commit scheduling profiler data stream ( huge benefit ) . * would make profiler easier use simple case ( n't want/need native profiler info ) since could start/stop within react devtools . * would let u add component call stack without extra serialization overhead . would following downside though : * recording profile native information would little complicated , since 'd need start react devtools _and then_ start browser profiler . ( could show instruction devtools profiler though . ) # # note component call stack scheduling profiler currently show component _names_ thing like state-updates ( e.g . `` state update scheduled foo '' ) include component call stack . would useful : * component stack would help identify _which instance foo_ e.g . scheduling update * call stack would show e.g . piece state updated ( ) reason n't include information wo n't want pay cost string serializing logging user timing mark .",
        "title_stopwords_removal_lemmatization": "combine profiler data source"
    },
    {
        "issue_id": 1013665541,
        "title": "Bug: Lint React Hook \"useState\" cannot be called in a class component",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2021-10-01T18:55:18Z",
        "status": "closed",
        "description": "\r\n## Steps To Reproduce\r\nEnglobe code in a static class make rule bug !\r\nActually rule detect React in class, but it not true ! \r\nThis is a pure ES6 js class with a proxi field to a React functions in scope.\r\n And is not a React Class components ! \r\n\r\n```tsx\r\ninterface PanelProps {}\r\nclass DOMAINE {\r\n\tstatic Panel : FC<PanelProps> = (props)=> {\r\n\t\tconst { children } = props;\r\n\t\tconst state = useState<unknown>(null);\r\n\t\r\n\t\tuseEffect(() => {});\r\n\t\treturn (\r\n\t\t\t<Bloc className='Panel' Flex Grow>\r\n\t\t\t\t{children}\r\n\t\t\t</Bloc>\r\n\t\t);\r\n\t};\r\n\tstatic a = class ACTIVITY {\r\n\t\tstatic Panel : VFC<PanelProps> = (props)=> {\r\n\t\t\tconst {  } = props;\r\n\t\t\tconst state = useState<unknown>(null);\r\n\t\t\r\n\t\t\tuseEffect(() => {});\r\n\t\t\treturn (\r\n\t\t\t\t<Bloc className='Panel' Flex Grow>\r\n\t\t\t\t\t\r\n\t\t\t\t</Bloc>\r\n\t\t\t);\r\n\t\t};\r\n\t}\r\n}\r\n\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/24865815/135672118-097b4751-e6bd-4922-96ed-6b6193609c2c.png)\r\n\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n```json\r\n{\r\n    \"env\": {\r\n        \"browser\": true,\r\n        \"es2021\": true,\r\n        \"node\": true\r\n    },\r\n    \"extends\": [\r\n        \"plugin:react/recommended\",\r\n        \"plugin:react-hooks/recommended\"\r\n    ],\r\n    \"parser\": \"@typescript-eslint/parser\",\r\n    \"parserOptions\": {\r\n        \"ecmaFeatures\": {\r\n            \"jsx\": true\r\n        },\r\n        \"ecmaVersion\": 12,\r\n        \"sourceType\": \"module\"\r\n    },\r\n    \"plugins\": [\r\n        \"react\",\r\n        \"@typescript-eslint\"\r\n    ],\r\n    \"rules\": {\r\n        \"array-bracket-spacing\": \"warn\",\r\n        \"multiline-comment-style\": \"warn\",\r\n        \"no-console\": \"warn\",\r\n        \"comma-dangle\": \"off\",\r\n        \"no-var\": \"warn\",\r\n        \"no-duplicate-imports\": \"error\"\r\n    }\r\n}\r\n```\r\nLink to code example: https://codesandbox.io/s/currying-https-9v064?file=/src/App.js\r\n\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\nRule think we use hooks inside a react Class ! \r\n\r\n\r\n## The expected behavior\r\nRule should not emit error about hooks for this structure\r\n",
        "remove_template_description": "Englobe code in a static class make rule bug !  Actually rule detect React in class, but it not true !   This is a pure ES6 js class with a proxi field to a React functions in scope.   And is not a React Class components !     ```tsx  interface PanelProps {}  class DOMAINE {  \tstatic Panel : FC<PanelProps> = (props)=> {  \t\tconst { children } = props;  \t\tconst state = useState<unknown>(null);  \t  \t\tuseEffect(() => {});  \t\treturn (  \t\t\t<Bloc className='Panel' Flex Grow>  \t\t\t\t{children}  \t\t\t</Bloc>  \t\t);  \t};  \tstatic a = class ACTIVITY {  \t\tstatic Panel : VFC<PanelProps> = (props)=> {  \t\t\tconst {  } = props;  \t\t\tconst state = useState<unknown>(null);  \t\t  \t\t\tuseEffect(() => {});  \t\t\treturn (  \t\t\t\t<Bloc className='Panel' Flex Grow>  \t\t\t\t\t  \t\t\t\t</Bloc>  \t\t\t);  \t\t};  \t}  }    ```    ![image](https://user-images.githubusercontent.com/24865815/135672118-097b4751-e6bd-4922-96ed-6b6193609c2c.png)      <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->  ```json  {      \"env\": {          \"browser\": true,          \"es2021\": true,          \"node\": true      },      \"extends\": [          \"plugin:react/recommended\",          \"plugin:react-hooks/recommended\"      ],      \"parser\": \"@typescript-eslint/parser\",      \"parserOptions\": {          \"ecmaFeatures\": {              \"jsx\": true          },          \"ecmaVersion\": 12,          \"sourceType\": \"module\"      },      \"plugins\": [          \"react\",          \"@typescript-eslint\"      ],      \"rules\": {          \"array-bracket-spacing\": \"warn\",          \"multiline-comment-style\": \"warn\",          \"no-console\": \"warn\",          \"comma-dangle\": \"off\",          \"no-var\": \"warn\",          \"no-duplicate-imports\": \"error\"      }  }  ```  Link to code example: https://codesandbox.io/s/currying-https-9v064?file=/src/App.js    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Rule think we use hooks inside a react Class !         Rule should not emit error about hooks for this structure",
        "human_words": "Englobe code in a static class make rule bug !  Actually rule detect React in class, but it not true !   This is a pure ES6 js class with a proxi field to a React functions in scope.   And is not a React Class components !         ![image](https://user-images.githubusercontent.com/24865815/135672118-097b4751-e6bd-4922-96ed-6b6193609c2c.png)      <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/currying-https-9v064?file=/src/App.js    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Rule think we use hooks inside a react Class !         Rule should not emit error about hooks for this structure",
        "human_words_regrex": "Englobe code in a static class make rule bug ! Actually rule detect React in class, but it not true ! This is a pure ES6 js class with a proxi field to a React functions in scope. And is not a React Class components ! !  Link to code example:   Rule think we use hooks inside a react Class ! Rule should not emit error about hooks for this structure",
        "human_words_stopwords_removal_lemmatization": "englobe code static class make rule bug ! actually rule detect react class , true ! pure es6 j class proxi field react function scope . react class component ! ! link code example : rule think use hook inside react class ! rule emit error hook structure",
        "title_stopwords_removal_lemmatization": "bug : lint react hook `` usestate '' called class component"
    },
    {
        "issue_id": 1011773677,
        "title": "Bug: Submit events from a button inside a portal don't bubble up to a form in its React DOM Ancestry.",
        "label": [
            "Component: DOM",
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2021-09-30T06:35:02Z",
        "status": "open",
        "description": "From the docs of [React Portal](https://reactjs.org/docs/portals.html#event-bubbling-through-portals)\r\n>  An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree.\r\n\r\nHowever this doesn't seem to be the case with `<form>`s when using a `<button type='submit'>` that is inside a `Portal`.\r\nClicking a submit button that is inside a portal-ed modal which is contained by the `form` does not trigger the form's `onSubmit` event. The only way to get it to do so, is to wrap the submit button in an additional `<form>` element that is inside the portal as well. When this is done, then event bubbles up to _both_ forms, and the original, outer form's `onSubmit` is triggered as desired.\r\n\r\nReact version: 16.14.0\r\n\r\n## Steps To Reproduce\r\n\r\n1. Write a simple form element that contains a React `Portal`, such as a modal. \r\n2. Inside the`Portal`, add a submit button, e.g. `<button type='submit'>submit</button>`.\r\n3. Click the submit button inside the portal.\r\n\r\n### Workaround\r\n4. Inside the `Portal`, wrap the submit button you've made in an additional `form` element.\r\n5. Click the submit button inside the portal.\r\n\r\nLink to code example: https://codesandbox.io/s/new-dust-b6hoh?file=/src/App.tsx\r\n\r\n## The current behavior\r\nClicking the button inside the portal does not result in the form being submitted.\r\nClicking the button inside the portal with an additional form element results in both forms being submitted.\r\n\r\n## The expected behavior\r\nThe form outside of the portal is submitted by the portal's submit button (without including any additional form elements).",
        "remove_template_description": "From the docs of [React Portal](https://reactjs.org/docs/portals.html#event-bubbling-through-portals)  >  An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree.    However this doesn't seem to be the case with `<form>`s when using a `<button type='submit'>` that is inside a `Portal`.  Clicking a submit button that is inside a portal-ed modal which is contained by the `form` does not trigger the form's `onSubmit` event. The only way to get it to do so, is to wrap the submit button in an additional `<form>` element that is inside the portal as well. When this is done, then event bubbles up to _both_ forms, and the original, outer form's `onSubmit` is triggered as desired.    React version: 16.14.0        1. Write a simple form element that contains a React `Portal`, such as a modal.   2. Inside the`Portal`, add a submit button, e.g. `<button type='submit'>submit</button>`.  3. Click the submit button inside the portal.    ### Workaround  4. Inside the `Portal`, wrap the submit button you've made in an additional `form` element.  5. Click the submit button inside the portal.    Link to code example: https://codesandbox.io/s/new-dust-b6hoh?file=/src/App.tsx      Clicking the button inside the portal does not result in the form being submitted.  Clicking the button inside the portal with an additional form element results in both forms being submitted.      The form outside of the portal is submitted by the portal's submit button (without including any additional form elements).",
        "human_words": "From the docs of [React Portal](https://reactjs.org/docs/portals.html#event-bubbling-through-portals)  >  An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree.    However this doesn't seem to be the case with `<form>`s when using a `<button type='submit'>` that is inside a `Portal`.  Clicking a submit button that is inside a portal-ed modal which is contained by the `form` does not trigger the form's `onSubmit` event. The only way to get it to do so, is to wrap the submit button in an additional `<form>` element that is inside the portal as well. When this is done, then event bubbles up to _both_ forms, and the original, outer form's `onSubmit` is triggered as desired.    React version: 16.14.0        1. Write a simple form element that contains a React `Portal`, such as a modal.   2. Inside the`Portal`, add a submit button, e.g. `<button type='submit'>submit</button>`.  3. Click the submit button inside the portal.    ### Workaround  4. Inside the `Portal`, wrap the submit button you've made in an additional `form` element.  5. Click the submit button inside the portal.    Link to code example: https://codesandbox.io/s/new-dust-b6hoh?file=/src/App.tsx      Clicking the button inside the portal does not result in the form being submitted.  Clicking the button inside the portal with an additional form element results in both forms being submitted.      The form outside of the portal is submitted by the portal's submit button (without including any additional form elements).",
        "human_words_regrex": "From the docs of  > An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree. However this doesn't seem to be the case with ``s when using a `` that is inside a `Portal`. Clicking a submit button that is inside a portal-ed modal which is contained by the `form` does not trigger the form's `onSubmit` event. The only way to get it to do so, is to wrap the submit button in an additional `` element that is inside the portal as well. When this is done, then event bubbles up to _both_ forms, and the original, outer form's `onSubmit` is triggered as desired. React version: 16.14.0 1. Write a simple form element that contains a React `Portal`, such as a modal. 2. Inside the`Portal`, add a submit button, e.g. `submit`. 3. Click the submit button inside the portal. ### Workaround 4. Inside the `Portal`, wrap the submit button you've made in an additional `form` element. 5. Click the submit button inside the portal. Link to code example:  Clicking the button inside the portal does not result in the form being submitted. Clicking the button inside the portal with an additional form element results in both forms being submitted. The form outside of the portal is submitted by the portal's submit button (without including any additional form elements).",
        "human_words_stopwords_removal_lemmatization": "doc > event fired inside portal propagate ancestor containing react tree , even element ancestor dom tree . however n't seem case `` using `` inside ` portal ` . clicking submit button inside portal-ed modal contained ` form ` trigger form 's ` onsubmit ` event . way get , wrap submit button additional `` element inside portal well . done , event bubble _both_ form , original , outer form 's ` onsubmit ` triggered desired . react version : 16.14.0 1. write simple form element contains react ` portal ` , modal . 2. inside ` portal ` , add submit button , e.g . ` submit ` . 3. click submit button inside portal . # # # workaround 4. inside ` portal ` , wrap submit button 've made additional ` form ` element . 5. click submit button inside portal . link code example : clicking button inside portal result form submitted . clicking button inside portal additional form element result form submitted . form outside portal submitted portal 's submit button ( without including additional form element ) .",
        "title_stopwords_removal_lemmatization": "bug : submit event button inside portal n't bubble form react dom ancestry ."
    },
    {
        "issue_id": 1010184852,
        "title": "[Proposal] useState Get Callback",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-28T20:36:39Z",
        "status": "closed",
        "description": "Hi React Community, reading the features related to useState and batching, im finding problems where the state is not updated or when i have memoised a method using `useCallback`\r\n\r\ni would like to suggest about add a method to get the state in useState, an example for this approach can be this\r\n\r\n```\r\nconst useGetState = (initialValue, withGetCallback = false) => {\r\n  const [state, setState] = useState(initialValue);\r\n  if (!withGetCallback) {\r\n    return [state, setState];\r\n  }\r\n\r\n  const stateRef = useRef(state);\r\n  useEffect(() => {\r\n    stateRef.current = state;\r\n  }, [state]);\r\n\r\n  const getState = useCallback(() => {\r\n    return stateRef.current;\r\n  }, [stateRef]);\r\n\r\n  return [state, setState, getState, stateRef];\r\n};\r\n```\r\n\r\nan implementation could looks like this\r\n```\r\n    const [state, setState, getState] = useGetState(null, true);\r\n    // back compatibility\r\n    const [state, setState] = useGetState(null);  // (exactly same as normal useState)\r\n    // complex scenario\r\n    const [state, setState, getState, stateRef] = useGetState(null, true);\r\n    \r\n```\r\nusing useRef we can be able to get the instance of the value in any moment and in any place due that these callbacks never changes during the execution\r\n\r\n",
        "remove_template_description": "Hi React Community, reading the features related to useState and batching, im finding problems where the state is not updated or when i have memoised a method using `useCallback`    i would like to suggest about add a method to get the state in useState, an example for this approach can be this    ```  const useGetState = (initialValue, withGetCallback = false) => {    const [state, setState] = useState(initialValue);    if (!withGetCallback) {      return [state, setState];    }      const stateRef = useRef(state);    useEffect(() => {      stateRef.current = state;    }, [state]);      const getState = useCallback(() => {      return stateRef.current;    }, [stateRef]);      return [state, setState, getState, stateRef];  };  ```    an implementation could looks like this  ```      const [state, setState, getState] = useGetState(null, true);      // back compatibility      const [state, setState] = useGetState(null);  // (exactly same as normal useState)      // complex scenario      const [state, setState, getState, stateRef] = useGetState(null, true);        ```  using useRef we can be able to get the instance of the value in any moment and in any place due that these callbacks never changes during the execution",
        "human_words": "Hi React Community, reading the features related to useState and batching, im finding problems where the state is not updated or when i have memoised a method using `useCallback`    i would like to suggest about add a method to get the state in useState, an example for this approach can be this        an implementation could looks like this    using useRef we can be able to get the instance of the value in any moment and in any place due that these callbacks never changes during the execution",
        "human_words_regrex": "Hi React Community, reading the features related to useState and batching, im finding problems where the state is not updated or when i have memoised a method using `useCallback` i would like to suggest about add a method to get the state in useState, an example for this approach can be this an implementation could looks like this using useRef we can be able to get the instance of the value in any moment and in any place due that these callbacks never changes during the execution",
        "human_words_stopwords_removal_lemmatization": "hi react community , reading feature related usestate batching , im finding problem state updated memoised method using ` usecallback ` would like suggest add method get state usestate , example approach implementation could look like using useref able get instance value moment place due callback never change execution",
        "title_stopwords_removal_lemmatization": "[ proposal ] usestate get callback"
    },
    {
        "issue_id": 1008451736,
        "title": "Several tests fail on main with Node v16",
        "label": [
            "Component: Build Infrastructure",
            "Type: Discussion"
        ],
        "date": "2021-09-27T18:16:22Z",
        "status": "closed",
        "description": "I forked and cloned the repo this morning (at c88fb49d37fd01024e0a254a37b7810d107bdd1d), ran `yarn` and `yarn test`, and several tests failed.\r\n\r\nReact version: main (c88fb49d37fd01024e0a254a37b7810d107bdd1d)\r\n\r\n## Steps To Reproduce\r\n\r\n1. Clone repo\r\n2. `yarn` and `yarn test`\r\n\r\nI was on the latest NodeJS version (16.10.0). Note that tests pass for me when switching to the 14.x LTS release of Node.\r\n\r\n## The current behavior\r\n\r\n13 tests fail across 5 suites. Output at https://gist.github.com/josephsavona/91a3d48add8a1c47c71178522583281b\r\n\r\n## The expected behavior\r\n\r\nAll tests pass",
        "remove_template_description": "I forked and cloned the repo this morning (at c88fb49d37fd01024e0a254a37b7810d107bdd1d), ran `yarn` and `yarn test`, and several tests failed.    React version: main (c88fb49d37fd01024e0a254a37b7810d107bdd1d)        1. Clone repo  2. `yarn` and `yarn test`    I was on the latest NodeJS version (16.10.0). Note that tests pass for me when switching to the 14.x LTS release of Node.        13 tests fail across 5 suites. Output at https://gist.github.com/josephsavona/91a3d48add8a1c47c71178522583281b        All tests pass",
        "human_words": "I forked and cloned the repo this morning (at c88fb49d37fd01024e0a254a37b7810d107bdd1d), ran `yarn` and `yarn test`, and several tests failed.    React version: main (c88fb49d37fd01024e0a254a37b7810d107bdd1d)        1. Clone repo  2. `yarn` and `yarn test`    I was on the latest NodeJS version (16.10.0). Note that tests pass for me when switching to the 14.x LTS release of Node.        13 tests fail across 5 suites. Output at https://gist.github.com/josephsavona/91a3d48add8a1c47c71178522583281b        All tests pass",
        "human_words_regrex": "I forked and cloned the repo this morning (at c88fb49d37fd01024e0a254a37b7810d107bdd1d), ran `yarn` and `yarn test`, and several tests failed. React version: main (c88fb49d37fd01024e0a254a37b7810d107bdd1d) 1. Clone repo 2. `yarn` and `yarn test` I was on the latest NodeJS version (16.10.0). Note that tests pass for me when switching to the 14.x LTS release of Node. 13 tests fail across 5 suites. Output at  All tests pass",
        "human_words_stopwords_removal_lemmatization": "forked cloned repo morning ( c88fb49d37fd01024e0a254a37b7810d107bdd1d ) , ran ` yarn ` ` yarn test ` , several test failed . react version : main ( c88fb49d37fd01024e0a254a37b7810d107bdd1d ) 1. clone repo 2 . ` yarn ` ` yarn test ` latest nodejs version ( 16.10.0 ) . note test pas switching 14.x lts release node . 13 test fail across 5 suite . output test pas",
        "title_stopwords_removal_lemmatization": "several test fail main node v16"
    },
    {
        "issue_id": 1007897817,
        "title": "(continued) Warning when input elements don't reference onChange - does React like event bubbling?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-09-27T09:11:53Z",
        "status": "open",
        "description": "Continuation of the following issue:\r\n\r\n[**Inaccurate warning when value props is set without onChange.**\r\n](https://github.com/facebook/react/issues/1118)\r\n\r\nWhere a clear example in a new issue was [requested](https://github.com/facebook/react/issues/1118#issuecomment-333411651).\r\n\r\nSince it has gathered some popular comments since then, here is a new issue.\r\n\r\nIt is fully appreciated that this may be an annoying edge case that already has a workaround, but it still seems to crop up quite often in forums, Stackoverflow and while teaching React.\r\n\r\n### Issue\r\n\r\nIf someone wanted to structure their app making use of event bubbling, and as such, only requiring assigning one event handler to a parent element.\r\n\r\n```jsx\r\nfunction App() {\r\n  const [state, setState] = useState(\"test\")\r\n  return (\r\n    <div onChange={(e) => setState(e.target.value)}>\r\n      <input value={state} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\nThey will get a warning that the input element doesn't have an `onChange` handler.\r\n\r\nhttps://codesandbox.io/s/onchange-warning-wzswb?file=/src/App.js\r\n\r\nThe warning can be suppressed by adding a blank function to the input element:\r\n\r\n```\r\n<input value={state} onChange={()=>{}}/>\r\n```\r\n\r\nOf course, in this example the same function used on the parent div can be applied to the input element, but if there were many input elements that could be handled by the same event handler, it means that you need to reference the event handler in all of the input elements.\r\n\r\n```\r\n<input onChange={changeHandler}/>\r\n<input onChange={changeHandler}/>\r\n<input onChange={changeHandler}/>\r\n```\r\n\r\nOr if you wanted to use event bubbling with only one reference to the handler, to suppress the warnings you can:\r\n\r\n```\r\n<input onChange={()=>{}}/>\r\n<input onChange={()=>{}}/>\r\n<input onChange={()=>{}}/>\r\n```\r\n\r\n### TLDR of discussion in original issue\r\n\r\nThe main point of contention is the warning that pollutes the console. You can refactor to reference the `onChange` handler in all the input elements as is shown in the docs but that gets tedious and repetitive for large forms.  Having to attach an empty function to suppress warnings is a workaround but is also tedious and repetitive.\r\n\r\nThe warning may be good for people learning how to think in React but the fact that it is sometimes inaccurate is problematic. That is, its not clear whether using event bubbling goes against best practice or not. The warning just says that there is no `onChange` handler which is not always true. Using event bubbling to send information back up the tree seems to go against the idea of using React state to do that job. In either case, both ways work and can be done within React, however, relying on event bubbling causes the warning on the console.\r\n\r\nIs using event bubbling against the React way? Or is React just agnostic towards it?\r\n\r\nAssuming its not against it, for complex forms that take advantage of event bubbling, the error pollutes the console and a way to silence this specific error (or perhaps specific errors in general) without having to flag every single input would be appreciated.\r\n\r\n### Potential solutions proposed\r\n\r\n- Disable this warning completely.\r\n- Implement a way to disable this particular warning.\r\n- Make a \"beginner\" category of warnings that can be disabled.\r\n- Make it so that event bubbling in this way is just not allowed (please no).\r\n- Document the event bubbling approach and make it clear that using this way will generate warnings because its against the React way.\r\n- Change the warning text to make clear that there may be an `onChange` handler further up the tree that it is not detecting, and/or that handlers should always be referenced by each input.",
        "remove_template_description": "Continuation of the following issue:    [**Inaccurate warning when value props is set without onChange.**  ](https://github.com/facebook/react/issues/1118)    Where a clear example in a new issue was [requested](https://github.com/facebook/react/issues/1118#issuecomment-333411651).    Since it has gathered some popular comments since then, here is a new issue.    It is fully appreciated that this may be an annoying edge case that already has a workaround, but it still seems to crop up quite often in forums, Stackoverflow and while teaching React.    ### Issue    If someone wanted to structure their app making use of event bubbling, and as such, only requiring assigning one event handler to a parent element.    ```jsx  function App() {    const [state, setState] = useState(\"test\")    return (      <div onChange={(e) => setState(e.target.value)}>        <input value={state} />      </div>    );  }  ```    They will get a warning that the input element doesn't have an `onChange` handler.    https://codesandbox.io/s/onchange-warning-wzswb?file=/src/App.js    The warning can be suppressed by adding a blank function to the input element:    ```  <input value={state} onChange={()=>{}}/>  ```    Of course, in this example the same function used on the parent div can be applied to the input element, but if there were many input elements that could be handled by the same event handler, it means that you need to reference the event handler in all of the input elements.    ```  <input onChange={changeHandler}/>  <input onChange={changeHandler}/>  <input onChange={changeHandler}/>  ```    Or if you wanted to use event bubbling with only one reference to the handler, to suppress the warnings you can:    ```  <input onChange={()=>{}}/>  <input onChange={()=>{}}/>  <input onChange={()=>{}}/>  ```    ### TLDR of discussion in original issue    The main point of contention is the warning that pollutes the console. You can refactor to reference the `onChange` handler in all the input elements as is shown in the docs but that gets tedious and repetitive for large forms.  Having to attach an empty function to suppress warnings is a workaround but is also tedious and repetitive.    The warning may be good for people learning how to think in React but the fact that it is sometimes inaccurate is problematic. That is, its not clear whether using event bubbling goes against best practice or not. The warning just says that there is no `onChange` handler which is not always true. Using event bubbling to send information back up the tree seems to go against the idea of using React state to do that job. In either case, both ways work and can be done within React, however, relying on event bubbling causes the warning on the console.    Is using event bubbling against the React way? Or is React just agnostic towards it?    Assuming its not against it, for complex forms that take advantage of event bubbling, the error pollutes the console and a way to silence this specific error (or perhaps specific errors in general) without having to flag every single input would be appreciated.    ### Potential solutions proposed    - Disable this warning completely.  - Implement a way to disable this particular warning.  - Make a \"beginner\" category of warnings that can be disabled.  - Make it so that event bubbling in this way is just not allowed (please no).  - Document the event bubbling approach and make it clear that using this way will generate warnings because its against the React way.  - Change the warning text to make clear that there may be an `onChange` handler further up the tree that it is not detecting, and/or that handlers should always be referenced by each input.",
        "human_words": "Continuation of the following issue:    [**Inaccurate warning when value props is set without onChange.**  ](https://github.com/facebook/react/issues/1118)    Where a clear example in a new issue was [requested](https://github.com/facebook/react/issues/1118#issuecomment-333411651).    Since it has gathered some popular comments since then, here is a new issue.    It is fully appreciated that this may be an annoying edge case that already has a workaround, but it still seems to crop up quite often in forums, Stackoverflow and while teaching React.    ### Issue    If someone wanted to structure their app making use of event bubbling, and as such, only requiring assigning one event handler to a parent element.        They will get a warning that the input element doesn't have an `onChange` handler.    https://codesandbox.io/s/onchange-warning-wzswb?file=/src/App.js    The warning can be suppressed by adding a blank function to the input element:        Of course, in this example the same function used on the parent div can be applied to the input element, but if there were many input elements that could be handled by the same event handler, it means that you need to reference the event handler in all of the input elements.        Or if you wanted to use event bubbling with only one reference to the handler, to suppress the warnings you can:        ### TLDR of discussion in original issue    The main point of contention is the warning that pollutes the console. You can refactor to reference the `onChange` handler in all the input elements as is shown in the docs but that gets tedious and repetitive for large forms.  Having to attach an empty function to suppress warnings is a workaround but is also tedious and repetitive.    The warning may be good for people learning how to think in React but the fact that it is sometimes inaccurate is problematic. That is, its not clear whether using event bubbling goes against best practice or not. The warning just says that there is no `onChange` handler which is not always true. Using event bubbling to send information back up the tree seems to go against the idea of using React state to do that job. In either case, both ways work and can be done within React, however, relying on event bubbling causes the warning on the console.    Is using event bubbling against the React way? Or is React just agnostic towards it?    Assuming its not against it, for complex forms that take advantage of event bubbling, the error pollutes the console and a way to silence this specific error (or perhaps specific errors in general) without having to flag every single input would be appreciated.    ### Potential solutions proposed    - Disable this warning completely.  - Implement a way to disable this particular warning.  - Make a \"beginner\" category of warnings that can be disabled.  - Make it so that event bubbling in this way is just not allowed (please no).  - Document the event bubbling approach and make it clear that using this way will generate warnings because its against the React way.  - Change the warning text to make clear that there may be an `onChange` handler further up the tree that it is not detecting, and/or that handlers should always be referenced by each input.",
        "human_words_regrex": "Continuation of the following issue:  Where a clear example in a new issue was . Since it has gathered some popular comments since then, here is a new issue. It is fully appreciated that this may be an annoying edge case that already has a workaround, but it still seems to crop up quite often in forums, Stackoverflow and while teaching React. ### Issue If someone wanted to structure their app making use of event bubbling, and as such, only requiring assigning one event handler to a parent element. They will get a warning that the input element doesn't have an `onChange` handler.  The warning can be suppressed by adding a blank function to the input element: Of course, in this example the same function used on the parent div can be applied to the input element, but if there were many input elements that could be handled by the same event handler, it means that you need to reference the event handler in all of the input elements. Or if you wanted to use event bubbling with only one reference to the handler, to suppress the warnings you can: ### TLDR of discussion in original issue The main point of contention is the warning that pollutes the console. You can refactor to reference the `onChange` handler in all the input elements as is shown in the docs but that gets tedious and repetitive for large forms. Having to attach an empty function to suppress warnings is a workaround but is also tedious and repetitive. The warning may be good for people learning how to think in React but the fact that it is sometimes inaccurate is problematic. That is, its not clear whether using event bubbling goes against best practice or not. The warning just says that there is no `onChange` handler which is not always true. Using event bubbling to send information back up the tree seems to go against the idea of using React state to do that job. In either case, both ways work and can be done within React, however, relying on event bubbling causes the warning on the console. Is using event bubbling against the React way? Or is React just agnostic towards it? Assuming its not against it, for complex forms that take advantage of event bubbling, the error pollutes the console and a way to silence this specific error (or perhaps specific errors in general) without having to flag every single input would be appreciated. ### Potential solutions proposed - Disable this warning completely. - Implement a way to disable this particular warning. - Make a \"beginner\" category of warnings that can be disabled. - Make it so that event bubbling in this way is just not allowed (please no). - Document the event bubbling approach and make it clear that using this way will generate warnings because its against the React way. - Change the warning text to make clear that there may be an `onChange` handler further up the tree that it is not detecting, and/or that handlers should always be referenced by each input.",
        "human_words_stopwords_removal_lemmatization": "continuation following issue : clear example new issue . since gathered popular comment since , new issue . fully appreciated may annoying edge case already workaround , still seems crop quite often forum , stackoverflow teaching react . # # # issue someone wanted structure app making use event bubbling , , requiring assigning one event handler parent element . get warning input element n't ` onchange ` handler . warning suppressed adding blank function input element : course , example function used parent div applied input element , many input element could handled event handler , mean need reference event handler input element . wanted use event bubbling one reference handler , suppress warning : # # # tldr discussion original issue main point contention warning pollutes console . refactor reference ` onchange ` handler input element shown doc get tedious repetitive large form . attach empty function suppress warning workaround also tedious repetitive . warning may good people learning think react fact sometimes inaccurate problematic . , clear whether using event bubbling go best practice . warning say ` onchange ` handler always true . using event bubbling send information back tree seems go idea using react state job . either case , way work done within react , however , relying event bubbling cause warning console . using event bubbling react way ? react agnostic towards ? assuming , complex form take advantage event bubbling , error pollutes console way silence specific error ( perhaps specific error general ) without flag every single input would appreciated . # # # potential solution proposed - disable warning completely . - implement way disable particular warning . - make `` beginner '' category warning disabled . - make event bubbling way allowed ( please ) . - document event bubbling approach make clear using way generate warning react way . - change warning text make clear may ` onchange ` handler tree detecting , and/or handler always referenced input .",
        "title_stopwords_removal_lemmatization": "( continued ) warning input element n't reference onchange - react like event bubbling ?"
    },
    {
        "issue_id": 1007626395,
        "title": "React 18  lets React.memo save displayName?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-27T02:48:14Z",
        "status": "closed",
        "description": "Now\r\n\r\n```js\r\nconst User = React.memo(function User (){\r\n  return null\r\n})\r\n\r\nUser.displayName // undefined\r\n```\r\n\r\n\r\nNeed\r\n\r\n```js\r\nconst User = React.memo(function User (){\r\n  return null\r\n})\r\n\r\nUser.displayName // User\r\n```\r\n",
        "remove_template_description": "Now    ```js  const User = React.memo(function User (){    return null  })    User.displayName // undefined  ```      Need    ```js  const User = React.memo(function User (){    return null  })    User.displayName // User  ```",
        "human_words": "Now          Need    ",
        "human_words_regrex": "Now Need ",
        "human_words_stopwords_removal_lemmatization": "need",
        "title_stopwords_removal_lemmatization": "react 18 let react.memo save displayname ?"
    },
    {
        "issue_id": 1007096209,
        "title": "React 18 and headers changing during streaming",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-25T14:09:31Z",
        "status": "closed",
        "description": "Hi! My question is about React 18 and SSR with pipeToNodeWritable.\r\n\r\nWe have a great demo from @gaearon https://codesandbox.io/s/9hfqt with all new features with SSR. So, let's imagine, I want to set up cookie on the server side. In our example we need to have an isomorphic cookie implementation. On the client side we will use document.cookie and on the server side we will write our cookie to the specific header.\r\n\r\nAnd there is a problem. Let's try to write a cookie to the response object from express somewhere in a render, in any component. I know, looks like a bad idea, but it's just for an example. \r\n\r\nSo, If we will use pipeToNodeWritable, we will have an error, that we can not change Headers, cause they are already sent. Actually it looks like a problem with a correct HTTP-code, if something errored before we started streaming. But what should I do, if I need to change the response during streaming?\r\n\r\nMay be you have some ideas, how to fix this? Of course I know, I can use `onCompleteAll` instead of `onReadyToStream`, but I'll miss all new features like selective rehydration in that case.",
        "remove_template_description": "Hi! My question is about React 18 and SSR with pipeToNodeWritable.    We have a great demo from @gaearon https://codesandbox.io/s/9hfqt with all new features with SSR. So, let's imagine, I want to set up cookie on the server side. In our example we need to have an isomorphic cookie implementation. On the client side we will use document.cookie and on the server side we will write our cookie to the specific header.    And there is a problem. Let's try to write a cookie to the response object from express somewhere in a render, in any component. I know, looks like a bad idea, but it's just for an example.     So, If we will use pipeToNodeWritable, we will have an error, that we can not change Headers, cause they are already sent. Actually it looks like a problem with a correct HTTP-code, if something errored before we started streaming. But what should I do, if I need to change the response during streaming?    May be you have some ideas, how to fix this? Of course I know, I can use `onCompleteAll` instead of `onReadyToStream`, but I'll miss all new features like selective rehydration in that case.",
        "human_words": "Hi! My question is about React 18 and SSR with pipeToNodeWritable.    We have a great demo from @gaearon https://codesandbox.io/s/9hfqt with all new features with SSR. So, let's imagine, I want to set up cookie on the server side. In our example we need to have an isomorphic cookie implementation. On the client side we will use document.cookie and on the server side we will write our cookie to the specific header.    And there is a problem. Let's try to write a cookie to the response object from express somewhere in a render, in any component. I know, looks like a bad idea, but it's just for an example.     So, If we will use pipeToNodeWritable, we will have an error, that we can not change Headers, cause they are already sent. Actually it looks like a problem with a correct HTTP-code, if something errored before we started streaming. But what should I do, if I need to change the response during streaming?    May be you have some ideas, how to fix this? Of course I know, I can use `onCompleteAll` instead of `onReadyToStream`, but I'll miss all new features like selective rehydration in that case.",
        "human_words_regrex": "Hi! My question is about React 18 and SSR with pipeToNodeWritable. We have a great demo from @gaearon  with all new features with SSR. So, let's imagine, I want to set up cookie on the server side. In our example we need to have an isomorphic cookie implementation. On the client side we will use document.cookie and on the server side we will write our cookie to the specific header. And there is a problem. Let's try to write a cookie to the response object from express somewhere in a render, in any component. I know, looks like a bad idea, but it's just for an example. So, If we will use pipeToNodeWritable, we will have an error, that we can not change Headers, cause they are already sent. Actually it looks like a problem with a correct HTTP-code, if something errored before we started streaming. But what should I do, if I need to change the response during streaming? May be you have some ideas, how to fix this? Of course I know, I can use `onCompleteAll` instead of `onReadyToStream`, but I'll miss all new features like selective rehydration in that case.",
        "human_words_stopwords_removal_lemmatization": "hi ! question react 18 ssr pipetonodewritable . great demo @ gaearon new feature ssr . , let 's imagine , want set cookie server side . example need isomorphic cookie implementation . client side use document.cookie server side write cookie specific header . problem . let 's try write cookie response object express somewhere render , component . know , look like bad idea , 's example . , use pipetonodewritable , error , change header , cause already sent . actually look like problem correct http-code , something errored started streaming . , need change response streaming ? may idea , fix ? course know , use ` oncompleteall ` instead ` onreadytostream ` , 'll miss new feature like selective rehydration case .",
        "title_stopwords_removal_lemmatization": "react 18 header changing streaming"
    },
    {
        "issue_id": 1005217169,
        "title": "React 18  context",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-23T09:39:10Z",
        "status": "closed",
        "description": "\r\n Hi why context documentation are still explained as class items and no functionnal component ?\r\n in the future that will be removed or something like that? \r\n Thank for answer have good day \r\n\r\n",
        "remove_template_description": "Hi why context documentation are still explained as class items and no functionnal component ?   in the future that will be removed or something like that?    Thank for answer have good day",
        "human_words": "Hi why context documentation are still explained as class items and no functionnal component ?   in the future that will be removed or something like that?    Thank for answer have good day",
        "human_words_regrex": "Hi why context documentation are still explained as class items and no functionnal component ? in the future that will be removed or something like that? Thank for answer have good day",
        "human_words_stopwords_removal_lemmatization": "hi context documentation still explained class item functionnal component ? future removed something like ? thank answer good day",
        "title_stopwords_removal_lemmatization": "react 18 context"
    },
    {
        "issue_id": 1000707325,
        "title": "React 18: hydration mismatch when an external store is updated in an effect",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-20T08:35:04Z",
        "status": "closed",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version: https://github.com/facebook/react/pull/22347\r\n\r\n## Steps To Reproduce\r\n\r\n1. Read store (using `useSyncExternalStore`) inside a Suspense boundary where no component suspended\r\n2. Read store (using `useSyncExternalStore`) outside of any Suspense boundary\r\n3. Update store outside of any Suspense boundary in an effect (`useEffect`)\r\n\r\n\r\n```js\r\n<Store>\r\n  <Suspense fallback={null}>\r\n    <Demo>inside suspense has hydration mismatch</Demo>\r\n    {/* When the fallback is actually used on the server, we don't get a hydration mismatch */}\r\n    {/* <Suspender /> */}\r\n  </Suspense>\r\n  <Demo>outside suspense has no hydration mismatch</Demo>\r\n  <UpdatesStore />\r\n</Store>\r\n);\r\n```\r\n\r\nLink to code example: https://codesandbox.io/s/react-18-updating-store-in-an-effect-during-mount-causes-hydration-mismatch-uses-m6lwm?file=/src/index.js\r\n\r\n\r\n## The current behavior\r\n\r\n`<Demo />` inside the Suspense boundary causes a hydration mismatch since it's hydrated with the value set during `useEffect`.\r\n\r\n## The expected behavior\r\n\r\nNo hydration mismatch.\r\n\r\n## Repro explainer\r\n\r\nThe repro is based on https://github.com/reduxjs/react-redux/issues/1794 which is based on a usage from the mui.com docs. \r\nThe behavior this repro is implementing is reading a value from `window.localStorage` (e.g. settings) with a fallback on the server. \r\n\r\nThe `store` is a Redux store that is the same on Server and Client.\r\nReading from the `store` is implemented like so:\r\n```js\r\nconst ReduxStoreContext = createContext();\r\n\r\nfunction useValueRedux() {\r\n  const store = useContext(ReduxStoreContext);\r\n  const selector = useCallback(() => store.getState().codeVariant, [store]);\r\n\r\n  // The store is equivalent on Client and Server so we can just re-use `getSnapshot` for `getServerSnapshot`\r\n  return useSyncExternalStore(store.subscribe, selector, selector);\r\n}\r\n```\r\nThe repro contains an implementation that uses React Context for the store which works as expected i.e. no hydration mismatches.\r\n\r\n## Context\r\n\r\nI recently stumbled over\r\n\r\n> (In general, updates inside a passive effect are not encouraged.)\r\n\r\n-- https://github.com/facebook/react/pull/22277\r\n\r\nwhich makes it sound like this behavior is expected because the update is inside a passive effect. Though it's unclear what is meant by \"not encourage\". How would I render a default value on the Server and populate it with the actually desired value on the Client?\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: https://github.com/facebook/react/pull/22347        1. Read store (using `useSyncExternalStore`) inside a Suspense boundary where no component suspended  2. Read store (using `useSyncExternalStore`) outside of any Suspense boundary  3. Update store outside of any Suspense boundary in an effect (`useEffect`)      ```js  <Store>    <Suspense fallback={null}>      <Demo>inside suspense has hydration mismatch</Demo>      {/* When the fallback is actually used on the server, we don't get a hydration mismatch */}      {/* <Suspender /> */}    </Suspense>    <Demo>outside suspense has no hydration mismatch</Demo>    <UpdatesStore />  </Store>  );  ```    Link to code example: https://codesandbox.io/s/react-18-updating-store-in-an-effect-during-mount-causes-hydration-mismatch-uses-m6lwm?file=/src/index.js          `<Demo />` inside the Suspense boundary causes a hydration mismatch since it's hydrated with the value set during `useEffect`.        No hydration mismatch.    ## Repro explainer    The repro is based on https://github.com/reduxjs/react-redux/issues/1794 which is based on a usage from the mui.com docs.   The behavior this repro is implementing is reading a value from `window.localStorage` (e.g. settings) with a fallback on the server.     The `store` is a Redux store that is the same on Server and Client.  Reading from the `store` is implemented like so:  ```js  const ReduxStoreContext = createContext();    function useValueRedux() {    const store = useContext(ReduxStoreContext);    const selector = useCallback(() => store.getState().codeVariant, [store]);      // The store is equivalent on Client and Server so we can just re-use `getSnapshot` for `getServerSnapshot`    return useSyncExternalStore(store.subscribe, selector, selector);  }  ```  The repro contains an implementation that uses React Context for the store which works as expected i.e. no hydration mismatches.    ## Context    I recently stumbled over    > (In general, updates inside a passive effect are not encouraged.)    -- https://github.com/facebook/react/pull/22277    which makes it sound like this behavior is expected because the update is inside a passive effect. Though it's unclear what is meant by \"not encourage\". How would I render a default value on the Server and populate it with the actually desired value on the Client?",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: https://github.com/facebook/react/pull/22347        1. Read store (using `useSyncExternalStore`) inside a Suspense boundary where no component suspended  2. Read store (using `useSyncExternalStore`) outside of any Suspense boundary  3. Update store outside of any Suspense boundary in an effect (`useEffect`)          Link to code example: https://codesandbox.io/s/react-18-updating-store-in-an-effect-during-mount-causes-hydration-mismatch-uses-m6lwm?file=/src/index.js          `<Demo />` inside the Suspense boundary causes a hydration mismatch since it's hydrated with the value set during `useEffect`.        No hydration mismatch.    ## Repro explainer    The repro is based on https://github.com/reduxjs/react-redux/issues/1794 which is based on a usage from the mui.com docs.   The behavior this repro is implementing is reading a value from `window.localStorage` (e.g. settings) with a fallback on the server.     The `store` is a Redux store that is the same on Server and Client.  Reading from the `store` is implemented like so:    The repro contains an implementation that uses React Context for the store which works as expected i.e. no hydration mismatches.    ## Context    I recently stumbled over    > (In general, updates inside a passive effect are not encouraged.)    -- https://github.com/facebook/react/pull/22277    which makes it sound like this behavior is expected because the update is inside a passive effect. Though it's unclear what is meant by \"not encourage\". How would I render a default value on the Server and populate it with the actually desired value on the Client?",
        "human_words_regrex": " React version:  1. Read store (using `useSyncExternalStore`) inside a Suspense boundary where no component suspended 2. Read store (using `useSyncExternalStore`) outside of any Suspense boundary 3. Update store outside of any Suspense boundary in an effect (`useEffect`) Link to code example:  `` inside the Suspense boundary causes a hydration mismatch since it's hydrated with the value set during `useEffect`. No hydration mismatch. ## Repro explainer The repro is based on  which is based on a usage from the mui.com docs. The behavior this repro is implementing is reading a value from `window.localStorage` (e.g. settings) with a fallback on the server. The `store` is a Redux store that is the same on Server and Client. Reading from the `store` is implemented like so: The repro contains an implementation that uses React Context for the store which works as expected i.e. no hydration mismatches. ## Context I recently stumbled over > (In general, updates inside a passive effect are not encouraged.) --  which makes it sound like this behavior is expected because the update is inside a passive effect. Though it's unclear what is meant by \"not encourage\". How would I render a default value on the Server and populate it with the actually desired value on the Client?",
        "human_words_stopwords_removal_lemmatization": "react version : 1. read store ( using ` usesyncexternalstore ` ) inside suspense boundary component suspended 2. read store ( using ` usesyncexternalstore ` ) outside suspense boundary 3. update store outside suspense boundary effect ( ` useeffect ` ) link code example : `` inside suspense boundary cause hydration mismatch since 's hydrated value set ` useeffect ` . hydration mismatch . # # repro explainer repro based based usage mui.com doc . behavior repro implementing reading value ` window.localstorage ` ( e.g . setting ) fallback server . ` store ` redux store server client . reading ` store ` implemented like : repro contains implementation us react context store work expected i.e . hydration mismatch . # # context recently stumbled > ( general , update inside passive effect encouraged . ) -- make sound like behavior expected update inside passive effect . though 's unclear meant `` encourage '' . would render default value server populate actually desired value client ?",
        "title_stopwords_removal_lemmatization": "react 18 : hydration mismatch external store updated effect"
    },
    {
        "issue_id": 996257209,
        "title": "Bug: Native Component Stacks don't respect function \"displayName\" in Firefox",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2021-09-14T17:24:45Z",
        "status": "open",
        "description": "**Edit** See this comment for the key part of what's being reported/discussed on this issue: https://github.com/facebook/react/issues/22315#issuecomment-920061727\r\n\r\n# Original bug report below\r\n\r\nAs of #18561 component stacks are generated from native stack frames. This is problematic with HOCs that inherit from the input component in order to change its behavior. The somewhat popular @risingstack/react-easy-state package is one example of such a component. While it does assign a `displayName`, the new Native Component Stacks appear to ignore this. Instead, components wrapped in `view()` (from react-easy-state) are always shown with the name of the wrapper class, i.e., `ReactiveComp` or `ReactiveClassComp`.\r\n\r\nThis is especially catastrophic in the case of react-easy-state, where one is supposed to wrap essentially *all components in the entire codebase* in the `view()` HOC. The result is that component stacks become unusable for debugging.\r\n\r\nIs there perhaps a way to work around this (e.g. disable native component stacks, or some new way to explicitly provide a component name like `displayName`)?\r\n\r\n<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version: 17.0.1\r\n\r\n## Steps To Reproduce\r\n\r\n1. Apply a HOC that uses inheritance (i.e., inherits from the component instead of wrapping it in JSX) to a component.\r\n2. The component will always be named `ReactiveComp` or `ReactiveClassComp` in component stack traces.\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example: https://codesandbox.io/s/rough-tdd-wqepe?file=/src/App.tsx\r\n\r\n## The current behavior\r\n\r\n```\r\nSomething went wrong.\r\nError: sorry\r\n\r\nBadGuy@https://7ww9j.csb.app/src/App.tsx:21:9\r\nErrorBoundary@https://7ww9j.csb.app/src/App.tsx:33:5\r\ndiv\r\nApp\r\n```\r\n```\r\nSomething went wrong.\r\nError: sorry\r\n\r\nReactiveComp@https://7ww9j.csb.app/node_modules/@risingstack/react-easy-state/dist/es.es6.js:62:53\r\nErrorBoundary@https://7ww9j.csb.app/src/App.tsx:33:5\r\ndiv\r\nApp\r\n```\r\n\r\nNote how the component wrapped in `view()` is shown as `ReactiveComp` instead of either the function name or the explicitly assigned `displayName`.\r\n\r\n## The expected behavior\r\n\r\nThe name of the `ReactiveComp` wrapper should never appear in component stacks.",
        "remove_template_description": "**Edit** See this comment for the key part of what's being reported/discussed on this issue: https://github.com/facebook/react/issues/22315#issuecomment-920061727    # Original bug report below    As of #18561 component stacks are generated from native stack frames. This is problematic with HOCs that inherit from the input component in order to change its behavior. The somewhat popular @risingstack/react-easy-state package is one example of such a component. While it does assign a `displayName`, the new Native Component Stacks appear to ignore this. Instead, components wrapped in `view()` (from react-easy-state) are always shown with the name of the wrapper class, i.e., `ReactiveComp` or `ReactiveClassComp`.    This is especially catastrophic in the case of react-easy-state, where one is supposed to wrap essentially *all components in the entire codebase* in the `view()` HOC. The result is that component stacks become unusable for debugging.    Is there perhaps a way to work around this (e.g. disable native component stacks, or some new way to explicitly provide a component name like `displayName`)?    <!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: 17.0.1        1. Apply a HOC that uses inheritance (i.e., inherits from the component instead of wrapping it in JSX) to a component.  2. The component will always be named `ReactiveComp` or `ReactiveClassComp` in component stack traces.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/rough-tdd-wqepe?file=/src/App.tsx        ```  Something went wrong.  Error: sorry    BadGuy@https://7ww9j.csb.app/src/App.tsx:21:9  ErrorBoundary@https://7ww9j.csb.app/src/App.tsx:33:5  div  App  ```  ```  Something went wrong.  Error: sorry    ReactiveComp@https://7ww9j.csb.app/node_modules/@risingstack/react-easy-state/dist/es.es6.js:62:53  ErrorBoundary@https://7ww9j.csb.app/src/App.tsx:33:5  div  App  ```    Note how the component wrapped in `view()` is shown as `ReactiveComp` instead of either the function name or the explicitly assigned `displayName`.        The name of the `ReactiveComp` wrapper should never appear in component stacks.",
        "human_words": "**Edit** See this comment for the key part of what's being reported/discussed on this issue: https://github.com/facebook/react/issues/22315#issuecomment-920061727    # Original bug report below    As of #18561 component stacks are generated from native stack frames. This is problematic with HOCs that inherit from the input component in order to change its behavior. The somewhat popular @risingstack/react-easy-state package is one example of such a component. While it does assign a `displayName`, the new Native Component Stacks appear to ignore this. Instead, components wrapped in `view()` (from react-easy-state) are always shown with the name of the wrapper class, i.e., `ReactiveComp` or `ReactiveClassComp`.    This is especially catastrophic in the case of react-easy-state, where one is supposed to wrap essentially *all components in the entire codebase* in the `view()` HOC. The result is that component stacks become unusable for debugging.    Is there perhaps a way to work around this (e.g. disable native component stacks, or some new way to explicitly provide a component name like `displayName`)?    <!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: 17.0.1        1. Apply a HOC that uses inheritance (i.e., inherits from the component instead of wrapping it in JSX) to a component.  2. The component will always be named `ReactiveComp` or `ReactiveClassComp` in component stack traces.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/rough-tdd-wqepe?file=/src/App.tsx              Note how the component wrapped in `view()` is shown as `ReactiveComp` instead of either the function name or the explicitly assigned `displayName`.        The name of the `ReactiveComp` wrapper should never appear in component stacks.",
        "human_words_regrex": "**Edit** See this comment for the key part of what's being reported/discussed on this issue:  # Original bug report below As of #18561 component stacks are generated from native stack frames. This is problematic with HOCs that inherit from the input component in order to change its behavior. The somewhat popular @risingstack/react-easy-state package is one example of such a component. While it does assign a `displayName`, the new Native Component Stacks appear to ignore this. Instead, components wrapped in `view()` (from react-easy-state) are always shown with the name of the wrapper class, i.e., `ReactiveComp` or `ReactiveClassComp`. This is especially catastrophic in the case of react-easy-state, where one is supposed to wrap essentially *all components in the entire codebase* in the `view()` HOC. The result is that component stacks become unusable for debugging. Is there perhaps a way to work around this (e.g. disable native component stacks, or some new way to explicitly provide a component name like `displayName`)?  React version: 17.0.1 1. Apply a HOC that uses inheritance (i.e., inherits from the component instead of wrapping it in JSX) to a component. 2. The component will always be named `ReactiveComp` or `ReactiveClassComp` in component stack traces.  Link to code example:  Note how the component wrapped in `view()` is shown as `ReactiveComp` instead of either the function name or the explicitly assigned `displayName`. The name of the `ReactiveComp` wrapper should never appear in component stacks.",
        "human_words_stopwords_removal_lemmatization": "* * edit * * see comment key part 's reported/discussed issue : # original bug report # 18561 component stack generated native stack frame . problematic hocs inherit input component order change behavior . somewhat popular @ risingstack/react-easy-state package one example component . assign ` displayname ` , new native component stack appear ignore . instead , component wrapped ` view ( ) ` ( react-easy-state ) always shown name wrapper class , i.e. , ` reactivecomp ` ` reactiveclasscomp ` . especially catastrophic case react-easy-state , one supposed wrap essentially * component entire codebase * ` view ( ) ` hoc . result component stack become unusable debugging . perhaps way work around ( e.g . disable native component stack , new way explicitly provide component name like ` displayname ` ) ? react version : 17.0.1 1. apply hoc us inheritance ( i.e. , inherits component instead wrapping jsx ) component . 2. component always named ` reactivecomp ` ` reactiveclasscomp ` component stack trace . link code example : note component wrapped ` view ( ) ` shown ` reactivecomp ` instead either function name explicitly assigned ` displayname ` . name ` reactivecomp ` wrapper never appear component stack .",
        "title_stopwords_removal_lemmatization": "bug : native component stack n't respect function `` displayname '' firefox"
    },
    {
        "issue_id": 996216396,
        "title": "[React 18] Optimized React Server Components's webpack bundling",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-14T16:34:46Z",
        "status": "open",
        "description": "In a chat between Facebook and Shopify about React Server Component, @sebmarkbage had mentioned the need to improve React Server Component's bundling strategy in webpack.\r\n\r\n> The main thing is that by default you end up with way too many small chunks. You could use a telemetry based heuristic to inform bundling but without it, we think the best guidance is to analyze the server component's graph to group client components together by which server components use them.\r\nWe expect that the server will need to be built too, as a separate graph since best perf is gained when you prebuild the server anyway.\r\nSo it might be that the best API is building the server first and then using the data from that as input to building the client.\r\n\r\nLooking at [RSC demo app](https://github.com/reactjs/server-components-demo), there are a total of 8 `*.client.js` files, and 5 of them ended up as separate bundles using the current [webpack plugin](https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackPlugin.js).\r\n\r\nThis issue\u2019s main goal would be to investigate the current webpack plugin implementation and figure out any optimization that can be applied while keeping in mind React core team\u2019s guidance of \u201cbuilding the server first and then using the data from that as input to building the client.\u201d as an initial starting point.",
        "remove_template_description": "In a chat between Facebook and Shopify about React Server Component, @sebmarkbage had mentioned the need to improve React Server Component's bundling strategy in webpack.    > The main thing is that by default you end up with way too many small chunks. You could use a telemetry based heuristic to inform bundling but without it, we think the best guidance is to analyze the server component's graph to group client components together by which server components use them.  We expect that the server will need to be built too, as a separate graph since best perf is gained when you prebuild the server anyway.  So it might be that the best API is building the server first and then using the data from that as input to building the client.    Looking at [RSC demo app](https://github.com/reactjs/server-components-demo), there are a total of 8 `*.client.js` files, and 5 of them ended up as separate bundles using the current [webpack plugin](https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackPlugin.js).    This issue\u2019s main goal would be to investigate the current webpack plugin implementation and figure out any optimization that can be applied while keeping in mind React core team\u2019s guidance of \u201cbuilding the server first and then using the data from that as input to building the client.\u201d as an initial starting point.",
        "human_words": "In a chat between Facebook and Shopify about React Server Component, @sebmarkbage had mentioned the need to improve React Server Component's bundling strategy in webpack.    > The main thing is that by default you end up with way too many small chunks. You could use a telemetry based heuristic to inform bundling but without it, we think the best guidance is to analyze the server component's graph to group client components together by which server components use them.  We expect that the server will need to be built too, as a separate graph since best perf is gained when you prebuild the server anyway.  So it might be that the best API is building the server first and then using the data from that as input to building the client.    Looking at [RSC demo app](https://github.com/reactjs/server-components-demo), there are a total of 8 `*.client.js` files, and 5 of them ended up as separate bundles using the current [webpack plugin](https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackPlugin.js).    This issue\u2019s main goal would be to investigate the current webpack plugin implementation and figure out any optimization that can be applied while keeping in mind React core team\u2019s guidance of \u201cbuilding the server first and then using the data from that as input to building the client.\u201d as an initial starting point.",
        "human_words_regrex": "In a chat between Facebook and Shopify about React Server Component, @sebmarkbage had mentioned the need to improve React Server Component's bundling strategy in webpack. > The main thing is that by default you end up with way too many small chunks. You could use a telemetry based heuristic to inform bundling but without it, we think the best guidance is to analyze the server component's graph to group client components together by which server components use them. We expect that the server will need to be built too, as a separate graph since best perf is gained when you prebuild the server anyway. So it might be that the best API is building the server first and then using the data from that as input to building the client. Looking at , there are a total of 8 `*.client.js` files, and 5 of them ended up as separate bundles using the current . This issue\u2019s main goal would be to investigate the current webpack plugin implementation and figure out any optimization that can be applied while keeping in mind React core team\u2019s guidance of \u201cbuilding the server first and then using the data from that as input to building the client.\u201d as an initial starting point.",
        "human_words_stopwords_removal_lemmatization": "chat facebook shopify react server component , @ sebmarkbage mentioned need improve react server component 's bundling strategy webpack . > main thing default end way many small chunk . could use telemetry based heuristic inform bundling without , think best guidance analyze server component 's graph group client component together server component use . expect server need built , separate graph since best perf gained prebuild server anyway . might best api building server first using data input building client . looking , total 8 ` * .client.js ` file , 5 ended separate bundle using current . issue \u2019 main goal would investigate current webpack plugin implementation figure optimization applied keeping mind react core team \u2019 guidance \u201c building server first using data input building client. \u201d initial starting point .",
        "title_stopwords_removal_lemmatization": "[ react 18 ] optimized react server component 's webpack bundling"
    },
    {
        "issue_id": 995095131,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-13T16:32:44Z",
        "status": "closed",
        "description": "npm WARN deprecated flatten@1.0.3: flatten is deprecated in favor of utility frameworks such as lodash.\r\nnpm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintained \r\nnpm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintained\r\nnpm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated\r\nnpm WARN deprecated har-validator@5.1.5: this library is no longer supported\r\nnpm WARN deprecated request-promise-native@1.0.9: request-promise-native has been deprecated because it extends the now deprecated request package, see https://github.com/request/request/issues/3142\r\nnpm WARN deprecated chokidar@2.1.8: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies.\r\nnpm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated\r\nnpm WARN deprecated left-pad@1.3.0: use String.prototype.padStart()\r\nnpm WARN deprecated sane@4.1.0: some dependency vulnerabilities fixed, support for node < 10 dropped, and newer ECMAScript syntax/features added\r\nnpm WARN deprecated eslint-loader@3.0.2: This loader has been deprecated. Please use eslint-webpack-plugin        \r\nnpm WARN deprecated @hapi/address@2.1.4: Moved to 'npm install @sideway/address'\r\nnpm WARN deprecated querystring@0.2.0: The querystring API is considered Legacy. new code should use the URLSearchParams API instead.\r\nnpm WARN deprecated babel-eslint@10.0.3: babel-eslint is now @babel/eslint-parser. This package will no longer receive updates.\r\nnpm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.\r\nnpm WARN deprecated html-webpack-plugin@4.0.0-beta.5: please switch to a stable version\r\nnpm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintained   \r\nnpm WARN deprecated @hapi/joi@15.1.1: Switch to 'npm install joi'\r\nnpm WARN deprecated core-js@2.6.12: core-js@<3.3 is no longer maintained and not recommended for usage due to the\r\n\r\n### When installing React using command line showing above errors, what to do?",
        "remove_template_description": "npm WARN deprecated flatten@1.0.3: flatten is deprecated in favor of utility frameworks such as lodash.  npm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintained   npm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintained  npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated  npm WARN deprecated har-validator@5.1.5: this library is no longer supported  npm WARN deprecated request-promise-native@1.0.9: request-promise-native has been deprecated because it extends the now deprecated request package, see https://github.com/request/request/issues/3142  npm WARN deprecated chokidar@2.1.8: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies.  npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated  npm WARN deprecated left-pad@1.3.0: use String.prototype.padStart()  npm WARN deprecated sane@4.1.0: some dependency vulnerabilities fixed, support for node < 10 dropped, and newer ECMAScript syntax/features added  npm WARN deprecated eslint-loader@3.0.2: This loader has been deprecated. Please use eslint-webpack-plugin          npm WARN deprecated @hapi/address@2.1.4: Moved to 'npm install @sideway/address'  npm WARN deprecated querystring@0.2.0: The querystring API is considered Legacy. new code should use the URLSearchParams API instead.  npm WARN deprecated babel-eslint@10.0.3: babel-eslint is now @babel/eslint-parser. This package will no longer receive updates.  npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.  npm WARN deprecated html-webpack-plugin@4.0.0-beta.5: please switch to a stable version  npm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintained     npm WARN deprecated @hapi/joi@15.1.1: Switch to 'npm install joi'  npm WARN deprecated core-js@2.6.12: core-js@<3.3 is no longer maintained and not recommended for usage due to the    ### When installing React using command line showing above errors, what to do?",
        "human_words": "npm WARN deprecated flatten@1.0.3: flatten is deprecated in favor of utility frameworks such as lodash.  npm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintained   npm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintained  npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated  npm WARN deprecated har-validator@5.1.5: this library is no longer supported  npm WARN deprecated request-promise-native@1.0.9: request-promise-native has been deprecated because it extends the now deprecated request package, see https://github.com/request/request/issues/3142  npm WARN deprecated chokidar@2.1.8: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies.  npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated  npm WARN deprecated left-pad@1.3.0: use String.prototype.padStart()  npm WARN deprecated sane@4.1.0: some dependency vulnerabilities fixed, support for node < 10 dropped, and newer ECMAScript syntax/features added  npm WARN deprecated eslint-loader@3.0.2: This loader has been deprecated. Please use eslint-webpack-plugin          npm WARN deprecated @hapi/address@2.1.4: Moved to 'npm install @sideway/address'  npm WARN deprecated querystring@0.2.0: The querystring API is considered Legacy. new code should use the URLSearchParams API instead.  npm WARN deprecated babel-eslint@10.0.3: babel-eslint is now @babel/eslint-parser. This package will no longer receive updates.  npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.  npm WARN deprecated html-webpack-plugin@4.0.0-beta.5: please switch to a stable version  npm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintained     npm WARN deprecated @hapi/joi@15.1.1: Switch to 'npm install joi'  npm WARN deprecated core-js@2.6.12: core-js@<3.3 is no longer maintained and not recommended for usage due to the    ### When installing React using command line showing above errors, what to do?",
        "human_words_regrex": "npm WARN deprecated flatten@1.0.3: flatten is deprecated in favor of utility frameworks such as lodash. npm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintained npm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintained npm WARN deprecated urix@0.1.0: Please see  npm WARN deprecated har-validator@5.1.5: this library is no longer supported npm WARN deprecated request-promise-native@1.0.9: request-promise-native has been deprecated because it extends the now deprecated request package, see  npm WARN deprecated chokidar@2.1.8: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies. npm WARN deprecated resolve-url@0.2.1:  npm WARN deprecated left-pad@1.3.0: use String.prototype.padStart() npm WARN deprecated sane@4.1.0: some dependency vulnerabilities fixed, support for node < 10 dropped, and newer ECMAScript syntax/features added npm WARN deprecated eslint-loader@3.0.2: This loader has been deprecated. Please use eslint-webpack-plugin npm WARN deprecated @hapi/address@2.1.4: Moved to 'npm install @sideway/address' npm WARN deprecated querystring@0.2.0: The querystring API is considered Legacy. new code should use the URLSearchParams API instead. npm WARN deprecated babel-eslint@10.0.3: babel-eslint is now @babel/eslint-parser. This package will no longer receive updates. npm WARN deprecated uuid@3.4.0: Please upgrade to version 7 or higher. Older versions may use Math.random() in certain circumstances, which is known to be problematic. See  for details. npm WARN deprecated html-webpack-plugin@4.0.0-beta.5: please switch to a stable version npm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintained npm WARN deprecated @hapi/joi@15.1.1: Switch to 'npm install joi' npm WARN deprecated core-js@2.6.12: core-js@<3.3 is no longer maintained and not recommended for usage due to the ### When installing React using command line showing above errors, what to do?",
        "human_words_stopwords_removal_lemmatization": "npm warn deprecated flatten @ 1.0.3 : flatten deprecated favor utility framework lodash . npm warn deprecated @ hapi/bourne @ 1.3.2 : version deprecated longer supported maintained npm warn deprecated @ hapi/topo @ 3.1.6 : version deprecated longer supported maintained npm warn deprecated urix @ 0.1.0 : please see npm warn deprecated har-validator @ 5.1.5 : library longer supported npm warn deprecated request-promise-native @ 1.0.9 : request-promise-native deprecated extends deprecated request package , see npm warn deprecated chokidar @ 2.1.8 : chokidar 2 break node v14+ . upgrade chokidar 3 15x le dependency . npm warn deprecated resolve-url @ 0.2.1 : npm warn deprecated left-pad @ 1.3.0 : use string.prototype.padstart ( ) npm warn deprecated sane @ 4.1.0 : dependency vulnerability fixed , support node < 10 dropped , newer ecmascript syntax/features added npm warn deprecated eslint-loader @ 3.0.2 : loader deprecated . please use eslint-webpack-plugin npm warn deprecated @ hapi/address @ 2.1.4 : moved 'npm install @ sideway/address ' npm warn deprecated querystring @ 0.2.0 : querystring api considered legacy . new code use urlsearchparams api instead . npm warn deprecated babel-eslint @ 10.0.3 : babel-eslint @ babel/eslint-parser . package longer receive update . npm warn deprecated uuid @ 3.4.0 : please upgrade version 7 higher . older version may use math.random ( ) certain circumstance , known problematic . see detail . npm warn deprecated html-webpack-plugin @ 4.0.0-beta.5 : please switch stable version npm warn deprecated @ hapi/hoek @ 8.5.1 : version deprecated longer supported maintained npm warn deprecated @ hapi/joi @ 15.1.1 : switch 'npm install joi ' npm warn deprecated core-js @ 2.6.12 : core-js @ < 3.3 longer maintained recommended usage due # # # installing react using command line showing error , ?",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 991430625,
        "title": "DevTools: Profiling tool improvements umbrella",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Type: Umbrella"
        ],
        "date": "2021-09-08T18:51:28Z",
        "status": "open",
        "description": "I met with @lahmatiy this afternoon to chat about his project [react-render-tracker](https://github.com/lahmatiy/react-render-tracker). Here are a few pain points mentioned during the meeting:\r\n* Not clear when a component/tree is unmounted/remounted.\r\n* DevTools typically displays data for a component in current update (e.g. the latest) but doesn't represent changes over time.\r\n* It isn't always clear why something updates (e.g. why did context change higher up, what was the flow of props/state above that resulted in a new prop)\r\n* It's difficult to detect when effects re-run unexpectedly due to dependency problems. (Nothing really reports this.)\r\n\r\nThis is an umbrella issue for some ideas I wrote down during the discussion that might be good additions to the React DevTools/Profiler. The items listed below may be worked on independently\u2013 and some may turn out to be not worth doing (but they seem worth discussing and considering).\r\n\r\n## Legacy profiler\r\n\r\n### Track changed values\r\nThe Profiler currently has an opt-in setting for detecting _why_ something re-rendered, but all this does is show the name of the state/prop that changed. Should we also add a setting to display the changed value?\r\n\r\nWe shied away from doing this for a long time because:\r\n* We didn't want to incur the cost of serializing deep object structures during a profiling session.\r\n* Without eagerly serializing an object, we don't have a solution for mutable values. (We can't serialize these later since they may have changed.)\r\n\r\nMaybe there are some ways to address the above concerns though? For instance, we could reduce the amount of data we needed to eagerly serialize by:\r\n* Only serialize values that _changed_ between renders. (This would avoid the mutable object scenario.)\r\n* Only serialize _parts_ of an object that changed. (See [here](https://github.com/lahmatiy/react-render-tracker/blob/39d598aaa12274cb8a015dacf55b68687bde7d8d/src/publisher/react-integration/devtools-hook-handlers.ts#L356-L374) for possible precedent.)\r\n\r\nPerhaps this, combined with making the setting opt-in, would enable us to add this feature.\r\n\r\n### Explicitly display unmounts\r\nThe DevTools profiler only displays components that were _committed_ (e.g. visible on the screen at the point in time when work was committed), but React also spends time unmounting components\u2013 and perhaps an unmount isn't expected in some cases (e.g. when a wrapper object is added and React deeply unmounts and remounts a tree).\r\n\r\nShould we show some sort of rollup (e.g. at the commit level) for components that were un-mounted too? This way they wouldn't be invisible an easy to overlook.\r\n\r\n### Viewing changes for a subtree across time\r\nThe Components tab allows you to explore the entire application tree, or double-click to drill into what we call the [\"owners tree\"](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#owners-tree)\u2013 the list of things rendered by a particular component (the things it \"owns\").\r\n\r\nMaybe the Profiler could provide a similar method to drill into a component (e.g. double-clicking it) to then provide a snapshot of how that component changed over time? This might make it easier to discover things like unmounts/remounts within a known scope. (Or maybe we could also show other component-level summary stats when in this mode?)\r\n\r\n## Scheduling profiler\r\n\r\n### Explicit unmount/mount markers\r\nShould we add component un-mounts/mounts as explicit marks in the new profiler? Profiling tools currently focus on the time spent _rendering_ (or perhaps mounting) a component, but unmounts are somewhat hidden. (Perhaps more importantly, unexpected _remounts_ are not highlighted enough.)",
        "remove_template_description": "I met with @lahmatiy this afternoon to chat about his project [react-render-tracker](https://github.com/lahmatiy/react-render-tracker). Here are a few pain points mentioned during the meeting:  * Not clear when a component/tree is unmounted/remounted.  * DevTools typically displays data for a component in current update (e.g. the latest) but doesn't represent changes over time.  * It isn't always clear why something updates (e.g. why did context change higher up, what was the flow of props/state above that resulted in a new prop)  * It's difficult to detect when effects re-run unexpectedly due to dependency problems. (Nothing really reports this.)    This is an umbrella issue for some ideas I wrote down during the discussion that might be good additions to the React DevTools/Profiler. The items listed below may be worked on independently\u2013 and some may turn out to be not worth doing (but they seem worth discussing and considering).    ## Legacy profiler    ### Track changed values  The Profiler currently has an opt-in setting for detecting _why_ something re-rendered, but all this does is show the name of the state/prop that changed. Should we also add a setting to display the changed value?    We shied away from doing this for a long time because:  * We didn't want to incur the cost of serializing deep object structures during a profiling session.  * Without eagerly serializing an object, we don't have a solution for mutable values. (We can't serialize these later since they may have changed.)    Maybe there are some ways to address the above concerns though? For instance, we could reduce the amount of data we needed to eagerly serialize by:  * Only serialize values that _changed_ between renders. (This would avoid the mutable object scenario.)  * Only serialize _parts_ of an object that changed. (See [here](https://github.com/lahmatiy/react-render-tracker/blob/39d598aaa12274cb8a015dacf55b68687bde7d8d/src/publisher/react-integration/devtools-hook-handlers.ts#L356-L374) for possible precedent.)    Perhaps this, combined with making the setting opt-in, would enable us to add this feature.    ### Explicitly display unmounts  The DevTools profiler only displays components that were _committed_ (e.g. visible on the screen at the point in time when work was committed), but React also spends time unmounting components\u2013 and perhaps an unmount isn't expected in some cases (e.g. when a wrapper object is added and React deeply unmounts and remounts a tree).    Should we show some sort of rollup (e.g. at the commit level) for components that were un-mounted too? This way they wouldn't be invisible an easy to overlook.    ### Viewing changes for a subtree across time  The Components tab allows you to explore the entire application tree, or double-click to drill into what we call the [\"owners tree\"](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#owners-tree)\u2013 the list of things rendered by a particular component (the things it \"owns\").    Maybe the Profiler could provide a similar method to drill into a component (e.g. double-clicking it) to then provide a snapshot of how that component changed over time? This might make it easier to discover things like unmounts/remounts within a known scope. (Or maybe we could also show other component-level summary stats when in this mode?)    ## Scheduling profiler    ### Explicit unmount/mount markers  Should we add component un-mounts/mounts as explicit marks in the new profiler? Profiling tools currently focus on the time spent _rendering_ (or perhaps mounting) a component, but unmounts are somewhat hidden. (Perhaps more importantly, unexpected _remounts_ are not highlighted enough.)",
        "human_words": "I met with @lahmatiy this afternoon to chat about his project [react-render-tracker](https://github.com/lahmatiy/react-render-tracker). Here are a few pain points mentioned during the meeting:  * Not clear when a component/tree is unmounted/remounted.  * DevTools typically displays data for a component in current update (e.g. the latest) but doesn't represent changes over time.  * It isn't always clear why something updates (e.g. why did context change higher up, what was the flow of props/state above that resulted in a new prop)  * It's difficult to detect when effects re-run unexpectedly due to dependency problems. (Nothing really reports this.)    This is an umbrella issue for some ideas I wrote down during the discussion that might be good additions to the React DevTools/Profiler. The items listed below may be worked on independently\u2013 and some may turn out to be not worth doing (but they seem worth discussing and considering).    ## Legacy profiler    ### Track changed values  The Profiler currently has an opt-in setting for detecting _why_ something re-rendered, but all this does is show the name of the state/prop that changed. Should we also add a setting to display the changed value?    We shied away from doing this for a long time because:  * We didn't want to incur the cost of serializing deep object structures during a profiling session.  * Without eagerly serializing an object, we don't have a solution for mutable values. (We can't serialize these later since they may have changed.)    Maybe there are some ways to address the above concerns though? For instance, we could reduce the amount of data we needed to eagerly serialize by:  * Only serialize values that _changed_ between renders. (This would avoid the mutable object scenario.)  * Only serialize _parts_ of an object that changed. (See [here](https://github.com/lahmatiy/react-render-tracker/blob/39d598aaa12274cb8a015dacf55b68687bde7d8d/src/publisher/react-integration/devtools-hook-handlers.ts#L356-L374) for possible precedent.)    Perhaps this, combined with making the setting opt-in, would enable us to add this feature.    ### Explicitly display unmounts  The DevTools profiler only displays components that were _committed_ (e.g. visible on the screen at the point in time when work was committed), but React also spends time unmounting components\u2013 and perhaps an unmount isn't expected in some cases (e.g. when a wrapper object is added and React deeply unmounts and remounts a tree).    Should we show some sort of rollup (e.g. at the commit level) for components that were un-mounted too? This way they wouldn't be invisible an easy to overlook.    ### Viewing changes for a subtree across time  The Components tab allows you to explore the entire application tree, or double-click to drill into what we call the [\"owners tree\"](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#owners-tree)\u2013 the list of things rendered by a particular component (the things it \"owns\").    Maybe the Profiler could provide a similar method to drill into a component (e.g. double-clicking it) to then provide a snapshot of how that component changed over time? This might make it easier to discover things like unmounts/remounts within a known scope. (Or maybe we could also show other component-level summary stats when in this mode?)    ## Scheduling profiler    ### Explicit unmount/mount markers  Should we add component un-mounts/mounts as explicit marks in the new profiler? Profiling tools currently focus on the time spent _rendering_ (or perhaps mounting) a component, but unmounts are somewhat hidden. (Perhaps more importantly, unexpected _remounts_ are not highlighted enough.)",
        "human_words_regrex": "I met with @lahmatiy this afternoon to chat about his project . Here are a few pain points mentioned during the meeting: * Not clear when a component/tree is unmounted/remounted. * DevTools typically displays data for a component in current update (e.g. the latest) but doesn't represent changes over time. * It isn't always clear why something updates (e.g. why did context change higher up, what was the flow of props/state above that resulted in a new prop) * It's difficult to detect when effects re-run unexpectedly due to dependency problems. (Nothing really reports this.) This is an umbrella issue for some ideas I wrote down during the discussion that might be good additions to the React DevTools/Profiler. The items listed below may be worked on independently\u2013 and some may turn out to be not worth doing (but they seem worth discussing and considering). ## Legacy profiler ### Track changed values The Profiler currently has an opt-in setting for detecting _why_ something re-rendered, but all this does is show the name of the state/prop that changed. Should we also add a setting to display the changed value? We shied away from doing this for a long time because: * We didn't want to incur the cost of serializing deep object structures during a profiling session. * Without eagerly serializing an object, we don't have a solution for mutable values. (We can't serialize these later since they may have changed.) Maybe there are some ways to address the above concerns though? For instance, we could reduce the amount of data we needed to eagerly serialize by: * Only serialize values that _changed_ between renders. (This would avoid the mutable object scenario.) * Only serialize _parts_ of an object that changed. (See  for possible precedent.) Perhaps this, combined with making the setting opt-in, would enable us to add this feature. ### Explicitly display unmounts The DevTools profiler only displays components that were _committed_ (e.g. visible on the screen at the point in time when work was committed), but React also spends time unmounting components\u2013 and perhaps an unmount isn't expected in some cases (e.g. when a wrapper object is added and React deeply unmounts and remounts a tree). Should we show some sort of rollup (e.g. at the commit level) for components that were un-mounted too? This way they wouldn't be invisible an easy to overlook. ### Viewing changes for a subtree across time The Components tab allows you to explore the entire application tree, or double-click to drill into what we call the \u2013 the list of things rendered by a particular component (the things it \"owns\"). Maybe the Profiler could provide a similar method to drill into a component (e.g. double-clicking it) to then provide a snapshot of how that component changed over time? This might make it easier to discover things like unmounts/remounts within a known scope. (Or maybe we could also show other component-level summary stats when in this mode?) ## Scheduling profiler ### Explicit unmount/mount markers Should we add component un-mounts/mounts as explicit marks in the new profiler? Profiling tools currently focus on the time spent _rendering_ (or perhaps mounting) a component, but unmounts are somewhat hidden. (Perhaps more importantly, unexpected _remounts_ are not highlighted enough.)",
        "human_words_stopwords_removal_lemmatization": "met @ lahmatiy afternoon chat project . pain point mentioned meeting : * clear component/tree unmounted/remounted . * devtools typically display data component current update ( e.g . latest ) n't represent change time . * n't always clear something update ( e.g . context change higher , flow props/state resulted new prop ) * 's difficult detect effect re-run unexpectedly due dependency problem . ( nothing really report . ) umbrella issue idea wrote discussion might good addition react devtools/profiler . item listed may worked independently\u2013 may turn worth ( seem worth discussing considering ) . # # legacy profiler # # # track changed value profiler currently opt-in setting detecting _why_ something re-rendered , show name state/prop changed . also add setting display changed value ? shied away long time : * n't want incur cost serializing deep object structure profiling session . * without eagerly serializing object , n't solution mutable value . ( ca n't serialize later since may changed . ) maybe way address concern though ? instance , could reduce amount data needed eagerly serialize : * serialize value _changed_ render . ( would avoid mutable object scenario . ) * serialize _parts_ object changed . ( see possible precedent . ) perhaps , combined making setting opt-in , would enable u add feature . # # # explicitly display unmounts devtools profiler display component _committed_ ( e.g . visible screen point time work committed ) , react also spends time unmounting components\u2013 perhaps unmount n't expected case ( e.g . wrapper object added react deeply unmounts remount tree ) . show sort rollup ( e.g . commit level ) component un-mounted ? way would n't invisible easy overlook . # # # viewing change subtree across time component tab allows explore entire application tree , double-click drill call \u2013 list thing rendered particular component ( thing `` owns '' ) . maybe profiler could provide similar method drill component ( e.g . double-clicking ) provide snapshot component changed time ? might make easier discover thing like unmounts/remounts within known scope . ( maybe could also show component-level summary stats mode ? ) # # scheduling profiler # # # explicit unmount/mount marker add component un-mounts/mounts explicit mark new profiler ? profiling tool currently focus time spent _rendering_ ( perhaps mounting ) component , unmounts somewhat hidden . ( perhaps importantly , unexpected _remounts_ highlighted enough . )",
        "title_stopwords_removal_lemmatization": "devtools : profiling tool improvement umbrella"
    },
    {
        "issue_id": 989655954,
        "title": "Console log shows the wrong destination file ",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "React 18"
        ],
        "date": "2021-09-07T06:55:50Z",
        "status": "closed",
        "description": "in my browser console, log info go wrong, it should show real console.log file and correct line info, but now it always show \"react_devtools_backend.js: 4049\", link to source code show warning:\r\n \"Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\r\n* Move data fetching code or side effects to componentDidUpdate.\r\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\r\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\r\nPlease update the following components: %s\"\r\nwhen i disable react developer tools, it goes correctly. but it goes wrong in 4.18.0 react developer tools. and my colleagues' chrome with react developer tools 4.17.0 is right\r\n\r\n### Note from maintainers: https://github.com/facebook/react/issues/22257#issuecomment-916174962 is a workaround until this is fixed in React DevTools",
        "remove_template_description": "in my browser console, log info go wrong, it should show real console.log file and correct line info, but now it always show \"react_devtools_backend.js: 4049\", link to source code show warning:   \"Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.  * Move data fetching code or side effects to componentDidUpdate.  * If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state  * Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.  Please update the following components: %s\"  when i disable react developer tools, it goes correctly. but it goes wrong in 4.18.0 react developer tools. and my colleagues' chrome with react developer tools 4.17.0 is right    ### Note from maintainers: https://github.com/facebook/react/issues/22257#issuecomment-916174962 is a workaround until this is fixed in React DevTools",
        "human_words": "in my browser console, log info go wrong, it should show real console.log file and correct line info, but now it always show \"react_devtools_backend.js: 4049\", link to source code show warning:   \"Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.  * Move data fetching code or side effects to componentDidUpdate.  * If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state  * Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.  Please update the following components: %s\"  when i disable react developer tools, it goes correctly. but it goes wrong in 4.18.0 react developer tools. and my colleagues' chrome with react developer tools 4.17.0 is right    ### Note from maintainers: https://github.com/facebook/react/issues/22257#issuecomment-916174962 is a workaround until this is fixed in React DevTools",
        "human_words_regrex": "in my browser console, log info go wrong, it should show real console.log file and correct line info, but now it always show \"react_devtools_backend.js: 4049\", link to source code show warning: \"Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See  for details. * Move data fetching code or side effects to componentDidUpdate. * If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at:  * Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder. Please update the following components: %s\" when i disable react developer tools, it goes correctly. but it goes wrong in 4.18.0 react developer tools. and my colleagues' chrome with react developer tools 4.17.0 is right ### Note from maintainers:  is a workaround until this is fixed in React DevTools",
        "human_words_stopwords_removal_lemmatization": "browser console , log info go wrong , show real console.log file correct line info , always show `` react_devtools_backend.js : 4049 '' , link source code show warning : `` warning : componentwillreceiveprops renamed , recommended use . see detail . * move data fetching code side effect componentdidupdate . * 're updating state whenever prop change , refactor code use memoization technique move static getderivedstatefromprops . learn : * rename componentwillreceiveprops unsafe_componentwillreceiveprops suppress warning non-strict mode . react 17.x , unsafe_ name work . rename deprecated lifecycles new name , run ` npx react-codemod rename-unsafe-lifecycles ` project source folder . please update following component : % '' disable react developer tool , go correctly . go wrong 4.18.0 react developer tool . colleague ' chrome react developer tool 4.17.0 right # # # note maintainer : workaround fixed react devtools",
        "title_stopwords_removal_lemmatization": "console log show wrong destination file"
    },
    {
        "issue_id": 987920063,
        "title": "React 18 Fallback not showing with useTransition after delay exceeds timeoutMs",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-09-03T16:08:30Z",
        "status": "closed",
        "description": "I've tried the latest version of React 18 (as of today), and made a very simple test bed for the new APIs.\r\n\r\nI've got the full gist [here](https://gist.github.com/jacobp100/08f154a7b5eace8c4c2535ae4d351a51) - but for brevity, I've only copied the important bits below\r\n\r\n```jsx\r\nconst SUSPENSE_CONFIG = { timeoutMs: 1000 };\r\nconst RESOURCE_DELAY = 2000;\r\n\r\n// function Resource({ id }) { ... }\r\n\r\nfunction App() {\r\n  const [id, setId] = useState(undefined);\r\n  const [isPending, startTransition] = useTransition(SUSPENSE_CONFIG);\r\n\r\n  const incrId = useCallback(() => {\r\n    setId((id) => (id != null ? id + 1 : 0));\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <h1>{id != null ? `Resource ${id}` : \"Example\"}</h1>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        {id != null ? <Resource id={id} /> : <div>Nothing loaded</div>}\r\n      </Suspense>\r\n      <button type=\"button\" onClick={incrId}>\r\n        Load WITHOUT Transition\r\n      </button>\r\n      <button type=\"button\" onClick={() => startTransition(incrId)}>\r\n        Load WITH Transition {isPending ? \"(Pending...)\" : null}\r\n      </button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\nFrom my understanding, if I click the `Load WITH Transition` button, I should see `(Pending...)` in the button for a second, then the `Loading...` should show for a second, then both loading states are cleared as the resource is loaded.\r\n\r\nHowever, I cannot get the fallback to show when using `useTransition`. If I don't use that - the fallback loads perfectly.\r\n\r\nIs this a bug, or am I misunderstanding how this works?",
        "remove_template_description": "I've tried the latest version of React 18 (as of today), and made a very simple test bed for the new APIs.    I've got the full gist [here](https://gist.github.com/jacobp100/08f154a7b5eace8c4c2535ae4d351a51) - but for brevity, I've only copied the important bits below    ```jsx  const SUSPENSE_CONFIG = { timeoutMs: 1000 };  const RESOURCE_DELAY = 2000;    // function Resource({ id }) { ... }    function App() {    const [id, setId] = useState(undefined);    const [isPending, startTransition] = useTransition(SUSPENSE_CONFIG);      const incrId = useCallback(() => {      setId((id) => (id != null ? id + 1 : 0));    }, []);      return (      <>        <h1>{id != null ? `Resource ${id}` : \"Example\"}</h1>        <Suspense fallback={<div>Loading...</div>}>          {id != null ? <Resource id={id} /> : <div>Nothing loaded</div>}        </Suspense>        <button type=\"button\" onClick={incrId}>          Load WITHOUT Transition        </button>        <button type=\"button\" onClick={() => startTransition(incrId)}>          Load WITH Transition {isPending ? \"(Pending...)\" : null}        </button>      </>    );  }  ```    From my understanding, if I click the `Load WITH Transition` button, I should see `(Pending...)` in the button for a second, then the `Loading...` should show for a second, then both loading states are cleared as the resource is loaded.    However, I cannot get the fallback to show when using `useTransition`. If I don't use that - the fallback loads perfectly.    Is this a bug, or am I misunderstanding how this works?",
        "human_words": "I've tried the latest version of React 18 (as of today), and made a very simple test bed for the new APIs.    I've got the full gist [here](https://gist.github.com/jacobp100/08f154a7b5eace8c4c2535ae4d351a51) - but for brevity, I've only copied the important bits below        From my understanding, if I click the `Load WITH Transition` button, I should see `(Pending...)` in the button for a second, then the `Loading...` should show for a second, then both loading states are cleared as the resource is loaded.    However, I cannot get the fallback to show when using `useTransition`. If I don't use that - the fallback loads perfectly.    Is this a bug, or am I misunderstanding how this works?",
        "human_words_regrex": "I've tried the latest version of React 18 (as of today), and made a very simple test bed for the new APIs. I've got the full gist  - but for brevity, I've only copied the important bits below From my understanding, if I click the `Load WITH Transition` button, I should see `(Pending...)` in the button for a second, then the `Loading...` should show for a second, then both loading states are cleared as the resource is loaded. However, I cannot get the fallback to show when using `useTransition`. If I don't use that - the fallback loads perfectly. Is this a bug, or am I misunderstanding how this works?",
        "human_words_stopwords_removal_lemmatization": "'ve tried latest version react 18 ( today ) , made simple test bed new apis . 've got full gist - brevity , 've copied important bit understanding , click ` load transition ` button , see ` ( pending ... ) ` button second , ` loading ... ` show second , loading state cleared resource loaded . however , get fallback show using ` usetransition ` . n't use - fallback load perfectly . bug , misunderstanding work ?",
        "title_stopwords_removal_lemmatization": "react 18 fallback showing usetransition delay exceeds timeoutms"
    },
    {
        "issue_id": 983825977,
        "title": "React 17 npm run build does not copy the assets folder to dist",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-31T12:51:37Z",
        "status": "closed",
        "description": "the react configuration\r\n    \"@types/node\": \"^12.20.19\",\r\n    \"@types/react\": \"^17.0.16\",\r\n    \"@types/react-dom\": \"^17.0.9\",\r\n\r\ni have added config.json file in asset folder under src \r\nwhen i run  **`npm run build`** it does not copy the config.json file to dist folder.\r\ni wanted to change the different configuration settings for different environment (test,stag,prod ...)\r\ncan you help me how to achieve this?\r\n",
        "remove_template_description": "the react configuration      \"@types/node\": \"^12.20.19\",      \"@types/react\": \"^17.0.16\",      \"@types/react-dom\": \"^17.0.9\",    i have added config.json file in asset folder under src   when i run  **`npm run build`** it does not copy the config.json file to dist folder.  i wanted to change the different configuration settings for different environment (test,stag,prod ...)  can you help me how to achieve this?",
        "human_words": "the react configuration      \"@types/node\": \"^12.20.19\",      \"@types/react\": \"^17.0.16\",      \"@types/react-dom\": \"^17.0.9\",    i have added config.json file in asset folder under src   when i run  **`npm run build`** it does not copy the config.json file to dist folder.  i wanted to change the different configuration settings for different environment (test,stag,prod ...)  can you help me how to achieve this?",
        "human_words_regrex": "the react configuration \"@types/node\": \"^12.20.19\", \"@types/react\": \"^17.0.16\", \"@types/react-dom\": \"^17.0.9\", i have added config.json file in asset folder under src when i run **`npm run build`** it does not copy the config.json file to dist folder. i wanted to change the different configuration settings for different environment (test,stag,prod ...) can you help me how to achieve this?",
        "human_words_stopwords_removal_lemmatization": "react configuration `` @ types/node '' : `` ^12.20.19 '' , `` @ types/react '' : `` ^17.0.16 '' , `` @ types/react-dom '' : `` ^17.0.9 '' , added config.json file asset folder src run * * ` npm run build ` * * copy config.json file dist folder . wanted change different configuration setting different environment ( test , stag , prod ... ) help achieve ?",
        "title_stopwords_removal_lemmatization": "react 17 npm run build copy asset folder dist"
    },
    {
        "issue_id": 982419143,
        "title": "Suggestion: React 18 (PureComponent)",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-30T05:59:36Z",
        "status": "closed",
        "description": "Hello, I am a programmer.\r\nWhen I use PureComponent, it is very efficient. But React does not provide a setState method that can modify immutable data structures.\r\nTherefore, the immer library is used in the setState method to implement the modification of immutable data.\r\nYou can consider absorbing immer, and then provide an easy-to-use setState method.\r\n\r\n![image](https://user-images.githubusercontent.com/48673442/131292263-94202b6e-d461-4327-a021-0e0d8e3642ca.png)\r\n\r\nHere are more examples of use.\r\n![image](https://user-images.githubusercontent.com/48673442/131293818-26893034-acc3-4eba-9afa-2a4df0609420.png)\r\n",
        "remove_template_description": "Hello, I am a programmer.  When I use PureComponent, it is very efficient. But React does not provide a setState method that can modify immutable data structures.  Therefore, the immer library is used in the setState method to implement the modification of immutable data.  You can consider absorbing immer, and then provide an easy-to-use setState method.    ![image](https://user-images.githubusercontent.com/48673442/131292263-94202b6e-d461-4327-a021-0e0d8e3642ca.png)    Here are more examples of use.  ![image](https://user-images.githubusercontent.com/48673442/131293818-26893034-acc3-4eba-9afa-2a4df0609420.png)",
        "human_words": "Hello, I am a programmer.  When I use PureComponent, it is very efficient. But React does not provide a setState method that can modify immutable data structures.  Therefore, the immer library is used in the setState method to implement the modification of immutable data.  You can consider absorbing immer, and then provide an easy-to-use setState method.    ![image](https://user-images.githubusercontent.com/48673442/131292263-94202b6e-d461-4327-a021-0e0d8e3642ca.png)    Here are more examples of use.  ![image](https://user-images.githubusercontent.com/48673442/131293818-26893034-acc3-4eba-9afa-2a4df0609420.png)",
        "human_words_regrex": "Hello, I am a programmer. When I use PureComponent, it is very efficient. But React does not provide a setState method that can modify immutable data structures. Therefore, the immer library is used in the setState method to implement the modification of immutable data. You can consider absorbing immer, and then provide an easy-to-use setState method. ! Here are more examples of use. !",
        "human_words_stopwords_removal_lemmatization": "hello , programmer . use purecomponent , efficient . react provide setstate method modify immutable data structure . therefore , immer library used setstate method implement modification immutable data . consider absorbing immer , provide easy-to-use setstate method . ! example use . !",
        "title_stopwords_removal_lemmatization": "suggestion : react 18 ( purecomponent )"
    },
    {
        "issue_id": 981359557,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-27T15:27:34Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nIf You Having Any Issues Please Contact Me I will help You\r\ncode will submit on 1 day",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  If You Having Any Issues Please Contact Me I will help You  code will submit on 1 day",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  If You Having Any Issues Please Contact Me I will help You  code will submit on 1 day",
        "human_words_regrex": " If You Having Any Issues Please Contact Me I will help You code will submit on 1 day",
        "human_words_stopwords_removal_lemmatization": "issue please contact help code submit 1 day",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 976305403,
        "title": "React 18 and next.js",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-22T07:07:58Z",
        "status": "closed",
        "description": "react is so plain.we have to write bunch of code for small things, so i think react should include all functions (code) of next.js, for one or two functionality we have to change whole framework or make a new project and write whole bunch of code for it and there many opensource frameworks like next.js from which we can borrow functionality and improve react.if you are agree with me, its my pleasure to help you with writing code for it.main functionality i think react should have are in built all 3 types of SSR and file based routing.please reply me soon as possible. thanks in advance",
        "remove_template_description": "react is so plain.we have to write bunch of code for small things, so i think react should include all functions (code) of next.js, for one or two functionality we have to change whole framework or make a new project and write whole bunch of code for it and there many opensource frameworks like next.js from which we can borrow functionality and improve react.if you are agree with me, its my pleasure to help you with writing code for it.main functionality i think react should have are in built all 3 types of SSR and file based routing.please reply me soon as possible. thanks in advance",
        "human_words": "react is so plain.we have to write bunch of code for small things, so i think react should include all functions (code) of next.js, for one or two functionality we have to change whole framework or make a new project and write whole bunch of code for it and there many opensource frameworks like next.js from which we can borrow functionality and improve react.if you are agree with me, its my pleasure to help you with writing code for it.main functionality i think react should have are in built all 3 types of SSR and file based routing.please reply me soon as possible. thanks in advance",
        "human_words_regrex": "react is so plain.we have to write bunch of code for small things, so i think react should include all functions (code) of next.js, for one or two functionality we have to change whole framework or make a new project and write whole bunch of code for it and there many opensource frameworks like next.js from which we can borrow functionality and improve react.if you are agree with me, its my pleasure to help you with writing code for it.main functionality i think react should have are in built all 3 types of SSR and file based routing.please reply me soon as possible. thanks in advance",
        "human_words_stopwords_removal_lemmatization": "react plain.we write bunch code small thing , think react include function ( code ) next.js , one two functionality change whole framework make new project write whole bunch code many opensource framework like next.js borrow functionality improve react.if agree , pleasure help writing code it.main functionality think react built 3 type ssr file based routing.please reply soon possible . thanks advance",
        "title_stopwords_removal_lemmatization": "react 18 next.js"
    },
    {
        "issue_id": 975963061,
        "title": "Expecting hasShadowRoot from global scope",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-20T22:40:21Z",
        "status": "open",
        "description": "Think hasShadowRoot was added with a debug flag for ```if (CHROME &&  hasShadowRoot)``` (grepping or acking that should bring you to  the culprit). This breaks Chromium builds in Chrome and Electron.\r\n\r\nFor anyone riding the 18 wave;\r\n\r\n``` \r\n// somehwere above your entry / bundle\r\nglobalThis.hasShadowRoot = () => true\r\n\r\n// preload script electron\r\ncontextBridge.exposeInMainWorld('hasShadowRoot', () => true)\r\n```\r\n\r\nTo be clear; those are just temporary quick fixes to keep 18 juices flowing. Not recommended for actual use.",
        "remove_template_description": "Think hasShadowRoot was added with a debug flag for ```if (CHROME &&  hasShadowRoot)``` (grepping or acking that should bring you to  the culprit). This breaks Chromium builds in Chrome and Electron.    For anyone riding the 18 wave;    ```   // somehwere above your entry / bundle  globalThis.hasShadowRoot = () => true    // preload script electron  contextBridge.exposeInMainWorld('hasShadowRoot', () => true)  ```    To be clear; those are just temporary quick fixes to keep 18 juices flowing. Not recommended for actual use.",
        "human_words": "Think hasShadowRoot was added with a debug flag for  (grepping or acking that should bring you to  the culprit). This breaks Chromium builds in Chrome and Electron.    For anyone riding the 18 wave;        To be clear; those are just temporary quick fixes to keep 18 juices flowing. Not recommended for actual use.",
        "human_words_regrex": "Think hasShadowRoot was added with a debug flag for (grepping or acking that should bring you to the culprit). This breaks Chromium builds in Chrome and Electron. For anyone riding the 18 wave; To be clear; those are just temporary quick fixes to keep 18 juices flowing. Not recommended for actual use.",
        "human_words_stopwords_removal_lemmatization": "think hasshadowroot added debug flag ( grepping acking bring culprit ) . break chromium build chrome electron . anyone riding 18 wave ; clear ; temporary quick fix keep 18 juice flowing . recommended actual use .",
        "title_stopwords_removal_lemmatization": "expecting hasshadowroot global scope"
    },
    {
        "issue_id": 973962114,
        "title": "Standalone DevTools Profiler should work with no connected clients",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Size: Small"
        ],
        "date": "2021-08-18T18:52:43Z",
        "status": "closed",
        "description": "When the standalone DevTools are opened without a running React application, this is what's currently shown:\r\n\r\n<img width=\"912\" alt=\"Screen Shot 2021-08-18 at 1 47 49 PM\" src=\"https://user-images.githubusercontent.com/1285131/129954886-681cfa9f-17dd-4ac0-8989-2e08a0d173fc.png\">\r\n\r\nBeing able to use the standalone app without any connected clients, just to inspect saved profiles, would be a nice to have though. We should move the greeting message / instructions into the Components tab (when there's no connected apps) and let the Profiler be used to import previous profiles.\r\n\r\nNote that doing this will likely require a new prop being passed to the outer DevTools component.",
        "remove_template_description": "When the standalone DevTools are opened without a running React application, this is what's currently shown:    <img width=\"912\" alt=\"Screen Shot 2021-08-18 at 1 47 49 PM\" src=\"https://user-images.githubusercontent.com/1285131/129954886-681cfa9f-17dd-4ac0-8989-2e08a0d173fc.png\">    Being able to use the standalone app without any connected clients, just to inspect saved profiles, would be a nice to have though. We should move the greeting message / instructions into the Components tab (when there's no connected apps) and let the Profiler be used to import previous profiles.    Note that doing this will likely require a new prop being passed to the outer DevTools component.",
        "human_words": "When the standalone DevTools are opened without a running React application, this is what's currently shown:    <img width=\"912\" alt=\"Screen Shot 2021-08-18 at 1 47 49 PM\" src=\"https://user-images.githubusercontent.com/1285131/129954886-681cfa9f-17dd-4ac0-8989-2e08a0d173fc.png\">    Being able to use the standalone app without any connected clients, just to inspect saved profiles, would be a nice to have though. We should move the greeting message / instructions into the Components tab (when there's no connected apps) and let the Profiler be used to import previous profiles.    Note that doing this will likely require a new prop being passed to the outer DevTools component.",
        "human_words_regrex": "When the standalone DevTools are opened without a running React application, this is what's currently shown: <img width=\"912\" alt=\"Screen Shot 2021-08-18 at 1 47 49 PM\" src=\" Being able to use the standalone app without any connected clients, just to inspect saved profiles, would be a nice to have though. We should move the greeting message / instructions into the Components tab (when there's no connected apps) and let the Profiler be used to import previous profiles. Note that doing this will likely require a new prop being passed to the outer DevTools component.",
        "human_words_stopwords_removal_lemmatization": "standalone devtools opened without running react application , 's currently shown : < img width= '' 912 '' alt= '' screen shot 2021-08-18 1 47 49 pm '' src= '' able use standalone app without connected client , inspect saved profile , would nice though . move greeting message / instruction component tab ( 's connected apps ) let profiler used import previous profile . note likely require new prop passed outer devtools component .",
        "title_stopwords_removal_lemmatization": "standalone devtools profiler work connected client"
    },
    {
        "issue_id": 970734689,
        "title": "Scheduling Profiler: Add React Native support",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Size: Medium-Large"
        ],
        "date": "2021-08-13T21:57:26Z",
        "status": "open",
        "description": "The [Scheduling Profiler](https://github.com/reactwg/react-18/discussions/76) currently reads data from an exported Chrome performance profile, including [User Timing API](https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API) marks created by React.\r\n\r\nThe Chrome profile contains native events (e.g. \"click\" events), CPU samples that can be used to display a flame graph of what JavaScript was running at a point in time, and base64 encoded screenshots (if enabled). The User Timing data contains info about when state updates are scheduled, when React renders or commits work, when components suspend, etc. This data is processed together to generate the Scheduler Profiler UI.\r\n\r\nReact Native (or more specifically Hermes) doesn't provide a way for users to record or export this data. (I think CPU sampling can be done somehow but I'm not sure how to access the information.) However even if we _only_ had the React User Timing marks, this would still be useful data to display in the profiler. (We could probably also add markers for React's synthetic events as a replacement for the native events.)\r\n\r\nThis data would need to be collected by something though (a User Timing polyfill for the embedded DevTools backend? some other more explicit API we add that calls through to User Timing API for the browser case and logs in-memory for RN?) and shared from the backend to the frontend.\r\n\r\nWhat about profiling locally? Perhaps the backend could gather this sample and periodically send it (encoded) to the frontend to be exported/downloaded. We'd probably only want to do this if the user started profiling (recording) in the UI. This would require us to add state for the new profiler (since it's currently read-only). But we plan to do this anyway for the browser extension (#22015).\r\n\r\nThis task is a placeholder for researching and proposing a way to add at least basic RN support.",
        "remove_template_description": "The [Scheduling Profiler](https://github.com/reactwg/react-18/discussions/76) currently reads data from an exported Chrome performance profile, including [User Timing API](https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API) marks created by React.    The Chrome profile contains native events (e.g. \"click\" events), CPU samples that can be used to display a flame graph of what JavaScript was running at a point in time, and base64 encoded screenshots (if enabled). The User Timing data contains info about when state updates are scheduled, when React renders or commits work, when components suspend, etc. This data is processed together to generate the Scheduler Profiler UI.    React Native (or more specifically Hermes) doesn't provide a way for users to record or export this data. (I think CPU sampling can be done somehow but I'm not sure how to access the information.) However even if we _only_ had the React User Timing marks, this would still be useful data to display in the profiler. (We could probably also add markers for React's synthetic events as a replacement for the native events.)    This data would need to be collected by something though (a User Timing polyfill for the embedded DevTools backend? some other more explicit API we add that calls through to User Timing API for the browser case and logs in-memory for RN?) and shared from the backend to the frontend.    What about profiling locally? Perhaps the backend could gather this sample and periodically send it (encoded) to the frontend to be exported/downloaded. We'd probably only want to do this if the user started profiling (recording) in the UI. This would require us to add state for the new profiler (since it's currently read-only). But we plan to do this anyway for the browser extension (#22015).    This task is a placeholder for researching and proposing a way to add at least basic RN support.",
        "human_words": "The [Scheduling Profiler](https://github.com/reactwg/react-18/discussions/76) currently reads data from an exported Chrome performance profile, including [User Timing API](https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API) marks created by React.    The Chrome profile contains native events (e.g. \"click\" events), CPU samples that can be used to display a flame graph of what JavaScript was running at a point in time, and base64 encoded screenshots (if enabled). The User Timing data contains info about when state updates are scheduled, when React renders or commits work, when components suspend, etc. This data is processed together to generate the Scheduler Profiler UI.    React Native (or more specifically Hermes) doesn't provide a way for users to record or export this data. (I think CPU sampling can be done somehow but I'm not sure how to access the information.) However even if we _only_ had the React User Timing marks, this would still be useful data to display in the profiler. (We could probably also add markers for React's synthetic events as a replacement for the native events.)    This data would need to be collected by something though (a User Timing polyfill for the embedded DevTools backend? some other more explicit API we add that calls through to User Timing API for the browser case and logs in-memory for RN?) and shared from the backend to the frontend.    What about profiling locally? Perhaps the backend could gather this sample and periodically send it (encoded) to the frontend to be exported/downloaded. We'd probably only want to do this if the user started profiling (recording) in the UI. This would require us to add state for the new profiler (since it's currently read-only). But we plan to do this anyway for the browser extension (#22015).    This task is a placeholder for researching and proposing a way to add at least basic RN support.",
        "human_words_regrex": "The  currently reads data from an exported Chrome performance profile, including  marks created by React. The Chrome profile contains native events (e.g. \"click\" events), CPU samples that can be used to display a flame graph of what JavaScript was running at a point in time, and base64 encoded screenshots (if enabled). The User Timing data contains info about when state updates are scheduled, when React renders or commits work, when components suspend, etc. This data is processed together to generate the Scheduler Profiler UI. React Native (or more specifically Hermes) doesn't provide a way for users to record or export this data. (I think CPU sampling can be done somehow but I'm not sure how to access the information.) However even if we _only_ had the React User Timing marks, this would still be useful data to display in the profiler. (We could probably also add markers for React's synthetic events as a replacement for the native events.) This data would need to be collected by something though (a User Timing polyfill for the embedded DevTools backend? some other more explicit API we add that calls through to User Timing API for the browser case and logs in-memory for RN?) and shared from the backend to the frontend. What about profiling locally? Perhaps the backend could gather this sample and periodically send it (encoded) to the frontend to be exported/downloaded. We'd probably only want to do this if the user started profiling (recording) in the UI. This would require us to add state for the new profiler (since it's currently read-only). But we plan to do this anyway for the browser extension (#22015). This task is a placeholder for researching and proposing a way to add at least basic RN support.",
        "human_words_stopwords_removal_lemmatization": "currently read data exported chrome performance profile , including mark created react . chrome profile contains native event ( e.g . `` click '' event ) , cpu sample used display flame graph javascript running point time , base64 encoded screenshots ( enabled ) . user timing data contains info state update scheduled , react render commits work , component suspend , etc . data processed together generate scheduler profiler ui . react native ( specifically hermes ) n't provide way user record export data . ( think cpu sampling done somehow 'm sure access information . ) however even _only_ react user timing mark , would still useful data display profiler . ( could probably also add marker react 's synthetic event replacement native event . ) data would need collected something though ( user timing polyfill embedded devtools backend ? explicit api add call user timing api browser case log in-memory rn ? ) shared backend frontend . profiling locally ? perhaps backend could gather sample periodically send ( encoded ) frontend exported/downloaded . 'd probably want user started profiling ( recording ) ui . would require u add state new profiler ( since 's currently read-only ) . plan anyway browser extension ( # 22015 ) . task placeholder researching proposing way add least basic rn support .",
        "title_stopwords_removal_lemmatization": "scheduling profiler : add react native support"
    },
    {
        "issue_id": 959092041,
        "title": "Question: Why `propagateContextChanges` not restore the `workInProgress.child.return` pointer?",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-03T13:00:15Z",
        "status": "open",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nThis  is the code from `ReactFiberNewContext.old.js`\r\n\r\nhttps://github.com/facebook/react/blob/19092ac8c354b92c2e0e27b73f391571ad452505/packages/react-reconciler/src/ReactFiberNewContext.old.js#L319-L333\r\n\r\nIn the function `propagateContextChanges` and `propagateContextChange_eager`, the `workInProgress.child.return` is changed in the beginning, but it is not restore in the end.\r\n\r\nIn case of `propagateContextChanges`:\r\n```js\r\nfunction propagateContextChanges<T>(\r\n  workInProgress: Fiber,\r\n  contexts: Array<any>,\r\n  renderLanes: Lanes,\r\n  forcePropagateEntireTree: boolean,\r\n): void {\r\n  // Only used by lazy implemenation\r\n  if (!enableLazyContextPropagation) {\r\n    return;\r\n  }\r\n  let fiber = workInProgress.child;\r\n  if (fiber !== null) {\r\n    //  caution:  before next line , fiber.return is workInProgress.alternate\r\n    fiber.return = workInProgress;\r\n   // after this line, fiber.return = workInProgress\r\n  }\r\n  \r\n  // ... omit the other code\r\n  // but in the end, there is no code to restore the  workInProgress.child.return\r\n  // maybe like this:\r\n  workInProgress.child.return = workInProgress.alternate;\r\n}\r\n\r\n```\r\nI think the `workInProgress.child` is same as `workInProgress.alternate.child` at this time.\r\n\r\nIf the `workInProgress.child.return` not restore, though the `workInProgress tree` is no difference , but maybe the `current tree` is broken?\r\n\r\nI'm confused about it some days, could anyone explain it?",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  This  is the code from `ReactFiberNewContext.old.js`    https://github.com/facebook/react/blob/19092ac8c354b92c2e0e27b73f391571ad452505/packages/react-reconciler/src/ReactFiberNewContext.old.js#L319-L333    In the function `propagateContextChanges` and `propagateContextChange_eager`, the `workInProgress.child.return` is changed in the beginning, but it is not restore in the end.    In case of `propagateContextChanges`:  ```js  function propagateContextChanges<T>(    workInProgress: Fiber,    contexts: Array<any>,    renderLanes: Lanes,    forcePropagateEntireTree: boolean,  ): void {    // Only used by lazy implemenation    if (!enableLazyContextPropagation) {      return;    }    let fiber = workInProgress.child;    if (fiber !== null) {      //  caution:  before next line , fiber.return is workInProgress.alternate      fiber.return = workInProgress;     // after this line, fiber.return = workInProgress    }        // ... omit the other code    // but in the end, there is no code to restore the  workInProgress.child.return    // maybe like this:    workInProgress.child.return = workInProgress.alternate;  }    ```  I think the `workInProgress.child` is same as `workInProgress.alternate.child` at this time.    If the `workInProgress.child.return` not restore, though the `workInProgress tree` is no difference , but maybe the `current tree` is broken?    I'm confused about it some days, could anyone explain it?",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  This  is the code from `ReactFiberNewContext.old.js`    https://github.com/facebook/react/blob/19092ac8c354b92c2e0e27b73f391571ad452505/packages/react-reconciler/src/ReactFiberNewContext.old.js#L319-L333    In the function `propagateContextChanges` and `propagateContextChange_eager`, the `workInProgress.child.return` is changed in the beginning, but it is not restore in the end.    In case of `propagateContextChanges`:    I think the `workInProgress.child` is same as `workInProgress.alternate.child` at this time.    If the `workInProgress.child.return` not restore, though the `workInProgress tree` is no difference , but maybe the `current tree` is broken?    I'm confused about it some days, could anyone explain it?",
        "human_words_regrex": " This is the code from `ReactFiberNewContext.old.js`  In the function `propagateContextChanges` and `propagateContextChange_eager`, the `workInProgress.child.return` is changed in the beginning, but it is not restore in the end. In case of `propagateContextChanges`: I think the `workInProgress.child` is same as `workInProgress.alternate.child` at this time. If the `workInProgress.child.return` not restore, though the `workInProgress tree` is no difference , but maybe the `current tree` is broken? I'm confused about it some days, could anyone explain it?",
        "human_words_stopwords_removal_lemmatization": "code ` reactfibernewcontext.old.js ` function ` propagatecontextchanges ` ` propagatecontextchange_eager ` , ` workinprogress.child.return ` changed beginning , restore end . case ` propagatecontextchanges ` : think ` workinprogress.child ` ` workinprogress.alternate.child ` time . ` workinprogress.child.return ` restore , though ` workinprogress tree ` difference , maybe ` current tree ` broken ? 'm confused day , could anyone explain ?",
        "title_stopwords_removal_lemmatization": "question : ` propagatecontextchanges ` restore ` workinprogress.child.return ` pointer ?"
    },
    {
        "issue_id": 957536061,
        "title": "[Question] useRef usage with concurrent mode",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-01T16:47:09Z",
        "status": "closed",
        "description": "Hi,\r\nI noticed some weird behavior and just want to verify it.\r\n\r\nWhen I wrap my application with `<StrictMode/>` I've some issues were using `useRef` is buggy in one of my hooks (I'm using them only for caching and previous values checks, and there's a state update inside that hook).\r\n\r\nOnce I replace the `useRef` with `useState` with same logic/purpose it works! (With zero additional changes) - It seems like useState can handle multiple render calls and useRef is **really** a mutable that don't care for such a cases.\r\n\r\nI'm aware that this adds some render when updating the state but seems like very stable compared with refs.\r\n\r\nThe questions are:\r\n\r\n1- Is it recommended to `useState` always and to refrain from using `useRef` for future compatibility when state updating is involved?\r\n\r\n2- If not, Does the react team intend on syncing `useRef` to handle such a cases?\r\n\r\nThanks",
        "remove_template_description": "Hi,  I noticed some weird behavior and just want to verify it.    When I wrap my application with `<StrictMode/>` I've some issues were using `useRef` is buggy in one of my hooks (I'm using them only for caching and previous values checks, and there's a state update inside that hook).    Once I replace the `useRef` with `useState` with same logic/purpose it works! (With zero additional changes) - It seems like useState can handle multiple render calls and useRef is **really** a mutable that don't care for such a cases.    I'm aware that this adds some render when updating the state but seems like very stable compared with refs.    The questions are:    1- Is it recommended to `useState` always and to refrain from using `useRef` for future compatibility when state updating is involved?    2- If not, Does the react team intend on syncing `useRef` to handle such a cases?    Thanks",
        "human_words": "Hi,  I noticed some weird behavior and just want to verify it.    When I wrap my application with `<StrictMode/>` I've some issues were using `useRef` is buggy in one of my hooks (I'm using them only for caching and previous values checks, and there's a state update inside that hook).    Once I replace the `useRef` with `useState` with same logic/purpose it works! (With zero additional changes) - It seems like useState can handle multiple render calls and useRef is **really** a mutable that don't care for such a cases.    I'm aware that this adds some render when updating the state but seems like very stable compared with refs.    The questions are:    1- Is it recommended to `useState` always and to refrain from using `useRef` for future compatibility when state updating is involved?    2- If not, Does the react team intend on syncing `useRef` to handle such a cases?    Thanks",
        "human_words_regrex": "Hi, I noticed some weird behavior and just want to verify it. When I wrap my application with `` I've some issues were using `useRef` is buggy in one of my hooks (I'm using them only for caching and previous values checks, and there's a state update inside that hook). Once I replace the `useRef` with `useState` with same logic/purpose it works! (With zero additional changes) - It seems like useState can handle multiple render calls and useRef is **really** a mutable that don't care for such a cases. I'm aware that this adds some render when updating the state but seems like very stable compared with refs. The questions are: 1- Is it recommended to `useState` always and to refrain from using `useRef` for future compatibility when state updating is involved? 2- If not, Does the react team intend on syncing `useRef` to handle such a cases? Thanks",
        "human_words_stopwords_removal_lemmatization": "hi , noticed weird behavior want verify . wrap application `` 've issue using ` useref ` buggy one hook ( 'm using caching previous value check , 's state update inside hook ) . replace ` useref ` ` usestate ` logic/purpose work ! ( zero additional change ) - seems like usestate handle multiple render call useref * * really * * mutable n't care case . 'm aware add render updating state seems like stable compared ref . question : 1- recommended ` usestate ` always refrain using ` useref ` future compatibility state updating involved ? 2- , react team intend syncing ` useref ` handle case ? thanks",
        "title_stopwords_removal_lemmatization": "[ question ] useref usage concurrent mode"
    },
    {
        "issue_id": 957468282,
        "title": "Are you allowed to call setState in the function passed into setState hook.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-08-01T11:35:18Z",
        "status": "closed",
        "description": "<!--\r\nAre you allowed to call setState in the function passed into setState hook?\r\n-->\r\n",
        "remove_template_description": "<!--  Are you allowed to call setState in the function passed into setState hook?  -->",
        "human_words": "<!--  Are you allowed to call setState in the function passed into setState hook?  -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "allowed call setstate function passed setstate hook ."
    },
    {
        "issue_id": 957229701,
        "title": "React 18: useEffect calling twice inside a custom hook",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-31T11:42:19Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\nI'm testing React 18.0.0-alpha-dbe3363cc and get this issue, useEffect callback got to be called twice when passing an empty array ([]) to expect to run an effect and clean it up only once.\r\n\r\nCheck out this code: https://codesandbox.io/s/friendly-firefly-h5noz?file=/src/App.js",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->  I'm testing React 18.0.0-alpha-dbe3363cc and get this issue, useEffect callback got to be called twice when passing an empty array ([]) to expect to run an effect and clean it up only once.    Check out this code: https://codesandbox.io/s/friendly-firefly-h5noz?file=/src/App.js",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->  I'm testing React 18.0.0-alpha-dbe3363cc and get this issue, useEffect callback got to be called twice when passing an empty array ([]) to expect to run an effect and clean it up only once.    Check out this code: https://codesandbox.io/s/friendly-firefly-h5noz?file=/src/App.js",
        "human_words_regrex": " I'm testing React 18.0.0-alpha-dbe3363cc and get this issue, useEffect callback got to be called twice when passing an empty array ([]) to expect to run an effect and clean it up only once. Check out this code: ",
        "human_words_stopwords_removal_lemmatization": "'m testing react 18.0.0-alpha-dbe3363cc get issue , useeffect callback got called twice passing empty array ( [ ] ) expect run effect clean . check code :",
        "title_stopwords_removal_lemmatization": "react 18 : useeffect calling twice inside custom hook"
    },
    {
        "issue_id": 955455833,
        "title": "React CM Mode (18) stacking app during hydrateRoot",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-29T04:52:59Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version: 18.0.0-alpha-9f88b5355-20210728\r\n\r\n## Steps To Reproduce\r\n\r\nSee repo https://github.com/maraisr/react-suspense-repro\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example:\r\n\r\nhttps://github.com/maraisr/react-suspense-repro\r\n\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\n\r\nreact hydrateRoot is stacking dom trees\r\n\r\nwill note here that `Suspense` obviously isnt needed that as nothing is async. I can illustrate here as well if you require a demo with the Suspense needing to do something??\r\n\r\n## The expected behavior\r\n\r\nreact hydrateRoot to not stack dom trees\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: 18.0.0-alpha-9f88b5355-20210728        See repo https://github.com/maraisr/react-suspense-repro    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:    https://github.com/maraisr/react-suspense-repro    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->        react hydrateRoot is stacking dom trees    will note here that `Suspense` obviously isnt needed that as nothing is async. I can illustrate here as well if you require a demo with the Suspense needing to do something??        react hydrateRoot to not stack dom trees",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: 18.0.0-alpha-9f88b5355-20210728        See repo https://github.com/maraisr/react-suspense-repro    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:    https://github.com/maraisr/react-suspense-repro    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->        react hydrateRoot is stacking dom trees    will note here that `Suspense` obviously isnt needed that as nothing is async. I can illustrate here as well if you require a demo with the Suspense needing to do something??        react hydrateRoot to not stack dom trees",
        "human_words_regrex": " React version: 18.0.0-alpha-9f88b5355-20210728 See repo   Link to code example:   react hydrateRoot is stacking dom trees will note here that `Suspense` obviously isnt needed that as nothing is async. I can illustrate here as well if you require a demo with the Suspense needing to do something?? react hydrateRoot to not stack dom trees",
        "human_words_stopwords_removal_lemmatization": "react version : 18.0.0-alpha-9f88b5355-20210728 see repo link code example : react hydrateroot stacking dom tree note ` suspense ` obviously isnt needed nothing async . illustrate well require demo suspense needing something ? ? react hydrateroot stack dom tree",
        "title_stopwords_removal_lemmatization": "react cm mode ( 18 ) stacking app hydrateroot"
    },
    {
        "issue_id": 952645038,
        "title": "React 18: Display release date before relase commit in alpha releases",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-26T08:28:50Z",
        "status": "closed",
        "description": "Using `alpha` as an example the version is generated as `18.0.0-alpha-$COMMIT_SHA-$RELEASE_DATE` (https://github.com/eps1lon/react/blob/355591add41c0f6dad738fdb1b6603e0786b7b4e/scripts/release/utils.js#L78-L80). \r\n\r\nCould we display the `$RELASE_DATE` before the `$COMMIT_SHA` so that sorting the versions like SemVer would (every part separated by a dash is sorted alphanumerically) is useful (sorting commits alphanumerically isn't that useful)? For example, codesandbox offers a dropdown to select the version with the entries sorted. Selecting the most recent version isn't trivial with the current format while using the npm dist tag isn't viable for scenarios where we want to create reproductions.",
        "remove_template_description": "Using `alpha` as an example the version is generated as `18.0.0-alpha-$COMMIT_SHA-$RELEASE_DATE` (https://github.com/eps1lon/react/blob/355591add41c0f6dad738fdb1b6603e0786b7b4e/scripts/release/utils.js#L78-L80).     Could we display the `$RELASE_DATE` before the `$COMMIT_SHA` so that sorting the versions like SemVer would (every part separated by a dash is sorted alphanumerically) is useful (sorting commits alphanumerically isn't that useful)? For example, codesandbox offers a dropdown to select the version with the entries sorted. Selecting the most recent version isn't trivial with the current format while using the npm dist tag isn't viable for scenarios where we want to create reproductions.",
        "human_words": "Using `alpha` as an example the version is generated as `18.0.0-alpha-$COMMIT_SHA-$RELEASE_DATE` (https://github.com/eps1lon/react/blob/355591add41c0f6dad738fdb1b6603e0786b7b4e/scripts/release/utils.js#L78-L80).     Could we display the `$RELASE_DATE` before the `$COMMIT_SHA` so that sorting the versions like SemVer would (every part separated by a dash is sorted alphanumerically) is useful (sorting commits alphanumerically isn't that useful)? For example, codesandbox offers a dropdown to select the version with the entries sorted. Selecting the most recent version isn't trivial with the current format while using the npm dist tag isn't viable for scenarios where we want to create reproductions.",
        "human_words_regrex": "Using `alpha` as an example the version is generated as `18.0.0-alpha-$COMMIT_SHA-$RELEASE_DATE` ( Could we display the `$RELASE_DATE` before the `$COMMIT_SHA` so that sorting the versions like SemVer would (every part separated by a dash is sorted alphanumerically) is useful (sorting commits alphanumerically isn't that useful)? For example, codesandbox offers a dropdown to select the version with the entries sorted. Selecting the most recent version isn't trivial with the current format while using the npm dist tag isn't viable for scenarios where we want to create reproductions.",
        "human_words_stopwords_removal_lemmatization": "using ` alpha ` example version generated ` 18.0.0-alpha- $ commit_sha- $ release_date ` ( could display ` $ relase_date ` ` $ commit_sha ` sorting version like semver would ( every part separated dash sorted alphanumerically ) useful ( sorting commits alphanumerically n't useful ) ? example , codesandbox offer dropdown select version entry sorted . selecting recent version n't trivial current format using npm dist tag n't viable scenario want create reproduction .",
        "title_stopwords_removal_lemmatization": "react 18 : display release date relase commit alpha release"
    },
    {
        "issue_id": 950483404,
        "title": "DevTools: Order of higher-order component badges",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-07-22T09:48:55Z",
        "status": "closed",
        "description": "Given \r\n\r\n```jsx\r\nconst StyleDiv = forwardRef(function Component({ children }, ref) {\r\n  return <div ref={ref}>{children}</div>;\r\n});\r\n\r\nStyleDiv.displayName = `styled(connected(div))`;\r\n```\r\n\r\n-- https://codesandbox.io/s/little-sky-y8h1b?file=/src/App.js\r\n\r\nI would expect that the badges from the display name are prioritized in the component tree.\r\nHowever, devtools currently displays the `ForwardRef` badge first:\r\n\r\n> `div ForwardRef +2`\r\n![Screenshot from 2021-07-22 11-44-32](https://user-images.githubusercontent.com/12292047/126619858-20b3747b-8723-4306-b5b0-13457d8f45e2.png)\r\n\r\nOddly enough, the inline devtools in codesandbox do prioritize the badge from the `displayName` (maybe this regressed?):\r\n\r\n> `div styled +2` ![Screenshot from 2021-07-22 11-45-27](https://user-images.githubusercontent.com/12292047/126620032-bda9ef1a-ab26-4df3-a10c-e0e8c5cfc3d3.png)\r\n\r\n\r\nThere's also an argument to be made that devtools should not display the `ForwardRef` badge to begin with (since we explicitly omitted it in `displayName`). That can be discussed separately but would solve the issue entirely.",
        "remove_template_description": "Given     ```jsx  const StyleDiv = forwardRef(function Component({ children }, ref) {    return <div ref={ref}>{children}</div>;  });    StyleDiv.displayName = `styled(connected(div))`;  ```    -- https://codesandbox.io/s/little-sky-y8h1b?file=/src/App.js    I would expect that the badges from the display name are prioritized in the component tree.  However, devtools currently displays the `ForwardRef` badge first:    > `div ForwardRef +2`  ![Screenshot from 2021-07-22 11-44-32](https://user-images.githubusercontent.com/12292047/126619858-20b3747b-8723-4306-b5b0-13457d8f45e2.png)    Oddly enough, the inline devtools in codesandbox do prioritize the badge from the `displayName` (maybe this regressed?):    > `div styled +2` ![Screenshot from 2021-07-22 11-45-27](https://user-images.githubusercontent.com/12292047/126620032-bda9ef1a-ab26-4df3-a10c-e0e8c5cfc3d3.png)      There's also an argument to be made that devtools should not display the `ForwardRef` badge to begin with (since we explicitly omitted it in `displayName`). That can be discussed separately but would solve the issue entirely.",
        "human_words": "Given         -- https://codesandbox.io/s/little-sky-y8h1b?file=/src/App.js    I would expect that the badges from the display name are prioritized in the component tree.  However, devtools currently displays the `ForwardRef` badge first:    > `div ForwardRef +2`  ![Screenshot from 2021-07-22 11-44-32](https://user-images.githubusercontent.com/12292047/126619858-20b3747b-8723-4306-b5b0-13457d8f45e2.png)    Oddly enough, the inline devtools in codesandbox do prioritize the badge from the `displayName` (maybe this regressed?):    > `div styled +2` ![Screenshot from 2021-07-22 11-45-27](https://user-images.githubusercontent.com/12292047/126620032-bda9ef1a-ab26-4df3-a10c-e0e8c5cfc3d3.png)      There's also an argument to be made that devtools should not display the `ForwardRef` badge to begin with (since we explicitly omitted it in `displayName`). That can be discussed separately but would solve the issue entirely.",
        "human_words_regrex": "Given --  I would expect that the badges from the display name are prioritized in the component tree. However, devtools currently displays the `ForwardRef` badge first: > `div ForwardRef +2` ! Oddly enough, the inline devtools in codesandbox do prioritize the badge from the `displayName` (maybe this regressed?): > `div styled +2` ! There's also an argument to be made that devtools should not display the `ForwardRef` badge to begin with (since we explicitly omitted it in `displayName`). That can be discussed separately but would solve the issue entirely.",
        "human_words_stopwords_removal_lemmatization": "given -- would expect badge display name prioritized component tree . however , devtools currently display ` forwardref ` badge first : > ` div forwardref +2 ` ! oddly enough , inline devtools codesandbox prioritize badge ` displayname ` ( maybe regressed ? ) : > ` div styled +2 ` ! 's also argument made devtools display ` forwardref ` badge begin ( since explicitly omitted ` displayname ` ) . discussed separately would solve issue entirely .",
        "title_stopwords_removal_lemmatization": "devtools : order higher-order component badge"
    },
    {
        "issue_id": 947633743,
        "title": "Bug: Potential bug in \u201cofficial\u201d useInterval example",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2021-07-19T13:06:30Z",
        "status": "closed",
        "description": "Maybe this is not a bug of react, but this is related to a blog post by react team member; many people have probably read or used that post.\r\nThe bug is explained here: https://stackoverflow.com/questions/68407187/potential-bug-in-official-useinterval-example\r\nI think feedback from react team would be useful. ",
        "remove_template_description": "Maybe this is not a bug of react, but this is related to a blog post by react team member; many people have probably read or used that post.  The bug is explained here: https://stackoverflow.com/questions/68407187/potential-bug-in-official-useinterval-example  I think feedback from react team would be useful.",
        "human_words": "Maybe this is not a bug of react, but this is related to a blog post by react team member; many people have probably read or used that post.  The bug is explained here: https://stackoverflow.com/questions/68407187/potential-bug-in-official-useinterval-example  I think feedback from react team would be useful.",
        "human_words_regrex": "Maybe this is not a bug of react, but this is related to a blog post by react team member; many people have probably read or used that post. The bug is explained here:  I think feedback from react team would be useful.",
        "human_words_stopwords_removal_lemmatization": "maybe bug react , related blog post react team member ; many people probably read used post . bug explained : think feedback react team would useful .",
        "title_stopwords_removal_lemmatization": "bug : potential bug \u201c official \u201d useinterval example"
    },
    {
        "issue_id": 947461653,
        "title": "Discussion: break up `import()` that are NOT doing ES import work ?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-07-19T09:32:33Z",
        "status": "closed",
        "description": "# Background information\r\n\r\nI have been developing a [fimga](https://www.figma.com/) plugin and recently get an exact error as described in https://github.com/figma/plugin-typings/issues/36. The root cause is that the [Secure ECMAScript (SES)](https://github.com/endojs/endo/tree/master/packages/ses) in figma tries to block any instances of the `dynamic import expression` in the code being evaluated. However, The SES shim doesn't use a full parser, so they can't tell precisely when the evaluated code contains a real import, but they do employ a regular expression to spot anything that might be a real import expression. The regular expression used is [`new RegExp('(^|[^.])\\\\bimport(\\\\s*(?:\\\\(|/[/*]))', 'g')`](https://github.com/endojs/endo/blob/master/packages/ses/src/transforms.js#L105), which matches the string `import()` in [Reactlazy.js](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91). Therefore, it's identified as a `dynamic import expression`, resulting in a false positive.\r\n\r\nThe discussion I would like to bring up is: whether the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) should be be broken up, as what has been done in [`React.lazy.js`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L94)? Though `import()` doesn't look like a valid Javascript import statement, it does lead to some confusion for some platforms (E.g. figma) which don't have a strict validation. And it seems there is no harm if the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) is also broken up?\r\n\r\n",
        "remove_template_description": "# Background information    I have been developing a [fimga](https://www.figma.com/) plugin and recently get an exact error as described in https://github.com/figma/plugin-typings/issues/36. The root cause is that the [Secure ECMAScript (SES)](https://github.com/endojs/endo/tree/master/packages/ses) in figma tries to block any instances of the `dynamic import expression` in the code being evaluated. However, The SES shim doesn't use a full parser, so they can't tell precisely when the evaluated code contains a real import, but they do employ a regular expression to spot anything that might be a real import expression. The regular expression used is [`new RegExp('(^|[^.])\\\\bimport(\\\\s*(?:\\\\(|/[/*]))', 'g')`](https://github.com/endojs/endo/blob/master/packages/ses/src/transforms.js#L105), which matches the string `import()` in [Reactlazy.js](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91). Therefore, it's identified as a `dynamic import expression`, resulting in a false positive.    The discussion I would like to bring up is: whether the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) should be be broken up, as what has been done in [`React.lazy.js`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L94)? Though `import()` doesn't look like a valid Javascript import statement, it does lead to some confusion for some platforms (E.g. figma) which don't have a strict validation. And it seems there is no harm if the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) is also broken up?",
        "human_words": "# Background information    I have been developing a [fimga](https://www.figma.com/) plugin and recently get an exact error as described in https://github.com/figma/plugin-typings/issues/36. The root cause is that the [Secure ECMAScript (SES)](https://github.com/endojs/endo/tree/master/packages/ses) in figma tries to block any instances of the `dynamic import expression` in the code being evaluated. However, The SES shim doesn't use a full parser, so they can't tell precisely when the evaluated code contains a real import, but they do employ a regular expression to spot anything that might be a real import expression. The regular expression used is [`new RegExp('(^|[^.])\\\\bimport(\\\\s*(?:\\\\(|/[/*]))', 'g')`](https://github.com/endojs/endo/blob/master/packages/ses/src/transforms.js#L105), which matches the string `import()` in [Reactlazy.js](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91). Therefore, it's identified as a `dynamic import expression`, resulting in a false positive.    The discussion I would like to bring up is: whether the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) should be be broken up, as what has been done in [`React.lazy.js`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L94)? Though `import()` doesn't look like a valid Javascript import statement, it does lead to some confusion for some platforms (E.g. figma) which don't have a strict validation. And it seems there is no harm if the [`import()`](https://github.com/facebook/react/blob/HEAD/packages/react/src/ReactLazy.js#L91) is also broken up?",
        "human_words_regrex": "# Background information I have been developing a  plugin and recently get an exact error as described in  The root cause is that the  in figma tries to block any instances of the `dynamic import expression` in the code being evaluated. However, The SES shim doesn't use a full parser, so they can't tell precisely when the evaluated code contains a real import, but they do employ a regular expression to spot anything that might be a real import expression. The regular expression used is , which matches the string `import()` in . Therefore, it's identified as a `dynamic import expression`, resulting in a false positive. The discussion I would like to bring up is: whether the  should be be broken up, as what has been done in ? Though `import()` doesn't look like a valid Javascript import statement, it does lead to some confusion for some platforms (E.g. figma) which don't have a strict validation. And it seems there is no harm if the  is also broken up?",
        "human_words_stopwords_removal_lemmatization": "# background information developing plugin recently get exact error described root cause figma try block instance ` dynamic import expression ` code evaluated . however , s shim n't use full parser , ca n't tell precisely evaluated code contains real import , employ regular expression spot anything might real import expression . regular expression used , match string ` import ( ) ` . therefore , 's identified ` dynamic import expression ` , resulting false positive . discussion would like bring : whether broken , done ? though ` import ( ) ` n't look like valid javascript import statement , lead confusion platform ( e.g . figma ) n't strict validation . seems harm also broken ?",
        "title_stopwords_removal_lemmatization": "discussion : break ` import ( ) ` e import work ?"
    },
    {
        "issue_id": 946836619,
        "title": "React 18 let's make ref.currant to be reactive value",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-17T14:39:21Z",
        "status": "open",
        "description": "Let's add this hook as part of the core. Since this is a common need, many people often ask the question \"Why does useEffect not sense ref.current changes?\"\r\n\r\n```js\r\n// approximate implementation\r\nconst useReactiveRef = (defaultValue) => {\r\n  const [current, ref] = useState(defaultValue)\r\n  ref.current = current\r\n  return ref\r\n}\r\n```\r\n\r\nUsage example:\r\n```js\r\nconst Component = () => {\r\n  const ref = React.useReactiveRef()\r\n\r\n  useEffect(() => {\r\n    // ref.current now is reactive\r\n    console.log(ref.current)\r\n  }, [ref.current])\r\n\r\n  return <div ref={ref}></div>\r\n}\r\n```\r\n",
        "remove_template_description": "Let's add this hook as part of the core. Since this is a common need, many people often ask the question \"Why does useEffect not sense ref.current changes?\"    ```js  // approximate implementation  const useReactiveRef = (defaultValue) => {    const [current, ref] = useState(defaultValue)    ref.current = current    return ref  }  ```    Usage example:  ```js  const Component = () => {    const ref = React.useReactiveRef()      useEffect(() => {      // ref.current now is reactive      console.log(ref.current)    }, [ref.current])      return <div ref={ref}></div>  }  ```",
        "human_words": "Let's add this hook as part of the core. Since this is a common need, many people often ask the question \"Why does useEffect not sense ref.current changes?\"        Usage example:  ",
        "human_words_regrex": "Let's add this hook as part of the core. Since this is a common need, many people often ask the question \"Why does useEffect not sense ref.current changes?\" Usage example: ",
        "human_words_stopwords_removal_lemmatization": "let 's add hook part core . since common need , many people often ask question `` useeffect sense ref.current change ? '' usage example :",
        "title_stopwords_removal_lemmatization": "react 18 let 's make ref.currant reactive value"
    },
    {
        "issue_id": 944352954,
        "title": "[React 18] Bug: `Maximum update depth exceeded` on the `ref` prop when suspending",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-14T11:58:30Z",
        "status": "closed",
        "description": "Functional `ref` prop throws a `Maximum update depth exceeded` error when suspending.\r\n\r\nReact version: `18.0.0-alpha-464f27572-20210713`\r\n\r\n## Steps To Reproduce\r\n\r\n1. Click on the `suspend` button: https://codesandbox.io/s/ref-set-too-many-times-jm0c3?file=/src/App.js.\r\n\r\n## The current behavior\r\n\r\nClicking on the `suspend` button throws a `Maximum update depth exceeded` error.\r\n\r\n## The expected behavior\r\n\r\nClicking on the `suspend` button suspends.",
        "remove_template_description": "Functional `ref` prop throws a `Maximum update depth exceeded` error when suspending.    React version: `18.0.0-alpha-464f27572-20210713`        1. Click on the `suspend` button: https://codesandbox.io/s/ref-set-too-many-times-jm0c3?file=/src/App.js.        Clicking on the `suspend` button throws a `Maximum update depth exceeded` error.        Clicking on the `suspend` button suspends.",
        "human_words": "Functional `ref` prop throws a `Maximum update depth exceeded` error when suspending.    React version: `18.0.0-alpha-464f27572-20210713`        1. Click on the `suspend` button: https://codesandbox.io/s/ref-set-too-many-times-jm0c3?file=/src/App.js.        Clicking on the `suspend` button throws a `Maximum update depth exceeded` error.        Clicking on the `suspend` button suspends.",
        "human_words_regrex": "Functional `ref` prop throws a `Maximum update depth exceeded` error when suspending. React version: `18.0.0-alpha-464f27572-20210713` 1. Click on the `suspend` button:  Clicking on the `suspend` button throws a `Maximum update depth exceeded` error. Clicking on the `suspend` button suspends.",
        "human_words_stopwords_removal_lemmatization": "functional ` ref ` prop throw ` maximum update depth exceeded ` error suspending . react version : ` 18.0.0-alpha-464f27572-20210713 ` 1. click ` suspend ` button : clicking ` suspend ` button throw ` maximum update depth exceeded ` error . clicking ` suspend ` button suspends .",
        "title_stopwords_removal_lemmatization": "[ react 18 ] bug : ` maximum update depth exceeded ` ` ref ` prop suspending"
    },
    {
        "issue_id": 940790936,
        "title": "Strict effects and unmounted ref flag",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-09T13:57:58Z",
        "status": "closed",
        "description": "Posting this issue to share a common phenomenon related to strict effect, I have created a sandbox to demonstrate this issue: https://codesandbox.io/s/unmount-guard-in-strict-effect-5eneb?file=/src/App.js\r\n\r\nPreviously this is a common practice to have a `unmounted` ref indicating whether current component is unmounted, and to prevent calls to `setState` after unmount in order to get rid of those ugly console warnings.\r\n\r\nWith react 18's strict effect, the intentional \"mount -> unmount -> mount\" steps may break some unmounted ref implements, the [ahooks implementation](https://github.com/alibaba/hooks/blob/7b026c03dde61449b051bb63ba68507115227cda/packages/hooks/src/useUnmountedRef/index.ts) is incorrect while the [react-use implement](https://github.com/streamich/react-use/blob/90e72a5340460816e2159b2c461254661b00e1d3/src/useMountedState.ts) is correct.\r\n\r\nWe can simply fix it by \"revive\" this ref in mount effect:\r\n\r\n```\r\nconst unmounted = useRef(false);\r\nuseEffect(\r\n  () => {\r\n    // Add this line!\r\n    unmounted.current = false;\r\n    return () => {\r\n      unmounted.current = true;\r\n    };\r\n  },\r\n  []\r\n);\r\n```\r\n\r\nStill, I have 3 questions related to this:\r\n\r\n1. In real world concurrent mode, is there a chance that `fakeFetch` may resolve after component is unmounted and before it is remounted?\r\n2. Is this mean that we **should not** guard our `setState` calls with an unmounted ref flag? Maybe simply allow `setState` on an \"unmounted\" component can perfectly fix this problem.\r\n3. Since we don't want to cancel fetch in unmount (maybe this is a side effect, or duplicated request can hit performance), is there any recommended practice to handle such situations?\r\n",
        "remove_template_description": "Posting this issue to share a common phenomenon related to strict effect, I have created a sandbox to demonstrate this issue: https://codesandbox.io/s/unmount-guard-in-strict-effect-5eneb?file=/src/App.js    Previously this is a common practice to have a `unmounted` ref indicating whether current component is unmounted, and to prevent calls to `setState` after unmount in order to get rid of those ugly console warnings.    With react 18's strict effect, the intentional \"mount -> unmount -> mount\" steps may break some unmounted ref implements, the [ahooks implementation](https://github.com/alibaba/hooks/blob/7b026c03dde61449b051bb63ba68507115227cda/packages/hooks/src/useUnmountedRef/index.ts) is incorrect while the [react-use implement](https://github.com/streamich/react-use/blob/90e72a5340460816e2159b2c461254661b00e1d3/src/useMountedState.ts) is correct.    We can simply fix it by \"revive\" this ref in mount effect:    ```  const unmounted = useRef(false);  useEffect(    () => {      // Add this line!      unmounted.current = false;      return () => {        unmounted.current = true;      };    },    []  );  ```    Still, I have 3 questions related to this:    1. In real world concurrent mode, is there a chance that `fakeFetch` may resolve after component is unmounted and before it is remounted?  2. Is this mean that we **should not** guard our `setState` calls with an unmounted ref flag? Maybe simply allow `setState` on an \"unmounted\" component can perfectly fix this problem.  3. Since we don't want to cancel fetch in unmount (maybe this is a side effect, or duplicated request can hit performance), is there any recommended practice to handle such situations?",
        "human_words": "Posting this issue to share a common phenomenon related to strict effect, I have created a sandbox to demonstrate this issue: https://codesandbox.io/s/unmount-guard-in-strict-effect-5eneb?file=/src/App.js    Previously this is a common practice to have a `unmounted` ref indicating whether current component is unmounted, and to prevent calls to `setState` after unmount in order to get rid of those ugly console warnings.    With react 18's strict effect, the intentional \"mount -> unmount -> mount\" steps may break some unmounted ref implements, the [ahooks implementation](https://github.com/alibaba/hooks/blob/7b026c03dde61449b051bb63ba68507115227cda/packages/hooks/src/useUnmountedRef/index.ts) is incorrect while the [react-use implement](https://github.com/streamich/react-use/blob/90e72a5340460816e2159b2c461254661b00e1d3/src/useMountedState.ts) is correct.    We can simply fix it by \"revive\" this ref in mount effect:        Still, I have 3 questions related to this:    1. In real world concurrent mode, is there a chance that `fakeFetch` may resolve after component is unmounted and before it is remounted?  2. Is this mean that we **should not** guard our `setState` calls with an unmounted ref flag? Maybe simply allow `setState` on an \"unmounted\" component can perfectly fix this problem.  3. Since we don't want to cancel fetch in unmount (maybe this is a side effect, or duplicated request can hit performance), is there any recommended practice to handle such situations?",
        "human_words_regrex": "Posting this issue to share a common phenomenon related to strict effect, I have created a sandbox to demonstrate this issue:  Previously this is a common practice to have a `unmounted` ref indicating whether current component is unmounted, and to prevent calls to `setState` after unmount in order to get rid of those ugly console warnings. With react 18's strict effect, the intentional \"mount -> unmount -> mount\" steps may break some unmounted ref implements, the  is incorrect while the  is correct. We can simply fix it by \"revive\" this ref in mount effect: Still, I have 3 questions related to this: 1. In real world concurrent mode, is there a chance that `fakeFetch` may resolve after component is unmounted and before it is remounted? 2. Is this mean that we **should not** guard our `setState` calls with an unmounted ref flag? Maybe simply allow `setState` on an \"unmounted\" component can perfectly fix this problem. 3. Since we don't want to cancel fetch in unmount (maybe this is a side effect, or duplicated request can hit performance), is there any recommended practice to handle such situations?",
        "human_words_stopwords_removal_lemmatization": "posting issue share common phenomenon related strict effect , created sandbox demonstrate issue : previously common practice ` unmounted ` ref indicating whether current component unmounted , prevent call ` setstate ` unmount order get rid ugly console warning . react 18 's strict effect , intentional `` mount - > unmount - > mount '' step may break unmounted ref implement , incorrect correct . simply fix `` revive '' ref mount effect : still , 3 question related : 1. real world concurrent mode , chance ` fakefetch ` may resolve component unmounted remounted ? 2. mean * * * * guard ` setstate ` call unmounted ref flag ? maybe simply allow ` setstate ` `` unmounted '' component perfectly fix problem . 3. since n't want cancel fetch unmount ( maybe side effect , duplicated request hit performance ) , recommended practice handle situation ?",
        "title_stopwords_removal_lemmatization": "strict effect unmounted ref flag"
    },
    {
        "issue_id": 938694344,
        "title": "useEffect in React 18 (StrictMode) gets called twice.",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-07T09:38:07Z",
        "status": "closed",
        "description": "Why is useEffect called twice in React 18 with StrictMode (if I set deps to be an empty array)?\r\n\r\nExpected behavior: \r\n![image](https://user-images.githubusercontent.com/84848052/124736513-bfd01f00-df1f-11eb-9212-847d74acdf18.png)\r\n\r\nStrange behavior:\r\n![image](https://user-images.githubusercontent.com/84848052/124736688-eb530980-df1f-11eb-9e7d-fe17d91d8a98.png)\r\n\r\nExamples:\r\nExpected behavior in React 17: https://codesandbox.io/s/react-17-useeffect-mud1l\r\nExpected behavior in React 18 without StrictMode: https://codesandbox.io/s/react-18-useeffect-without-strict-mode-g788s\r\nStrange behavior in React 18 with StrictMode: https://codesandbox.io/s/react-18-useeffect-2d14y\r\n",
        "remove_template_description": "Why is useEffect called twice in React 18 with StrictMode (if I set deps to be an empty array)?    Expected behavior:   ![image](https://user-images.githubusercontent.com/84848052/124736513-bfd01f00-df1f-11eb-9212-847d74acdf18.png)    Strange behavior:  ![image](https://user-images.githubusercontent.com/84848052/124736688-eb530980-df1f-11eb-9e7d-fe17d91d8a98.png)    Examples:  Expected behavior in React 17: https://codesandbox.io/s/react-17-useeffect-mud1l  Expected behavior in React 18 without StrictMode: https://codesandbox.io/s/react-18-useeffect-without-strict-mode-g788s  Strange behavior in React 18 with StrictMode: https://codesandbox.io/s/react-18-useeffect-2d14y",
        "human_words": "Why is useEffect called twice in React 18 with StrictMode (if I set deps to be an empty array)?    Expected behavior:   ![image](https://user-images.githubusercontent.com/84848052/124736513-bfd01f00-df1f-11eb-9212-847d74acdf18.png)    Strange behavior:  ![image](https://user-images.githubusercontent.com/84848052/124736688-eb530980-df1f-11eb-9e7d-fe17d91d8a98.png)    Examples:  Expected behavior in React 17: https://codesandbox.io/s/react-17-useeffect-mud1l  Expected behavior in React 18 without StrictMode: https://codesandbox.io/s/react-18-useeffect-without-strict-mode-g788s  Strange behavior in React 18 with StrictMode: https://codesandbox.io/s/react-18-useeffect-2d14y",
        "human_words_regrex": "Why is useEffect called twice in React 18 with StrictMode (if I set deps to be an empty array)? Expected behavior: ! Strange behavior: ! Examples: Expected behavior in React 17:  Expected behavior in React 18 without StrictMode:  Strange behavior in React 18 with StrictMode: ",
        "human_words_stopwords_removal_lemmatization": "useeffect called twice react 18 strictmode ( set deps empty array ) ? expected behavior : ! strange behavior : ! example : expected behavior react 17 : expected behavior react 18 without strictmode : strange behavior react 18 strictmode :",
        "title_stopwords_removal_lemmatization": "useeffect react 18 ( strictmode ) get called twice ."
    },
    {
        "issue_id": 938255509,
        "title": "React 17/18 custom Synthetic Events",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-06T20:59:28Z",
        "status": "open",
        "description": "The Previous solution in #10135 no longer works for React 17 or React 18.\r\n\r\nIt would be really convenient to be able to craft events that react handles for custom inputs.\r\n\r\ne.g. I have an accordion component and would like to add the ability to use it as an input, when the user clicks a button I'd like to dispatch a change event so their handlers get called. ",
        "remove_template_description": "The Previous solution in #10135 no longer works for React 17 or React 18.    It would be really convenient to be able to craft events that react handles for custom inputs.    e.g. I have an accordion component and would like to add the ability to use it as an input, when the user clicks a button I'd like to dispatch a change event so their handlers get called.",
        "human_words": "The Previous solution in #10135 no longer works for React 17 or React 18.    It would be really convenient to be able to craft events that react handles for custom inputs.    e.g. I have an accordion component and would like to add the ability to use it as an input, when the user clicks a button I'd like to dispatch a change event so their handlers get called.",
        "human_words_regrex": "The Previous solution in #10135 no longer works for React 17 or React 18. It would be really convenient to be able to craft events that react handles for custom inputs. e.g. I have an accordion component and would like to add the ability to use it as an input, when the user clicks a button I'd like to dispatch a change event so their handlers get called.",
        "human_words_stopwords_removal_lemmatization": "previous solution # 10135 longer work react 17 react 18. would really convenient able craft event react handle custom input . e.g . accordion component would like add ability use input , user click button 'd like dispatch change event handler get called .",
        "title_stopwords_removal_lemmatization": "react 17/18 custom synthetic event"
    },
    {
        "issue_id": 938158389,
        "title": "State updated properly, DOM not updated accordingly",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-06T18:35:28Z",
        "status": "closed",
        "description": "### Why is the last sibling component being deleted instead of the desired one?\r\n\r\nI created a component called `Node` which has a state with two properties: `name` and `children`. `name` stores the `Node`'s name and `children` stores the child `Node`s. You can add children and nest them, but when you try to delete one, it always deletes the last *sibling* `Node` instead.\r\n\r\n#### NOTE \r\n> In the React DevTools component tab, the state updates properly and the desired child is deleted from the `children` property of the `Node`'s state, but on the DOM, the *last sibling* is deleted whereas the one desired to be deleted is not.\r\n\r\n### Screenshots :computer: \r\n![github-react-node-children-issue](https://user-images.githubusercontent.com/60361305/124649654-667fd580-deb6-11eb-86f3-5bd4af7d0ba4.png)\r\nAs seen, state updates properly, removing the **child 1** `Node`, but the DOM updates differently, removing the **child 3** `Node`, which is the *last sibling*\r\n\r\n### [CodeSandbox link](https://codesandbox.io/s/quirky-greider-p6g72?file=/src/components/Node.jsx) :link:\r\n\r\n### Reproduce\r\n- [ ] Open the sandbox\r\n- [ ] Create some child `Node`s by clicking on `+` button\r\n- [ ] Name each child `Node` differently by typing the name in the textfield saying \"Node name\"\r\n- [ ] Try to delete any child that is not the *last sibling*, by clicking the `-` button near the respective textfield\r\n- You will notice that the *last sibling* `Node` gets removed instead of the desired `Node`",
        "remove_template_description": "### Why is the last sibling component being deleted instead of the desired one?    I created a component called `Node` which has a state with two properties: `name` and `children`. `name` stores the `Node`'s name and `children` stores the child `Node`s. You can add children and nest them, but when you try to delete one, it always deletes the last *sibling* `Node` instead.    #### NOTE   > In the React DevTools component tab, the state updates properly and the desired child is deleted from the `children` property of the `Node`'s state, but on the DOM, the *last sibling* is deleted whereas the one desired to be deleted is not.    ### Screenshots :computer:   ![github-react-node-children-issue](https://user-images.githubusercontent.com/60361305/124649654-667fd580-deb6-11eb-86f3-5bd4af7d0ba4.png)  As seen, state updates properly, removing the **child 1** `Node`, but the DOM updates differently, removing the **child 3** `Node`, which is the *last sibling*    ### [CodeSandbox link](https://codesandbox.io/s/quirky-greider-p6g72?file=/src/components/Node.jsx) :link:    ### Reproduce  - [ ] Open the sandbox  - [ ] Create some child `Node`s by clicking on `+` button  - [ ] Name each child `Node` differently by typing the name in the textfield saying \"Node name\"  - [ ] Try to delete any child that is not the *last sibling*, by clicking the `-` button near the respective textfield  - You will notice that the *last sibling* `Node` gets removed instead of the desired `Node`",
        "human_words": "### Why is the last sibling component being deleted instead of the desired one?    I created a component called `Node` which has a state with two properties: `name` and `children`. `name` stores the `Node`'s name and `children` stores the child `Node`s. You can add children and nest them, but when you try to delete one, it always deletes the last *sibling* `Node` instead.    #### NOTE   > In the React DevTools component tab, the state updates properly and the desired child is deleted from the `children` property of the `Node`'s state, but on the DOM, the *last sibling* is deleted whereas the one desired to be deleted is not.    ### Screenshots :computer:   ![github-react-node-children-issue](https://user-images.githubusercontent.com/60361305/124649654-667fd580-deb6-11eb-86f3-5bd4af7d0ba4.png)  As seen, state updates properly, removing the **child 1** `Node`, but the DOM updates differently, removing the **child 3** `Node`, which is the *last sibling*    ### [CodeSandbox link](https://codesandbox.io/s/quirky-greider-p6g72?file=/src/components/Node.jsx) :link:    ### Reproduce  - [ ] Open the sandbox  - [ ] Create some child `Node`s by clicking on `+` button  - [ ] Name each child `Node` differently by typing the name in the textfield saying \"Node name\"  - [ ] Try to delete any child that is not the *last sibling*, by clicking the `-` button near the respective textfield  - You will notice that the *last sibling* `Node` gets removed instead of the desired `Node`",
        "human_words_regrex": "### Why is the last sibling component being deleted instead of the desired one? I created a component called `Node` which has a state with two properties: `name` and `children`. `name` stores the `Node`'s name and `children` stores the child `Node`s. You can add children and nest them, but when you try to delete one, it always deletes the last *sibling* `Node` instead. #### NOTE > In the React DevTools component tab, the state updates properly and the desired child is deleted from the `children` property of the `Node`'s state, but on the DOM, the *last sibling* is deleted whereas the one desired to be deleted is not. ### Screenshots :computer: ! As seen, state updates properly, removing the **child 1** `Node`, but the DOM updates differently, removing the **child 3** `Node`, which is the *last sibling* ###  :link: ### Reproduce - [ ] Open the sandbox - [ ] Create some child `Node`s by clicking on `+` button - [ ] Name each child `Node` differently by typing the name in the textfield saying \"Node name\" - [ ] Try to delete any child that is not the *last sibling*, by clicking the `-` button near the respective textfield - You will notice that the *last sibling* `Node` gets removed instead of the desired `Node`",
        "human_words_stopwords_removal_lemmatization": "# # # last sibling component deleted instead desired one ? created component called ` node ` state two property : ` name ` ` child ` . ` name ` store ` node ` 's name ` child ` store child ` node ` . add child nest , try delete one , always deletes last * sibling * ` node ` instead . # # # # note > react devtools component tab , state update properly desired child deleted ` child ` property ` node ` 's state , dom , * last sibling * deleted whereas one desired deleted . # # # screenshots : computer : ! seen , state update properly , removing * * child 1 * * ` node ` , dom update differently , removing * * child 3 * * ` node ` , * last sibling * # # # : link : # # # reproduce - [ ] open sandbox - [ ] create child ` node ` clicking ` + ` button - [ ] name child ` node ` differently typing name textfield saying `` node name '' - [ ] try delete child * last sibling * , clicking ` - ` button near respective textfield - notice * last sibling * ` node ` get removed instead desired ` node `",
        "title_stopwords_removal_lemmatization": "state updated properly , dom updated accordingly"
    },
    {
        "issue_id": 935821343,
        "title": "React 18  Feature request",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-02T14:27:07Z",
        "status": "closed",
        "description": "Make native component's property types importable for developer to be able to extend his/hers components.\r\n\r\ne.g\r\n\r\n```javascript\r\nconst MyInputComponent = (props) => {\r\n   return (\r\n       <>\r\n          // my other things\r\n          <input {...props}/>\r\n      </>\r\n   )\r\n}\r\n\r\nMyInputComponent.propTypes = {\r\n     ....nativeReactJSXInputProps, // importable from react core\r\n     myProp1: PropTypes.string\r\n}\r\n```\r\nThe goal is to assist IDE(s) to find all correct prop types of my component.",
        "remove_template_description": "Make native component's property types importable for developer to be able to extend his/hers components.    e.g    ```javascript  const MyInputComponent = (props) => {     return (         <>            // my other things            <input {...props}/>        </>     )  }    MyInputComponent.propTypes = {       ....nativeReactJSXInputProps, // importable from react core       myProp1: PropTypes.string  }  ```  The goal is to assist IDE(s) to find all correct prop types of my component.",
        "human_words": "Make native component's property types importable for developer to be able to extend his/hers components.    e.g      The goal is to assist IDE(s) to find all correct prop types of my component.",
        "human_words_regrex": "Make native component's property types importable for developer to be able to extend his/hers components. e.g The goal is to assist IDE(s) to find all correct prop types of my component.",
        "human_words_stopwords_removal_lemmatization": "make native component 's property type importable developer able extend his/hers component . e.g goal assist ide ( ) find correct prop type component .",
        "title_stopwords_removal_lemmatization": "react 18 feature request"
    },
    {
        "issue_id": 935436824,
        "title": "React 18 Enable Better ES6 Class Integration With Hooks",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-07-02T05:44:05Z",
        "status": "closed",
        "description": "# Problem Statement\r\nOne of the hardest part of working with javascript over the years has been keeping dealing with version support and change over time of third party code. It seems like react 18 is going to focus on performance and server side viewing framework.  **However, one of the big divides in many products, components and libraries is using ES6 Classes vs Purely Functional Components.** \r\n\r\n# Timing Details\r\nIn past versions of react life cycle methods required use of classes. Modern javascript can use hoisting to make functional components faster to load. However, class components are also more consistent with larger market share of developers. The main motivation behind hooks in react though was to enable code to be branched and worked on more independently and by concurrent developers. Right now, functional components are seen as a place to make things faster but es class components are still considered ok. \r\n\r\n# Future Outlook\r\nIn the future hooks are likely to grow, developers who are use to older versions of react or who are use to OOP are likely to prefer class components, leading to lots of react code styles in lots of ways. This may make maintenance and community packages more likely to break as future versions of react try to take advantage of browsers IDL's and ECMA advancements.  React 18 is also likely to add more of a footprint and more use cases. React native should also be considered, as more and more companies find value in javascript.  Overall the community effect and the maintenance of react is likely to get harder and not easier, but the sooner es6 class components and functional components patterns  can be well defined the more developers can adjust. \r\n",
        "remove_template_description": "# Problem Statement  One of the hardest part of working with javascript over the years has been keeping dealing with version support and change over time of third party code. It seems like react 18 is going to focus on performance and server side viewing framework.  **However, one of the big divides in many products, components and libraries is using ES6 Classes vs Purely Functional Components.**     # Timing Details  In past versions of react life cycle methods required use of classes. Modern javascript can use hoisting to make functional components faster to load. However, class components are also more consistent with larger market share of developers. The main motivation behind hooks in react though was to enable code to be branched and worked on more independently and by concurrent developers. Right now, functional components are seen as a place to make things faster but es class components are still considered ok.     # Future Outlook  In the future hooks are likely to grow, developers who are use to older versions of react or who are use to OOP are likely to prefer class components, leading to lots of react code styles in lots of ways. This may make maintenance and community packages more likely to break as future versions of react try to take advantage of browsers IDL's and ECMA advancements.  React 18 is also likely to add more of a footprint and more use cases. React native should also be considered, as more and more companies find value in javascript.  Overall the community effect and the maintenance of react is likely to get harder and not easier, but the sooner es6 class components and functional components patterns  can be well defined the more developers can adjust.",
        "human_words": "# Problem Statement  One of the hardest part of working with javascript over the years has been keeping dealing with version support and change over time of third party code. It seems like react 18 is going to focus on performance and server side viewing framework.  **However, one of the big divides in many products, components and libraries is using ES6 Classes vs Purely Functional Components.**     # Timing Details  In past versions of react life cycle methods required use of classes. Modern javascript can use hoisting to make functional components faster to load. However, class components are also more consistent with larger market share of developers. The main motivation behind hooks in react though was to enable code to be branched and worked on more independently and by concurrent developers. Right now, functional components are seen as a place to make things faster but es class components are still considered ok.     # Future Outlook  In the future hooks are likely to grow, developers who are use to older versions of react or who are use to OOP are likely to prefer class components, leading to lots of react code styles in lots of ways. This may make maintenance and community packages more likely to break as future versions of react try to take advantage of browsers IDL's and ECMA advancements.  React 18 is also likely to add more of a footprint and more use cases. React native should also be considered, as more and more companies find value in javascript.  Overall the community effect and the maintenance of react is likely to get harder and not easier, but the sooner es6 class components and functional components patterns  can be well defined the more developers can adjust.",
        "human_words_regrex": "# Problem Statement One of the hardest part of working with javascript over the years has been keeping dealing with version support and change over time of third party code. It seems like react 18 is going to focus on performance and server side viewing framework. **However, one of the big divides in many products, components and libraries is using ES6 Classes vs Purely Functional Components.** # Timing Details In past versions of react life cycle methods required use of classes. Modern javascript can use hoisting to make functional components faster to load. However, class components are also more consistent with larger market share of developers. The main motivation behind hooks in react though was to enable code to be branched and worked on more independently and by concurrent developers. Right now, functional components are seen as a place to make things faster but es class components are still considered ok. # Future Outlook In the future hooks are likely to grow, developers who are use to older versions of react or who are use to OOP are likely to prefer class components, leading to lots of react code styles in lots of ways. This may make maintenance and community packages more likely to break as future versions of react try to take advantage of browsers IDL's and ECMA advancements. React 18 is also likely to add more of a footprint and more use cases. React native should also be considered, as more and more companies find value in javascript. Overall the community effect and the maintenance of react is likely to get harder and not easier, but the sooner es6 class components and functional components patterns can be well defined the more developers can adjust.",
        "human_words_stopwords_removal_lemmatization": "# problem statement one hardest part working javascript year keeping dealing version support change time third party code . seems like react 18 going focus performance server side viewing framework . * * however , one big divide many product , component library using es6 class v purely functional component . * * # timing detail past version react life cycle method required use class . modern javascript use hoisting make functional component faster load . however , class component also consistent larger market share developer . main motivation behind hook react though enable code branched worked independently concurrent developer . right , functional component seen place make thing faster e class component still considered ok. # future outlook future hook likely grow , developer use older version react use oop likely prefer class component , leading lot react code style lot way . may make maintenance community package likely break future version react try take advantage browser idl 's ecma advancement . react 18 also likely add footprint use case . react native also considered , company find value javascript . overall community effect maintenance react likely get harder easier , sooner es6 class component functional component pattern well defined developer adjust .",
        "title_stopwords_removal_lemmatization": "react 18 enable better es6 class integration hook"
    },
    {
        "issue_id": 935136652,
        "title": "Community feedback on console silencing",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-07-01T19:08:35Z",
        "status": "closed",
        "description": "Hi, I know this issue has been discussed endlessly so I apologize for bringing it up again. I hope this issue is net helpful. \ud83e\udd1e \r\n\r\nQuick summary: as of https://github.com/facebook/react/pull/18547, React 17 silences console logs during the second rendering pass in strict mode, in dev. It's a trade-off between the confusion of logging multiple times for a single render pass and the confusion of only logging once even though the code was actually called twice.\r\n\r\nNote that there's an outstanding PR to make it configurable (https://github.com/facebook/react/pull/19710) but it seems to be stalled awaiting review.\r\n\r\nSince the change was released, I've seen a number of issues in which folks have been confused by the behavior, e.g.:\r\n\r\n- https://github.com/facebook/react/issues/20835\r\n- https://github.com/facebook/react/issues/20982\r\n- https://github.com/facebook/react/issues/20367\r\n- https://github.com/facebook/react/issues/20090\r\n- https://github.com/facebook/react/issues/21178\r\n- https://github.com/facebook/react/issues/21126\r\n- https://github.com/facebook/react/issues/20851\r\n- https://github.com/facebook/react/issues/20575\r\n\r\nThe response from the core team has generally been that, yes, this behavior can be confusing, but the previous behavior was equally if not more confusing. It's a trade-off without a clear answer. (Examples: [1](https://github.com/facebook/react/issues/20090#issuecomment-715926549), [2](https://github.com/facebook/react/issues/20835#issuecomment-781393974), [3](https://github.com/facebook/react/issues/20367#issuecomment-737610144).)\r\n\r\nI totally understand this perspective and I've tried to internalize it, but, frankly, the longer it's been since the release, the more it seems to me like the new behavior is actually just significantly more confusing for most people. My signal is:\r\n1. Anecdotally, it's a recurring source of confusion within my company, much more so than the old behavior was. It's also probably the source of the most \"oh, that's weird\" reactions (vs. \"oh, I get it now\") when explained, compared with other React nuances.\r\n2. The change was only released 8 months ago and there are already many GitHub issues expressing confusion about it, seemingly more than there ever were for the old behavior. (There used to be more instances where people weren't aware that strict mode double-invokes components, but it's not that the new behavior makes this any more clear, it just means that fewer people are now learning this fact, which doesn't seem good?) The rate of new issues also doesn't seem to be slowing as was [hypothesized](https://github.com/facebook/react/issues/20367#issuecomment-737764279).\r\n3. The implementing PR ([#18547](https://github.com/facebook/react/pull/18547)) currently has 19 downvotes vs. 2 upvotes. Obviously people who dislike the change are more likely to downvote, but PRs are rarely this controversial and in fact this is the [most downvoted non-docs PR](https://github.com/facebook/react/pulls?q=is%3Apr+sort%3Areactions--1-desc+is%3Aclosed) in the whole repo.\r\n\r\nAltogether, the change was clearly well-reasoned and well-intentioned, but now that it's had some time to settle, what I'm asking is:\r\n1. Does my perspective on the community reaction align with your perception?\r\n2. Have you observed a different reaction internally at FB?\r\n3. In aggregate, does any of this change your original perspective at all?\r\n\r\nI hope this is a fair take and a helpful set of questions to ask. Thanks for taking the time to read.\r\n\r\n---\r\n\r\n(FWIW, if I had to guess, I'd propose that one reason for the new behavior being more confusing is that the old behavior is only confusing until you learn that strict mode = double render, whereas the new behavior continues to be confusing after you learn it because there are subtleties. e.g., \"which pass gets silenced again?\", \"oh, right, it's the second one, so if you log a value and render it, the console might show something different than the screen\", \"what about when you set state in render?\", \"what about refs?\", etc.)",
        "remove_template_description": "Hi, I know this issue has been discussed endlessly so I apologize for bringing it up again. I hope this issue is net helpful. \ud83e\udd1e     Quick summary: as of https://github.com/facebook/react/pull/18547, React 17 silences console logs during the second rendering pass in strict mode, in dev. It's a trade-off between the confusion of logging multiple times for a single render pass and the confusion of only logging once even though the code was actually called twice.    Note that there's an outstanding PR to make it configurable (https://github.com/facebook/react/pull/19710) but it seems to be stalled awaiting review.    Since the change was released, I've seen a number of issues in which folks have been confused by the behavior, e.g.:    - https://github.com/facebook/react/issues/20835  - https://github.com/facebook/react/issues/20982  - https://github.com/facebook/react/issues/20367  - https://github.com/facebook/react/issues/20090  - https://github.com/facebook/react/issues/21178  - https://github.com/facebook/react/issues/21126  - https://github.com/facebook/react/issues/20851  - https://github.com/facebook/react/issues/20575    The response from the core team has generally been that, yes, this behavior can be confusing, but the previous behavior was equally if not more confusing. It's a trade-off without a clear answer. (Examples: [1](https://github.com/facebook/react/issues/20090#issuecomment-715926549), [2](https://github.com/facebook/react/issues/20835#issuecomment-781393974), [3](https://github.com/facebook/react/issues/20367#issuecomment-737610144).)    I totally understand this perspective and I've tried to internalize it, but, frankly, the longer it's been since the release, the more it seems to me like the new behavior is actually just significantly more confusing for most people. My signal is:  1. Anecdotally, it's a recurring source of confusion within my company, much more so than the old behavior was. It's also probably the source of the most \"oh, that's weird\" reactions (vs. \"oh, I get it now\") when explained, compared with other React nuances.  2. The change was only released 8 months ago and there are already many GitHub issues expressing confusion about it, seemingly more than there ever were for the old behavior. (There used to be more instances where people weren't aware that strict mode double-invokes components, but it's not that the new behavior makes this any more clear, it just means that fewer people are now learning this fact, which doesn't seem good?) The rate of new issues also doesn't seem to be slowing as was [hypothesized](https://github.com/facebook/react/issues/20367#issuecomment-737764279).  3. The implementing PR ([#18547](https://github.com/facebook/react/pull/18547)) currently has 19 downvotes vs. 2 upvotes. Obviously people who dislike the change are more likely to downvote, but PRs are rarely this controversial and in fact this is the [most downvoted non-docs PR](https://github.com/facebook/react/pulls?q=is%3Apr+sort%3Areactions--1-desc+is%3Aclosed) in the whole repo.    Altogether, the change was clearly well-reasoned and well-intentioned, but now that it's had some time to settle, what I'm asking is:  1. Does my perspective on the community reaction align with your perception?  2. Have you observed a different reaction internally at FB?  3. In aggregate, does any of this change your original perspective at all?    I hope this is a fair take and a helpful set of questions to ask. Thanks for taking the time to read.    ---    (FWIW, if I had to guess, I'd propose that one reason for the new behavior being more confusing is that the old behavior is only confusing until you learn that strict mode = double render, whereas the new behavior continues to be confusing after you learn it because there are subtleties. e.g., \"which pass gets silenced again?\", \"oh, right, it's the second one, so if you log a value and render it, the console might show something different than the screen\", \"what about when you set state in render?\", \"what about refs?\", etc.)",
        "human_words": "Hi, I know this issue has been discussed endlessly so I apologize for bringing it up again. I hope this issue is net helpful. \ud83e\udd1e     Quick summary: as of https://github.com/facebook/react/pull/18547, React 17 silences console logs during the second rendering pass in strict mode, in dev. It's a trade-off between the confusion of logging multiple times for a single render pass and the confusion of only logging once even though the code was actually called twice.    Note that there's an outstanding PR to make it configurable (https://github.com/facebook/react/pull/19710) but it seems to be stalled awaiting review.    Since the change was released, I've seen a number of issues in which folks have been confused by the behavior, e.g.:    - https://github.com/facebook/react/issues/20835  - https://github.com/facebook/react/issues/20982  - https://github.com/facebook/react/issues/20367  - https://github.com/facebook/react/issues/20090  - https://github.com/facebook/react/issues/21178  - https://github.com/facebook/react/issues/21126  - https://github.com/facebook/react/issues/20851  - https://github.com/facebook/react/issues/20575    The response from the core team has generally been that, yes, this behavior can be confusing, but the previous behavior was equally if not more confusing. It's a trade-off without a clear answer. (Examples: [1](https://github.com/facebook/react/issues/20090#issuecomment-715926549), [2](https://github.com/facebook/react/issues/20835#issuecomment-781393974), [3](https://github.com/facebook/react/issues/20367#issuecomment-737610144).)    I totally understand this perspective and I've tried to internalize it, but, frankly, the longer it's been since the release, the more it seems to me like the new behavior is actually just significantly more confusing for most people. My signal is:  1. Anecdotally, it's a recurring source of confusion within my company, much more so than the old behavior was. It's also probably the source of the most \"oh, that's weird\" reactions (vs. \"oh, I get it now\") when explained, compared with other React nuances.  2. The change was only released 8 months ago and there are already many GitHub issues expressing confusion about it, seemingly more than there ever were for the old behavior. (There used to be more instances where people weren't aware that strict mode double-invokes components, but it's not that the new behavior makes this any more clear, it just means that fewer people are now learning this fact, which doesn't seem good?) The rate of new issues also doesn't seem to be slowing as was [hypothesized](https://github.com/facebook/react/issues/20367#issuecomment-737764279).  3. The implementing PR ([#18547](https://github.com/facebook/react/pull/18547)) currently has 19 downvotes vs. 2 upvotes. Obviously people who dislike the change are more likely to downvote, but PRs are rarely this controversial and in fact this is the [most downvoted non-docs PR](https://github.com/facebook/react/pulls?q=is%3Apr+sort%3Areactions--1-desc+is%3Aclosed) in the whole repo.    Altogether, the change was clearly well-reasoned and well-intentioned, but now that it's had some time to settle, what I'm asking is:  1. Does my perspective on the community reaction align with your perception?  2. Have you observed a different reaction internally at FB?  3. In aggregate, does any of this change your original perspective at all?    I hope this is a fair take and a helpful set of questions to ask. Thanks for taking the time to read.    ---    (FWIW, if I had to guess, I'd propose that one reason for the new behavior being more confusing is that the old behavior is only confusing until you learn that strict mode = double render, whereas the new behavior continues to be confusing after you learn it because there are subtleties. e.g., \"which pass gets silenced again?\", \"oh, right, it's the second one, so if you log a value and render it, the console might show something different than the screen\", \"what about when you set state in render?\", \"what about refs?\", etc.)",
        "human_words_regrex": "Hi, I know this issue has been discussed endlessly so I apologize for bringing it up again. I hope this issue is net helpful. \ud83e\udd1e Quick summary: as of  React 17 silences console logs during the second rendering pass in strict mode, in dev. It's a trade-off between the confusion of logging multiple times for a single render pass and the confusion of only logging once even though the code was actually called twice. Note that there's an outstanding PR to make it configurable ( but it seems to be stalled awaiting review. Since the change was released, I've seen a number of issues in which folks have been confused by the behavior, e.g.: -  -  -  -  -  -  -  -  The response from the core team has generally been that, yes, this behavior can be confusing, but the previous behavior was equally if not more confusing. It's a trade-off without a clear answer. (Examples: , , .) I totally understand this perspective and I've tried to internalize it, but, frankly, the longer it's been since the release, the more it seems to me like the new behavior is actually just significantly more confusing for most people. My signal is: 1. Anecdotally, it's a recurring source of confusion within my company, much more so than the old behavior was. It's also probably the source of the most \"oh, that's weird\" reactions (vs. \"oh, I get it now\") when explained, compared with other React nuances. 2. The change was only released 8 months ago and there are already many GitHub issues expressing confusion about it, seemingly more than there ever were for the old behavior. (There used to be more instances where people weren't aware that strict mode double-invokes components, but it's not that the new behavior makes this any more clear, it just means that fewer people are now learning this fact, which doesn't seem good?) The rate of new issues also doesn't seem to be slowing as was . 3. The implementing PR () currently has 19 downvotes vs. 2 upvotes. Obviously people who dislike the change are more likely to downvote, but PRs are rarely this controversial and in fact this is the  in the whole repo. Altogether, the change was clearly well-reasoned and well-intentioned, but now that it's had some time to settle, what I'm asking is: 1. Does my perspective on the community reaction align with your perception? 2. Have you observed a different reaction internally at FB? 3. In aggregate, does any of this change your original perspective at all? I hope this is a fair take and a helpful set of questions to ask. Thanks for taking the time to read. --- (FWIW, if I had to guess, I'd propose that one reason for the new behavior being more confusing is that the old behavior is only confusing until you learn that strict mode = double render, whereas the new behavior continues to be confusing after you learn it because there are subtleties. e.g., \"which pass gets silenced again?\", \"oh, right, it's the second one, so if you log a value and render it, the console might show something different than the screen\", \"what about when you set state in render?\", \"what about refs?\", etc.)",
        "human_words_stopwords_removal_lemmatization": "hi , know issue discussed endlessly apologize bringing . hope issue net helpful . \ud83e\udd1e quick summary : react 17 silence console log second rendering pas strict mode , dev . 's trade-off confusion logging multiple time single render pas confusion logging even though code actually called twice . note 's outstanding pr make configurable ( seems stalled awaiting review . since change released , 've seen number issue folk confused behavior , e.g . : - - - - - - - - response core team generally , yes , behavior confusing , previous behavior equally confusing . 's trade-off without clear answer . ( example : , , . ) totally understand perspective 've tried internalize , , frankly , longer 's since release , seems like new behavior actually significantly confusing people . signal : 1. anecdotally , 's recurring source confusion within company , much old behavior . 's also probably source `` oh , 's weird '' reaction ( vs. `` oh , get '' ) explained , compared react nuance . 2. change released 8 month ago already many github issue expressing confusion , seemingly ever old behavior . ( used instance people n't aware strict mode double-invokes component , 's new behavior make clear , mean fewer people learning fact , n't seem good ? ) rate new issue also n't seem slowing . 3. implementing pr ( ) currently 19 downvotes vs. 2 upvotes . obviously people dislike change likely downvote , pr rarely controversial fact whole repo . altogether , change clearly well-reasoned well-intentioned , 's time settle , 'm asking : 1. perspective community reaction align perception ? 2. observed different reaction internally fb ? 3. aggregate , change original perspective ? hope fair take helpful set question ask . thanks taking time read . -- - ( fwiw , guess , 'd propose one reason new behavior confusing old behavior confusing learn strict mode = double render , whereas new behavior continues confusing learn subtlety . e.g. , `` pas get silenced ? `` , `` oh , right , 's second one , log value render , console might show something different screen '' , `` set state render ? `` , `` ref ? `` , etc . )",
        "title_stopwords_removal_lemmatization": "community feedback console silencing"
    },
    {
        "issue_id": 932622934,
        "title": "React 18: \"missing act()\" warnings partially missing if a prior render threw",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-29T12:50:36Z",
        "status": "closed",
        "description": "Specifically `An update to * inside a test was not wrapped in act(...)` is not logged when a prior update threw. \r\n\r\n<details>\r\n<summary>failing test (#21766)</summary>\r\n\r\n```js\r\n// @gate __DEV__\r\nit('warns if a setState is called outside of act(...) after a component threw', () => {\r\n  let setValue = null;\r\n  function App({defaultValue}) {\r\n    if (defaultValue === undefined) {\r\n      throw new Error();\r\n    }\r\n    const [value, _setValue] = React.useState(defaultValue);\r\n    setValue = _setValue;\r\n    return value;\r\n  }\r\n\r\n  expect(() => {\r\n    act(() => {\r\n      render(<App defaultValue={undefined} />, container);\r\n    });\r\n  }).toThrow();\r\n\r\n  act(() => {\r\n    rerender(<App defaultValue={0} />, container);\r\n  });\r\n\r\n  expect(() => setValue(1)).toErrorDev([\r\n    'An update to App inside a test was not wrapped in act(...).',\r\n  ]);\r\n});\r\n```\r\n</details>\r\n\r\nWhat I noticed is that in https://github.com/facebook/react/blob/27c9c95e23ddedb9163373950e364dd62038f6c0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2855-L2865\r\nthe `executionContext` will still equal `RetryAfterError` when we would expect a \"missing act\" warning.\r\n\r\n\"missing act\" warnings are working as expected with legacy roots.",
        "remove_template_description": "Specifically `An update to * inside a test was not wrapped in act(...)` is not logged when a prior update threw.     <details>  <summary>failing test (#21766)</summary>    ```js  // @gate __DEV__  it('warns if a setState is called outside of act(...) after a component threw', () => {    let setValue = null;    function App({defaultValue}) {      if (defaultValue === undefined) {        throw new Error();      }      const [value, _setValue] = React.useState(defaultValue);      setValue = _setValue;      return value;    }      expect(() => {      act(() => {        render(<App defaultValue={undefined} />, container);      });    }).toThrow();      act(() => {      rerender(<App defaultValue={0} />, container);    });      expect(() => setValue(1)).toErrorDev([      'An update to App inside a test was not wrapped in act(...).',    ]);  });  ```  </details>    What I noticed is that in https://github.com/facebook/react/blob/27c9c95e23ddedb9163373950e364dd62038f6c0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2855-L2865  the `executionContext` will still equal `RetryAfterError` when we would expect a \"missing act\" warning.    \"missing act\" warnings are working as expected with legacy roots.",
        "human_words": "Specifically `An update to * inside a test was not wrapped in act(...)` is not logged when a prior update threw.     <details>  <summary>failing test (#21766)</summary>      </details>    What I noticed is that in https://github.com/facebook/react/blob/27c9c95e23ddedb9163373950e364dd62038f6c0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2855-L2865  the `executionContext` will still equal `RetryAfterError` when we would expect a \"missing act\" warning.    \"missing act\" warnings are working as expected with legacy roots.",
        "human_words_regrex": "Specifically `An update to * inside a test was not wrapped in act(...)` is not logged when a prior update threw.  failing test (#21766)  What I noticed is that in  the `executionContext` will still equal `RetryAfterError` when we would expect a \"missing act\" warning. \"missing act\" warnings are working as expected with legacy roots.",
        "human_words_stopwords_removal_lemmatization": "specifically ` update * inside test wrapped act ( ... ) ` logged prior update threw . failing test ( # 21766 ) noticed ` executioncontext ` still equal ` retryaftererror ` would expect `` missing act '' warning . `` missing act '' warning working expected legacy root .",
        "title_stopwords_removal_lemmatization": "react 18 : `` missing act ( ) '' warning partially missing prior render threw"
    },
    {
        "issue_id": 926083124,
        "title": "React 18: Error boundaries actually catches errors in effects",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-21T10:43:39Z",
        "status": "closed",
        "description": "Given\r\n```js\r\nfunction ThrowInEffect() {\r\n  React.useEffect(() => {\r\n    throw new Error('passive effect')\r\n  }, [])\r\n  return null;\r\n}\r\n```\r\n\r\nIn React 17 this error got logged to the console (and triggered the error overlay in create-react-app) regardless of whether `ThrowInEffect` was a child of an Error Boundary or not.\r\n\r\nIn React 18 (`createRoot` and legacy root API) an Error Boundary will prevent logging that error to the console (and not trigger the error overlay in create-react-app).\r\n\r\nErrors during render work like they did in React 17.\r\n\r\nBehavior in React 17: https://codesandbox.io/s/react-17-error-boundaries-vp21e?file=/src/index.js\r\nBehavior in React 18: https://codesandbox.io/s/react-18-error-boundaries-psd56?file=/src/index.js\r\n\r\n\r\nRecording of effect errors in React 17 and 18 and with and without Error Boundaries_\r\n\r\nhttps://user-images.githubusercontent.com/12292047/122749780-053ced00-d28e-11eb-98ce-075dcdc53ee2.mp4\r\n\r\n",
        "remove_template_description": "Given  ```js  function ThrowInEffect() {    React.useEffect(() => {      throw new Error('passive effect')    }, [])    return null;  }  ```    In React 17 this error got logged to the console (and triggered the error overlay in create-react-app) regardless of whether `ThrowInEffect` was a child of an Error Boundary or not.    In React 18 (`createRoot` and legacy root API) an Error Boundary will prevent logging that error to the console (and not trigger the error overlay in create-react-app).    Errors during render work like they did in React 17.    Behavior in React 17: https://codesandbox.io/s/react-17-error-boundaries-vp21e?file=/src/index.js  Behavior in React 18: https://codesandbox.io/s/react-18-error-boundaries-psd56?file=/src/index.js      Recording of effect errors in React 17 and 18 and with and without Error Boundaries_    https://user-images.githubusercontent.com/12292047/122749780-053ced00-d28e-11eb-98ce-075dcdc53ee2.mp4",
        "human_words": "Given      In React 17 this error got logged to the console (and triggered the error overlay in create-react-app) regardless of whether `ThrowInEffect` was a child of an Error Boundary or not.    In React 18 (`createRoot` and legacy root API) an Error Boundary will prevent logging that error to the console (and not trigger the error overlay in create-react-app).    Errors during render work like they did in React 17.    Behavior in React 17: https://codesandbox.io/s/react-17-error-boundaries-vp21e?file=/src/index.js  Behavior in React 18: https://codesandbox.io/s/react-18-error-boundaries-psd56?file=/src/index.js      Recording of effect errors in React 17 and 18 and with and without Error Boundaries_    https://user-images.githubusercontent.com/12292047/122749780-053ced00-d28e-11eb-98ce-075dcdc53ee2.mp4",
        "human_words_regrex": "Given In React 17 this error got logged to the console (and triggered the error overlay in create-react-app) regardless of whether `ThrowInEffect` was a child of an Error Boundary or not. In React 18 (`createRoot` and legacy root API) an Error Boundary will prevent logging that error to the console (and not trigger the error overlay in create-react-app). Errors during render work like they did in React 17. Behavior in React 17:  Behavior in React 18:  Recording of effect errors in React 17 and 18 and with and without Error Boundaries_ ",
        "human_words_stopwords_removal_lemmatization": "given react 17 error got logged console ( triggered error overlay create-react-app ) regardless whether ` throwineffect ` child error boundary . react 18 ( ` createroot ` legacy root api ) error boundary prevent logging error console ( trigger error overlay create-react-app ) . error render work like react 17. behavior react 17 : behavior react 18 : recording effect error react 17 18 without error boundaries_",
        "title_stopwords_removal_lemmatization": "react 18 : error boundary actually catch error effect"
    },
    {
        "issue_id": 924750916,
        "title": "React 18 data fetching network call cancellation",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-18T10:05:49Z",
        "status": "open",
        "description": "I understood from various discussions online that for Suspense for data fetching to work properly React needs to be more directly involved in the mechanics of fetching data from the network. How will that work in practice? Would it take care of XHR cancellation for example in case a Suspense subtree is no longer needed or changes props? What will it mean for using libraries like Axios? Can strategies like retry with exponential backoff still be implemented? HTTP caching behavior?",
        "remove_template_description": "I understood from various discussions online that for Suspense for data fetching to work properly React needs to be more directly involved in the mechanics of fetching data from the network. How will that work in practice? Would it take care of XHR cancellation for example in case a Suspense subtree is no longer needed or changes props? What will it mean for using libraries like Axios? Can strategies like retry with exponential backoff still be implemented? HTTP caching behavior?",
        "human_words": "I understood from various discussions online that for Suspense for data fetching to work properly React needs to be more directly involved in the mechanics of fetching data from the network. How will that work in practice? Would it take care of XHR cancellation for example in case a Suspense subtree is no longer needed or changes props? What will it mean for using libraries like Axios? Can strategies like retry with exponential backoff still be implemented? HTTP caching behavior?",
        "human_words_regrex": "I understood from various discussions online that for Suspense for data fetching to work properly React needs to be more directly involved in the mechanics of fetching data from the network. How will that work in practice? Would it take care of XHR cancellation for example in case a Suspense subtree is no longer needed or changes props? What will it mean for using libraries like Axios? Can strategies like retry with exponential backoff still be implemented? HTTP caching behavior?",
        "human_words_stopwords_removal_lemmatization": "understood various discussion online suspense data fetching work properly react need directly involved mechanic fetching data network . work practice ? would take care xhr cancellation example case suspense subtree longer needed change prop ? mean using library like axios ? strategy like retry exponential backoff still implemented ? http caching behavior ?",
        "title_stopwords_removal_lemmatization": "react 18 data fetching network call cancellation"
    },
    {
        "issue_id": 923206650,
        "title": "React 18 : Possible Transition use case? Rendering large table with filtered tabs",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-16T23:19:42Z",
        "status": "closed",
        "description": "Apologies if this is an inappropriate place to ask this type of question. When reading about React 18, in particular the startTransition API, I started thinking of problems I've run into in the past where I had to do lots of manual management of renders to provide good UX. I tried to recreate the original problem (at least a contrived version of it) in a CodeSandbox:\r\n\r\nhttps://codesandbox.io/s/usetransition-tab-test-575cu?file=/src/App.js\r\n\r\nI attempted to describe the problem in the sandbox, but basically I am trying to optimize the interaction and navigation of the Tab components onClick\u2014the \"high priority\" update\u2014and defer the rendering of the table data (through a loading spinner or delay of table data rendering). \r\n\r\nReading through the [startTransition](https://github.com/reactwg/react-18/discussions/41) explanation, I'm not sure if this an appropriate use case. My tab component is not a native browser component, and it seems that I only have the ability to mark \"low-priority\" updates and not the opposite (eg. wrapping handleClick as a high-priority update).\r\n\r\nI was hoping to get some clarification if my mental model is off here. I am aware there are other ways to deal with this problem (eg. list virtualization), but I'm mostly trying to understand the scope of the startTransition API.\r\n\r\nThanks for all the hard work! I'm very excited about the new developments in React 18 and appreciate your team's commitment to pragmatism.\r\n\r\n\r\n",
        "remove_template_description": "Apologies if this is an inappropriate place to ask this type of question. When reading about React 18, in particular the startTransition API, I started thinking of problems I've run into in the past where I had to do lots of manual management of renders to provide good UX. I tried to recreate the original problem (at least a contrived version of it) in a CodeSandbox:    https://codesandbox.io/s/usetransition-tab-test-575cu?file=/src/App.js    I attempted to describe the problem in the sandbox, but basically I am trying to optimize the interaction and navigation of the Tab components onClick\u2014the \"high priority\" update\u2014and defer the rendering of the table data (through a loading spinner or delay of table data rendering).     Reading through the [startTransition](https://github.com/reactwg/react-18/discussions/41) explanation, I'm not sure if this an appropriate use case. My tab component is not a native browser component, and it seems that I only have the ability to mark \"low-priority\" updates and not the opposite (eg. wrapping handleClick as a high-priority update).    I was hoping to get some clarification if my mental model is off here. I am aware there are other ways to deal with this problem (eg. list virtualization), but I'm mostly trying to understand the scope of the startTransition API.    Thanks for all the hard work! I'm very excited about the new developments in React 18 and appreciate your team's commitment to pragmatism.",
        "human_words": "Apologies if this is an inappropriate place to ask this type of question. When reading about React 18, in particular the startTransition API, I started thinking of problems I've run into in the past where I had to do lots of manual management of renders to provide good UX. I tried to recreate the original problem (at least a contrived version of it) in a CodeSandbox:    https://codesandbox.io/s/usetransition-tab-test-575cu?file=/src/App.js    I attempted to describe the problem in the sandbox, but basically I am trying to optimize the interaction and navigation of the Tab components onClick\u2014the \"high priority\" update\u2014and defer the rendering of the table data (through a loading spinner or delay of table data rendering).     Reading through the [startTransition](https://github.com/reactwg/react-18/discussions/41) explanation, I'm not sure if this an appropriate use case. My tab component is not a native browser component, and it seems that I only have the ability to mark \"low-priority\" updates and not the opposite (eg. wrapping handleClick as a high-priority update).    I was hoping to get some clarification if my mental model is off here. I am aware there are other ways to deal with this problem (eg. list virtualization), but I'm mostly trying to understand the scope of the startTransition API.    Thanks for all the hard work! I'm very excited about the new developments in React 18 and appreciate your team's commitment to pragmatism.",
        "human_words_regrex": "Apologies if this is an inappropriate place to ask this type of question. When reading about React 18, in particular the startTransition API, I started thinking of problems I've run into in the past where I had to do lots of manual management of renders to provide good UX. I tried to recreate the original problem (at least a contrived version of it) in a CodeSandbox:  I attempted to describe the problem in the sandbox, but basically I am trying to optimize the interaction and navigation of the Tab components onClick\u2014the \"high priority\" update\u2014and defer the rendering of the table data (through a loading spinner or delay of table data rendering). Reading through the  explanation, I'm not sure if this an appropriate use case. My tab component is not a native browser component, and it seems that I only have the ability to mark \"low-priority\" updates and not the opposite (eg. wrapping handleClick as a high-priority update). I was hoping to get some clarification if my mental model is off here. I am aware there are other ways to deal with this problem (eg. list virtualization), but I'm mostly trying to understand the scope of the startTransition API. Thanks for all the hard work! I'm very excited about the new developments in React 18 and appreciate your team's commitment to pragmatism.",
        "human_words_stopwords_removal_lemmatization": "apology inappropriate place ask type question . reading react 18 , particular starttransition api , started thinking problem 've run past lot manual management render provide good ux . tried recreate original problem ( least contrived version ) codesandbox : attempted describe problem sandbox , basically trying optimize interaction navigation tab component onclick\u2014the `` high priority '' update\u2014and defer rendering table data ( loading spinner delay table data rendering ) . reading explanation , 'm sure appropriate use case . tab component native browser component , seems ability mark `` low-priority '' update opposite ( eg . wrapping handleclick high-priority update ) . hoping get clarification mental model . aware way deal problem ( eg . list virtualization ) , 'm mostly trying understand scope starttransition api . thanks hard work ! 'm excited new development react 18 appreciate team 's commitment pragmatism .",
        "title_stopwords_removal_lemmatization": "react 18 : possible transition use case ? rendering large table filtered tab"
    },
    {
        "issue_id": 921876197,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-15T22:58:11Z",
        "status": "closed",
        "description": "<!--\r\n  Ask a question or share feedback about the React 18 release here.\r\n-->\r\n",
        "remove_template_description": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words": "<!--    Ask a question or share feedback about the React 18 release here.  -->",
        "human_words_regrex": "",
        "human_words_stopwords_removal_lemmatization": "",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 919969775,
        "title": "React 18: react-router@v5 is breaking in the Strict Mode (strict effects)",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-14T03:43:07Z",
        "status": "closed",
        "description": "https://github.com/ReactTraining/react-router/issues/7870\r\n\r\nI do not have permission to post https://github.com/reactwg/react-18/discussions. Please open and pin a new issue in that repo to list all widely-used library that does not work with React 18 or need special handling.",
        "remove_template_description": "https://github.com/ReactTraining/react-router/issues/7870    I do not have permission to post https://github.com/reactwg/react-18/discussions. Please open and pin a new issue in that repo to list all widely-used library that does not work with React 18 or need special handling.",
        "human_words": "https://github.com/ReactTraining/react-router/issues/7870    I do not have permission to post https://github.com/reactwg/react-18/discussions. Please open and pin a new issue in that repo to list all widely-used library that does not work with React 18 or need special handling.",
        "human_words_regrex": " I do not have permission to post  Please open and pin a new issue in that repo to list all widely-used library that does not work with React 18 or need special handling.",
        "human_words_stopwords_removal_lemmatization": "permission post please open pin new issue repo list widely-used library work react 18 need special handling .",
        "title_stopwords_removal_lemmatization": "react 18 : react-router @ v5 breaking strict mode ( strict effect )"
    },
    {
        "issue_id": 919854929,
        "title": "React 18 ",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-13T18:23:34Z",
        "status": "closed",
        "description": "\r\nJust a suggestion\r\n\r\nIn React 18 , React should accept extra params to setState function so dev can specify what changed in more general terms that he/she can use in `React.memo()` to determine if that changes should re-render the specific component with the new data  \r\n\r\nit should be something like this \r\n\r\n```javascript\r\nsetState(\r\n  [...state.users, user], \r\n  {action:'USER_ADDED', id : 'some_id'}\r\n);\r\n```\r\n\r\nthe broadcast can be any arbitrary data\r\n\r\n\r\nand then  in the User component, we can catch that broadcast in React.memo() like this\r\n\r\n```javascript\r\nconst User= (user)=>{\r\n   // component code   \r\n}\r\n```\r\n\r\n```javascript\r\nexport default React.memo(User, (prev, next, brodcast)=>{\r\n  if(broadcast?.action === 'ACTION_ADDED'  &&  next.id !== broadcast.id){\r\n   // should not re-render this component\r\n   return true;\r\n }\r\n return false;\r\n});\r\n```\r\n\r\nthis should work with batch setState as well just instead of object, broadcast should have an array of broadcasts\r\n\r\nthis will save the devs from deep comparison of props if it holds a lot of data nodes in it.\r\n",
        "remove_template_description": "Just a suggestion    In React 18 , React should accept extra params to setState function so dev can specify what changed in more general terms that he/she can use in `React.memo()` to determine if that changes should re-render the specific component with the new data      it should be something like this     ```javascript  setState(    [...state.users, user],     {action:'USER_ADDED', id : 'some_id'}  );  ```    the broadcast can be any arbitrary data      and then  in the User component, we can catch that broadcast in React.memo() like this    ```javascript  const User= (user)=>{     // component code     }  ```    ```javascript  export default React.memo(User, (prev, next, brodcast)=>{    if(broadcast?.action === 'ACTION_ADDED'  &&  next.id !== broadcast.id){     // should not re-render this component     return true;   }   return false;  });  ```    this should work with batch setState as well just instead of object, broadcast should have an array of broadcasts    this will save the devs from deep comparison of props if it holds a lot of data nodes in it.",
        "human_words": "Just a suggestion    In React 18 , React should accept extra params to setState function so dev can specify what changed in more general terms that he/she can use in `React.memo()` to determine if that changes should re-render the specific component with the new data      it should be something like this         the broadcast can be any arbitrary data      and then  in the User component, we can catch that broadcast in React.memo() like this            this should work with batch setState as well just instead of object, broadcast should have an array of broadcasts    this will save the devs from deep comparison of props if it holds a lot of data nodes in it.",
        "human_words_regrex": "Just a suggestion In React 18 , React should accept extra params to setState function so dev can specify what changed in more general terms that he/she can use in `React.memo()` to determine if that changes should re-render the specific component with the new data it should be something like this the broadcast can be any arbitrary data and then in the User component, we can catch that broadcast in React.memo() like this this should work with batch setState as well just instead of object, broadcast should have an array of broadcasts this will save the devs from deep comparison of props if it holds a lot of data nodes in it.",
        "human_words_stopwords_removal_lemmatization": "suggestion react 18 , react accept extra params setstate function dev specify changed general term he/she use ` react.memo ( ) ` determine change re-render specific component new data something like broadcast arbitrary data user component , catch broadcast react.memo ( ) like work batch setstate well instead object , broadcast array broadcast save devs deep comparison prop hold lot data node .",
        "title_stopwords_removal_lemmatization": "react 18"
    },
    {
        "issue_id": 919517691,
        "title": "Question: Transition starvation in React 18?",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-12T10:25:53Z",
        "status": "open",
        "description": "Main question:\r\n\r\n> What happens if a transition gets constantly interrupted before it has time to finish, and are there any cases where we need to worry about this in userland?\r\n\r\nSubquestion:\r\n\r\n> What exactly interrupts a transition? Is it only user events, or also for example when a new transition happens and if so, is it only if a new transition happens in the same component or an ancestor, or is it app-wide?\r\n\r\nI've seen discussions around the starvation problem now and then (can't remember where) so I'm curious about if you have ended up with a specific approach in React 18 or if this is yet undecided? It struck me that since interrupted work is no longer reused, maybe this has the potential for happening more often now?\r\n\r\nThe heuristics is an internal detail that can be tweaked of course, so I'm mostly interested if this is something I'll need to ever care about as a developer?\r\n\r\nPerhaps more concretely:\r\n\r\n> What happens if I call `startTransition` in a `requestAnimationFrame` and it never has time to finish?",
        "remove_template_description": "Main question:    > What happens if a transition gets constantly interrupted before it has time to finish, and are there any cases where we need to worry about this in userland?    Subquestion:    > What exactly interrupts a transition? Is it only user events, or also for example when a new transition happens and if so, is it only if a new transition happens in the same component or an ancestor, or is it app-wide?    I've seen discussions around the starvation problem now and then (can't remember where) so I'm curious about if you have ended up with a specific approach in React 18 or if this is yet undecided? It struck me that since interrupted work is no longer reused, maybe this has the potential for happening more often now?    The heuristics is an internal detail that can be tweaked of course, so I'm mostly interested if this is something I'll need to ever care about as a developer?    Perhaps more concretely:    > What happens if I call `startTransition` in a `requestAnimationFrame` and it never has time to finish?",
        "human_words": "Main question:    > What happens if a transition gets constantly interrupted before it has time to finish, and are there any cases where we need to worry about this in userland?    Subquestion:    > What exactly interrupts a transition? Is it only user events, or also for example when a new transition happens and if so, is it only if a new transition happens in the same component or an ancestor, or is it app-wide?    I've seen discussions around the starvation problem now and then (can't remember where) so I'm curious about if you have ended up with a specific approach in React 18 or if this is yet undecided? It struck me that since interrupted work is no longer reused, maybe this has the potential for happening more often now?    The heuristics is an internal detail that can be tweaked of course, so I'm mostly interested if this is something I'll need to ever care about as a developer?    Perhaps more concretely:    > What happens if I call `startTransition` in a `requestAnimationFrame` and it never has time to finish?",
        "human_words_regrex": "Main question: > What happens if a transition gets constantly interrupted before it has time to finish, and are there any cases where we need to worry about this in userland? Subquestion: > What exactly interrupts a transition? Is it only user events, or also for example when a new transition happens and if so, is it only if a new transition happens in the same component or an ancestor, or is it app-wide? I've seen discussions around the starvation problem now and then (can't remember where) so I'm curious about if you have ended up with a specific approach in React 18 or if this is yet undecided? It struck me that since interrupted work is no longer reused, maybe this has the potential for happening more often now? The heuristics is an internal detail that can be tweaked of course, so I'm mostly interested if this is something I'll need to ever care about as a developer? Perhaps more concretely: > What happens if I call `startTransition` in a `requestAnimationFrame` and it never has time to finish?",
        "human_words_stopwords_removal_lemmatization": "main question : > happens transition get constantly interrupted time finish , case need worry userland ? subquestion : > exactly interrupt transition ? user event , also example new transition happens , new transition happens component ancestor , app-wide ? 've seen discussion around starvation problem ( ca n't remember ) 'm curious ended specific approach react 18 yet undecided ? struck since interrupted work longer reused , maybe potential happening often ? heuristic internal detail tweaked course , 'm mostly interested something 'll need ever care developer ? perhaps concretely : > happens call ` starttransition ` ` requestanimationframe ` never time finish ?",
        "title_stopwords_removal_lemmatization": "question : transition starvation react 18 ?"
    },
    {
        "issue_id": 918907241,
        "title": "Feedback on startTransition/useTransition syntax",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-11T15:42:43Z",
        "status": "closed",
        "description": "As recommended on the React 18 blog post, I'd like to give feedback on [startTransition](https://github.com/reactwg/react-18/discussions/41) as I don't have access to the working group.\r\n\r\nI have two concerns regarding the `startTransition` callback syntax:\r\n1. If I want to dynamically use or not use the transition behavior, I'd have to use complicated code like:\r\n   ```tsx\r\n   if (canBeDelayed) {\r\n     startTransition(() => {\r\n       setState(newValue);\r\n     });\r\n   } else {\r\n     setState(newValue);\r\n   }\r\n   ```\r\n2. It is not intuitive that `startTransition` only affects `setState` calls when I can wrap arbitrary code inside it.\r\n\r\nHave you considered an alternative syntax, e.g. by adding another parameter to the `setState` callback? This makes it easy to subscribe to the feature dynamically, and avoids nesting the code.\r\n\r\n```tsx\r\nsetState(newValue, { isTransition: true });\r\n```\r\n\r\nInstead of the new `useTransition` hook, you could expand the return values of `useState`:\r\n\r\n```tsx\r\nconst [state, setState, isPending] = React.useState(startValue);\r\n```\r\n\r\nIn my opinion, this results in a cleaner syntax that is more idiomatic with the existing hooks.\r\n\r\nWhere can I find previous discussion on why you settled for the `startTransition` syntax? And is the syntax set in stone or are you still willing to make changes like these?",
        "remove_template_description": "As recommended on the React 18 blog post, I'd like to give feedback on [startTransition](https://github.com/reactwg/react-18/discussions/41) as I don't have access to the working group.    I have two concerns regarding the `startTransition` callback syntax:  1. If I want to dynamically use or not use the transition behavior, I'd have to use complicated code like:     ```tsx     if (canBeDelayed) {       startTransition(() => {         setState(newValue);       });     } else {       setState(newValue);     }     ```  2. It is not intuitive that `startTransition` only affects `setState` calls when I can wrap arbitrary code inside it.    Have you considered an alternative syntax, e.g. by adding another parameter to the `setState` callback? This makes it easy to subscribe to the feature dynamically, and avoids nesting the code.    ```tsx  setState(newValue, { isTransition: true });  ```    Instead of the new `useTransition` hook, you could expand the return values of `useState`:    ```tsx  const [state, setState, isPending] = React.useState(startValue);  ```    In my opinion, this results in a cleaner syntax that is more idiomatic with the existing hooks.    Where can I find previous discussion on why you settled for the `startTransition` syntax? And is the syntax set in stone or are you still willing to make changes like these?",
        "human_words": "As recommended on the React 18 blog post, I'd like to give feedback on [startTransition](https://github.com/reactwg/react-18/discussions/41) as I don't have access to the working group.    I have two concerns regarding the `startTransition` callback syntax:  1. If I want to dynamically use or not use the transition behavior, I'd have to use complicated code like:       2. It is not intuitive that `startTransition` only affects `setState` calls when I can wrap arbitrary code inside it.    Have you considered an alternative syntax, e.g. by adding another parameter to the `setState` callback? This makes it easy to subscribe to the feature dynamically, and avoids nesting the code.        Instead of the new `useTransition` hook, you could expand the return values of `useState`:        In my opinion, this results in a cleaner syntax that is more idiomatic with the existing hooks.    Where can I find previous discussion on why you settled for the `startTransition` syntax? And is the syntax set in stone or are you still willing to make changes like these?",
        "human_words_regrex": "As recommended on the React 18 blog post, I'd like to give feedback on  as I don't have access to the working group. I have two concerns regarding the `startTransition` callback syntax: 1. If I want to dynamically use or not use the transition behavior, I'd have to use complicated code like: 2. It is not intuitive that `startTransition` only affects `setState` calls when I can wrap arbitrary code inside it. Have you considered an alternative syntax, e.g. by adding another parameter to the `setState` callback? This makes it easy to subscribe to the feature dynamically, and avoids nesting the code. Instead of the new `useTransition` hook, you could expand the return values of `useState`: In my opinion, this results in a cleaner syntax that is more idiomatic with the existing hooks. Where can I find previous discussion on why you settled for the `startTransition` syntax? And is the syntax set in stone or are you still willing to make changes like these?",
        "human_words_stopwords_removal_lemmatization": "recommended react 18 blog post , 'd like give feedback n't access working group . two concern regarding ` starttransition ` callback syntax : 1. want dynamically use use transition behavior , 'd use complicated code like : 2. intuitive ` starttransition ` affect ` setstate ` call wrap arbitrary code inside . considered alternative syntax , e.g . adding another parameter ` setstate ` callback ? make easy subscribe feature dynamically , avoids nesting code . instead new ` usetransition ` hook , could expand return value ` usestate ` : opinion , result cleaner syntax idiomatic existing hook . find previous discussion settled ` starttransition ` syntax ? syntax set stone still willing make change like ?",
        "title_stopwords_removal_lemmatization": "feedback starttransition/usetransition syntax"
    },
    {
        "issue_id": 918501732,
        "title": "Concurrency / time-slicing by default",
        "label": [
            "Type: Discussion",
            "React 18"
        ],
        "date": "2021-06-11T09:32:25Z",
        "status": "open",
        "description": "Will concurrency / time-slicing ever become the default behavior? Or will it always require a startTransition block to opt-in?\nIf it will become the default at some point, will that become part of the React 18 timeline or a later major release?",
        "remove_template_description": "Will concurrency / time-slicing ever become the default behavior? Or will it always require a startTransition block to opt-in? If it will become the default at some point, will that become part of the React 18 timeline or a later major release?",
        "human_words": "Will concurrency / time-slicing ever become the default behavior? Or will it always require a startTransition block to opt-in? If it will become the default at some point, will that become part of the React 18 timeline or a later major release?",
        "human_words_regrex": "Will concurrency / time-slicing ever become the default behavior? Or will it always require a startTransition block to opt-in? If it will become the default at some point, will that become part of the React 18 timeline or a later major release?",
        "human_words_stopwords_removal_lemmatization": "concurrency / time-slicing ever become default behavior ? always require starttransition block opt-in ? become default point , become part react 18 timeline later major release ?",
        "title_stopwords_removal_lemmatization": "concurrency / time-slicing default"
    },
    {
        "issue_id": 871267736,
        "title": "ACR/VPAT",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-04-29T17:27:40Z",
        "status": "closed",
        "description": "Is there an ACR/VPAT for react developer tools?\r\n\r\nhttps://www.itic.org/policy/accessibility/vpat",
        "remove_template_description": "Is there an ACR/VPAT for react developer tools?    https://www.itic.org/policy/accessibility/vpat",
        "human_words": "Is there an ACR/VPAT for react developer tools?    https://www.itic.org/policy/accessibility/vpat",
        "human_words_regrex": "Is there an ACR/VPAT for react developer tools? ",
        "human_words_stopwords_removal_lemmatization": "acr/vpat react developer tool ?",
        "title_stopwords_removal_lemmatization": "acr/vpat"
    },
    {
        "issue_id": 870240055,
        "title": "Bug: Impossible to use on async hooks",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2021-04-28T18:41:21Z",
        "status": "open",
        "description": "The rule that prevents using async functions in the hook makes sense in most cases, but there are some valid hooks that have async functions.  See useAsyncEffect as an example.  (https://www.npmjs.com/package/use-async-effect)\r\n\r\nSince the no async rule is bundled with the 'react-hooks/exhaustive-deps' rule, there is no way to use this with an async hook.\r\n\r\nReact version: 16, 17\r\n\r\n## Steps To Reproduce\r\n\r\n1. Create a file that uses useAsyncHook\r\n\r\n2. Configure plugin -> \r\n\r\n    \"react-hooks/exhaustive-deps\": [\r\n      \"warn\",\r\n      {\r\n        \"additionalHooks\": \"(useAsyncEffect)\"\r\n      }\r\n    ]\r\n\r\n3. lint - see error\r\n\r\n## The current behavior\r\n\r\nlinter displays:\r\n\r\n warning  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\r\n\r\nuseEffect(() => {\r\n  async function fetchData() {\r\n    // You can await here\r\n    const response = await MyAPI.getData(someId);\r\n    // ...\r\n  }\r\n  fetchData();\r\n}, [someId]); // Or [] if effect doesn't need props or state\r\n\r\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching  react-hooks/exhaustive-deps\r\n\r\n## The expected behavior\r\n\r\nSeveral options:\r\n\r\n1. Detect the proper use of async in the hook (may be tough)\r\n2. Make a \"react-hooks/no-async\" rule to control this behavior (allows exhaustive-dpes check w/o this warning)\r\n3. Add settings for the \"additionalHooks\" property to specify hook by hook functionality\r\n\r\nI would say that all 3 of this would be great, but #2 to me seems to be a very simple fix.\r\n",
        "remove_template_description": "The rule that prevents using async functions in the hook makes sense in most cases, but there are some valid hooks that have async functions.  See useAsyncEffect as an example.  (https://www.npmjs.com/package/use-async-effect)    Since the no async rule is bundled with the 'react-hooks/exhaustive-deps' rule, there is no way to use this with an async hook.    React version: 16, 17        1. Create a file that uses useAsyncHook    2. Configure plugin ->         \"react-hooks/exhaustive-deps\": [        \"warn\",        {          \"additionalHooks\": \"(useAsyncEffect)\"        }      ]    3. lint - see error        linter displays:     warning  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:    useEffect(() => {    async function fetchData() {      // You can await here      const response = await MyAPI.getData(someId);      // ...    }    fetchData();  }, [someId]); // Or [] if effect doesn't need props or state    Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching  react-hooks/exhaustive-deps        Several options:    1. Detect the proper use of async in the hook (may be tough)  2. Make a \"react-hooks/no-async\" rule to control this behavior (allows exhaustive-dpes check w/o this warning)  3. Add settings for the \"additionalHooks\" property to specify hook by hook functionality    I would say that all 3 of this would be great, but #2 to me seems to be a very simple fix.",
        "human_words": "The rule that prevents using async functions in the hook makes sense in most cases, but there are some valid hooks that have async functions.  See useAsyncEffect as an example.  (https://www.npmjs.com/package/use-async-effect)    Since the no async rule is bundled with the 'react-hooks/exhaustive-deps' rule, there is no way to use this with an async hook.    React version: 16, 17        1. Create a file that uses useAsyncHook    2. Configure plugin ->         \"react-hooks/exhaustive-deps\": [        \"warn\",        {          \"additionalHooks\": \"(useAsyncEffect)\"        }      ]    3. lint - see error        linter displays:     warning  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:    useEffect(() => {    async function fetchData() {      // You can await here      const response = await MyAPI.getData(someId);      // ...    }    fetchData();  }, [someId]); // Or [] if effect doesn't need props or state    Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching  react-hooks/exhaustive-deps        Several options:    1. Detect the proper use of async in the hook (may be tough)  2. Make a \"react-hooks/no-async\" rule to control this behavior (allows exhaustive-dpes check w/o this warning)  3. Add settings for the \"additionalHooks\" property to specify hook by hook functionality    I would say that all 3 of this would be great, but #2 to me seems to be a very simple fix.",
        "human_words_regrex": "The rule that prevents using async functions in the hook makes sense in most cases, but there are some valid hooks that have async functions. See useAsyncEffect as an example. ( Since the no async rule is bundled with the 'react-hooks/exhaustive-deps' rule, there is no way to use this with an async hook. React version: 16, 17 1. Create a file that uses useAsyncHook 2. Configure plugin -> \"react-hooks/exhaustive-deps\": [ \"warn\", { \"additionalHooks\": \"(useAsyncEffect)\" } ] 3. lint - see error linter displays: warning Effect callbacks are synchronous to prevent race conditions. Put the async function inside: useEffect(() => { async function fetchData() { // You can await here const response = await MyAPI.getData(someId); // ... } fetchData(); }, [someId]); // Or [] if effect doesn't need props or state Learn more about data fetching with Hooks:  react-hooks/exhaustive-deps Several options: 1. Detect the proper use of async in the hook (may be tough) 2. Make a \"react-hooks/no-async\" rule to control this behavior (allows exhaustive-dpes check w/o this warning) 3. Add settings for the \"additionalHooks\" property to specify hook by hook functionality I would say that all 3 of this would be great, but #2 to me seems to be a very simple fix.",
        "human_words_stopwords_removal_lemmatization": "rule prevents using async function hook make sense case , valid hook async function . see useasynceffect example . ( since async rule bundled 'react-hooks/exhaustive-deps ' rule , way use async hook . react version : 16 , 17 1. create file us useasynchook 2. configure plugin - > `` react-hooks/exhaustive-deps '' : [ `` warn '' , { `` additionalhooks '' : `` ( useasynceffect ) '' } ] 3. lint - see error linter display : warning effect callback synchronous prevent race condition . put async function inside : useeffect ( ( ) = > { async function fetchdata ( ) { // await const response = await myapi.getdata ( someid ) ; // ... } fetchdata ( ) ; } , [ someid ] ) ; // [ ] effect n't need prop state learn data fetching hook : react-hooks/exhaustive-deps several option : 1. detect proper use async hook ( may tough ) 2. make `` react-hooks/no-async '' rule control behavior ( allows exhaustive-dpes check w/o warning ) 3. add setting `` additionalhooks '' property specify hook hook functionality would say 3 would great , # 2 seems simple fix .",
        "title_stopwords_removal_lemmatization": "bug : impossible use async hook"
    },
    {
        "issue_id": 859612017,
        "title": "Bug: Component inside `<option>` is rendered as `[object Object]` without issuing a warning",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2021-04-16T08:51:50Z",
        "status": "closed",
        "description": "React version: 17.0.2\r\n\r\n## Steps To Reproduce\r\n\r\n1. Nest a component inside an `<option>` tag\r\n\r\nLink to code example: https://codesandbox.io/s/component-inside-option-b1j8s?file=/src/App.js\r\n\r\n## The current behavior\r\n\r\nThe value of the component is rendered as `[object Object]` without issuing a warning in the console.\r\n\r\n## The expected behavior\r\n\r\nPreferably: The value of the component is shown instead of `[object Object]`. See also #13586.\r\n\r\nAlternatively: Issue a warning in the console, like when nesting a `<span>` inside an `<option>` tag:\r\n```\r\nWarning: Only strings and numbers are supported as <option> children.\r\n```\r\n\r\nIn the linked code example, this warning is issued for the `<span>`, but not the `<Comp>`.",
        "remove_template_description": "React version: 17.0.2        1. Nest a component inside an `<option>` tag    Link to code example: https://codesandbox.io/s/component-inside-option-b1j8s?file=/src/App.js        The value of the component is rendered as `[object Object]` without issuing a warning in the console.        Preferably: The value of the component is shown instead of `[object Object]`. See also #13586.    Alternatively: Issue a warning in the console, like when nesting a `<span>` inside an `<option>` tag:  ```  Warning: Only strings and numbers are supported as <option> children.  ```    In the linked code example, this warning is issued for the `<span>`, but not the `<Comp>`.",
        "human_words": "React version: 17.0.2        1. Nest a component inside an `<option>` tag    Link to code example: https://codesandbox.io/s/component-inside-option-b1j8s?file=/src/App.js        The value of the component is rendered as `[object Object]` without issuing a warning in the console.        Preferably: The value of the component is shown instead of `[object Object]`. See also #13586.    Alternatively: Issue a warning in the console, like when nesting a `<span>` inside an `<option>` tag:      In the linked code example, this warning is issued for the `<span>`, but not the `<Comp>`.",
        "human_words_regrex": "React version: 17.0.2 1. Nest a component inside an `` tag Link to code example:  The value of the component is rendered as `[object Object]` without issuing a warning in the console. Preferably: The value of the component is shown instead of `[object Object]`. See also #13586. Alternatively: Issue a warning in the console, like when nesting a `` inside an `` tag: In the linked code example, this warning is issued for the ``, but not the ``.",
        "human_words_stopwords_removal_lemmatization": "react version : 17.0.2 1. nest component inside `` tag link code example : value component rendered ` [ object object ] ` without issuing warning console . preferably : value component shown instead ` [ object object ] ` . see also # 13586. alternatively : issue warning console , like nesting `` inside `` tag : linked code example , warning issued `` , `` .",
        "title_stopwords_removal_lemmatization": "bug : component inside ` < option > ` rendered ` [ object object ] ` without issuing warning"
    },
    {
        "issue_id": 859070960,
        "title": "DevTools React recommendations UI / architecture",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-04-15T16:53:20Z",
        "status": "open",
        "description": "Up until this point, DevTools has generally presented information without making specific recommendations. For example, the Profiler shows which components are faster or slower, relative to each other, but makes no recommendations about how slow is too slow or when/where memoization should be added.\r\n\r\nSome overall architecture and UX for this would probably be good to consider adding to DevTools.\r\n\r\nIdeas for things DevTools might warn about:\r\n* `undefined` return value (could indicate an accidental early return)\r\n* Components that render \"too slow\" (above some threshold)\r\n* When there is a sync update (e.g. recommend `useTransition`)\r\n* When memoization (e.g. `React.memo` or `useMemo`) might be helpful\r\n* Multi-pass renders\r\n\r\nPerhaps we could add an audit mode to check a specific component (or the whole tree) for problems like the ones above.",
        "remove_template_description": "Up until this point, DevTools has generally presented information without making specific recommendations. For example, the Profiler shows which components are faster or slower, relative to each other, but makes no recommendations about how slow is too slow or when/where memoization should be added.    Some overall architecture and UX for this would probably be good to consider adding to DevTools.    Ideas for things DevTools might warn about:  * `undefined` return value (could indicate an accidental early return)  * Components that render \"too slow\" (above some threshold)  * When there is a sync update (e.g. recommend `useTransition`)  * When memoization (e.g. `React.memo` or `useMemo`) might be helpful  * Multi-pass renders    Perhaps we could add an audit mode to check a specific component (or the whole tree) for problems like the ones above.",
        "human_words": "Up until this point, DevTools has generally presented information without making specific recommendations. For example, the Profiler shows which components are faster or slower, relative to each other, but makes no recommendations about how slow is too slow or when/where memoization should be added.    Some overall architecture and UX for this would probably be good to consider adding to DevTools.    Ideas for things DevTools might warn about:  * `undefined` return value (could indicate an accidental early return)  * Components that render \"too slow\" (above some threshold)  * When there is a sync update (e.g. recommend `useTransition`)  * When memoization (e.g. `React.memo` or `useMemo`) might be helpful  * Multi-pass renders    Perhaps we could add an audit mode to check a specific component (or the whole tree) for problems like the ones above.",
        "human_words_regrex": "Up until this point, DevTools has generally presented information without making specific recommendations. For example, the Profiler shows which components are faster or slower, relative to each other, but makes no recommendations about how slow is too slow or when/where memoization should be added. Some overall architecture and UX for this would probably be good to consider adding to DevTools. Ideas for things DevTools might warn about: * `undefined` return value (could indicate an accidental early return) * Components that render \"too slow\" (above some threshold) * When there is a sync update (e.g. recommend `useTransition`) * When memoization (e.g. `React.memo` or `useMemo`) might be helpful * Multi-pass renders Perhaps we could add an audit mode to check a specific component (or the whole tree) for problems like the ones above.",
        "human_words_stopwords_removal_lemmatization": "point , devtools generally presented information without making specific recommendation . example , profiler show component faster slower , relative , make recommendation slow slow when/where memoization added . overall architecture ux would probably good consider adding devtools . idea thing devtools might warn : * ` undefined ` return value ( could indicate accidental early return ) * component render `` slow '' ( threshold ) * sync update ( e.g . recommend ` usetransition ` ) * memoization ( e.g . ` react.memo ` ` usememo ` ) might helpful * multi-pass render perhaps could add audit mode check specific component ( whole tree ) problem like one .",
        "title_stopwords_removal_lemmatization": "devtools react recommendation ui / architecture"
    },
    {
        "issue_id": 857351418,
        "title": "eslint-plugin-react-hooks should flag uses of createRef in function components",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2021-04-13T21:55:29Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nUsing `createRef` in a function component is almost certainly a mistake. You probably want `useRef` instead. This can easily lead to confusing bugs. See, for example, [this popular Stack Overflow question][1].\r\n\r\nBanning `createRef` outright would yield false positives on class components. I suggested adding a rule to flag this specifically in function components to eslint-plugin-react (https://github.com/yannickcr/eslint-plugin-react/issues/2966) but they suggested that I file an issue over here instead.\r\n\r\nReact version: react@16.13.1\r\n\r\n## Steps To Reproduce\r\n\r\n1. Set up eslint-plugin-react-hooks and create a function component that uses `React.createRef`.\r\n2. No complaints.\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example: https://codesandbox.io/s/cool-volhard-9zj0s\r\n\r\n```ts\r\nexport default function App() {\r\n  const ref = React.createRef(0);\r\n  // Change to this to make the example work as intended:\r\n  // const ref = React.useRef(0);\r\n  const [, update] = React.useState(0);\r\n\r\n  const handleClick = () => {\r\n    ref.current += 1;\r\n    update((n) => n + 1);\r\n  };\r\n  React.useEffect(() => {\r\n    ref.current = 0;\r\n  }, [ref]);\r\n\r\n  return (\r\n    <div className=\"App\" ref={ref}>\r\n      <h1>Hello CodeSandbox</h1>\r\n      <h2>Value is {ref.current}</h2>\r\n      <button onClick={handleClick}>Click Me</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\n\r\neslint-plugin-react-hooks does not report an issue.\r\n\r\n## The expected behavior\r\n\r\neslint-plugin-react-hooks should report an issue, namely that the `createRef` should be `useRef`.\r\n\r\n[1]: https://stackoverflow.com/questions/54620698/whats-the-difference-between-useref-and-createref/54620836#54620836",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    Using `createRef` in a function component is almost certainly a mistake. You probably want `useRef` instead. This can easily lead to confusing bugs. See, for example, [this popular Stack Overflow question][1].    Banning `createRef` outright would yield false positives on class components. I suggested adding a rule to flag this specifically in function components to eslint-plugin-react (https://github.com/yannickcr/eslint-plugin-react/issues/2966) but they suggested that I file an issue over here instead.    React version: react@16.13.1        1. Set up eslint-plugin-react-hooks and create a function component that uses `React.createRef`.  2. No complaints.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/cool-volhard-9zj0s    ```ts  export default function App() {    const ref = React.createRef(0);    // Change to this to make the example work as intended:    // const ref = React.useRef(0);    const [, update] = React.useState(0);      const handleClick = () => {      ref.current += 1;      update((n) => n + 1);    };    React.useEffect(() => {      ref.current = 0;    }, [ref]);      return (      <div className=\"App\" ref={ref}>        <h1>Hello CodeSandbox</h1>        <h2>Value is {ref.current}</h2>        <button onClick={handleClick}>Click Me</button>      </div>    );  }  ```    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->        eslint-plugin-react-hooks does not report an issue.        eslint-plugin-react-hooks should report an issue, namely that the `createRef` should be `useRef`.    [1]: https://stackoverflow.com/questions/54620698/whats-the-difference-between-useref-and-createref/54620836#54620836",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    Using `createRef` in a function component is almost certainly a mistake. You probably want `useRef` instead. This can easily lead to confusing bugs. See, for example, [this popular Stack Overflow question][1].    Banning `createRef` outright would yield false positives on class components. I suggested adding a rule to flag this specifically in function components to eslint-plugin-react (https://github.com/yannickcr/eslint-plugin-react/issues/2966) but they suggested that I file an issue over here instead.    React version: react@16.13.1        1. Set up eslint-plugin-react-hooks and create a function component that uses `React.createRef`.  2. No complaints.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: https://codesandbox.io/s/cool-volhard-9zj0s        <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->        eslint-plugin-react-hooks does not report an issue.        eslint-plugin-react-hooks should report an issue, namely that the `createRef` should be `useRef`.    [1]: https://stackoverflow.com/questions/54620698/whats-the-difference-between-useref-and-createref/54620836#54620836",
        "human_words_regrex": " Using `createRef` in a function component is almost certainly a mistake. You probably want `useRef` instead. This can easily lead to confusing bugs. See, for example, [this popular Stack Overflow question][1]. Banning `createRef` outright would yield false positives on class components. I suggested adding a rule to flag this specifically in function components to eslint-plugin-react ( but they suggested that I file an issue over here instead. React version: react@16.13.1 1. Set up eslint-plugin-react-hooks and create a function component that uses `React.createRef`. 2. No complaints.  Link to code example:   eslint-plugin-react-hooks does not report an issue. eslint-plugin-react-hooks should report an issue, namely that the `createRef` should be `useRef`. [1]: ",
        "human_words_stopwords_removal_lemmatization": "using ` createref ` function component almost certainly mistake . probably want ` useref ` instead . easily lead confusing bug . see , example , [ popular stack overflow question ] [ 1 ] . banning ` createref ` outright would yield false positive class component . suggested adding rule flag specifically function component eslint-plugin-react ( suggested file issue instead . react version : react @ 16.13.1 1. set eslint-plugin-react-hooks create function component us ` react.createref ` . 2. complaint . link code example : eslint-plugin-react-hooks report issue . eslint-plugin-react-hooks report issue , namely ` createref ` ` useref ` . [ 1 ] :",
        "title_stopwords_removal_lemmatization": "eslint-plugin-react-hooks flag us createref function component"
    },
    {
        "issue_id": 855951351,
        "title": "Feature request: unmounting flag in useEffect cleanup",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-04-12T13:00:01Z",
        "status": "closed",
        "description": "Would it be possible to add a boolean argument to the useEffect cleanup method that would indicate wheter or not the cleanup was triggered because of dependency changing or because of the component unmounting?\r\n\r\nExample:\r\n```\r\nuseEffect(() => {\r\n  const cancelSource = Axios.CancelToken.source();\r\n  // ... queue request using the id and cancelSource.token\r\n  return (isUnmounting) => cancelSource.cancel('cancelled because ' + (isUnmounting ? 'component is unmounting' : 'dependency changed'));\r\n}, [id]);\r\n```",
        "remove_template_description": "Would it be possible to add a boolean argument to the useEffect cleanup method that would indicate wheter or not the cleanup was triggered because of dependency changing or because of the component unmounting?    Example:  ```  useEffect(() => {    const cancelSource = Axios.CancelToken.source();    // ... queue request using the id and cancelSource.token    return (isUnmounting) => cancelSource.cancel('cancelled because ' + (isUnmounting ? 'component is unmounting' : 'dependency changed'));  }, [id]);  ```",
        "human_words": "Would it be possible to add a boolean argument to the useEffect cleanup method that would indicate wheter or not the cleanup was triggered because of dependency changing or because of the component unmounting?    Example:  ",
        "human_words_regrex": "Would it be possible to add a boolean argument to the useEffect cleanup method that would indicate wheter or not the cleanup was triggered because of dependency changing or because of the component unmounting? Example: ",
        "human_words_stopwords_removal_lemmatization": "would possible add boolean argument useeffect cleanup method would indicate wheter cleanup triggered dependency changing component unmounting ? example :",
        "title_stopwords_removal_lemmatization": "feature request : unmounting flag useeffect cleanup"
    },
    {
        "issue_id": 838594630,
        "title": "Bug: useState with class as initial state throws an error",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2021-03-23T10:51:17Z",
        "status": "open",
        "description": "Using a JavaScript class as initial state in `useState` throws an error. This is because `mountState` check if the initial state is a function by `typeof initialState === 'function'` and classes are technically functions. However since ES6+, I feel like most developers don't consider classes functions because of the less prototype-inheritance feel since ES6 and the `class` keyword.\r\n\r\n\r\nReact version: 17.0.2\r\n\r\n\r\n## Steps To Reproduce\r\n\r\n1. Define an ES6 class\r\n2. Use the class as `initialState` argument to `useState`\r\n\r\nCode example:\r\n\r\n```jsx\r\nimport { useState } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nclass A {}\r\n\r\nfunction App() {\r\n  const [cls, setCls] = useState(A);\r\n  return <h2>{cls.name}</h2>;\r\n}\r\n\r\nReactDOM.render(<App />, document.body);\r\n```\r\n\r\n## The current behavior\r\n\r\n```\r\nTypeError: Cannot call a class as a function\r\n    at _classCallCheck (eval at z (eval.js:42), <anonymous>:3:11)\r\n    at A (VM302 index.js:19)\r\n    at mountState (react-dom.development.js:10436)\r\n    at Object.useState (react-dom.development.js:10919)\r\n    at useState (react.development.js:954)\r\n    at App (VM302 index.js:25)\r\n```\r\n\r\nAlternatively, the error can be `TypeError: Class constructor X cannot be invoked without 'new'`.\r\n\r\n\r\n## The expected behavior\r\n\r\nAs mentioned in the description above, I would \r\n\r\n- either expect classes to work\r\n- or mention this caveat in the docs.\r\n\r\nI guess checking, if the initial state is actually a non-class function, could cause instances of subclasses of functions not to work (depending how the check is done).\r\n",
        "remove_template_description": "Using a JavaScript class as initial state in `useState` throws an error. This is because `mountState` check if the initial state is a function by `typeof initialState === 'function'` and classes are technically functions. However since ES6+, I feel like most developers don't consider classes functions because of the less prototype-inheritance feel since ES6 and the `class` keyword.      React version: 17.0.2          1. Define an ES6 class  2. Use the class as `initialState` argument to `useState`    Code example:    ```jsx  import { useState } from \"react\";  import ReactDOM from \"react-dom\";    class A {}    function App() {    const [cls, setCls] = useState(A);    return <h2>{cls.name}</h2>;  }    ReactDOM.render(<App />, document.body);  ```        ```  TypeError: Cannot call a class as a function      at _classCallCheck (eval at z (eval.js:42), <anonymous>:3:11)      at A (VM302 index.js:19)      at mountState (react-dom.development.js:10436)      at Object.useState (react-dom.development.js:10919)      at useState (react.development.js:954)      at App (VM302 index.js:25)  ```    Alternatively, the error can be `TypeError: Class constructor X cannot be invoked without 'new'`.          As mentioned in the description above, I would     - either expect classes to work  - or mention this caveat in the docs.    I guess checking, if the initial state is actually a non-class function, could cause instances of subclasses of functions not to work (depending how the check is done).",
        "human_words": "Using a JavaScript class as initial state in `useState` throws an error. This is because `mountState` check if the initial state is a function by `typeof initialState === 'function'` and classes are technically functions. However since ES6+, I feel like most developers don't consider classes functions because of the less prototype-inheritance feel since ES6 and the `class` keyword.      React version: 17.0.2          1. Define an ES6 class  2. Use the class as `initialState` argument to `useState`    Code example:                Alternatively, the error can be `TypeError: Class constructor X cannot be invoked without 'new'`.          As mentioned in the description above, I would     - either expect classes to work  - or mention this caveat in the docs.    I guess checking, if the initial state is actually a non-class function, could cause instances of subclasses of functions not to work (depending how the check is done).",
        "human_words_regrex": "Using a JavaScript class as initial state in `useState` throws an error. This is because `mountState` check if the initial state is a function by `typeof initialState === 'function'` and classes are technically functions. However since ES6+, I feel like most developers don't consider classes functions because of the less prototype-inheritance feel since ES6 and the `class` keyword. React version: 17.0.2 1. Define an ES6 class 2. Use the class as `initialState` argument to `useState` Code example: Alternatively, the error can be `TypeError: Class constructor X cannot be invoked without 'new'`. As mentioned in the description above, I would - either expect classes to work - or mention this caveat in the docs. I guess checking, if the initial state is actually a non-class function, could cause instances of subclasses of functions not to work (depending how the check is done).",
        "human_words_stopwords_removal_lemmatization": "using javascript class initial state ` usestate ` throw error . ` mountstate ` check initial state function ` typeof initialstate === 'function ' ` class technically function . however since es6+ , feel like developer n't consider class function le prototype-inheritance feel since es6 ` class ` keyword . react version : 17.0.2 1. define es6 class 2. use class ` initialstate ` argument ` usestate ` code example : alternatively , error ` typeerror : class constructor x invoked without 'new ' ` . mentioned description , would - either expect class work - mention caveat doc . guess checking , initial state actually non-class function , could cause instance subclass function work ( depending check done ) .",
        "title_stopwords_removal_lemmatization": "bug : usestate class initial state throw error"
    },
    {
        "issue_id": 816603408,
        "title": "React throws many fake errors when warnings are issued",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-02-25T16:39:08Z",
        "status": "open",
        "description": "In describeNativeComponentFrame, the component rendering is intentionally failed so that we can gather details from the stack trace for some warnings. The Chrome dev tools will break on every single one of these, sometimes more than once. We have many, many components in our call stack before the warning is triggered, throwing many false errors, making it very difficult for us to use the dev tools to investigate unrelated errors when the warnings are present.\r\n\r\nReact version: 17.0.1\r\n\r\n1. Create a simple minimal React page.\r\n2. Render a simple \"hello world\" component with a warning.\r\n3. Open the Chrome dev tools, click break on all exceptions with caught exceptions, and then reload the page.\r\n\r\nLink to code example:\r\n\r\nhttps://github.com/markboyall/react-break-example\r\n\r\nThe current behaviour is that it breaks once per component in the stack frame, causing an unmanageable number of fake breaks. The expected behaviour is that React does not interfere with the browser dev tools can be used to debug our own code.\r\n\r\nPrevious versions of React could issue warnings with one break at the warning site only at most, which was an acceptable tradeoff.",
        "remove_template_description": "In describeNativeComponentFrame, the component rendering is intentionally failed so that we can gather details from the stack trace for some warnings. The Chrome dev tools will break on every single one of these, sometimes more than once. We have many, many components in our call stack before the warning is triggered, throwing many false errors, making it very difficult for us to use the dev tools to investigate unrelated errors when the warnings are present.    React version: 17.0.1    1. Create a simple minimal React page.  2. Render a simple \"hello world\" component with a warning.  3. Open the Chrome dev tools, click break on all exceptions with caught exceptions, and then reload the page.    Link to code example:    https://github.com/markboyall/react-break-example    The current behaviour is that it breaks once per component in the stack frame, causing an unmanageable number of fake breaks. The expected behaviour is that React does not interfere with the browser dev tools can be used to debug our own code.    Previous versions of React could issue warnings with one break at the warning site only at most, which was an acceptable tradeoff.",
        "human_words": "In describeNativeComponentFrame, the component rendering is intentionally failed so that we can gather details from the stack trace for some warnings. The Chrome dev tools will break on every single one of these, sometimes more than once. We have many, many components in our call stack before the warning is triggered, throwing many false errors, making it very difficult for us to use the dev tools to investigate unrelated errors when the warnings are present.    React version: 17.0.1    1. Create a simple minimal React page.  2. Render a simple \"hello world\" component with a warning.  3. Open the Chrome dev tools, click break on all exceptions with caught exceptions, and then reload the page.    Link to code example:    https://github.com/markboyall/react-break-example    The current behaviour is that it breaks once per component in the stack frame, causing an unmanageable number of fake breaks. The expected behaviour is that React does not interfere with the browser dev tools can be used to debug our own code.    Previous versions of React could issue warnings with one break at the warning site only at most, which was an acceptable tradeoff.",
        "human_words_regrex": "In describeNativeComponentFrame, the component rendering is intentionally failed so that we can gather details from the stack trace for some warnings. The Chrome dev tools will break on every single one of these, sometimes more than once. We have many, many components in our call stack before the warning is triggered, throwing many false errors, making it very difficult for us to use the dev tools to investigate unrelated errors when the warnings are present. React version: 17.0.1 1. Create a simple minimal React page. 2. Render a simple \"hello world\" component with a warning. 3. Open the Chrome dev tools, click break on all exceptions with caught exceptions, and then reload the page. Link to code example:  The current behaviour is that it breaks once per component in the stack frame, causing an unmanageable number of fake breaks. The expected behaviour is that React does not interfere with the browser dev tools can be used to debug our own code. Previous versions of React could issue warnings with one break at the warning site only at most, which was an acceptable tradeoff.",
        "human_words_stopwords_removal_lemmatization": "describenativecomponentframe , component rendering intentionally failed gather detail stack trace warning . chrome dev tool break every single one , sometimes . many , many component call stack warning triggered , throwing many false error , making difficult u use dev tool investigate unrelated error warning present . react version : 17.0.1 1. create simple minimal react page . 2. render simple `` hello world '' component warning . 3. open chrome dev tool , click break exception caught exception , reload page . link code example : current behaviour break per component stack frame , causing unmanageable number fake break . expected behaviour react interfere browser dev tool used debug code . previous version react could issue warning one break warning site , acceptable tradeoff .",
        "title_stopwords_removal_lemmatization": "react throw many fake error warning issued"
    },
    {
        "issue_id": 810703714,
        "title": "Impact: Removal of `function.displayName` in Chromium ",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-02-18T02:41:23Z",
        "status": "open",
        "description": "Chromium plan to [remove the non-standard property `fn.displayName` property](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64). How would this impact React [`component.displayName`](https://reactjs.org/docs/react-component.html#displayname)?\r\n\r\nLinks:\r\n- Chromium: [Remove non-standard fn.displayName support](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64)\r\n- React: [Component.displayName](https://reactjs.org/docs/react-component.html#displayname)\r\n\r\n#### TL;DR;\r\n\r\nChromium has traditionally supported the non-standard `fn.displayName` property as a way to provide developer-controlled debug names for functions that show up in `error.stack` and in `DevTools` stack traces. \r\n\r\nWith ES6, `fn.name` is configurable as a standard, which is a portable replacement for `fn.displayName`. Also, V8 added logic to automatically infer good function names from the source code. \r\n\r\n\r\n\r\n\r\n",
        "remove_template_description": "Chromium plan to [remove the non-standard property `fn.displayName` property](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64). How would this impact React [`component.displayName`](https://reactjs.org/docs/react-component.html#displayname)?    Links:  - Chromium: [Remove non-standard fn.displayName support](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64)  - React: [Component.displayName](https://reactjs.org/docs/react-component.html#displayname)    #### TL;DR;    Chromium has traditionally supported the non-standard `fn.displayName` property as a way to provide developer-controlled debug names for functions that show up in `error.stack` and in `DevTools` stack traces.     With ES6, `fn.name` is configurable as a standard, which is a portable replacement for `fn.displayName`. Also, V8 added logic to automatically infer good function names from the source code.",
        "human_words": "Chromium plan to [remove the non-standard property `fn.displayName` property](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64). How would this impact React [`component.displayName`](https://reactjs.org/docs/react-component.html#displayname)?    Links:  - Chromium: [Remove non-standard fn.displayName support](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64)  - React: [Component.displayName](https://reactjs.org/docs/react-component.html#displayname)    #### TL;DR;    Chromium has traditionally supported the non-standard `fn.displayName` property as a way to provide developer-controlled debug names for functions that show up in `error.stack` and in `DevTools` stack traces.     With ES6, `fn.name` is configurable as a standard, which is a portable replacement for `fn.displayName`. Also, V8 added logic to automatically infer good function names from the source code.",
        "human_words_regrex": "Chromium plan to . How would this impact React ? Links: - Chromium:  - React:  #### TL;DR; Chromium has traditionally supported the non-standard `fn.displayName` property as a way to provide developer-controlled debug names for functions that show up in `error.stack` and in `DevTools` stack traces. With ES6, `fn.name` is configurable as a standard, which is a portable replacement for `fn.displayName`. Also, V8 added logic to automatically infer good function names from the source code.",
        "human_words_stopwords_removal_lemmatization": "chromium plan . would impact react ? link : - chromium : - react : # # # # tl ; dr ; chromium traditionally supported non-standard ` fn.displayname ` property way provide developer-controlled debug name function show ` error.stack ` ` devtools ` stack trace . es6 , ` fn.name ` configurable standard , portable replacement ` fn.displayname ` . also , v8 added logic automatically infer good function name source code .",
        "title_stopwords_removal_lemmatization": "impact : removal ` function.displayname ` chromium"
    },
    {
        "issue_id": 810674611,
        "title": "Feature Request: usePureEffect",
        "label": [
            "Type: Discussion"
        ],
        "date": "2021-02-18T01:34:41Z",
        "status": "closed",
        "description": "It would be great if React exposed a hook, potentially called `usePureEffect`, that works like `useEffect` (runs some code on some dependency change), but does not run on initial mount. \r\n\r\nThis seems to be a common issue in the community. The de facto solution is to write a custom hook based on `useEffect` that keeps track of the initial render (via `useState` or `useRef`). While such a hook is arguably easy to implement (see below), since it's so common, it would be much more convenient if this was part of React's core API.\r\n\r\nPotential Implementation\r\n```js\r\nconst usePureEffect = (func, dependencies) => {\r\n  const isFirstRender = useRef(true)\r\n  useEffect(() => {\r\n    if (isFirstRender.current) {\r\n      isFirstRender.current = false\r\n      return () => {}\r\n    }\r\n    return func()\r\n  }, dependencies)\r\n}\r\n```",
        "remove_template_description": "It would be great if React exposed a hook, potentially called `usePureEffect`, that works like `useEffect` (runs some code on some dependency change), but does not run on initial mount.     This seems to be a common issue in the community. The de facto solution is to write a custom hook based on `useEffect` that keeps track of the initial render (via `useState` or `useRef`). While such a hook is arguably easy to implement (see below), since it's so common, it would be much more convenient if this was part of React's core API.    Potential Implementation  ```js  const usePureEffect = (func, dependencies) => {    const isFirstRender = useRef(true)    useEffect(() => {      if (isFirstRender.current) {        isFirstRender.current = false        return () => {}      }      return func()    }, dependencies)  }  ```",
        "human_words": "It would be great if React exposed a hook, potentially called `usePureEffect`, that works like `useEffect` (runs some code on some dependency change), but does not run on initial mount.     This seems to be a common issue in the community. The de facto solution is to write a custom hook based on `useEffect` that keeps track of the initial render (via `useState` or `useRef`). While such a hook is arguably easy to implement (see below), since it's so common, it would be much more convenient if this was part of React's core API.    Potential Implementation  ",
        "human_words_regrex": "It would be great if React exposed a hook, potentially called `usePureEffect`, that works like `useEffect` (runs some code on some dependency change), but does not run on initial mount. This seems to be a common issue in the community. The de facto solution is to write a custom hook based on `useEffect` that keeps track of the initial render (via `useState` or `useRef`). While such a hook is arguably easy to implement (see below), since it's so common, it would be much more convenient if this was part of React's core API. Potential Implementation ",
        "human_words_stopwords_removal_lemmatization": "would great react exposed hook , potentially called ` usepureeffect ` , work like ` useeffect ` ( run code dependency change ) , run initial mount . seems common issue community . de facto solution write custom hook based ` useeffect ` keep track initial render ( via ` usestate ` ` useref ` ) . hook arguably easy implement ( see ) , since 's common , would much convenient part react 's core api . potential implementation",
        "title_stopwords_removal_lemmatization": "feature request : usepureeffect"
    },
    {
        "issue_id": 806658905,
        "title": "Bug: devtools reload-and-profile feature is defeated by sync-xhr feature policy",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-02-11T19:01:26Z",
        "status": "closed",
        "description": "React version: all\r\n\r\n## Steps To Reproduce\r\n\r\n1. Visit a site that uses `Feature-Policy: sync-xhr 'none'` and has the profiling build of react enabled\r\n2. Attempt to use the \"reload and start profiling\" feature of devtools\r\n3. The xhr request will fail on reload because it [attempts to make a synchronous XHR call](https://github.com/facebook/react/blob/9198a5cec0936a21a5ba194a22fcbac03eba5d1d/packages/react-devtools-extensions/src/injectGlobalHook.js#L84).  The profiling tab will be stuck in \"press record to stop recording\" state.  Devtools will now fail to load on all subsequent refreshes unless the developer clears session storage, because it keeps trying and failing to make that XHR request.\r\n\r\n## The current behavior\r\nsee `3.` above\r\n\r\n## The expected behavior\r\nIdeally, this feature would not depend on synchronous XHR to function.  [Browsers are deprecating it](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#synchronous_request) and sites are blocking it via `Feature-Policy` due to third-party javascript abusing it.\r\nIn its current state, the feature should fail more gracefully when the XHR is blocked due to feature policy or in the future when browsers start blocking it by default.",
        "remove_template_description": "React version: all        1. Visit a site that uses `Feature-Policy: sync-xhr 'none'` and has the profiling build of react enabled  2. Attempt to use the \"reload and start profiling\" feature of devtools  3. The xhr request will fail on reload because it [attempts to make a synchronous XHR call](https://github.com/facebook/react/blob/9198a5cec0936a21a5ba194a22fcbac03eba5d1d/packages/react-devtools-extensions/src/injectGlobalHook.js#L84).  The profiling tab will be stuck in \"press record to stop recording\" state.  Devtools will now fail to load on all subsequent refreshes unless the developer clears session storage, because it keeps trying and failing to make that XHR request.      see `3.` above      Ideally, this feature would not depend on synchronous XHR to function.  [Browsers are deprecating it](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#synchronous_request) and sites are blocking it via `Feature-Policy` due to third-party javascript abusing it.  In its current state, the feature should fail more gracefully when the XHR is blocked due to feature policy or in the future when browsers start blocking it by default.",
        "human_words": "React version: all        1. Visit a site that uses `Feature-Policy: sync-xhr 'none'` and has the profiling build of react enabled  2. Attempt to use the \"reload and start profiling\" feature of devtools  3. The xhr request will fail on reload because it [attempts to make a synchronous XHR call](https://github.com/facebook/react/blob/9198a5cec0936a21a5ba194a22fcbac03eba5d1d/packages/react-devtools-extensions/src/injectGlobalHook.js#L84).  The profiling tab will be stuck in \"press record to stop recording\" state.  Devtools will now fail to load on all subsequent refreshes unless the developer clears session storage, because it keeps trying and failing to make that XHR request.      see `3.` above      Ideally, this feature would not depend on synchronous XHR to function.  [Browsers are deprecating it](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#synchronous_request) and sites are blocking it via `Feature-Policy` due to third-party javascript abusing it.  In its current state, the feature should fail more gracefully when the XHR is blocked due to feature policy or in the future when browsers start blocking it by default.",
        "human_words_regrex": "React version: all 1. Visit a site that uses `Feature-Policy: sync-xhr 'none'` and has the profiling build of react enabled 2. Attempt to use the \"reload and start profiling\" feature of devtools 3. The xhr request will fail on reload because it . The profiling tab will be stuck in \"press record to stop recording\" state. Devtools will now fail to load on all subsequent refreshes unless the developer clears session storage, because it keeps trying and failing to make that XHR request. see `3.` above Ideally, this feature would not depend on synchronous XHR to function.  and sites are blocking it via `Feature-Policy` due to third-party javascript abusing it. In its current state, the feature should fail more gracefully when the XHR is blocked due to feature policy or in the future when browsers start blocking it by default.",
        "human_words_stopwords_removal_lemmatization": "react version : 1. visit site us ` feature-policy : sync-xhr 'none ' ` profiling build react enabled 2. attempt use `` reload start profiling '' feature devtools 3. xhr request fail reload . profiling tab stuck `` press record stop recording '' state . devtools fail load subsequent refreshes unless developer clear session storage , keep trying failing make xhr request . see ` 3. ` ideally , feature would depend synchronous xhr function . site blocking via ` feature-policy ` due third-party javascript abusing . current state , feature fail gracefully xhr blocked due feature policy future browser start blocking default .",
        "title_stopwords_removal_lemmatization": "bug : devtools reload-and-profile feature defeated sync-xhr feature policy"
    },
    {
        "issue_id": 806620228,
        "title": "Bug: Anonymous component name in developer tool with run build but not run start",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2021-02-11T18:03:37Z",
        "status": "closed",
        "description": "Components name are not displayed in developer tool in production environment (during tests). But they are in the local one launched with npm run start.\r\n![image](https://user-images.githubusercontent.com/3542010/107675868-cde38180-6c98-11eb-9b78-e0005cab77e9.png)\r\n\r\nI configured webpack to to have almost the same behavior between two environments but I did not succeed to have the expected behavior.\r\nIt seems linked to the displayName property which is not set under \"type\".\r\n\r\nproduction env\r\n![image](https://user-images.githubusercontent.com/3542010/107676040-03886a80-6c99-11eb-85e1-54a182e44b29.png)\r\n\r\nlocal env\r\n![image](https://user-images.githubusercontent.com/3542010/107676128-169b3a80-6c99-11eb-9de5-518ec250571d.png)\r\n\r\n\r\nReact version: 17.0.1\r\n\r\n## Steps To Reproduce\r\n\r\nYou can reproduce the bug by using React.memo on an anonymous function and then set displayName on the output.\r\n\r\nExample:\r\n```\r\nexport default App = React.memo(() => {\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>Hello CodeSandbox</h1>\r\n      <h2>Start editing to see some magic happen!</h2>\r\n    </div>\r\n  );\r\n});\r\nApp.displayName = \"App\";\r\n```\r\n\r\nActually, the bug is probably that the displayName is not taken into account on memo by the react devtool. But since the object is not generated the same way in both environments, I'm not quite sure.",
        "remove_template_description": "Components name are not displayed in developer tool in production environment (during tests). But they are in the local one launched with npm run start.  ![image](https://user-images.githubusercontent.com/3542010/107675868-cde38180-6c98-11eb-9b78-e0005cab77e9.png)    I configured webpack to to have almost the same behavior between two environments but I did not succeed to have the expected behavior.  It seems linked to the displayName property which is not set under \"type\".    production env  ![image](https://user-images.githubusercontent.com/3542010/107676040-03886a80-6c99-11eb-85e1-54a182e44b29.png)    local env  ![image](https://user-images.githubusercontent.com/3542010/107676128-169b3a80-6c99-11eb-9de5-518ec250571d.png)      React version: 17.0.1        You can reproduce the bug by using React.memo on an anonymous function and then set displayName on the output.    Example:  ```  export default App = React.memo(() => {    return (      <div className=\"App\">        <h1>Hello CodeSandbox</h1>        <h2>Start editing to see some magic happen!</h2>      </div>    );  });  App.displayName = \"App\";  ```    Actually, the bug is probably that the displayName is not taken into account on memo by the react devtool. But since the object is not generated the same way in both environments, I'm not quite sure.",
        "human_words": "Components name are not displayed in developer tool in production environment (during tests). But they are in the local one launched with npm run start.  ![image](https://user-images.githubusercontent.com/3542010/107675868-cde38180-6c98-11eb-9b78-e0005cab77e9.png)    I configured webpack to to have almost the same behavior between two environments but I did not succeed to have the expected behavior.  It seems linked to the displayName property which is not set under \"type\".    production env  ![image](https://user-images.githubusercontent.com/3542010/107676040-03886a80-6c99-11eb-85e1-54a182e44b29.png)    local env  ![image](https://user-images.githubusercontent.com/3542010/107676128-169b3a80-6c99-11eb-9de5-518ec250571d.png)      React version: 17.0.1        You can reproduce the bug by using React.memo on an anonymous function and then set displayName on the output.    Example:      Actually, the bug is probably that the displayName is not taken into account on memo by the react devtool. But since the object is not generated the same way in both environments, I'm not quite sure.",
        "human_words_regrex": "Components name are not displayed in developer tool in production environment (during tests). But they are in the local one launched with npm run start. ! I configured webpack to to have almost the same behavior between two environments but I did not succeed to have the expected behavior. It seems linked to the displayName property which is not set under \"type\". production env ! local env ! React version: 17.0.1 You can reproduce the bug by using React.memo on an anonymous function and then set displayName on the output. Example: Actually, the bug is probably that the displayName is not taken into account on memo by the react devtool. But since the object is not generated the same way in both environments, I'm not quite sure.",
        "human_words_stopwords_removal_lemmatization": "component name displayed developer tool production environment ( test ) . local one launched npm run start . ! configured webpack almost behavior two environment succeed expected behavior . seems linked displayname property set `` type '' . production env ! local env ! react version : 17.0.1 reproduce bug using react.memo anonymous function set displayname output . example : actually , bug probably displayname taken account memo react devtool . since object generated way environment , 'm quite sure .",
        "title_stopwords_removal_lemmatization": "bug : anonymous component name developer tool run build run start"
    },
    {
        "issue_id": 782595008,
        "title": "Feature Request: Provide an optimization option for simple stateless components",
        "label": [
            "Resolution: Needs More Information",
            "Type: Discussion"
        ],
        "date": "2021-01-09T12:11:52Z",
        "status": "closed",
        "description": "Please look at the following code first.\r\n```jsx\r\nfunction A() {\r\n  return <HeavyComponent someProp={true} />;\r\n}\r\n\r\nfunction B() {\r\n  return <HeavyComponent someProp={false} />;\r\n}\r\n\r\nfunction C() {\r\n  const [state, setState] = useState(true);\r\n  return state ? <A /> : <B />;\r\n}\r\n\r\nfunction D() {\r\n  const [state, setState] = useState(true);\r\n  return state ? A() : B();\r\n}\r\n```\r\n`HeavyComponent` is literally a heavy component that requires large computation for rendering. Assume that nobody wants the scenario that `HeavyComponent` mounts and unmounts frequently.\r\n\r\nAnd as you can see, `A` and `B` do very simple jobs. They are just tiny components that just wrap `HeavyComponent` in each different way. `A` and `B` can be switched to each other in both `C` and `D`. The rendering result will be the same in `C` and `D`. But the internal behaviors differ from each other. `C` causes `HeavyComponent` to mount whenever it rerenders, while `D` doesn't. If there are `useEffect` calls with empty `deps` inside `HeavyComponent`'s body, then they will be called each time `state` in C changes, while they won't with `D`. So, `D` is better in performance than `C`.\r\n\r\nHowever, the problem is that `A()` and `B()` are not the recommended style in React code. If `A` and `B` are used only inside the module not being exported to others than the author, then `A()` is an acceptable hack. But sometimes, at least in my case, components like `A` and `B` should be exported outside the module. And it's hard to expect users of my library to use `A` and `B` in an efficient way like inside `D`. I hope there is a way to let users use `<A />` instead of `A()` not worrying about the performance.\r\n\r\nI think you can point out that I don't need to define `A` and `B` and I can use `HeavyComponent` directly instead. But it's just a simplified example. In real practice, I have more than one props and also more components. Each component represents the semantic of the combination of props passing to  `HeavyComponent` by name of itself. \r\n> My case is a little specific and not usual, so I don't think I can explain well my issue. I'll happy if someone helps me with familiar examples of `A` and `B` in real practice that many people have met before.\r\n\r\nI'll also export `HeavyComponent` directly, but users will get confused about its props at the first glance. So it would be better to export handy components `A` and `B` also.\r\n\r\nI suppose the implementation would not be complicated. The following is my psuedo code.\r\n```jsx\r\nfunction simpleComponent(component) {\r\n  const x = (...args) => component(...args)\r\n  x.isSimple = true;\r\n  return x;\r\n}\r\n\r\nfunction createElement(component, props) {\r\n  if(component.isSimple) {\r\n    return component(props);\r\n  }\r\n  // do original behavior\r\n  // ...\r\n}\r\n\r\nconst A = simpleComponent(() => <HeavyComponent someProp={true} />);\r\nconst B = simpleComponent(() => <HeavyComponent someProp={false} />);\r\n```\r\nI said _stateless_ in the title, but _hookless_ would be the correct condition. `useEffect`, `useRef` and other hooks are not permitted inside the body of simple components. Of course, I don't think simple is a good name. I'll be happy to see suggestions.\r\n\r\nDoes this seem a reasonable option to consider?",
        "remove_template_description": "Please look at the following code first.  ```jsx  function A() {    return <HeavyComponent someProp={true} />;  }    function B() {    return <HeavyComponent someProp={false} />;  }    function C() {    const [state, setState] = useState(true);    return state ? <A /> : <B />;  }    function D() {    const [state, setState] = useState(true);    return state ? A() : B();  }  ```  `HeavyComponent` is literally a heavy component that requires large computation for rendering. Assume that nobody wants the scenario that `HeavyComponent` mounts and unmounts frequently.    And as you can see, `A` and `B` do very simple jobs. They are just tiny components that just wrap `HeavyComponent` in each different way. `A` and `B` can be switched to each other in both `C` and `D`. The rendering result will be the same in `C` and `D`. But the internal behaviors differ from each other. `C` causes `HeavyComponent` to mount whenever it rerenders, while `D` doesn't. If there are `useEffect` calls with empty `deps` inside `HeavyComponent`'s body, then they will be called each time `state` in C changes, while they won't with `D`. So, `D` is better in performance than `C`.    However, the problem is that `A()` and `B()` are not the recommended style in React code. If `A` and `B` are used only inside the module not being exported to others than the author, then `A()` is an acceptable hack. But sometimes, at least in my case, components like `A` and `B` should be exported outside the module. And it's hard to expect users of my library to use `A` and `B` in an efficient way like inside `D`. I hope there is a way to let users use `<A />` instead of `A()` not worrying about the performance.    I think you can point out that I don't need to define `A` and `B` and I can use `HeavyComponent` directly instead. But it's just a simplified example. In real practice, I have more than one props and also more components. Each component represents the semantic of the combination of props passing to  `HeavyComponent` by name of itself.   > My case is a little specific and not usual, so I don't think I can explain well my issue. I'll happy if someone helps me with familiar examples of `A` and `B` in real practice that many people have met before.    I'll also export `HeavyComponent` directly, but users will get confused about its props at the first glance. So it would be better to export handy components `A` and `B` also.    I suppose the implementation would not be complicated. The following is my psuedo code.  ```jsx  function simpleComponent(component) {    const x = (...args) => component(...args)    x.isSimple = true;    return x;  }    function createElement(component, props) {    if(component.isSimple) {      return component(props);    }    // do original behavior    // ...  }    const A = simpleComponent(() => <HeavyComponent someProp={true} />);  const B = simpleComponent(() => <HeavyComponent someProp={false} />);  ```  I said _stateless_ in the title, but _hookless_ would be the correct condition. `useEffect`, `useRef` and other hooks are not permitted inside the body of simple components. Of course, I don't think simple is a good name. I'll be happy to see suggestions.    Does this seem a reasonable option to consider?",
        "human_words": "Please look at the following code first.    `HeavyComponent` is literally a heavy component that requires large computation for rendering. Assume that nobody wants the scenario that `HeavyComponent` mounts and unmounts frequently.    And as you can see, `A` and `B` do very simple jobs. They are just tiny components that just wrap `HeavyComponent` in each different way. `A` and `B` can be switched to each other in both `C` and `D`. The rendering result will be the same in `C` and `D`. But the internal behaviors differ from each other. `C` causes `HeavyComponent` to mount whenever it rerenders, while `D` doesn't. If there are `useEffect` calls with empty `deps` inside `HeavyComponent`'s body, then they will be called each time `state` in C changes, while they won't with `D`. So, `D` is better in performance than `C`.    However, the problem is that `A()` and `B()` are not the recommended style in React code. If `A` and `B` are used only inside the module not being exported to others than the author, then `A()` is an acceptable hack. But sometimes, at least in my case, components like `A` and `B` should be exported outside the module. And it's hard to expect users of my library to use `A` and `B` in an efficient way like inside `D`. I hope there is a way to let users use `<A />` instead of `A()` not worrying about the performance.    I think you can point out that I don't need to define `A` and `B` and I can use `HeavyComponent` directly instead. But it's just a simplified example. In real practice, I have more than one props and also more components. Each component represents the semantic of the combination of props passing to  `HeavyComponent` by name of itself.   > My case is a little specific and not usual, so I don't think I can explain well my issue. I'll happy if someone helps me with familiar examples of `A` and `B` in real practice that many people have met before.    I'll also export `HeavyComponent` directly, but users will get confused about its props at the first glance. So it would be better to export handy components `A` and `B` also.    I suppose the implementation would not be complicated. The following is my psuedo code.    I said _stateless_ in the title, but _hookless_ would be the correct condition. `useEffect`, `useRef` and other hooks are not permitted inside the body of simple components. Of course, I don't think simple is a good name. I'll be happy to see suggestions.    Does this seem a reasonable option to consider?",
        "human_words_regrex": "Please look at the following code first. `HeavyComponent` is literally a heavy component that requires large computation for rendering. Assume that nobody wants the scenario that `HeavyComponent` mounts and unmounts frequently. And as you can see, `A` and `B` do very simple jobs. They are just tiny components that just wrap `HeavyComponent` in each different way. `A` and `B` can be switched to each other in both `C` and `D`. The rendering result will be the same in `C` and `D`. But the internal behaviors differ from each other. `C` causes `HeavyComponent` to mount whenever it rerenders, while `D` doesn't. If there are `useEffect` calls with empty `deps` inside `HeavyComponent`'s body, then they will be called each time `state` in C changes, while they won't with `D`. So, `D` is better in performance than `C`. However, the problem is that `A()` and `B()` are not the recommended style in React code. If `A` and `B` are used only inside the module not being exported to others than the author, then `A()` is an acceptable hack. But sometimes, at least in my case, components like `A` and `B` should be exported outside the module. And it's hard to expect users of my library to use `A` and `B` in an efficient way like inside `D`. I hope there is a way to let users use `` instead of `A()` not worrying about the performance. I think you can point out that I don't need to define `A` and `B` and I can use `HeavyComponent` directly instead. But it's just a simplified example. In real practice, I have more than one props and also more components. Each component represents the semantic of the combination of props passing to `HeavyComponent` by name of itself. > My case is a little specific and not usual, so I don't think I can explain well my issue. I'll happy if someone helps me with familiar examples of `A` and `B` in real practice that many people have met before. I'll also export `HeavyComponent` directly, but users will get confused about its props at the first glance. So it would be better to export handy components `A` and `B` also. I suppose the implementation would not be complicated. The following is my psuedo code. I said _stateless_ in the title, but _hookless_ would be the correct condition. `useEffect`, `useRef` and other hooks are not permitted inside the body of simple components. Of course, I don't think simple is a good name. I'll be happy to see suggestions. Does this seem a reasonable option to consider?",
        "human_words_stopwords_removal_lemmatization": "please look following code first . ` heavycomponent ` literally heavy component requires large computation rendering . assume nobody want scenario ` heavycomponent ` mount unmounts frequently . see , ` ` ` b ` simple job . tiny component wrap ` heavycomponent ` different way . ` ` ` b ` switched ` c ` ` ` . rendering result ` c ` ` ` . internal behavior differ . ` c ` cause ` heavycomponent ` mount whenever rerenders , ` ` n't . ` useeffect ` call empty ` deps ` inside ` heavycomponent ` 's body , called time ` state ` c change , wo n't ` ` . , ` ` better performance ` c ` . however , problem ` ( ) ` ` b ( ) ` recommended style react code . ` ` ` b ` used inside module exported others author , ` ( ) ` acceptable hack . sometimes , least case , component like ` ` ` b ` exported outside module . 's hard expect user library use ` ` ` b ` efficient way like inside ` ` . hope way let user use `` instead ` ( ) ` worrying performance . think point n't need define ` ` ` b ` use ` heavycomponent ` directly instead . 's simplified example . real practice , one prop also component . component represents semantic combination prop passing ` heavycomponent ` name . > case little specific usual , n't think explain well issue . 'll happy someone help familiar example ` ` ` b ` real practice many people met . 'll also export ` heavycomponent ` directly , user get confused prop first glance . would better export handy component ` ` ` b ` also . suppose implementation would complicated . following psuedo code . said _stateless_ title , _hookless_ would correct condition . ` useeffect ` , ` useref ` hook permitted inside body simple component . course , n't think simple good name . 'll happy see suggestion . seem reasonable option consider ?",
        "title_stopwords_removal_lemmatization": "feature request : provide optimization option simple stateless component"
    },
    {
        "issue_id": 772165438,
        "title": "Discussion: useEffect deps array",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2020-12-21T13:21:46Z",
        "status": "closed",
        "description": "# What is it\r\nSince the hooks launch, I've been working with various teams and developers, and all of them, I repeat, ALL of them, seniors and juniors. Have been using useEffect \"wrong\" (considering what the react team intended). They all use the dependency array as an update array. There is no reason to keep hammering us, telling us that it is a dependency array if no one uses that way.\r\n\r\n# What I propose\r\nChange linters and documentation to reflect the array as an update array, not as a dependency. Maybe add a third argument that should run as an actual dependency array, that does not trigger the code inside.",
        "remove_template_description": "# What is it  Since the hooks launch, I've been working with various teams and developers, and all of them, I repeat, ALL of them, seniors and juniors. Have been using useEffect \"wrong\" (considering what the react team intended). They all use the dependency array as an update array. There is no reason to keep hammering us, telling us that it is a dependency array if no one uses that way.    # What I propose  Change linters and documentation to reflect the array as an update array, not as a dependency. Maybe add a third argument that should run as an actual dependency array, that does not trigger the code inside.",
        "human_words": "# What is it  Since the hooks launch, I've been working with various teams and developers, and all of them, I repeat, ALL of them, seniors and juniors. Have been using useEffect \"wrong\" (considering what the react team intended). They all use the dependency array as an update array. There is no reason to keep hammering us, telling us that it is a dependency array if no one uses that way.    # What I propose  Change linters and documentation to reflect the array as an update array, not as a dependency. Maybe add a third argument that should run as an actual dependency array, that does not trigger the code inside.",
        "human_words_regrex": "# What is it Since the hooks launch, I've been working with various teams and developers, and all of them, I repeat, ALL of them, seniors and juniors. Have been using useEffect \"wrong\" (considering what the react team intended). They all use the dependency array as an update array. There is no reason to keep hammering us, telling us that it is a dependency array if no one uses that way. # What I propose Change linters and documentation to reflect the array as an update array, not as a dependency. Maybe add a third argument that should run as an actual dependency array, that does not trigger the code inside.",
        "human_words_stopwords_removal_lemmatization": "# since hook launch , 've working various team developer , , repeat , , senior junior . using useeffect `` wrong '' ( considering react team intended ) . use dependency array update array . reason keep hammering u , telling u dependency array one us way . # propose change linters documentation reflect array update array , dependency . maybe add third argument run actual dependency array , trigger code inside .",
        "title_stopwords_removal_lemmatization": "discussion : useeffect deps array"
    },
    {
        "issue_id": 771336870,
        "title": "Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2020-12-19T08:31:02Z",
        "status": "closed",
        "description": "componentDidMount () {\r\n  this.setState({})\r\n}\r\ncomponentWillUnmount () {\r\n  this.setState = () => false\r\n}\r\n\r\nQuickly switch this component\r\n",
        "remove_template_description": "componentDidMount () {    this.setState({})  }  componentWillUnmount () {    this.setState = () => false  }    Quickly switch this component",
        "human_words": "componentDidMount () {    this.setState({})  }  componentWillUnmount () {    this.setState = () => false  }    Quickly switch this component",
        "human_words_regrex": "componentDidMount () { this.setState({}) } componentWillUnmount () { this.setState = () => false } Quickly switch this component",
        "human_words_stopwords_removal_lemmatization": "componentdidmount ( ) { this.setstate ( { } ) } componentwillunmount ( ) { this.setstate = ( ) = > false } quickly switch component",
        "title_stopwords_removal_lemmatization": "ca n't perform react state update unmounted component . no-op , indicates memory leak application . fix , cancel subscription asynchronous task componentwillunmount method ."
    },
    {
        "issue_id": 757230726,
        "title": "CRA: Fast Refresh breaks embedded DevTools backend",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Component: Fast Refresh"
        ],
        "date": "2020-12-04T16:27:29Z",
        "status": "open",
        "description": "`TypeError: undefined is not a function (near '...e.sub...')\r\n(anonymous function)\r\nsrc/backend/index.js:26\r\n  23 |   // DevTools didn't get injected into this page (maybe b'c of the contentType).\r\n  24 |   return () => {};\r\n  25 | }\r\n> 26 | const subs = [\r\n     | ^  27 |   hook.sub(\r\n  28 |     'renderer-attached',\r\n  29 |     ({\r\nView compiled\r\n(anonymous function)\r\nsrc/backend.js:179\r\n  176 |   hook.emit('shutdown');\r\n  177 | });\r\n  178 | \r\n> 179 | initBackend(hook, agent, window);\r\n      | ^  180 | \r\n  181 | // Setup React Native style editor if the environment supports it.\r\n  182 | if (resolveRNStyle != null || hook.resolveRNStyle != null) {`\r\nReact version:\r\n\r\n## Steps To Reproduce\r\n\r\n1. create-react-app\r\n2. yarn add react-devtools\r\n3. in index.js add import 'react-devtools' on first line\r\n4. start react-devtools\r\n4. start create-react-app devserver\r\n6. go to localhost:3000\r\n7. crash\r\n\r\n\r\nLink to code example:\r\n\r\nadd react-devtools on first line of vanilla 'create-react-app'\r\n\r\n## The current behavior\r\n\r\n<img width=\"941\" alt=\"devtools\" src=\"https://user-images.githubusercontent.com/5372632/101188389-f24a2e80-3655-11eb-9a6b-239ac8742eb1.png\">\r\n\r\n## The expected behavior\r\n\r\nDebug-Session\r\n\r\n\r\n\r\n",
        "remove_template_description": "`TypeError: undefined is not a function (near '...e.sub...')  (anonymous function)  src/backend/index.js:26    23 |   // DevTools didn't get injected into this page (maybe b'c of the contentType).    24 |   return () => {};    25 | }  > 26 | const subs = [       | ^  27 |   hook.sub(    28 |     'renderer-attached',    29 |     ({  View compiled  (anonymous function)  src/backend.js:179    176 |   hook.emit('shutdown');    177 | });    178 |   > 179 | initBackend(hook, agent, window);        | ^  180 |     181 | // Setup React Native style editor if the environment supports it.    182 | if (resolveRNStyle != null || hook.resolveRNStyle != null) {`  React version:        1. create-react-app  2. yarn add react-devtools  3. in index.js add import 'react-devtools' on first line  4. start react-devtools  4. start create-react-app devserver  6. go to localhost:3000  7. crash      Link to code example:    add react-devtools on first line of vanilla 'create-react-app'        <img width=\"941\" alt=\"devtools\" src=\"https://user-images.githubusercontent.com/5372632/101188389-f24a2e80-3655-11eb-9a6b-239ac8742eb1.png\">        Debug-Session",
        "human_words": "`TypeError: undefined is not a function (near '...e.sub...')  (anonymous function)  src/backend/index.js:26    23 |   // DevTools didn't get injected into this page (maybe b'c of the contentType).    24 |   return () => {};    25 | }  > 26 | const subs = [       | ^  27 |   hook.sub(    28 |     'renderer-attached',    29 |     ({  View compiled  (anonymous function)  src/backend.js:179    176 |   hook.emit('shutdown');    177 | });    178 |   > 179 | initBackend(hook, agent, window);        | ^  180 |     181 | // Setup React Native style editor if the environment supports it.    182 | if (resolveRNStyle != null || hook.resolveRNStyle != null) {`  React version:        1. create-react-app  2. yarn add react-devtools  3. in index.js add import 'react-devtools' on first line  4. start react-devtools  4. start create-react-app devserver  6. go to localhost:3000  7. crash      Link to code example:    add react-devtools on first line of vanilla 'create-react-app'        <img width=\"941\" alt=\"devtools\" src=\"https://user-images.githubusercontent.com/5372632/101188389-f24a2e80-3655-11eb-9a6b-239ac8742eb1.png\">        Debug-Session",
        "human_words_regrex": "`TypeError: undefined is not a function (near '...e.sub...') (anonymous function) src/backend/index.js:26 23 | // DevTools didn't get injected into this page (maybe b'c of the contentType). 24 | return () => {}; 25 | } > 26 | const subs = [ | ^ 27 | hook.sub( 28 | 'renderer-attached', 29 | ({ View compiled (anonymous function) src/backend.js:179 176 | hook.emit('shutdown'); 177 | }); 178 | > 179 | initBackend(hook, agent, window); | ^ 180 | 181 | // Setup React Native style editor if the environment supports it. 182 | if (resolveRNStyle != null || hook.resolveRNStyle != null) {` React version: 1. create-react-app 2. yarn add react-devtools 3. in index.js add import 'react-devtools' on first line 4. start react-devtools 4. start create-react-app devserver 6. go to localhost:3000 7. crash Link to code example: add react-devtools on first line of vanilla 'create-react-app' <img width=\"941\" alt=\"devtools\" src=\" Debug-Session",
        "human_words_stopwords_removal_lemmatization": "` typeerror : undefined function ( near ' ... e.sub ... ' ) ( anonymous function ) src/backend/index.js:26 23 | // devtools n't get injected page ( maybe b ' c contenttype ) . 24 | return ( ) = > { } ; 25 | } > 26 | const sub = [ | ^ 27 | hook.sub ( 28 | 'renderer-attached ' , 29 | ( { view compiled ( anonymous function ) src/backend.js:179 176 | hook.emit ( 'shutdown ' ) ; 177 | } ) ; 178 | > 179 | initbackend ( hook , agent , window ) ; | ^ 180 | 181 | // setup react native style editor environment support . 182 | ( resolvernstyle ! = null || hook.resolvernstyle ! = null ) { ` react version : 1. create-react-app 2. yarn add react-devtools 3. index.js add import 'react-devtools ' first line 4. start react-devtools 4. start create-react-app devserver 6. go localhost:3000 7. crash link code example : add react-devtools first line vanilla 'create-react-app ' < img width= '' 941 '' alt= '' devtools '' src= '' debug-session",
        "title_stopwords_removal_lemmatization": "cra : fast refresh break embedded devtools backend"
    },
    {
        "issue_id": 754204759,
        "title": "TypeError: Cannot read property 'setExtraStackFrame' of undefined",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-12-01T09:11:09Z",
        "status": "open",
        "description": "I try Upgrade to the New JSX Transform in my project.(According to the official tutorial.)\r\nI used production react  in development  environment\uff0cI see this error.\r\nbut, if used development react in  development  environment\uff0c every thing is ok.\r\n\r\nReact version:\r\n17.0.1\r\n## The current behavior\r\nTypeError: Cannot read property 'setExtraStackFrame' of undefined\r\n\r\n## Additional information\r\n  react.production.min.js:22 Uncaught TypeError: Cannot read property 'setExtraStackFrame' of undefined\r\n    at setCurrentlyValidatingElement (react-jsx-runtime.development.js:574)\r\n    at checkPropTypes (react-jsx-runtime.development.js:618)\r\n    at validatePropTypes (react-jsx-runtime.development.js:1072)\r\n    at jsxWithValidation (react-jsx-runtime.development.js:1192)\r\n    at jsxWithValidationDynamic (react-jsx-runtime.development.js:1209)\r\n    at PartPage (PartPage.js:161)\r\n    at Le (react-dom.production.min.js:100)\r\n    at Re (react-dom.production.min.js:113)\r\n    at Pj (react-dom.production.min.js:232)\r\n    at di (react-dom.production.min.js:168)",
        "remove_template_description": "I try Upgrade to the New JSX Transform in my project.(According to the official tutorial.)  I used production react  in development  environment\uff0cI see this error.  but, if used development react in  development  environment\uff0c every thing is ok.    React version:  17.0.1    TypeError: Cannot read property 'setExtraStackFrame' of undefined    ## Additional information    react.production.min.js:22 Uncaught TypeError: Cannot read property 'setExtraStackFrame' of undefined      at setCurrentlyValidatingElement (react-jsx-runtime.development.js:574)      at checkPropTypes (react-jsx-runtime.development.js:618)      at validatePropTypes (react-jsx-runtime.development.js:1072)      at jsxWithValidation (react-jsx-runtime.development.js:1192)      at jsxWithValidationDynamic (react-jsx-runtime.development.js:1209)      at PartPage (PartPage.js:161)      at Le (react-dom.production.min.js:100)      at Re (react-dom.production.min.js:113)      at Pj (react-dom.production.min.js:232)      at di (react-dom.production.min.js:168)",
        "human_words": "I try Upgrade to the New JSX Transform in my project.(According to the official tutorial.)  I used production react  in development  environment\uff0cI see this error.  but, if used development react in  development  environment\uff0c every thing is ok.    React version:  17.0.1    TypeError: Cannot read property 'setExtraStackFrame' of undefined    ## Additional information    react.production.min.js:22 Uncaught TypeError: Cannot read property 'setExtraStackFrame' of undefined      at setCurrentlyValidatingElement (react-jsx-runtime.development.js:574)      at checkPropTypes (react-jsx-runtime.development.js:618)      at validatePropTypes (react-jsx-runtime.development.js:1072)      at jsxWithValidation (react-jsx-runtime.development.js:1192)      at jsxWithValidationDynamic (react-jsx-runtime.development.js:1209)      at PartPage (PartPage.js:161)      at Le (react-dom.production.min.js:100)      at Re (react-dom.production.min.js:113)      at Pj (react-dom.production.min.js:232)      at di (react-dom.production.min.js:168)",
        "human_words_regrex": "I try Upgrade to the New JSX Transform in my project.(According to the official tutorial.) I used production react in development environment\uff0cI see this error. but, if used development react in development environment\uff0c every thing is ok. React version: 17.0.1 TypeError: Cannot read property 'setExtraStackFrame' of undefined ## Additional information react.production.min.js:22 Uncaught TypeError: Cannot read property 'setExtraStackFrame' of undefined at setCurrentlyValidatingElement (react-jsx-runtime.development.js:574) at checkPropTypes (react-jsx-runtime.development.js:618) at validatePropTypes (react-jsx-runtime.development.js:1072) at jsxWithValidation (react-jsx-runtime.development.js:1192) at jsxWithValidationDynamic (react-jsx-runtime.development.js:1209) at PartPage (PartPage.js:161) at Le (react-dom.production.min.js:100) at Re (react-dom.production.min.js:113) at Pj (react-dom.production.min.js:232) at di (react-dom.production.min.js:168)",
        "human_words_stopwords_removal_lemmatization": "try upgrade new jsx transform project . ( according official tutorial . ) used production react development environment\uff0ci see error . , used development react development environment\uff0c every thing ok. react version : 17.0.1 typeerror : read property 'setextrastackframe ' undefined # # additional information react.production.min.js:22 uncaught typeerror : read property 'setextrastackframe ' undefined setcurrentlyvalidatingelement ( react-jsx-runtime.development.js:574 ) checkproptypes ( react-jsx-runtime.development.js:618 ) validateproptypes ( react-jsx-runtime.development.js:1072 ) jsxwithvalidation ( react-jsx-runtime.development.js:1192 ) jsxwithvalidationdynamic ( react-jsx-runtime.development.js:1209 ) partpage ( partpage.js:161 ) le ( react-dom.production.min.js:100 ) ( react-dom.production.min.js:113 ) pj ( react-dom.production.min.js:232 ) di ( react-dom.production.min.js:168 )",
        "title_stopwords_removal_lemmatization": "typeerror : read property 'setextrastackframe ' undefined"
    },
    {
        "issue_id": 744224410,
        "title": "Bug: CM double rendering affects how the renderer deals with events",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-11-16T22:00:40Z",
        "status": "closed",
        "description": "My custom renderer registers events in the createInstance phase: https://github.com/pmndrs/react-three-fiber/blob/master/src/renderer.tsx#L359 it recognizes events of a certain type and stores them on the main instance. i believe this is also similar to how art does it: https://github.com/facebook/react/blob/master/packages/react-art/src/ReactARTHostConfig.js#L284 The instance will later go through its event-handler array to call them when needed.\r\n\r\n### The problem\r\n\r\nConcurrent mode double renders the view, creates all the instances twice, adds the events twice, but only appends the second fragment to the container node. The first fragment is left hanging. It has written its events into the main instance, but it is not taken away nor is removeChild called on it. The main instance has both events listed as active and will execute them both, it does not know that one leads to a dead fragment.\r\n\r\n### Demo\r\n\r\nDemo to reproduce: https://codesandbox.io/s/react-three-fiber-gestures-forked-v6vyv (click the box, it has two \"up\" events in the console)\r\n\r\nFrom looking through the react-art source-code, it should exhibit the same problem.\r\n\r\n### Solution\r\n\r\nI can understand that components need to be pure. But the renderer needs to mutate and store stuff. The reconciler should give some indication that a created instance is invalid, so that its internal effects can be removed.\r\n\r\nIf this turns out to be not a bug, how should the renderer store the events? If we take react-art as a reference it adds them in createInstance and removes them on removeChild.",
        "remove_template_description": "My custom renderer registers events in the createInstance phase: https://github.com/pmndrs/react-three-fiber/blob/master/src/renderer.tsx#L359 it recognizes events of a certain type and stores them on the main instance. i believe this is also similar to how art does it: https://github.com/facebook/react/blob/master/packages/react-art/src/ReactARTHostConfig.js#L284 The instance will later go through its event-handler array to call them when needed.    ### The problem    Concurrent mode double renders the view, creates all the instances twice, adds the events twice, but only appends the second fragment to the container node. The first fragment is left hanging. It has written its events into the main instance, but it is not taken away nor is removeChild called on it. The main instance has both events listed as active and will execute them both, it does not know that one leads to a dead fragment.    ### Demo    Demo to reproduce: https://codesandbox.io/s/react-three-fiber-gestures-forked-v6vyv (click the box, it has two \"up\" events in the console)    From looking through the react-art source-code, it should exhibit the same problem.    ### Solution    I can understand that components need to be pure. But the renderer needs to mutate and store stuff. The reconciler should give some indication that a created instance is invalid, so that its internal effects can be removed.    If this turns out to be not a bug, how should the renderer store the events? If we take react-art as a reference it adds them in createInstance and removes them on removeChild.",
        "human_words": "My custom renderer registers events in the createInstance phase: https://github.com/pmndrs/react-three-fiber/blob/master/src/renderer.tsx#L359 it recognizes events of a certain type and stores them on the main instance. i believe this is also similar to how art does it: https://github.com/facebook/react/blob/master/packages/react-art/src/ReactARTHostConfig.js#L284 The instance will later go through its event-handler array to call them when needed.    ### The problem    Concurrent mode double renders the view, creates all the instances twice, adds the events twice, but only appends the second fragment to the container node. The first fragment is left hanging. It has written its events into the main instance, but it is not taken away nor is removeChild called on it. The main instance has both events listed as active and will execute them both, it does not know that one leads to a dead fragment.    ### Demo    Demo to reproduce: https://codesandbox.io/s/react-three-fiber-gestures-forked-v6vyv (click the box, it has two \"up\" events in the console)    From looking through the react-art source-code, it should exhibit the same problem.    ### Solution    I can understand that components need to be pure. But the renderer needs to mutate and store stuff. The reconciler should give some indication that a created instance is invalid, so that its internal effects can be removed.    If this turns out to be not a bug, how should the renderer store the events? If we take react-art as a reference it adds them in createInstance and removes them on removeChild.",
        "human_words_regrex": "My custom renderer registers events in the createInstance phase:  it recognizes events of a certain type and stores them on the main instance. i believe this is also similar to how art does it:  The instance will later go through its event-handler array to call them when needed. ### The problem Concurrent mode double renders the view, creates all the instances twice, adds the events twice, but only appends the second fragment to the container node. The first fragment is left hanging. It has written its events into the main instance, but it is not taken away nor is removeChild called on it. The main instance has both events listed as active and will execute them both, it does not know that one leads to a dead fragment. ### Demo Demo to reproduce:  (click the box, it has two \"up\" events in the console) From looking through the react-art source-code, it should exhibit the same problem. ### Solution I can understand that components need to be pure. But the renderer needs to mutate and store stuff. The reconciler should give some indication that a created instance is invalid, so that its internal effects can be removed. If this turns out to be not a bug, how should the renderer store the events? If we take react-art as a reference it adds them in createInstance and removes them on removeChild.",
        "human_words_stopwords_removal_lemmatization": "custom renderer register event createinstance phase : recognizes event certain type store main instance . believe also similar art : instance later go event-handler array call needed . # # # problem concurrent mode double render view , creates instance twice , add event twice , appends second fragment container node . first fragment left hanging . written event main instance , taken away removechild called . main instance event listed active execute , know one lead dead fragment . # # # demo demo reproduce : ( click box , two `` '' event console ) looking react-art source-code , exhibit problem . # # # solution understand component need pure . renderer need mutate store stuff . reconciler give indication created instance invalid , internal effect removed . turn bug , renderer store event ? take react-art reference add createinstance remove removechild .",
        "title_stopwords_removal_lemmatization": "bug : cm double rendering affect renderer deal event"
    },
    {
        "issue_id": 738044698,
        "title": "Distribute source maps for easier debugging in Chrome's Performance tab",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-11-06T21:10:50Z",
        "status": "closed",
        "description": "~~I want to propose the addition of a new file in the `react-dom` npm package called `react-dom.production.js` \u2014 a non-minified version of `react-dom` production build.~~\r\n\r\nEdit: After some discussion(see below) it seems that distributing source maps makes more sense. Source maps will help you see the real function names and explore them. (The points below apply for source maps as well.)\r\n\r\n## Why?\r\n\r\nThere are a few ways to profile React's performance \u2014 none of them provide a low-level view of what's happening. I believe the best way to profile React is using Chrome's Performance tab using a non-minified production build. Here's why:\r\n- **Familiar.** People use the Performance tab for every other performance profiling so they are familiar with how to use it.\r\n- **Powerful.** The Performance tab is extremely powerful. Years of engineering have been put into developing it.\r\n- **Better understanding.** When using the React DevTools profiler I have a common problem \u2013 I see a component being rendered slowly but I don't know what is causing it. In order to understand I need a more low-level view. Here are some questions that can be answered only with the Chrome Performance tab:\r\n    - What's the balance between the app's code and React execution times? Should I implement some frequently updated components using custom non-React implementation?\r\n    - What time is spend on setting attribute values, setting `innerHTML` and adding and removing listeners?\r\n    - What time is spent on disposing effects? Is there a specific dispose function that is taking more than usual?\r\n    - What time is spent on mounting effects? Is there a specific effect mount that is taking more than usual?\r\n\r\n## Disadvantages\r\n\r\nAs with every solution, there are some drawbacks to using this approach:\r\n- **Documentation needed.** In order to make sense of what's happening you will need some knowledge of the core functions in React. A little guide with the names of the functions for mount/unmount, effects, and DOM manipulations will be useful. This of course can be done by the community(you are already linking to some community posts in React's documentation).\r\n- **Requires more skill.** This isn't for everybody. It's aimed at more experienced developers. This type of profiling is a lot more overwhelming than the current approach.\r\n- **May not fit your principles.** Maybe it's not part of your principles to introduce and promote such a complicated solution. Maybe you are more interested in searching for a more elegant and minimal solution.",
        "remove_template_description": "~~I want to propose the addition of a new file in the `react-dom` npm package called `react-dom.production.js` \u2014 a non-minified version of `react-dom` production build.~~    Edit: After some discussion(see below) it seems that distributing source maps makes more sense. Source maps will help you see the real function names and explore them. (The points below apply for source maps as well.)    ## Why?    There are a few ways to profile React's performance \u2014 none of them provide a low-level view of what's happening. I believe the best way to profile React is using Chrome's Performance tab using a non-minified production build. Here's why:  - **Familiar.** People use the Performance tab for every other performance profiling so they are familiar with how to use it.  - **Powerful.** The Performance tab is extremely powerful. Years of engineering have been put into developing it.  - **Better understanding.** When using the React DevTools profiler I have a common problem \u2013 I see a component being rendered slowly but I don't know what is causing it. In order to understand I need a more low-level view. Here are some questions that can be answered only with the Chrome Performance tab:      - What's the balance between the app's code and React execution times? Should I implement some frequently updated components using custom non-React implementation?      - What time is spend on setting attribute values, setting `innerHTML` and adding and removing listeners?      - What time is spent on disposing effects? Is there a specific dispose function that is taking more than usual?      - What time is spent on mounting effects? Is there a specific effect mount that is taking more than usual?    ## Disadvantages    As with every solution, there are some drawbacks to using this approach:  - **Documentation needed.** In order to make sense of what's happening you will need some knowledge of the core functions in React. A little guide with the names of the functions for mount/unmount, effects, and DOM manipulations will be useful. This of course can be done by the community(you are already linking to some community posts in React's documentation).  - **Requires more skill.** This isn't for everybody. It's aimed at more experienced developers. This type of profiling is a lot more overwhelming than the current approach.  - **May not fit your principles.** Maybe it's not part of your principles to introduce and promote such a complicated solution. Maybe you are more interested in searching for a more elegant and minimal solution.",
        "human_words": "~~I want to propose the addition of a new file in the `react-dom` npm package called `react-dom.production.js` \u2014 a non-minified version of `react-dom` production build.~~    Edit: After some discussion(see below) it seems that distributing source maps makes more sense. Source maps will help you see the real function names and explore them. (The points below apply for source maps as well.)    ## Why?    There are a few ways to profile React's performance \u2014 none of them provide a low-level view of what's happening. I believe the best way to profile React is using Chrome's Performance tab using a non-minified production build. Here's why:  - **Familiar.** People use the Performance tab for every other performance profiling so they are familiar with how to use it.  - **Powerful.** The Performance tab is extremely powerful. Years of engineering have been put into developing it.  - **Better understanding.** When using the React DevTools profiler I have a common problem \u2013 I see a component being rendered slowly but I don't know what is causing it. In order to understand I need a more low-level view. Here are some questions that can be answered only with the Chrome Performance tab:      - What's the balance between the app's code and React execution times? Should I implement some frequently updated components using custom non-React implementation?      - What time is spend on setting attribute values, setting `innerHTML` and adding and removing listeners?      - What time is spent on disposing effects? Is there a specific dispose function that is taking more than usual?      - What time is spent on mounting effects? Is there a specific effect mount that is taking more than usual?    ## Disadvantages    As with every solution, there are some drawbacks to using this approach:  - **Documentation needed.** In order to make sense of what's happening you will need some knowledge of the core functions in React. A little guide with the names of the functions for mount/unmount, effects, and DOM manipulations will be useful. This of course can be done by the community(you are already linking to some community posts in React's documentation).  - **Requires more skill.** This isn't for everybody. It's aimed at more experienced developers. This type of profiling is a lot more overwhelming than the current approach.  - **May not fit your principles.** Maybe it's not part of your principles to introduce and promote such a complicated solution. Maybe you are more interested in searching for a more elegant and minimal solution.",
        "human_words_regrex": "~~I want to propose the addition of a new file in the `react-dom` npm package called `react-dom.production.js` \u2014 a non-minified version of `react-dom` production build.~~ Edit: After some discussion(see below) it seems that distributing source maps makes more sense. Source maps will help you see the real function names and explore them. (The points below apply for source maps as well.) ## Why? There are a few ways to profile React's performance \u2014 none of them provide a low-level view of what's happening. I believe the best way to profile React is using Chrome's Performance tab using a non-minified production build. Here's why: - **Familiar.** People use the Performance tab for every other performance profiling so they are familiar with how to use it. - **Powerful.** The Performance tab is extremely powerful. Years of engineering have been put into developing it. - **Better understanding.** When using the React DevTools profiler I have a common problem \u2013 I see a component being rendered slowly but I don't know what is causing it. In order to understand I need a more low-level view. Here are some questions that can be answered only with the Chrome Performance tab: - What's the balance between the app's code and React execution times? Should I implement some frequently updated components using custom non-React implementation? - What time is spend on setting attribute values, setting `innerHTML` and adding and removing listeners? - What time is spent on disposing effects? Is there a specific dispose function that is taking more than usual? - What time is spent on mounting effects? Is there a specific effect mount that is taking more than usual? ## Disadvantages As with every solution, there are some drawbacks to using this approach: - **Documentation needed.** In order to make sense of what's happening you will need some knowledge of the core functions in React. A little guide with the names of the functions for mount/unmount, effects, and DOM manipulations will be useful. This of course can be done by the community(you are already linking to some community posts in React's documentation). - **Requires more skill.** This isn't for everybody. It's aimed at more experienced developers. This type of profiling is a lot more overwhelming than the current approach. - **May not fit your principles.** Maybe it's not part of your principles to introduce and promote such a complicated solution. Maybe you are more interested in searching for a more elegant and minimal solution.",
        "human_words_stopwords_removal_lemmatization": "~~i want propose addition new file ` react-dom ` npm package called ` react-dom.production.js ` \u2014 non-minified version ` react-dom ` production build.~~ edit : discussion ( see ) seems distributing source map make sense . source map help see real function name explore . ( point apply source map well . ) # # ? way profile react 's performance \u2014 none provide low-level view 's happening . believe best way profile react using chrome 's performance tab using non-minified production build . 's : - * * familiar . * * people use performance tab every performance profiling familiar use . - * * powerful . * * performance tab extremely powerful . year engineering put developing . - * * better understanding . * * using react devtools profiler common problem \u2013 see component rendered slowly n't know causing . order understand need low-level view . question answered chrome performance tab : - 's balance app 's code react execution time ? implement frequently updated component using custom non-react implementation ? - time spend setting attribute value , setting ` innerhtml ` adding removing listener ? - time spent disposing effect ? specific dispose function taking usual ? - time spent mounting effect ? specific effect mount taking usual ? # # disadvantage every solution , drawback using approach : - * * documentation needed . * * order make sense 's happening need knowledge core function react . little guide name function mount/unmount , effect , dom manipulation useful . course done community ( already linking community post react 's documentation ) . - * * requires skill . * * n't everybody . 's aimed experienced developer . type profiling lot overwhelming current approach . - * * may fit principle . * * maybe 's part principle introduce promote complicated solution . maybe interested searching elegant minimal solution .",
        "title_stopwords_removal_lemmatization": "distribute source map easier debugging chrome 's performance tab"
    },
    {
        "issue_id": 736428231,
        "title": "Bug: can not pass some special custom attribute such as `size` ",
        "label": [
            "Component: DOM",
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2020-11-04T21:15:20Z",
        "status": "open",
        "description": "As we know after react 16 we can use any custom attributes in dom elements \r\nbut there is a bug which some special attributes (such as `size`) are not forwarding to dom element\r\n\r\n![screenshot](https://user-images.githubusercontent.com/30382711/98168556-f91f3d80-1eff-11eb-8518-5647cd854e00.png)\r\n\r\n\r\nReact version: 16.13 & 17.0\r\n\r\n## Steps To Reproduce\r\n\r\n1. render a dom element with some custom attributes including `size`\r\n2. inspect output and you will see your custom attributes but size\r\n\r\nLink to code example:\r\nhttps://codesandbox.io/s/setting-size-as-custom-attr-hdom2?file=/src/App.js\r\n\r\n## The current behavior\r\n`size` attribute will not show in output\r\n\r\n## The expected behavior\r\n`size` should be in output\r\n",
        "remove_template_description": "As we know after react 16 we can use any custom attributes in dom elements   but there is a bug which some special attributes (such as `size`) are not forwarding to dom element    ![screenshot](https://user-images.githubusercontent.com/30382711/98168556-f91f3d80-1eff-11eb-8518-5647cd854e00.png)      React version: 16.13 & 17.0        1. render a dom element with some custom attributes including `size`  2. inspect output and you will see your custom attributes but size    Link to code example:  https://codesandbox.io/s/setting-size-as-custom-attr-hdom2?file=/src/App.js      `size` attribute will not show in output      `size` should be in output",
        "human_words": "As we know after react 16 we can use any custom attributes in dom elements   but there is a bug which some special attributes (such as `size`) are not forwarding to dom element    ![screenshot](https://user-images.githubusercontent.com/30382711/98168556-f91f3d80-1eff-11eb-8518-5647cd854e00.png)      React version: 16.13 & 17.0        1. render a dom element with some custom attributes including `size`  2. inspect output and you will see your custom attributes but size    Link to code example:  https://codesandbox.io/s/setting-size-as-custom-attr-hdom2?file=/src/App.js      `size` attribute will not show in output      `size` should be in output",
        "human_words_regrex": "As we know after react 16 we can use any custom attributes in dom elements but there is a bug which some special attributes (such as `size`) are not forwarding to dom element ! React version: 16.13 & 17.0 1. render a dom element with some custom attributes including `size` 2. inspect output and you will see your custom attributes but size Link to code example:  `size` attribute will not show in output `size` should be in output",
        "human_words_stopwords_removal_lemmatization": "know react 16 use custom attribute dom element bug special attribute ( ` size ` ) forwarding dom element ! react version : 16.13 & 17.0 1. render dom element custom attribute including ` size ` 2. inspect output see custom attribute size link code example : ` size ` attribute show output ` size ` output",
        "title_stopwords_removal_lemmatization": "bug : pas special custom attribute ` size `"
    },
    {
        "issue_id": 732847191,
        "title": "react-devtools-inline: How to remount/reuse DevTools frontend after unmount",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-10-30T03:12:49Z",
        "status": "open",
        "description": "DevTools closes the bridge whenever it is unmounted [(Link to relevant code)](https://github.com/facebook/react/blob/master/packages/react-devtools-shared/src/devtools/views/DevTools.js#L172-L181). In the case of the chrome extension this is fine because the node is never unmounted, but in use cases with `react-devtools-inline` (eg: codesandbox), where you are only given one <DevTools/> instance this causes the bridge to be closed, and never recreated if for whatever reason <DevTools/> is unmounted (which happens when switching tabs).\r\n\r\nI am willing to submit a PR, but wanted to discuss the fix before making it - the fix I see is adding a flag to <DevTools/> to not close the bridge on unmount, and making it an opt-in flag users of <DevTools/> (recommended in the case of react-devtools-inline). Adding an ability to manually access the bridge would then let the developer manually control the lifecycle - but I'm unsure the risk/issue of keeping a dangling bridge open, so I don't see this as strictly necessary.\r\n\r\nReact version: N/A\r\nReact-devtools-inline: 4.9.0\r\n\r\n## Steps To Reproduce\r\n\r\n1.  Create a code-sandbox React environment\r\n2. Open React DevTools tab\r\n3. Switch to Problems tab (or any other tab)\r\n4. Switch back to React DevTools tab\r\n5. Bridge has been closed, `index.js:55 Cannot send message \"highlightNativeElement\" through a Bridge that has been shutdown.` is printed in console. New react nodes can not be inspected.\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example: N/A\r\nCode example isn't relevant, any CodeSandbox will reproduce this. (even with no additional code)\r\n\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\nInspecting elements that haven't previously been inspected will fail because bridge communication fails if the <DevTools/> ever unmounts and remounts\r\n\r\n## The expected behavior\r\nThe bridge doesn't close even on unmount when using `react-devtools-inline`, or an option is available when mounting <DevTools/> to not automatically close the bridge.",
        "remove_template_description": "DevTools closes the bridge whenever it is unmounted [(Link to relevant code)](https://github.com/facebook/react/blob/master/packages/react-devtools-shared/src/devtools/views/DevTools.js#L172-L181). In the case of the chrome extension this is fine because the node is never unmounted, but in use cases with `react-devtools-inline` (eg: codesandbox), where you are only given one <DevTools/> instance this causes the bridge to be closed, and never recreated if for whatever reason <DevTools/> is unmounted (which happens when switching tabs).    I am willing to submit a PR, but wanted to discuss the fix before making it - the fix I see is adding a flag to <DevTools/> to not close the bridge on unmount, and making it an opt-in flag users of <DevTools/> (recommended in the case of react-devtools-inline). Adding an ability to manually access the bridge would then let the developer manually control the lifecycle - but I'm unsure the risk/issue of keeping a dangling bridge open, so I don't see this as strictly necessary.    React version: N/A  React-devtools-inline: 4.9.0        1.  Create a code-sandbox React environment  2. Open React DevTools tab  3. Switch to Problems tab (or any other tab)  4. Switch back to React DevTools tab  5. Bridge has been closed, `index.js:55 Cannot send message \"highlightNativeElement\" through a Bridge that has been shutdown.` is printed in console. New react nodes can not be inspected.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: N/A  Code example isn't relevant, any CodeSandbox will reproduce this. (even with no additional code)    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Inspecting elements that haven't previously been inspected will fail because bridge communication fails if the <DevTools/> ever unmounts and remounts      The bridge doesn't close even on unmount when using `react-devtools-inline`, or an option is available when mounting <DevTools/> to not automatically close the bridge.",
        "human_words": "DevTools closes the bridge whenever it is unmounted [(Link to relevant code)](https://github.com/facebook/react/blob/master/packages/react-devtools-shared/src/devtools/views/DevTools.js#L172-L181). In the case of the chrome extension this is fine because the node is never unmounted, but in use cases with `react-devtools-inline` (eg: codesandbox), where you are only given one <DevTools/> instance this causes the bridge to be closed, and never recreated if for whatever reason <DevTools/> is unmounted (which happens when switching tabs).    I am willing to submit a PR, but wanted to discuss the fix before making it - the fix I see is adding a flag to <DevTools/> to not close the bridge on unmount, and making it an opt-in flag users of <DevTools/> (recommended in the case of react-devtools-inline). Adding an ability to manually access the bridge would then let the developer manually control the lifecycle - but I'm unsure the risk/issue of keeping a dangling bridge open, so I don't see this as strictly necessary.    React version: N/A  React-devtools-inline: 4.9.0        1.  Create a code-sandbox React environment  2. Open React DevTools tab  3. Switch to Problems tab (or any other tab)  4. Switch back to React DevTools tab  5. Bridge has been closed, `index.js:55 Cannot send message \"highlightNativeElement\" through a Bridge that has been shutdown.` is printed in console. New react nodes can not be inspected.    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example: N/A  Code example isn't relevant, any CodeSandbox will reproduce this. (even with no additional code)    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Inspecting elements that haven't previously been inspected will fail because bridge communication fails if the <DevTools/> ever unmounts and remounts      The bridge doesn't close even on unmount when using `react-devtools-inline`, or an option is available when mounting <DevTools/> to not automatically close the bridge.",
        "human_words_regrex": "DevTools closes the bridge whenever it is unmounted . In the case of the chrome extension this is fine because the node is never unmounted, but in use cases with `react-devtools-inline` (eg: codesandbox), where you are only given one  instance this causes the bridge to be closed, and never recreated if for whatever reason  is unmounted (which happens when switching tabs). I am willing to submit a PR, but wanted to discuss the fix before making it - the fix I see is adding a flag to  to not close the bridge on unmount, and making it an opt-in flag users of  (recommended in the case of react-devtools-inline). Adding an ability to manually access the bridge would then let the developer manually control the lifecycle - but I'm unsure the risk/issue of keeping a dangling bridge open, so I don't see this as strictly necessary. React version: N/A React-devtools-inline: 4.9.0 1. Create a code-sandbox React environment 2. Open React DevTools tab 3. Switch to Problems tab (or any other tab) 4. Switch back to React DevTools tab 5. Bridge has been closed, `index.js:55 Cannot send message \"highlightNativeElement\" through a Bridge that has been shutdown.` is printed in console. New react nodes can not be inspected.  Link to code example: N/A Code example isn't relevant, any CodeSandbox will reproduce this. (even with no additional code)  Inspecting elements that haven't previously been inspected will fail because bridge communication fails if the  ever unmounts and remounts The bridge doesn't close even on unmount when using `react-devtools-inline`, or an option is available when mounting  to not automatically close the bridge.",
        "human_words_stopwords_removal_lemmatization": "devtools close bridge whenever unmounted . case chrome extension fine node never unmounted , use case ` react-devtools-inline ` ( eg : codesandbox ) , given one instance cause bridge closed , never recreated whatever reason unmounted ( happens switching tab ) . willing submit pr , wanted discus fix making - fix see adding flag close bridge unmount , making opt-in flag user ( recommended case react-devtools-inline ) . adding ability manually access bridge would let developer manually control lifecycle - 'm unsure risk/issue keeping dangling bridge open , n't see strictly necessary . react version : n/a react-devtools-inline : 4.9.0 1. create code-sandbox react environment 2. open react devtools tab 3. switch problem tab ( tab ) 4. switch back react devtools tab 5. bridge closed , ` index.js:55 send message `` highlightnativeelement '' bridge shutdown. ` printed console . new react node inspected . link code example : n/a code example n't relevant , codesandbox reproduce . ( even additional code ) inspecting element n't previously inspected fail bridge communication fails ever unmounts remount bridge n't close even unmount using ` react-devtools-inline ` , option available mounting automatically close bridge .",
        "title_stopwords_removal_lemmatization": "react-devtools-inline : remount/reuse devtools frontend unmount"
    },
    {
        "issue_id": 732038021,
        "title": "Bug: Should have a queue",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2020-10-29T06:21:45Z",
        "status": "open",
        "description": "```\r\nreact-dom.development.js:89 Warning: React has detected a change in the order of Hooks called by wrappedComponent. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\r\n\r\n   Previous render            Next render\r\n   ------------------------------------------------------\r\n1. useState                   useState\r\n2. useCallback                useCallback\r\n3. useRef                     useRef\r\n4. useDebugValue              useDebugValue\r\n5. useEffect                  useEffect\r\n6. useLayoutEffect            useState\r\n   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    in wrappedComponent (created by ApprovalManageView)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)\r\n    in ApprovalManageView (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in Transition (created by ForwardRef(Collapse))\r\n    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))\r\n    in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in wrappedComponent (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in wrappedComponent (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in ApprovalsSidebar (created by Context.Consumer)\r\n    in ApprovalsSidebarWrapper (created by ContentSidebarContent)\r\n    in ContentSidebarContent (created by SidebarDesktop)\r\n    in div (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in ErrorBoundary (created by SidebarDesktop)\r\n    in SidebarDesktop (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(AccordionDetails))\r\n    in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))\r\n    in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Accordion))\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in Transition (created by ForwardRef(Collapse))\r\n    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))\r\n    in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))\r\n    in div (created by ForwardRef(Paper))\r\n    in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))\r\n    in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))\r\n    in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))\r\n    in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)\r\n    in span (created by ForwardRef(Badge))\r\n    in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))\r\n    in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by Sidebar)\r\n    in Sidebar (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by ContentEditViewUnstyled)\r\n    in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))\r\n    in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)\r\n    in div (created by WithSizeDelayed)\r\n    in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))\r\n    in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)\r\n    in form (created by Context.Consumer)\r\n    in FormClassValidator (created by ContentEditForm)\r\n    in ContentEditForm (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)\r\n    in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))\r\n    in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))\r\n    in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)\r\n    in LoadableComponent (created by ContentEditViewPage)\r\n    in ContentEditViewPage (created by react2angular(ContentEditViewPage))\r\n    in Suspense (created by react2angular(ContentEditViewPage))\r\n    in DropContextProvider\r\n    in Unknown (created by DragDropContext(Component))\r\n    in DragDropContext(Component) (created by Providers)\r\n    in SnackbarProvider (created by Providers)\r\n    in MuiPickersUtilsProvider (created by Providers)\r\n    in ThemeProvider (created by AppThemeProvider)\r\n    in AppThemeProvider (created by Providers)\r\n    in Providers (created by SubProviders)\r\n    in SubProviders (created by react2angular(ContentEditViewPage))\r\n    in react2angular(ContentEditViewPage)\r\n    in Unknown (created by HotExportedComponent)\r\n    in AppContainer (created by HotExportedComponent)\r\n    in HotExportedComponent\r\nprintWarning @ react-dom.development.js:89\r\nerror @ react-dom.development.js:61\r\nwarnOnHookMismatchInDev @ react-dom.development.js:14738\r\nupdateHookTypesDev @ react-dom.development.js:14697\r\nuseState @ react-dom.development.js:15967\r\nuseState @ react.development.js:1497\r\n(anonymous) @ ContentApprovalStatusView.tsx:38\r\n(anonymous) @ mobxreactlite.esm.js:344\r\n(anonymous) @ mobxreactlite.esm.js:306\r\ntrackDerivedFunction @ mobx.module.js:761\r\n./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795\r\nuseObserver @ mobxreactlite.esm.js:304\r\n(anonymous) @ mobxreactlite.esm.js:343\r\nrenderWithHooks @ react-dom.development.js:14826\r\nupdateFunctionComponent @ react-dom.development.js:17059\r\nupdateSimpleMemoComponent @ react-dom.development.js:16997\r\nbeginWork @ react-dom.development.js:18721\r\nbeginWork$1 @ react-dom.development.js:23211\r\nperformUnitOfWork @ react-dom.development.js:22189\r\nworkLoopSync @ react-dom.development.js:22162\r\nperformSyncWorkOnRoot @ react-dom.development.js:21788\r\n(anonymous) @ react-dom.development.js:11112\r\nunstable_runWithPriority @ scheduler.development.js:643\r\nrunWithPriority$1 @ react-dom.development.js:11062\r\nflushSyncCallbackQueueImpl @ react-dom.development.js:11107\r\nflushSyncCallbackQueue @ react-dom.development.js:11095\r\nbatchedUpdates$1 @ react-dom.development.js:21894\r\nreactionScheduler @ mobx.module.js:1905\r\nrunReactions @ mobx.module.js:1881\r\nendBatch @ mobx.module.js:1581\r\n_endAction @ mobx.module.js:967\r\nexecuteAction @ mobx.module.js:921\r\nupdateApproval @ mobx.module.js:901\r\n(anonymous) @ ApprovalManageView.tsx:334\r\n(anonymous) @ tslib.es6.js:74\r\n__awaiter @ tslib.es6.js:70\r\nonApprovalEditFormSubmit @ ApprovalManageView.tsx:268\r\n(anonymous) @ FormClassValidator.tsx:266\r\nPromise.then (async)\r\nonSubmit @ FormClassValidator.tsx:262\r\nonClick @ ApprovalEditView.tsx:1487\r\ncallCallback @ react-dom.development.js:189\r\ninvokeGuardedCallbackDev @ react-dom.development.js:238\r\ninvokeGuardedCallback @ react-dom.development.js:293\r\ninvokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307\r\nexecuteDispatch @ react-dom.development.js:390\r\nexecuteDispatchesInOrder @ react-dom.development.js:415\r\nexecuteDispatchesAndRelease @ react-dom.development.js:3279\r\nexecuteDispatchesAndReleaseTopLevel @ react-dom.development.js:3288\r\nforEachAccumulated @ react-dom.development.js:3260\r\nrunEventsInBatch @ react-dom.development.js:3305\r\nrunExtractedPluginEventsInBatch @ react-dom.development.js:3515\r\nhandleTopLevel @ react-dom.development.js:3559\r\nbatchedEventUpdates$1 @ react-dom.development.js:21903\r\nbatchedEventUpdates @ react-dom.development.js:1061\r\ndispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569\r\nattemptToDispatchEvent @ react-dom.development.js:4268\r\ndispatchEvent @ react-dom.development.js:4190\r\nunstable_runWithPriority @ scheduler.development.js:643\r\nrunWithPriority$1 @ react-dom.development.js:11062\r\ndiscreteUpdates$1 @ react-dom.development.js:21919\r\ndiscreteUpdates @ react-dom.development.js:1072\r\ndispatchDiscreteEvent @ react-dom.development.js:4169\r\nShow 8 more frames\r\nreact-dom.development.js:15066 Uncaught Error: Should have a queue. This is likely a bug in React. Please file an issue.\r\n    at updateReducer (react-dom.development.js:15066)\r\n    at updateState (react-dom.development.js:15260)\r\n    at Object.useState (react-dom.development.js:15972)\r\n    at Object.useState (react.development.js:1497)\r\n    at ContentApprovalStatusView.tsx:38\r\n    at mobxreactlite.esm.js:344\r\n    at mobxreactlite.esm.js:306\r\n    at trackDerivedFunction (mobx.module.js:761)\r\n    at Reaction../node_modules/mobx/lib/mobx.module.js.Reaction.track (mobx.module.js:1795)\r\n    at useObserver (mobxreactlite.esm.js:304)\r\nupdateReducer @ react-dom.development.js:15066\r\nupdateState @ react-dom.development.js:15260\r\nuseState @ react-dom.development.js:15972\r\nuseState @ react.development.js:1497\r\n(anonymous) @ ContentApprovalStatusView.tsx:38\r\n(anonymous) @ mobxreactlite.esm.js:344\r\n(anonymous) @ mobxreactlite.esm.js:306\r\ntrackDerivedFunction @ mobx.module.js:761\r\n./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795\r\nuseObserver @ mobxreactlite.esm.js:304\r\n(anonymous) @ mobxreactlite.esm.js:343\r\nrenderWithHooks @ react-dom.development.js:14826\r\nupdateFunctionComponent @ react-dom.development.js:17059\r\nupdateSimpleMemoComponent @ react-dom.development.js:16997\r\nbeginWork @ react-dom.development.js:18721\r\ncallCallback @ react-dom.development.js:189\r\ninvokeGuardedCallbackDev @ react-dom.development.js:238\r\ninvokeGuardedCallback @ react-dom.development.js:293\r\nbeginWork$1 @ react-dom.development.js:23235\r\nperformUnitOfWork @ react-dom.development.js:22189\r\nworkLoopSync @ react-dom.development.js:22162\r\nperformSyncWorkOnRoot @ react-dom.development.js:21788\r\n(anonymous) @ react-dom.development.js:11112\r\nunstable_runWithPriority @ scheduler.development.js:643\r\nrunWithPriority$1 @ react-dom.development.js:11062\r\nflushSyncCallbackQueueImpl @ react-dom.development.js:11107\r\nflushSyncCallbackQueue @ react-dom.development.js:11095\r\nbatchedUpdates$1 @ react-dom.development.js:21894\r\nreactionScheduler @ mobx.module.js:1905\r\nrunReactions @ mobx.module.js:1881\r\nendBatch @ mobx.module.js:1581\r\n_endAction @ mobx.module.js:967\r\nexecuteAction @ mobx.module.js:921\r\nupdateApproval @ mobx.module.js:901\r\n(anonymous) @ ApprovalManageView.tsx:334\r\n(anonymous) @ tslib.es6.js:74\r\n__awaiter @ tslib.es6.js:70\r\nonApprovalEditFormSubmit @ ApprovalManageView.tsx:268\r\n(anonymous) @ FormClassValidator.tsx:266\r\nPromise.then (async)\r\nonSubmit @ FormClassValidator.tsx:262\r\nonClick @ ApprovalEditView.tsx:1487\r\ncallCallback @ react-dom.development.js:189\r\ninvokeGuardedCallbackDev @ react-dom.development.js:238\r\ninvokeGuardedCallback @ react-dom.development.js:293\r\ninvokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307\r\nexecuteDispatch @ react-dom.development.js:390\r\nexecuteDispatchesInOrder @ react-dom.development.js:415\r\nexecuteDispatchesAndRelease @ react-dom.development.js:3279\r\nexecuteDispatchesAndReleaseTopLevel @ react-dom.development.js:3288\r\nforEachAccumulated @ react-dom.development.js:3260\r\nrunEventsInBatch @ react-dom.development.js:3305\r\nrunExtractedPluginEventsInBatch @ react-dom.development.js:3515\r\nhandleTopLevel @ react-dom.development.js:3559\r\nbatchedEventUpdates$1 @ react-dom.development.js:21903\r\nbatchedEventUpdates @ react-dom.development.js:1061\r\ndispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569\r\nattemptToDispatchEvent @ react-dom.development.js:4268\r\ndispatchEvent @ react-dom.development.js:4190\r\nunstable_runWithPriority @ scheduler.development.js:643\r\nrunWithPriority$1 @ react-dom.development.js:11062\r\ndiscreteUpdates$1 @ react-dom.development.js:21919\r\ndiscreteUpdates @ react-dom.development.js:1072\r\ndispatchDiscreteEvent @ react-dom.development.js:4169\r\nShow 9 more frames\r\nreact-dom.development.js:19561 The above error occurred in the <wrappedComponent> component:\r\n    in wrappedComponent (created by ApprovalManageView)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)\r\n    in ApprovalManageView (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in Transition (created by ForwardRef(Collapse))\r\n    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))\r\n    in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in wrappedComponent (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)\r\n    in wrappedComponent (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)\r\n    in ApprovalsSidebar (created by Context.Consumer)\r\n    in ApprovalsSidebarWrapper (created by ContentSidebarContent)\r\n    in ContentSidebarContent (created by SidebarDesktop)\r\n    in div (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)\r\n    in ErrorBoundary (created by SidebarDesktop)\r\n    in SidebarDesktop (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(AccordionDetails))\r\n    in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))\r\n    in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Accordion))\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in div (created by Transition)\r\n    in Transition (created by ForwardRef(Collapse))\r\n    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))\r\n    in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))\r\n    in div (created by ForwardRef(Paper))\r\n    in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))\r\n    in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))\r\n    in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))\r\n    in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)\r\n    in span (created by ForwardRef(Badge))\r\n    in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))\r\n    in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by Sidebar)\r\n    in Sidebar (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by ContentEditViewUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)\r\n    in SidebarStoreProvider (created by ContentEditViewUnstyled)\r\n    in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))\r\n    in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)\r\n    in div (created by WithSizeDelayed)\r\n    in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))\r\n    in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)\r\n    in form (created by Context.Consumer)\r\n    in FormClassValidator (created by ContentEditForm)\r\n    in ContentEditForm (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)\r\n    in div (created by ForwardRef(Grid))\r\n    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))\r\n    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)\r\n    in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))\r\n    in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))\r\n    in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)\r\n    in LoadableComponent (created by ContentEditViewPage)\r\n    in ContentEditViewPage (created by react2angular(ContentEditViewPage))\r\n    in Suspense (created by react2angular(ContentEditViewPage))\r\n    in DropContextProvider\r\n    in Unknown (created by DragDropContext(Component))\r\n    in DragDropContext(Component) (created by Providers)\r\n    in SnackbarProvider (created by Providers)\r\n    in MuiPickersUtilsProvider (created by Providers)\r\n    in ThemeProvider (created by AppThemeProvider)\r\n    in AppThemeProvider (created by Providers)\r\n    in Providers (created by SubProviders)\r\n    in SubProviders (created by react2angular(ContentEditViewPage))\r\n    in react2angular(ContentEditViewPage)\r\n    in Unknown (created by HotExportedComponent)\r\n    in AppContainer (created by HotExportedComponent)\r\n    in HotExportedComponent\r\n\r\nReact will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.\r\n```\r\nReact will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.\r\n\r\nReact version:\r\n\r\n## Steps To Reproduce\r\n\r\n1. use condition before hooks\r\n\r\n```typescript\r\n    const [state, setState] = React.useState<State>({...defaultState});\r\n    const actions = store.isBulk ? {} : store.getActions(entity, switchView);\r\n\r\n   // this line if it is below the onToggle then everything fine and have no error\r\n    if (!approval) { return null; }\r\n\r\n    const onToggle = React.useCallback((ev: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\r\n        const collapsibleName = ev.currentTarget.dataset.type + 'Open';\r\n        const value = !state[collapsibleName];\r\n        setState({ ...state, ...defaultState, [collapsibleName]: value });\r\n    }, [state]);\r\n\r\n```\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example:\r\n\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\ncrash the rendeing\r\n\r\n## The expected behavior\r\nit should have an error message which localize better where the error was if cannot be fixed this issue :)",
        "remove_template_description": "```  react-dom.development.js:89 Warning: React has detected a change in the order of Hooks called by wrappedComponent. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks       Previous render            Next render     ------------------------------------------------------  1. useState                   useState  2. useCallback                useCallback  3. useRef                     useRef  4. useDebugValue              useDebugValue  5. useEffect                  useEffect  6. useLayoutEffect            useState     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        in wrappedComponent (created by ApprovalManageView)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)      in ApprovalManageView (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in div (created by Transition)      in div (created by Transition)      in div (created by Transition)      in Transition (created by ForwardRef(Collapse))      in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))      in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in wrappedComponent (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in wrappedComponent (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in ApprovalsSidebar (created by Context.Consumer)      in ApprovalsSidebarWrapper (created by ContentSidebarContent)      in ContentSidebarContent (created by SidebarDesktop)      in div (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in ErrorBoundary (created by SidebarDesktop)      in SidebarDesktop (created by ContentEditViewUnstyled)      in div (created by ForwardRef(AccordionDetails))      in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))      in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Accordion))      in div (created by Transition)      in div (created by Transition)      in div (created by Transition)      in Transition (created by ForwardRef(Collapse))      in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))      in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))      in div (created by ForwardRef(Paper))      in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))      in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))      in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))      in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)      in span (created by ForwardRef(Badge))      in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))      in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by Sidebar)      in Sidebar (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by ContentEditViewUnstyled)      in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))      in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)      in div (created by WithSizeDelayed)      in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))      in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)      in form (created by Context.Consumer)      in FormClassValidator (created by ContentEditForm)      in ContentEditForm (created by ContentEditFormLoaderUnstyled)      in div (created by ContentEditFormLoaderUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)      in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))      in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))      in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)      in LoadableComponent (created by ContentEditViewPage)      in ContentEditViewPage (created by react2angular(ContentEditViewPage))      in Suspense (created by react2angular(ContentEditViewPage))      in DropContextProvider      in Unknown (created by DragDropContext(Component))      in DragDropContext(Component) (created by Providers)      in SnackbarProvider (created by Providers)      in MuiPickersUtilsProvider (created by Providers)      in ThemeProvider (created by AppThemeProvider)      in AppThemeProvider (created by Providers)      in Providers (created by SubProviders)      in SubProviders (created by react2angular(ContentEditViewPage))      in react2angular(ContentEditViewPage)      in Unknown (created by HotExportedComponent)      in AppContainer (created by HotExportedComponent)      in HotExportedComponent  printWarning @ react-dom.development.js:89  error @ react-dom.development.js:61  warnOnHookMismatchInDev @ react-dom.development.js:14738  updateHookTypesDev @ react-dom.development.js:14697  useState @ react-dom.development.js:15967  useState @ react.development.js:1497  (anonymous) @ ContentApprovalStatusView.tsx:38  (anonymous) @ mobxreactlite.esm.js:344  (anonymous) @ mobxreactlite.esm.js:306  trackDerivedFunction @ mobx.module.js:761  ./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795  useObserver @ mobxreactlite.esm.js:304  (anonymous) @ mobxreactlite.esm.js:343  renderWithHooks @ react-dom.development.js:14826  updateFunctionComponent @ react-dom.development.js:17059  updateSimpleMemoComponent @ react-dom.development.js:16997  beginWork @ react-dom.development.js:18721  beginWork$1 @ react-dom.development.js:23211  performUnitOfWork @ react-dom.development.js:22189  workLoopSync @ react-dom.development.js:22162  performSyncWorkOnRoot @ react-dom.development.js:21788  (anonymous) @ react-dom.development.js:11112  unstable_runWithPriority @ scheduler.development.js:643  runWithPriority$1 @ react-dom.development.js:11062  flushSyncCallbackQueueImpl @ react-dom.development.js:11107  flushSyncCallbackQueue @ react-dom.development.js:11095  batchedUpdates$1 @ react-dom.development.js:21894  reactionScheduler @ mobx.module.js:1905  runReactions @ mobx.module.js:1881  endBatch @ mobx.module.js:1581  _endAction @ mobx.module.js:967  executeAction @ mobx.module.js:921  updateApproval @ mobx.module.js:901  (anonymous) @ ApprovalManageView.tsx:334  (anonymous) @ tslib.es6.js:74  __awaiter @ tslib.es6.js:70  onApprovalEditFormSubmit @ ApprovalManageView.tsx:268  (anonymous) @ FormClassValidator.tsx:266  Promise.then (async)  onSubmit @ FormClassValidator.tsx:262  onClick @ ApprovalEditView.tsx:1487  callCallback @ react-dom.development.js:189  invokeGuardedCallbackDev @ react-dom.development.js:238  invokeGuardedCallback @ react-dom.development.js:293  invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307  executeDispatch @ react-dom.development.js:390  executeDispatchesInOrder @ react-dom.development.js:415  executeDispatchesAndRelease @ react-dom.development.js:3279  executeDispatchesAndReleaseTopLevel @ react-dom.development.js:3288  forEachAccumulated @ react-dom.development.js:3260  runEventsInBatch @ react-dom.development.js:3305  runExtractedPluginEventsInBatch @ react-dom.development.js:3515  handleTopLevel @ react-dom.development.js:3559  batchedEventUpdates$1 @ react-dom.development.js:21903  batchedEventUpdates @ react-dom.development.js:1061  dispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569  attemptToDispatchEvent @ react-dom.development.js:4268  dispatchEvent @ react-dom.development.js:4190  unstable_runWithPriority @ scheduler.development.js:643  runWithPriority$1 @ react-dom.development.js:11062  discreteUpdates$1 @ react-dom.development.js:21919  discreteUpdates @ react-dom.development.js:1072  dispatchDiscreteEvent @ react-dom.development.js:4169  Show 8 more frames  react-dom.development.js:15066 Uncaught Error: Should have a queue. This is likely a bug in React. Please file an issue.      at updateReducer (react-dom.development.js:15066)      at updateState (react-dom.development.js:15260)      at Object.useState (react-dom.development.js:15972)      at Object.useState (react.development.js:1497)      at ContentApprovalStatusView.tsx:38      at mobxreactlite.esm.js:344      at mobxreactlite.esm.js:306      at trackDerivedFunction (mobx.module.js:761)      at Reaction../node_modules/mobx/lib/mobx.module.js.Reaction.track (mobx.module.js:1795)      at useObserver (mobxreactlite.esm.js:304)  updateReducer @ react-dom.development.js:15066  updateState @ react-dom.development.js:15260  useState @ react-dom.development.js:15972  useState @ react.development.js:1497  (anonymous) @ ContentApprovalStatusView.tsx:38  (anonymous) @ mobxreactlite.esm.js:344  (anonymous) @ mobxreactlite.esm.js:306  trackDerivedFunction @ mobx.module.js:761  ./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795  useObserver @ mobxreactlite.esm.js:304  (anonymous) @ mobxreactlite.esm.js:343  renderWithHooks @ react-dom.development.js:14826  updateFunctionComponent @ react-dom.development.js:17059  updateSimpleMemoComponent @ react-dom.development.js:16997  beginWork @ react-dom.development.js:18721  callCallback @ react-dom.development.js:189  invokeGuardedCallbackDev @ react-dom.development.js:238  invokeGuardedCallback @ react-dom.development.js:293  beginWork$1 @ react-dom.development.js:23235  performUnitOfWork @ react-dom.development.js:22189  workLoopSync @ react-dom.development.js:22162  performSyncWorkOnRoot @ react-dom.development.js:21788  (anonymous) @ react-dom.development.js:11112  unstable_runWithPriority @ scheduler.development.js:643  runWithPriority$1 @ react-dom.development.js:11062  flushSyncCallbackQueueImpl @ react-dom.development.js:11107  flushSyncCallbackQueue @ react-dom.development.js:11095  batchedUpdates$1 @ react-dom.development.js:21894  reactionScheduler @ mobx.module.js:1905  runReactions @ mobx.module.js:1881  endBatch @ mobx.module.js:1581  _endAction @ mobx.module.js:967  executeAction @ mobx.module.js:921  updateApproval @ mobx.module.js:901  (anonymous) @ ApprovalManageView.tsx:334  (anonymous) @ tslib.es6.js:74  __awaiter @ tslib.es6.js:70  onApprovalEditFormSubmit @ ApprovalManageView.tsx:268  (anonymous) @ FormClassValidator.tsx:266  Promise.then (async)  onSubmit @ FormClassValidator.tsx:262  onClick @ ApprovalEditView.tsx:1487  callCallback @ react-dom.development.js:189  invokeGuardedCallbackDev @ react-dom.development.js:238  invokeGuardedCallback @ react-dom.development.js:293  invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307  executeDispatch @ react-dom.development.js:390  executeDispatchesInOrder @ react-dom.development.js:415  executeDispatchesAndRelease @ react-dom.development.js:3279  executeDispatchesAndReleaseTopLevel @ react-dom.development.js:3288  forEachAccumulated @ react-dom.development.js:3260  runEventsInBatch @ react-dom.development.js:3305  runExtractedPluginEventsInBatch @ react-dom.development.js:3515  handleTopLevel @ react-dom.development.js:3559  batchedEventUpdates$1 @ react-dom.development.js:21903  batchedEventUpdates @ react-dom.development.js:1061  dispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569  attemptToDispatchEvent @ react-dom.development.js:4268  dispatchEvent @ react-dom.development.js:4190  unstable_runWithPriority @ scheduler.development.js:643  runWithPriority$1 @ react-dom.development.js:11062  discreteUpdates$1 @ react-dom.development.js:21919  discreteUpdates @ react-dom.development.js:1072  dispatchDiscreteEvent @ react-dom.development.js:4169  Show 9 more frames  react-dom.development.js:19561 The above error occurred in the <wrappedComponent> component:      in wrappedComponent (created by ApprovalManageView)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)      in ApprovalManageView (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in div (created by Transition)      in div (created by Transition)      in div (created by Transition)      in Transition (created by ForwardRef(Collapse))      in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))      in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in wrappedComponent (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)      in wrappedComponent (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)      in ApprovalsSidebar (created by Context.Consumer)      in ApprovalsSidebarWrapper (created by ContentSidebarContent)      in ContentSidebarContent (created by SidebarDesktop)      in div (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)      in ErrorBoundary (created by SidebarDesktop)      in SidebarDesktop (created by ContentEditViewUnstyled)      in div (created by ForwardRef(AccordionDetails))      in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))      in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Accordion))      in div (created by Transition)      in div (created by Transition)      in div (created by Transition)      in Transition (created by ForwardRef(Collapse))      in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))      in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))      in div (created by ForwardRef(Paper))      in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))      in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))      in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))      in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)      in span (created by ForwardRef(Badge))      in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))      in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by Sidebar)      in Sidebar (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by ContentEditViewUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)      in SidebarStoreProvider (created by ContentEditViewUnstyled)      in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))      in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)      in div (created by WithSizeDelayed)      in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))      in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)      in form (created by Context.Consumer)      in FormClassValidator (created by ContentEditForm)      in ContentEditForm (created by ContentEditFormLoaderUnstyled)      in div (created by ContentEditFormLoaderUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)      in div (created by ForwardRef(Grid))      in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))      in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)      in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))      in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))      in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)      in LoadableComponent (created by ContentEditViewPage)      in ContentEditViewPage (created by react2angular(ContentEditViewPage))      in Suspense (created by react2angular(ContentEditViewPage))      in DropContextProvider      in Unknown (created by DragDropContext(Component))      in DragDropContext(Component) (created by Providers)      in SnackbarProvider (created by Providers)      in MuiPickersUtilsProvider (created by Providers)      in ThemeProvider (created by AppThemeProvider)      in AppThemeProvider (created by Providers)      in Providers (created by SubProviders)      in SubProviders (created by react2angular(ContentEditViewPage))      in react2angular(ContentEditViewPage)      in Unknown (created by HotExportedComponent)      in AppContainer (created by HotExportedComponent)      in HotExportedComponent    React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.  ```  React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.    React version:        1. use condition before hooks    ```typescript      const [state, setState] = React.useState<State>({...defaultState});      const actions = store.isBulk ? {} : store.getActions(entity, switchView);       // this line if it is below the onToggle then everything fine and have no error      if (!approval) { return null; }        const onToggle = React.useCallback((ev: React.MouseEvent<HTMLDivElement, MouseEvent>) => {          const collapsibleName = ev.currentTarget.dataset.type + 'Open';          const value = !state[collapsibleName];          setState({ ...state, ...defaultState, [collapsibleName]: value });      }, [state]);    ```    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      crash the rendeing      it should have an error message which localize better where the error was if cannot be fixed this issue :)",
        "human_words": "  React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.    React version:        1. use condition before hooks        <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      crash the rendeing      it should have an error message which localize better where the error was if cannot be fixed this issue :)",
        "human_words_regrex": " React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary. React version: 1. use condition before hooks  Link to code example:  crash the rendeing it should have an error message which localize better where the error was if cannot be fixed this issue :)",
        "human_words_stopwords_removal_lemmatization": "react try recreate component tree scratch using error boundary provided , errorboundary . react version : 1. use condition hook link code example : crash rendeing error message localize better error fixed issue : )",
        "title_stopwords_removal_lemmatization": "bug : queue"
    },
    {
        "issue_id": 729520952,
        "title": "feature: Move react-is to react/is",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-10-26T12:28:28Z",
        "status": "closed",
        "description": "Currently `react` and `react-is` are built using a `shared/` package. That means that `react-is` (just like `react-dom`) has to have the same version number as `react` to avoid potential issues due to different code from `shared/`.\r\n\r\nHowever, right now a lot of [libraries are wrongly declaring `react-is` as a direct dependency](https://www.npmjs.com/browse/depended/react-is)<sup>1</sup> while declaring  `react` as a peer. Technically correct would be declaring `react-is` as a peer as well leading to more burden for app developers. This is slightly different to having `react` as a peer dependency because every app developer also needs `react` as a dependency. The same doesn't always hold true for `react-is`.\r\n\r\nSince `react-is` has no dependencies it would be more ergonomically for libraries if `react-is` would be available from `react/is` since they already have `react` as a peer dependency. There are two possibilities for this:\r\n1. Move `react-is` to `react/is`\r\n1. Make `react-is` a dependency of `react` and re-export it from `react/is`\r\n\r\nI guess marking `react-is` as a peer would be the approach that would be more consistent. It's really just annoying for libraries but if that's what you would recommend then I'm fine with it as well.\r\n\r\nAs far as I can tell this is really just a technicality right now i.e. I haven't seen any actual issues. I just stumbled over it while working on React 17 compat. So far it looks like we're in a position to declare 16.8 and 17 as the range for react in our `peerDependencies` which leaves us with a slightly awkward `\"react-is\": \"^16.8.0 || ^17.0.0\"` in the `dependencies` (I might be trying too hard to avoid additional peer deps).\r\n\r\n<sup>1</sup> Popular examples include `prop-types`, `react-redux`, `react-router`, `@material-ui/core`,  `next`\r\n",
        "remove_template_description": "Currently `react` and `react-is` are built using a `shared/` package. That means that `react-is` (just like `react-dom`) has to have the same version number as `react` to avoid potential issues due to different code from `shared/`.    However, right now a lot of [libraries are wrongly declaring `react-is` as a direct dependency](https://www.npmjs.com/browse/depended/react-is)<sup>1</sup> while declaring  `react` as a peer. Technically correct would be declaring `react-is` as a peer as well leading to more burden for app developers. This is slightly different to having `react` as a peer dependency because every app developer also needs `react` as a dependency. The same doesn't always hold true for `react-is`.    Since `react-is` has no dependencies it would be more ergonomically for libraries if `react-is` would be available from `react/is` since they already have `react` as a peer dependency. There are two possibilities for this:  1. Move `react-is` to `react/is`  1. Make `react-is` a dependency of `react` and re-export it from `react/is`    I guess marking `react-is` as a peer would be the approach that would be more consistent. It's really just annoying for libraries but if that's what you would recommend then I'm fine with it as well.    As far as I can tell this is really just a technicality right now i.e. I haven't seen any actual issues. I just stumbled over it while working on React 17 compat. So far it looks like we're in a position to declare 16.8 and 17 as the range for react in our `peerDependencies` which leaves us with a slightly awkward `\"react-is\": \"^16.8.0 || ^17.0.0\"` in the `dependencies` (I might be trying too hard to avoid additional peer deps).    <sup>1</sup> Popular examples include `prop-types`, `react-redux`, `react-router`, `@material-ui/core`,  `next`",
        "human_words": "Currently `react` and `react-is` are built using a `shared/` package. That means that `react-is` (just like `react-dom`) has to have the same version number as `react` to avoid potential issues due to different code from `shared/`.    However, right now a lot of [libraries are wrongly declaring `react-is` as a direct dependency](https://www.npmjs.com/browse/depended/react-is)<sup>1</sup> while declaring  `react` as a peer. Technically correct would be declaring `react-is` as a peer as well leading to more burden for app developers. This is slightly different to having `react` as a peer dependency because every app developer also needs `react` as a dependency. The same doesn't always hold true for `react-is`.    Since `react-is` has no dependencies it would be more ergonomically for libraries if `react-is` would be available from `react/is` since they already have `react` as a peer dependency. There are two possibilities for this:  1. Move `react-is` to `react/is`  1. Make `react-is` a dependency of `react` and re-export it from `react/is`    I guess marking `react-is` as a peer would be the approach that would be more consistent. It's really just annoying for libraries but if that's what you would recommend then I'm fine with it as well.    As far as I can tell this is really just a technicality right now i.e. I haven't seen any actual issues. I just stumbled over it while working on React 17 compat. So far it looks like we're in a position to declare 16.8 and 17 as the range for react in our `peerDependencies` which leaves us with a slightly awkward `\"react-is\": \"^16.8.0 || ^17.0.0\"` in the `dependencies` (I might be trying too hard to avoid additional peer deps).    <sup>1</sup> Popular examples include `prop-types`, `react-redux`, `react-router`, `@material-ui/core`,  `next`",
        "human_words_regrex": "Currently `react` and `react-is` are built using a `shared/` package. That means that `react-is` (just like `react-dom`) has to have the same version number as `react` to avoid potential issues due to different code from `shared/`. However, right now a lot of 1 while declaring `react` as a peer. Technically correct would be declaring `react-is` as a peer as well leading to more burden for app developers. This is slightly different to having `react` as a peer dependency because every app developer also needs `react` as a dependency. The same doesn't always hold true for `react-is`. Since `react-is` has no dependencies it would be more ergonomically for libraries if `react-is` would be available from `react/is` since they already have `react` as a peer dependency. There are two possibilities for this: 1. Move `react-is` to `react/is` 1. Make `react-is` a dependency of `react` and re-export it from `react/is` I guess marking `react-is` as a peer would be the approach that would be more consistent. It's really just annoying for libraries but if that's what you would recommend then I'm fine with it as well. As far as I can tell this is really just a technicality right now i.e. I haven't seen any actual issues. I just stumbled over it while working on React 17 compat. So far it looks like we're in a position to declare 16.8 and 17 as the range for react in our `peerDependencies` which leaves us with a slightly awkward `\"react-is\": \"^16.8.0 || ^17.0.0\"` in the `dependencies` (I might be trying too hard to avoid additional peer deps). 1 Popular examples include `prop-types`, `react-redux`, `react-router`, `@material-ui/core`, `next`",
        "human_words_stopwords_removal_lemmatization": "currently ` react ` ` react-is ` built using ` shared/ ` package . mean ` react-is ` ( like ` react-dom ` ) version number ` react ` avoid potential issue due different code ` shared/ ` . however , right lot 1 declaring ` react ` peer . technically correct would declaring ` react-is ` peer well leading burden app developer . slightly different ` react ` peer dependency every app developer also need ` react ` dependency . n't always hold true ` react-is ` . since ` react-is ` dependency would ergonomically library ` react-is ` would available ` react/is ` since already ` react ` peer dependency . two possibility : 1. move ` react-is ` ` react/is ` 1. make ` react-is ` dependency ` react ` re-export ` react/is ` guess marking ` react-is ` peer would approach would consistent . 's really annoying library 's would recommend 'm fine well . far tell really technicality right i.e . n't seen actual issue . stumbled working react 17 compat . far look like 're position declare 16.8 17 range react ` peerdependencies ` leaf u slightly awkward ` `` react-is '' : `` ^16.8.0 || ^17.0.0 '' ` ` dependency ` ( might trying hard avoid additional peer deps ) . 1 popular example include ` prop-types ` , ` react-redux ` , ` react-router ` , ` @ material-ui/core ` , ` next `",
        "title_stopwords_removal_lemmatization": "feature : move react-is react/is"
    },
    {
        "issue_id": 728803156,
        "title": "In StrictMode, the useState() initializer function is called twice, but one of the results is discarded",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-10-24T14:41:09Z",
        "status": "closed",
        "description": "React version: 17.0.1\r\nReact reconciler:  0.26.0 \r\n\r\n## Steps To Reproduce\r\n\r\nLink to code example: https://codesandbox.io/s/r3f-contact-shadow-forked-iggyv?file=/src/index.js:308-745\r\n\r\n```jsx\r\nlet log = console.log\r\n\r\nlet id = 0\r\nfunction Obj(node) {\r\n  this.id = id++\r\n  log('constructor', this.id)\r\n  node.addEventListener('wheel', () => log(this.id, 'wheel'), false)\r\n}\r\n\r\nfunction App(props) {\r\n  // The object is created twice, why does react do that, it's not documented\r\n  const [obj] = useState(() => log('new object') || new Obj(document.body))\r\n  return <div>{obj.id}</div>\r\n}\r\n\r\nReactDOM.unstable_createRoot(document.getElementById('root')).render(<App />)\r\n```\r\n\r\n### old demo\r\n\r\nhttps://codesandbox.io/s/r3f-contact-shadow-forked-e44m3?file=/src/index.js\r\n\r\nThis demo creates a local object which is supposed to live within the components lifecycle.\r\nFor some reason concurrent mode creates two versions of that object, but one is stuck in the view section. \r\nThese controls aren't allowed to zoom, yet, when you give you mousewheel - it zooms. The control clearly receives the flag.\r\n\r\nThis does not happen in blocking mode and previous reconcilers (for instance react 16.4.x and reconcilers pre 0.26\r\n\r\nDebugging in this is almost impossible as React swallows console.logs. Some users have found out that it indeed creates two branches of local state: https://twitter.com/belinburgh/status/1319990608010874883\r\n\r\nThe state object (orbit-controls) has side-effects, it creates events, but that is and should be of no consequence.",
        "remove_template_description": "React version: 17.0.1  React reconciler:  0.26.0         Link to code example: https://codesandbox.io/s/r3f-contact-shadow-forked-iggyv?file=/src/index.js:308-745    ```jsx  let log = console.log    let id = 0  function Obj(node) {    this.id = id++    log('constructor', this.id)    node.addEventListener('wheel', () => log(this.id, 'wheel'), false)  }    function App(props) {    // The object is created twice, why does react do that, it's not documented    const [obj] = useState(() => log('new object') || new Obj(document.body))    return <div>{obj.id}</div>  }    ReactDOM.unstable_createRoot(document.getElementById('root')).render(<App />)  ```    ### old demo    https://codesandbox.io/s/r3f-contact-shadow-forked-e44m3?file=/src/index.js    This demo creates a local object which is supposed to live within the components lifecycle.  For some reason concurrent mode creates two versions of that object, but one is stuck in the view section.   These controls aren't allowed to zoom, yet, when you give you mousewheel - it zooms. The control clearly receives the flag.    This does not happen in blocking mode and previous reconcilers (for instance react 16.4.x and reconcilers pre 0.26    Debugging in this is almost impossible as React swallows console.logs. Some users have found out that it indeed creates two branches of local state: https://twitter.com/belinburgh/status/1319990608010874883    The state object (orbit-controls) has side-effects, it creates events, but that is and should be of no consequence.",
        "human_words": "React version: 17.0.1  React reconciler:  0.26.0         Link to code example: https://codesandbox.io/s/r3f-contact-shadow-forked-iggyv?file=/src/index.js:308-745        ### old demo    https://codesandbox.io/s/r3f-contact-shadow-forked-e44m3?file=/src/index.js    This demo creates a local object which is supposed to live within the components lifecycle.  For some reason concurrent mode creates two versions of that object, but one is stuck in the view section.   These controls aren't allowed to zoom, yet, when you give you mousewheel - it zooms. The control clearly receives the flag.    This does not happen in blocking mode and previous reconcilers (for instance react 16.4.x and reconcilers pre 0.26    Debugging in this is almost impossible as React swallows console.logs. Some users have found out that it indeed creates two branches of local state: https://twitter.com/belinburgh/status/1319990608010874883    The state object (orbit-controls) has side-effects, it creates events, but that is and should be of no consequence.",
        "human_words_regrex": "React version: 17.0.1 React reconciler: 0.26.0 Link to code example:  ### old demo  This demo creates a local object which is supposed to live within the components lifecycle. For some reason concurrent mode creates two versions of that object, but one is stuck in the view section. These controls aren't allowed to zoom, yet, when you give you mousewheel - it zooms. The control clearly receives the flag. This does not happen in blocking mode and previous reconcilers (for instance react 16.4.x and reconcilers pre 0.26 Debugging in this is almost impossible as React swallows console.logs. Some users have found out that it indeed creates two branches of local state:  The state object (orbit-controls) has side-effects, it creates events, but that is and should be of no consequence.",
        "human_words_stopwords_removal_lemmatization": "react version : 17.0.1 react reconciler : 0.26.0 link code example : # # # old demo demo creates local object supposed live within component lifecycle . reason concurrent mode creates two version object , one stuck view section . control n't allowed zoom , yet , give mousewheel - zoom . control clearly receives flag . happen blocking mode previous reconciler ( instance react 16.4.x reconciler pre 0.26 debugging almost impossible react swallow console.logs . user found indeed creates two branch local state : state object ( orbit-controls ) side-effects , creates event , consequence .",
        "title_stopwords_removal_lemmatization": "strictmode , usestate ( ) initializer function called twice , one result discarded"
    },
    {
        "issue_id": 724004094,
        "title": "Feature Proposal: className can be an array of class names strings",
        "label": [
            "Resolution: Duplicate",
            "Type: Discussion"
        ],
        "date": "2020-10-18T13:11:21Z",
        "status": "closed",
        "description": "### Description\r\nThe current `className` prop on any JSX element takes only a string, that is supposed to be the class name to add to the corresponding element. This prop expects a string which makes it very easy to attach a single class name to the element.\r\n\r\nFor example: \r\n```\r\n<div className=\"my-css-class-name\"></div>\r\n```\r\n\r\n### Problem\r\nThe limitation I ran into while using className, is when I wanted to attach a couple classes to the same element, I naturally tried to do something like this:\r\n```\r\n<div className={\"my-css-class-name\", \"my-other-css-class-name\"}></div>\r\n```\r\nBut unfortunately it didn't work, [I then realized that it's not possible with the current JSX specification](https://reactjs.org/docs/faq-styling.html#how-do-i-add-css-classes-to-components).\r\n\r\nThe proposed solution in the FAQ link I shared above suggests manually attaching the strings and add a space, or use another package called [\"Classnames\"](https://www.npmjs.com/package/classnames#usage-with-reactjs).\r\n\r\n### Feature Proposal\r\nI as a react user, expected naturally that I could provide multiple classes with JSX, so I think it can be useful for other developers, if the prop `className` can take an array of strings (classes) and does a simple `Array.join(\" \")` in this case. So that developers won't have to join them manually or use the other package \"Classnames\". I believe this could be beneficial for the simple use case, and also for a more advanced use case like mine (using Material UI's `makeStyles`).\r\n\r\nI would appreciate your thoughts on this suggestion. Furthermore, if discussion concludes that you agree to adopt such change, I would be more than happy to contribute it, as by chance I was looking at the beginner-friendly issues for contributors a couple days ago and couldn't find something (they're all assigned).",
        "remove_template_description": "### Description  The current `className` prop on any JSX element takes only a string, that is supposed to be the class name to add to the corresponding element. This prop expects a string which makes it very easy to attach a single class name to the element.    For example:   ```  <div className=\"my-css-class-name\"></div>  ```    ### Problem  The limitation I ran into while using className, is when I wanted to attach a couple classes to the same element, I naturally tried to do something like this:  ```  <div className={\"my-css-class-name\", \"my-other-css-class-name\"}></div>  ```  But unfortunately it didn't work, [I then realized that it's not possible with the current JSX specification](https://reactjs.org/docs/faq-styling.html#how-do-i-add-css-classes-to-components).    The proposed solution in the FAQ link I shared above suggests manually attaching the strings and add a space, or use another package called [\"Classnames\"](https://www.npmjs.com/package/classnames#usage-with-reactjs).    ### Feature Proposal  I as a react user, expected naturally that I could provide multiple classes with JSX, so I think it can be useful for other developers, if the prop `className` can take an array of strings (classes) and does a simple `Array.join(\" \")` in this case. So that developers won't have to join them manually or use the other package \"Classnames\". I believe this could be beneficial for the simple use case, and also for a more advanced use case like mine (using Material UI's `makeStyles`).    I would appreciate your thoughts on this suggestion. Furthermore, if discussion concludes that you agree to adopt such change, I would be more than happy to contribute it, as by chance I was looking at the beginner-friendly issues for contributors a couple days ago and couldn't find something (they're all assigned).",
        "human_words": "### Description  The current `className` prop on any JSX element takes only a string, that is supposed to be the class name to add to the corresponding element. This prop expects a string which makes it very easy to attach a single class name to the element.    For example:       ### Problem  The limitation I ran into while using className, is when I wanted to attach a couple classes to the same element, I naturally tried to do something like this:    But unfortunately it didn't work, [I then realized that it's not possible with the current JSX specification](https://reactjs.org/docs/faq-styling.html#how-do-i-add-css-classes-to-components).    The proposed solution in the FAQ link I shared above suggests manually attaching the strings and add a space, or use another package called [\"Classnames\"](https://www.npmjs.com/package/classnames#usage-with-reactjs).    ### Feature Proposal  I as a react user, expected naturally that I could provide multiple classes with JSX, so I think it can be useful for other developers, if the prop `className` can take an array of strings (classes) and does a simple `Array.join(\" \")` in this case. So that developers won't have to join them manually or use the other package \"Classnames\". I believe this could be beneficial for the simple use case, and also for a more advanced use case like mine (using Material UI's `makeStyles`).    I would appreciate your thoughts on this suggestion. Furthermore, if discussion concludes that you agree to adopt such change, I would be more than happy to contribute it, as by chance I was looking at the beginner-friendly issues for contributors a couple days ago and couldn't find something (they're all assigned).",
        "human_words_regrex": "### Description The current `className` prop on any JSX element takes only a string, that is supposed to be the class name to add to the corresponding element. This prop expects a string which makes it very easy to attach a single class name to the element. For example: ### Problem The limitation I ran into while using className, is when I wanted to attach a couple classes to the same element, I naturally tried to do something like this: But unfortunately it didn't work, . The proposed solution in the FAQ link I shared above suggests manually attaching the strings and add a space, or use another package called . ### Feature Proposal I as a react user, expected naturally that I could provide multiple classes with JSX, so I think it can be useful for other developers, if the prop `className` can take an array of strings (classes) and does a simple `Array.join(\" \")` in this case. So that developers won't have to join them manually or use the other package \"Classnames\". I believe this could be beneficial for the simple use case, and also for a more advanced use case like mine (using Material UI's `makeStyles`). I would appreciate your thoughts on this suggestion. Furthermore, if discussion concludes that you agree to adopt such change, I would be more than happy to contribute it, as by chance I was looking at the beginner-friendly issues for contributors a couple days ago and couldn't find something (they're all assigned).",
        "human_words_stopwords_removal_lemmatization": "# # # description current ` classname ` prop jsx element take string , supposed class name add corresponding element . prop expects string make easy attach single class name element . example : # # # problem limitation ran using classname , wanted attach couple class element , naturally tried something like : unfortunately n't work , . proposed solution faq link shared suggests manually attaching string add space , use another package called . # # # feature proposal react user , expected naturally could provide multiple class jsx , think useful developer , prop ` classname ` take array string ( class ) simple ` array.join ( `` `` ) ` case . developer wo n't join manually use package `` classnames '' . believe could beneficial simple use case , also advanced use case like mine ( using material ui 's ` makestyles ` ) . would appreciate thought suggestion . furthermore , discussion concludes agree adopt change , would happy contribute , chance looking beginner-friendly issue contributor couple day ago could n't find something ( 're assigned ) .",
        "title_stopwords_removal_lemmatization": "feature proposal : classname array class name string"
    },
    {
        "issue_id": 723727027,
        "title": "Clarify SSR expectations/contract",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-10-17T10:31:37Z",
        "status": "closed",
        "description": "I've been asked about the safety of a certain pattern and I'd like to clarify this with you (the React team). \r\n\r\nIn my opinion - the actual SSRed output and the hydrating tree **do not have to match**. This is, of course, a weird space of things and one should understand how things work together to even think about it, but there is no technical aspect forbidding this now. Question is - is it safe to assume that such a \"use case\" will stay supported in the future. I believe it is because the only thing that is used as an input to the rehydration is the current HTML structure and the React team doesn't intend to ship any extra metadata in the SSRed output about the actual render tree that was used to render it.\r\n\r\nThis can be a little bit of a vague question - so let's take a look at an example. Emotion does 2 things on the server differently than on the client:\r\n1. it does not use `React.forwardRef` (refs are useless on the server, so we don't see a need to grow the render tree rather significantly by using it)\r\n2. we render `<style>` elements \"inline\", together with other elements. This is an example SSRed output:\r\n```html\r\n<div id=\"react-root\">\r\n  <style data-emotion-css=\"bjcoli\">\r\n    .css-bjcoli{color:green;}\r\n  </style>\r\n  <div class=\"css-bjcoli\">\r\n    <style data-emotion-css=\"ihiui2\">\r\n      .css-ihiui2{color:hotpink;}\r\n    </style>\r\n    <div class=\"css-ihiui2\">\r\n    </div>\r\n    <div class=\"css-ihiui2\">\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\nOn the client we:\r\n- use `React.forwardRef` as it's important to do so\r\n- we **move** `<style>` elements to the `<head>` **before** rehydration can even be called\r\n\r\nThis makes the HTML structure **identical** to what React sees during the first render so there is **no SSR mismatch**, even though initially there kinda is one.\r\n\r\nWe totally understand this is a gray area and trickery - question is: do u plan to make things like this break in the future? I totally would understand the answer being \"we can't guarantee that\", but at the same time it would be great if it would be accompanied by \"probably not, this is _safe_ to do and there are no plans to make this break now\"\r\n\r\ncc @eps1lon ",
        "remove_template_description": "I've been asked about the safety of a certain pattern and I'd like to clarify this with you (the React team).     In my opinion - the actual SSRed output and the hydrating tree **do not have to match**. This is, of course, a weird space of things and one should understand how things work together to even think about it, but there is no technical aspect forbidding this now. Question is - is it safe to assume that such a \"use case\" will stay supported in the future. I believe it is because the only thing that is used as an input to the rehydration is the current HTML structure and the React team doesn't intend to ship any extra metadata in the SSRed output about the actual render tree that was used to render it.    This can be a little bit of a vague question - so let's take a look at an example. Emotion does 2 things on the server differently than on the client:  1. it does not use `React.forwardRef` (refs are useless on the server, so we don't see a need to grow the render tree rather significantly by using it)  2. we render `<style>` elements \"inline\", together with other elements. This is an example SSRed output:  ```html  <div id=\"react-root\">    <style data-emotion-css=\"bjcoli\">      .css-bjcoli{color:green;}    </style>    <div class=\"css-bjcoli\">      <style data-emotion-css=\"ihiui2\">        .css-ihiui2{color:hotpink;}      </style>      <div class=\"css-ihiui2\">      </div>      <div class=\"css-ihiui2\">      </div>    </div>  </div>  ```    On the client we:  - use `React.forwardRef` as it's important to do so  - we **move** `<style>` elements to the `<head>` **before** rehydration can even be called    This makes the HTML structure **identical** to what React sees during the first render so there is **no SSR mismatch**, even though initially there kinda is one.    We totally understand this is a gray area and trickery - question is: do u plan to make things like this break in the future? I totally would understand the answer being \"we can't guarantee that\", but at the same time it would be great if it would be accompanied by \"probably not, this is _safe_ to do and there are no plans to make this break now\"    cc @eps1lon",
        "human_words": "I've been asked about the safety of a certain pattern and I'd like to clarify this with you (the React team).     In my opinion - the actual SSRed output and the hydrating tree **do not have to match**. This is, of course, a weird space of things and one should understand how things work together to even think about it, but there is no technical aspect forbidding this now. Question is - is it safe to assume that such a \"use case\" will stay supported in the future. I believe it is because the only thing that is used as an input to the rehydration is the current HTML structure and the React team doesn't intend to ship any extra metadata in the SSRed output about the actual render tree that was used to render it.    This can be a little bit of a vague question - so let's take a look at an example. Emotion does 2 things on the server differently than on the client:  1. it does not use `React.forwardRef` (refs are useless on the server, so we don't see a need to grow the render tree rather significantly by using it)  2. we render `<style>` elements \"inline\", together with other elements. This is an example SSRed output:      On the client we:  - use `React.forwardRef` as it's important to do so  - we **move** `<style>` elements to the `<head>` **before** rehydration can even be called    This makes the HTML structure **identical** to what React sees during the first render so there is **no SSR mismatch**, even though initially there kinda is one.    We totally understand this is a gray area and trickery - question is: do u plan to make things like this break in the future? I totally would understand the answer being \"we can't guarantee that\", but at the same time it would be great if it would be accompanied by \"probably not, this is _safe_ to do and there are no plans to make this break now\"    cc @eps1lon",
        "human_words_regrex": "I've been asked about the safety of a certain pattern and I'd like to clarify this with you (the React team). In my opinion - the actual SSRed output and the hydrating tree **do not have to match**. This is, of course, a weird space of things and one should understand how things work together to even think about it, but there is no technical aspect forbidding this now. Question is - is it safe to assume that such a \"use case\" will stay supported in the future. I believe it is because the only thing that is used as an input to the rehydration is the current HTML structure and the React team doesn't intend to ship any extra metadata in the SSRed output about the actual render tree that was used to render it. This can be a little bit of a vague question - so let's take a look at an example. Emotion does 2 things on the server differently than on the client: 1. it does not use `React.forwardRef` (refs are useless on the server, so we don't see a need to grow the render tree rather significantly by using it) 2. we render `` elements \"inline\", together with other elements. This is an example SSRed output: On the client we: - use `React.forwardRef` as it's important to do so - we **move** `` elements to the `` **before** rehydration can even be called This makes the HTML structure **identical** to what React sees during the first render so there is **no SSR mismatch**, even though initially there kinda is one. We totally understand this is a gray area and trickery - question is: do u plan to make things like this break in the future? I totally would understand the answer being \"we can't guarantee that\", but at the same time it would be great if it would be accompanied by \"probably not, this is _safe_ to do and there are no plans to make this break now\" cc @eps1lon",
        "human_words_stopwords_removal_lemmatization": "'ve asked safety certain pattern 'd like clarify ( react team ) . opinion - actual ssred output hydrating tree * * match * * . , course , weird space thing one understand thing work together even think , technical aspect forbidding . question - safe assume `` use case '' stay supported future . believe thing used input rehydration current html structure react team n't intend ship extra metadata ssred output actual render tree used render . little bit vague question - let 's take look example . emotion 2 thing server differently client : 1. use ` react.forwardref ` ( ref useless server , n't see need grow render tree rather significantly using ) 2. render `` element `` inline '' , together element . example ssred output : client : - use ` react.forwardref ` 's important - * * move * * `` element `` * * * * rehydration even called make html structure * * identical * * react see first render * * ssr mismatch * * , even though initially kinda one . totally understand gray area trickery - question : u plan make thing like break future ? totally would understand answer `` ca n't guarantee '' , time would great would accompanied `` probably , _safe_ plan make break '' cc @ eps1lon",
        "title_stopwords_removal_lemmatization": "clarify ssr expectations/contract"
    },
    {
        "issue_id": 719670665,
        "title": "Feature Request: Add Warning when consuming a context whose provider is not mounted",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-10-12T21:10:29Z",
        "status": "closed",
        "description": "React allows you to consume a `context`, even if it's `Provider` is not mounted. Imagine a scenario where you are building a new context, and forget to add the `Provider`. When you consume it with either `useContext` or the `Consumer` component, React will run without issue, but your code won't work as expected. This has led to hours of lost time debugging the wrong problem. Adding a warning that a context is being consumed that does not have its `Provider` mounted, would help to reduce the time spent debugging this issue.",
        "remove_template_description": "React allows you to consume a `context`, even if it's `Provider` is not mounted. Imagine a scenario where you are building a new context, and forget to add the `Provider`. When you consume it with either `useContext` or the `Consumer` component, React will run without issue, but your code won't work as expected. This has led to hours of lost time debugging the wrong problem. Adding a warning that a context is being consumed that does not have its `Provider` mounted, would help to reduce the time spent debugging this issue.",
        "human_words": "React allows you to consume a `context`, even if it's `Provider` is not mounted. Imagine a scenario where you are building a new context, and forget to add the `Provider`. When you consume it with either `useContext` or the `Consumer` component, React will run without issue, but your code won't work as expected. This has led to hours of lost time debugging the wrong problem. Adding a warning that a context is being consumed that does not have its `Provider` mounted, would help to reduce the time spent debugging this issue.",
        "human_words_regrex": "React allows you to consume a `context`, even if it's `Provider` is not mounted. Imagine a scenario where you are building a new context, and forget to add the `Provider`. When you consume it with either `useContext` or the `Consumer` component, React will run without issue, but your code won't work as expected. This has led to hours of lost time debugging the wrong problem. Adding a warning that a context is being consumed that does not have its `Provider` mounted, would help to reduce the time spent debugging this issue.",
        "human_words_stopwords_removal_lemmatization": "react allows consume ` context ` , even 's ` provider ` mounted . imagine scenario building new context , forget add ` provider ` . consume either ` usecontext ` ` consumer ` component , react run without issue , code wo n't work expected . led hour lost time debugging wrong problem . adding warning context consumed ` provider ` mounted , would help reduce time spent debugging issue .",
        "title_stopwords_removal_lemmatization": "feature request : add warning consuming context whose provider mounted"
    },
    {
        "issue_id": 707312008,
        "title": "FR: Allow displaying debug information for reconcilers in DevTools",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-09-23T12:18:50Z",
        "status": "open",
        "description": "React allows to develop custom reconcilers. However, currently it is not possible to display custom debug information about the generated Instances in the react DevTools.\r\n\r\nTherefore, I propose to introduce two functions into `HostConfig`:\r\n\r\n```TypeScript\r\n  getInstanceDebugInfo?: (instance: Instance) => any;\r\n  getTextInstanceDebugInfo?: (textInstance: TextInstance) => any\r\n```\r\n\r\nThey should return an object with custom debug information that would be shown in DevTools whenever an Instance-backed Component is highlighted.",
        "remove_template_description": "React allows to develop custom reconcilers. However, currently it is not possible to display custom debug information about the generated Instances in the react DevTools.    Therefore, I propose to introduce two functions into `HostConfig`:    ```TypeScript    getInstanceDebugInfo?: (instance: Instance) => any;    getTextInstanceDebugInfo?: (textInstance: TextInstance) => any  ```    They should return an object with custom debug information that would be shown in DevTools whenever an Instance-backed Component is highlighted.",
        "human_words": "React allows to develop custom reconcilers. However, currently it is not possible to display custom debug information about the generated Instances in the react DevTools.    Therefore, I propose to introduce two functions into `HostConfig`:        They should return an object with custom debug information that would be shown in DevTools whenever an Instance-backed Component is highlighted.",
        "human_words_regrex": "React allows to develop custom reconcilers. However, currently it is not possible to display custom debug information about the generated Instances in the react DevTools. Therefore, I propose to introduce two functions into `HostConfig`: They should return an object with custom debug information that would be shown in DevTools whenever an Instance-backed Component is highlighted.",
        "human_words_stopwords_removal_lemmatization": "react allows develop custom reconciler . however , currently possible display custom debug information generated instance react devtools . therefore , propose introduce two function ` hostconfig ` : return object custom debug information would shown devtools whenever instance-backed component highlighted .",
        "title_stopwords_removal_lemmatization": "fr : allow displaying debug information reconciler devtools"
    },
    {
        "issue_id": 704675708,
        "title": "Removal of <script> functionality needs to be added to https://reactjs.org/docs/ and a warning displayed while in development mode.",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-09-18T21:44:45Z",
        "status": "open",
        "description": "When a <script> tag is used within JSX there is functionality that tricks the browser into not executing the contained code or from fetching the `src`. There is a code comment indicating this behaviour:\r\n\r\n`Create the script via .innerHTML so its \"parser-inserted\" flag is set to true and it does not execute`\r\n\r\nbut for those who are expecting the tag to work like _every other html tag_ in React it is a bit of a surprise that wastes several hours tracking down the cause.  This \"feature\" is obviously there for security reasons, but there are numerous ways around it (changing the case of a letter such as <sCript src=\"...\">).\r\n\r\nPlease either remove this feature and add a warning while in dev mode stating that adding <script> tags is not best practices, or keep the feature but warn that <script> tags are not supported inline and document this behaviour in the React docs. I personally recommend the first once since it simplifies the React code base while allowing the developer to still proceed at their own risk.  The \"risk\" is minor since this isn't readily exploitable as the dangerouslySetHtml feature.\r\n\r\n",
        "remove_template_description": "When a <script> tag is used within JSX there is functionality that tricks the browser into not executing the contained code or from fetching the `src`. There is a code comment indicating this behaviour:    `Create the script via .innerHTML so its \"parser-inserted\" flag is set to true and it does not execute`    but for those who are expecting the tag to work like _every other html tag_ in React it is a bit of a surprise that wastes several hours tracking down the cause.  This \"feature\" is obviously there for security reasons, but there are numerous ways around it (changing the case of a letter such as <sCript src=\"...\">).    Please either remove this feature and add a warning while in dev mode stating that adding <script> tags is not best practices, or keep the feature but warn that <script> tags are not supported inline and document this behaviour in the React docs. I personally recommend the first once since it simplifies the React code base while allowing the developer to still proceed at their own risk.  The \"risk\" is minor since this isn't readily exploitable as the dangerouslySetHtml feature.",
        "human_words": "When a <script> tag is used within JSX there is functionality that tricks the browser into not executing the contained code or from fetching the `src`. There is a code comment indicating this behaviour:    `Create the script via .innerHTML so its \"parser-inserted\" flag is set to true and it does not execute`    but for those who are expecting the tag to work like _every other html tag_ in React it is a bit of a surprise that wastes several hours tracking down the cause.  This \"feature\" is obviously there for security reasons, but there are numerous ways around it (changing the case of a letter such as <sCript src=\"...\">).    Please either remove this feature and add a warning while in dev mode stating that adding <script> tags is not best practices, or keep the feature but warn that <script> tags are not supported inline and document this behaviour in the React docs. I personally recommend the first once since it simplifies the React code base while allowing the developer to still proceed at their own risk.  The \"risk\" is minor since this isn't readily exploitable as the dangerouslySetHtml feature.",
        "human_words_regrex": "When a  tag is used within JSX there is functionality that tricks the browser into not executing the contained code or from fetching the `src`. There is a code comment indicating this behaviour: `Create the script via .innerHTML so its \"parser-inserted\" flag is set to true and it does not execute` but for those who are expecting the tag to work like _every other html tag_ in React it is a bit of a surprise that wastes several hours tracking down the cause. This \"feature\" is obviously there for security reasons, but there are numerous ways around it (changing the case of a letter such as ). Please either remove this feature and add a warning while in dev mode stating that adding  tags is not best practices, or keep the feature but warn that  tags are not supported inline and document this behaviour in the React docs. I personally recommend the first once since it simplifies the React code base while allowing the developer to still proceed at their own risk. The \"risk\" is minor since this isn't readily exploitable as the dangerouslySetHtml feature.",
        "human_words_stopwords_removal_lemmatization": "tag used within jsx functionality trick browser executing contained code fetching ` src ` . code comment indicating behaviour : ` create script via .innerhtml `` parser-inserted '' flag set true execute ` expecting tag work like _every html tag_ react bit surprise waste several hour tracking cause . `` feature '' obviously security reason , numerous way around ( changing case letter ) . please either remove feature add warning dev mode stating adding tag best practice , keep feature warn tag supported inline document behaviour react doc . personally recommend first since simplifies react code base allowing developer still proceed risk . `` risk '' minor since n't readily exploitable dangerouslysethtml feature .",
        "title_stopwords_removal_lemmatization": "removal < script > functionality need added http : //reactjs.org/docs/ warning displayed development mode ."
    },
    {
        "issue_id": 703804545,
        "title": "Bug:  Component with a Symbol as key, causes Crash",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-09-17T18:14:16Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version:\r\n16.13.1\r\n# Steps To Reproduce\r\n\r\n1. Go To the link https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js\r\n2. We can see errors caused by this part of code: https://github.com/facebook/react/blob/6fddca27e75950adda92ab4f4946442907dc3bb7/packages/react/src/ReactElement.js#L228\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example:\r\nhttps://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\nCrash\r\n## The expected behavior\r\nNo crash\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:  16.13.1  # Steps To Reproduce    1. Go To the link https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js  2. We can see errors caused by this part of code: https://github.com/facebook/react/blob/6fddca27e75950adda92ab4f4946442907dc3bb7/packages/react/src/ReactElement.js#L228    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:  https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js  <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Crash    No crash",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:  16.13.1  # Steps To Reproduce    1. Go To the link https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js  2. We can see errors caused by this part of code: https://github.com/facebook/react/blob/6fddca27e75950adda92ab4f4946442907dc3bb7/packages/react/src/ReactElement.js#L228    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:  https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js  <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      Crash    No crash",
        "human_words_regrex": " React version: 16.13.1 # Steps To Reproduce 1. Go To the link  2. We can see errors caused by this part of code:   Link to code example:   Crash No crash",
        "human_words_stopwords_removal_lemmatization": "react version : 16.13.1 # step reproduce 1. go link 2. see error caused part code : link code example : crash crash",
        "title_stopwords_removal_lemmatization": "bug : component symbol key , cause crash"
    },
    {
        "issue_id": 702579429,
        "title": "Bug: Super gets strikethrought in react ",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-09-16T08:48:58Z",
        "status": "closed",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version:16.13.1\r\n I was wriitng code like this; \r\n\r\n\r\n\r\n\r\nimport React, { Component } from \"react\";\r\nimport { Message } from \"./Message\";\r\nimport ActionButton from \"./ActionButton\";\r\n\r\nexport default class App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      counter: 0\r\n    };\r\n  }\r\n}\r\n\r\n\r\n\r\nBut \" super(props) \" keyword get strikethrough automatically. I don't know why?\r\n\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:16.13.1   I was wriitng code like this;           import React, { Component } from \"react\";  import { Message } from \"./Message\";  import ActionButton from \"./ActionButton\";    export default class App extends Component {    constructor(props) {      super(props);      this.state = {        counter: 0      };    }  }        But \" super(props) \" keyword get strikethrough automatically. I don't know why?",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:16.13.1   I was wriitng code like this;           import React, { Component } from \"react\";  import { Message } from \"./Message\";  import ActionButton from \"./ActionButton\";    export default class App extends Component {    constructor(props) {      super(props);      this.state = {        counter: 0      };    }  }        But \" super(props) \" keyword get strikethrough automatically. I don't know why?",
        "human_words_regrex": " React version:16.13.1 I was wriitng code like this; import React, { Component } from \"react\"; import { Message } from \"./Message\"; import ActionButton from \"./ActionButton\"; export default class App extends Component { constructor(props) { super(props); this.state = { counter: 0 }; } } But \" super(props) \" keyword get strikethrough automatically. I don't know why?",
        "human_words_stopwords_removal_lemmatization": "react version:16.13.1 wriitng code like ; import react , { component } `` react '' ; import { message } `` ./message '' ; import actionbutton `` ./actionbutton '' ; export default class app extends component { constructor ( prop ) { super ( prop ) ; this.state = { counter : 0 } ; } } `` super ( prop ) `` keyword get strikethrough automatically . n't know ?",
        "title_stopwords_removal_lemmatization": "bug : super get strikethrought react"
    },
    {
        "issue_id": 699464639,
        "title": "[Feature Request]: distinguish \"what\" and \"when\" dependencies in useEffect",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2020-09-11T15:41:32Z",
        "status": "closed",
        "description": "## Feature\r\n\r\nA new overloading for `useEffect` (Typescript syntax):\r\n\r\n```ts\r\ninterface useEffect {\r\n  /**\r\n   * @param what - what this side effect does?\r\n   * @param whatDeps - which variables modify \u201cwhat\u201d the side effect does?\r\n   * These dependencies must match all live variables explicitly referenced\r\n   * in the body of the \u201cwhat\u201d callback.\r\n   * @param whenDeps - which variables modify \u201cwhen\u201d the side effect takes place?\r\n   * When and only when at least one of those dependencies change, the \u201cwhat\u201d\r\n   * callback should be executed.\r\n   */\r\n  (what: (...args: any[]) => any, whatDeps: any[], whenDeps: any[]): void;\r\n  /**\r\n   * @param what - what this side effect does?\r\n   * @param deps - an array of values that the effect depends on.\r\n   *\r\n   */\r\n  (what: (...args: any[]) => any, deps?: any[]): void;\r\n}\r\n```\r\n## Motivations\r\n\r\nIn the current implementation, the second argument of `useEffect`, \u201cdeps\u201d, [is described as such](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect):\r\n> The array of values that the effect depends on.\r\n\r\nThis definition does not account for an important nuance between two kind of dependencies:\r\n\r\n- *what* dependencies, those which require the effect callback to be ~*recomputed*~ *updated*;\r\n- *when* dependencies, those which require the effect callback to be ~*rerun*~ *executed*.\r\n\r\nThe community seems to be in need of a solution, see https://stackoverflow.com/q/55724642/2779871.\r\n\r\n## Use case\r\n\r\nI want to scroll to top of a component when the content changes (first dependency), but this effect also depends on a variable padding top (second dependency).\r\n\r\nWith the current implementation of `useEffect`, this is what I would do:\r\n```jsx\r\nfunction MyComponent(props) {\r\n  const { paddingTop, content } = props;\r\n  const ref = React.useRef();\r\n  React.useEffect(() => {\r\n    // scroll to paddingTop when content changes?\r\n    ref.current.scrollTo(0, paddingTop);\r\n  }, [paddingTop, content]);\r\n return <div ref={ref}>...</div>\r\n}\r\n```\r\nThere is an undesired behavior: the hook is executed on `paddingTop` changes. Moreover, `content` is not, semantically, a dependency of the callback, but rather a dependency of *when this side effect should take place*. So I could use a ref, store the previous value of `paddingTop`, and compare the two. But that is cumbersome.\r\n\r\n**What I would like to do, is express the *when this side-effect should take place* dependencies declaratively:**\r\n\r\n```jsx\r\nfunction MyComponent(props) {\r\n  const { paddingTop, content } = props;\r\n  const ref = React.useRef();\r\n  React.useEffect(() => {\r\n    // scroll to paddingTop when content changes.\r\n    ref.current.scrollTo(0, paddingTop);\r\n  }, [paddingTop], [content]);\r\n return <div ref={ref}>...</div>\r\n}\r\n```\r\n\r\n## Detailed behavior\r\n\r\nMy understanding is that this proposal would not be a breaking change and is 100% retrocompatible with current implementation.\r\n\r\n### One argument\r\n\r\n``` js\r\nuseEffect(what);\r\n```\r\n\r\nThe behavior is identical to current implementation. The effect is executed after each render cycle.\r\n\r\n### Two arguments\r\n\r\n``` js\r\nuseEffect(what, deps);\r\n```\r\nThe behavior is identical to current implementation. The second argument conflates *whatDeps* and *whenDeps*.\r\n\r\n### Empty second argument\r\n\r\n``` js\r\nuseEffect(what, []);\r\n```\r\n\r\nThe behavior is identical to current implementation. The callback is executed only once.\r\n\r\n### Empty third argument\r\n\r\n``` js\r\nuseEffect(what, whatDeps, []);\r\n```\r\n\r\nThe callback is executed only once, regardless of the changes in *whatDeps*.\r\n\r\n### Three arguments\r\n\r\n``` js\r\nuseEffect(what, whatDeps, whenDeps);\r\n```\r\n\r\nThe callback is executed when and only when at least one variable in *whenDeps* array changes, regardless of the changes in *whatDeps*.",
        "remove_template_description": "## Feature    A new overloading for `useEffect` (Typescript syntax):    ```ts  interface useEffect {    /**     * @param what - what this side effect does?     * @param whatDeps - which variables modify \u201cwhat\u201d the side effect does?     * These dependencies must match all live variables explicitly referenced     * in the body of the \u201cwhat\u201d callback.     * @param whenDeps - which variables modify \u201cwhen\u201d the side effect takes place?     * When and only when at least one of those dependencies change, the \u201cwhat\u201d     * callback should be executed.     */    (what: (...args: any[]) => any, whatDeps: any[], whenDeps: any[]): void;    /**     * @param what - what this side effect does?     * @param deps - an array of values that the effect depends on.     *     */    (what: (...args: any[]) => any, deps?: any[]): void;  }  ```  ## Motivations    In the current implementation, the second argument of `useEffect`, \u201cdeps\u201d, [is described as such](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect):  > The array of values that the effect depends on.    This definition does not account for an important nuance between two kind of dependencies:    - *what* dependencies, those which require the effect callback to be ~*recomputed*~ *updated*;  - *when* dependencies, those which require the effect callback to be ~*rerun*~ *executed*.    The community seems to be in need of a solution, see https://stackoverflow.com/q/55724642/2779871.    ## Use case    I want to scroll to top of a component when the content changes (first dependency), but this effect also depends on a variable padding top (second dependency).    With the current implementation of `useEffect`, this is what I would do:  ```jsx  function MyComponent(props) {    const { paddingTop, content } = props;    const ref = React.useRef();    React.useEffect(() => {      // scroll to paddingTop when content changes?      ref.current.scrollTo(0, paddingTop);    }, [paddingTop, content]);   return <div ref={ref}>...</div>  }  ```  There is an undesired behavior: the hook is executed on `paddingTop` changes. Moreover, `content` is not, semantically, a dependency of the callback, but rather a dependency of *when this side effect should take place*. So I could use a ref, store the previous value of `paddingTop`, and compare the two. But that is cumbersome.    **What I would like to do, is express the *when this side-effect should take place* dependencies declaratively:**    ```jsx  function MyComponent(props) {    const { paddingTop, content } = props;    const ref = React.useRef();    React.useEffect(() => {      // scroll to paddingTop when content changes.      ref.current.scrollTo(0, paddingTop);    }, [paddingTop], [content]);   return <div ref={ref}>...</div>  }  ```    ## Detailed behavior    My understanding is that this proposal would not be a breaking change and is 100% retrocompatible with current implementation.    ### One argument    ``` js  useEffect(what);  ```    The behavior is identical to current implementation. The effect is executed after each render cycle.    ### Two arguments    ``` js  useEffect(what, deps);  ```  The behavior is identical to current implementation. The second argument conflates *whatDeps* and *whenDeps*.    ### Empty second argument    ``` js  useEffect(what, []);  ```    The behavior is identical to current implementation. The callback is executed only once.    ### Empty third argument    ``` js  useEffect(what, whatDeps, []);  ```    The callback is executed only once, regardless of the changes in *whatDeps*.    ### Three arguments    ``` js  useEffect(what, whatDeps, whenDeps);  ```    The callback is executed when and only when at least one variable in *whenDeps* array changes, regardless of the changes in *whatDeps*.",
        "human_words": "## Feature    A new overloading for `useEffect` (Typescript syntax):      ## Motivations    In the current implementation, the second argument of `useEffect`, \u201cdeps\u201d, [is described as such](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect):  > The array of values that the effect depends on.    This definition does not account for an important nuance between two kind of dependencies:    - *what* dependencies, those which require the effect callback to be ~*recomputed*~ *updated*;  - *when* dependencies, those which require the effect callback to be ~*rerun*~ *executed*.    The community seems to be in need of a solution, see https://stackoverflow.com/q/55724642/2779871.    ## Use case    I want to scroll to top of a component when the content changes (first dependency), but this effect also depends on a variable padding top (second dependency).    With the current implementation of `useEffect`, this is what I would do:    There is an undesired behavior: the hook is executed on `paddingTop` changes. Moreover, `content` is not, semantically, a dependency of the callback, but rather a dependency of *when this side effect should take place*. So I could use a ref, store the previous value of `paddingTop`, and compare the two. But that is cumbersome.    **What I would like to do, is express the *when this side-effect should take place* dependencies declaratively:**        ## Detailed behavior    My understanding is that this proposal would not be a breaking change and is 100% retrocompatible with current implementation.    ### One argument        The behavior is identical to current implementation. The effect is executed after each render cycle.    ### Two arguments      The behavior is identical to current implementation. The second argument conflates *whatDeps* and *whenDeps*.    ### Empty second argument        The behavior is identical to current implementation. The callback is executed only once.    ### Empty third argument        The callback is executed only once, regardless of the changes in *whatDeps*.    ### Three arguments        The callback is executed when and only when at least one variable in *whenDeps* array changes, regardless of the changes in *whatDeps*.",
        "human_words_regrex": "## Feature A new overloading for `useEffect` (Typescript syntax): ## Motivations In the current implementation, the second argument of `useEffect`, \u201cdeps\u201d, : > The array of values that the effect depends on. This definition does not account for an important nuance between two kind of dependencies: - *what* dependencies, those which require the effect callback to be ~*recomputed*~ *updated*; - *when* dependencies, those which require the effect callback to be ~*rerun*~ *executed*. The community seems to be in need of a solution, see  ## Use case I want to scroll to top of a component when the content changes (first dependency), but this effect also depends on a variable padding top (second dependency). With the current implementation of `useEffect`, this is what I would do: There is an undesired behavior: the hook is executed on `paddingTop` changes. Moreover, `content` is not, semantically, a dependency of the callback, but rather a dependency of *when this side effect should take place*. So I could use a ref, store the previous value of `paddingTop`, and compare the two. But that is cumbersome. **What I would like to do, is express the *when this side-effect should take place* dependencies declaratively:** ## Detailed behavior My understanding is that this proposal would not be a breaking change and is 100% retrocompatible with current implementation. ### One argument The behavior is identical to current implementation. The effect is executed after each render cycle. ### Two arguments The behavior is identical to current implementation. The second argument conflates *whatDeps* and *whenDeps*. ### Empty second argument The behavior is identical to current implementation. The callback is executed only once. ### Empty third argument The callback is executed only once, regardless of the changes in *whatDeps*. ### Three arguments The callback is executed when and only when at least one variable in *whenDeps* array changes, regardless of the changes in *whatDeps*.",
        "human_words_stopwords_removal_lemmatization": "# # feature new overloading ` useeffect ` ( typescript syntax ) : # # motivation current implementation , second argument ` useeffect ` , \u201c deps \u201d , : > array value effect depends . definition account important nuance two kind dependency : - * * dependency , require effect callback ~ * recomputed * ~ * updated * ; - * * dependency , require effect callback ~ * rerun * ~ * executed * . community seems need solution , see # # use case want scroll top component content change ( first dependency ) , effect also depends variable padding top ( second dependency ) . current implementation ` useeffect ` , would : undesired behavior : hook executed ` paddingtop ` change . moreover , ` content ` , semantically , dependency callback , rather dependency * side effect take place * . could use ref , store previous value ` paddingtop ` , compare two . cumbersome . * * would like , express * side-effect take place * dependency declaratively : * * # # detailed behavior understanding proposal would breaking change 100 % retrocompatible current implementation . # # # one argument behavior identical current implementation . effect executed render cycle . # # # two argument behavior identical current implementation . second argument conflates * whatdeps * * whendeps * . # # # empty second argument behavior identical current implementation . callback executed . # # # empty third argument callback executed , regardless change * whatdeps * . # # # three argument callback executed least one variable * whendeps * array change , regardless change * whatdeps * .",
        "title_stopwords_removal_lemmatization": "[ feature request ] : distinguish `` '' `` '' dependency useeffect"
    },
    {
        "issue_id": 685885294,
        "title": "Bug: React Dev Tools extension causing unused code warning in Lighthouse audit",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-08-25T22:52:33Z",
        "status": "closed",
        "description": "\r\nWhen auditing my portfolio made with Create-React-App with the Chrome Lighthouse performance tool, I was showing a large amount of unused code when doing the mobile audit coming from the React Dev Tools extension url. After disabling the extension, my performance score went from 77 to 98.  \r\n\r\n\r\nReact version: 16.13.1\r\n\r\nDev Tools version: 4.8.2\r\n\r\n## Steps To Reproduce\r\n\r\n1. Open a live website made with CRA\r\n2. Run Lighthouse with Device: Mobile selected\r\n\r\nNot so much a bug as an issue when performance auditing. I don't believe posting my code will be of benefit, but if so then I'm happy to link to my website github.\r\n",
        "remove_template_description": "When auditing my portfolio made with Create-React-App with the Chrome Lighthouse performance tool, I was showing a large amount of unused code when doing the mobile audit coming from the React Dev Tools extension url. After disabling the extension, my performance score went from 77 to 98.        React version: 16.13.1    Dev Tools version: 4.8.2        1. Open a live website made with CRA  2. Run Lighthouse with Device: Mobile selected    Not so much a bug as an issue when performance auditing. I don't believe posting my code will be of benefit, but if so then I'm happy to link to my website github.",
        "human_words": "When auditing my portfolio made with Create-React-App with the Chrome Lighthouse performance tool, I was showing a large amount of unused code when doing the mobile audit coming from the React Dev Tools extension url. After disabling the extension, my performance score went from 77 to 98.        React version: 16.13.1    Dev Tools version: 4.8.2        1. Open a live website made with CRA  2. Run Lighthouse with Device: Mobile selected    Not so much a bug as an issue when performance auditing. I don't believe posting my code will be of benefit, but if so then I'm happy to link to my website github.",
        "human_words_regrex": "When auditing my portfolio made with Create-React-App with the Chrome Lighthouse performance tool, I was showing a large amount of unused code when doing the mobile audit coming from the React Dev Tools extension url. After disabling the extension, my performance score went from 77 to 98. React version: 16.13.1 Dev Tools version: 4.8.2 1. Open a live website made with CRA 2. Run Lighthouse with Device: Mobile selected Not so much a bug as an issue when performance auditing. I don't believe posting my code will be of benefit, but if so then I'm happy to link to my website github.",
        "human_words_stopwords_removal_lemmatization": "auditing portfolio made create-react-app chrome lighthouse performance tool , showing large amount unused code mobile audit coming react dev tool extension url . disabling extension , performance score went 77 98. react version : 16.13.1 dev tool version : 4.8.2 1. open live website made cra 2. run lighthouse device : mobile selected much bug issue performance auditing . n't believe posting code benefit , 'm happy link website github .",
        "title_stopwords_removal_lemmatization": "bug : react dev tool extension causing unused code warning lighthouse audit"
    },
    {
        "issue_id": 683461914,
        "title": "Discussion: Async cleanups of useEffect",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-08-21T10:26:29Z",
        "status": "open",
        "description": "Hi \ud83d\udc4b \r\n\r\nI've been asking about this on Twitter but was told that the issues here might be better to discuss this stuff.\r\n\r\nMy general concern is that async cleanups might lead to weird race conditions. It may be unwarranted but the concept itself sounds quite alarming to me and I'd like to discuss this, if possible.\r\n\r\nIf you go with the async cleanups then there is no guarantee that a scheduled work (or just any listeners) would get cleaned up before you get rid of a component instance, so for example:\r\n```js\r\nuseEffect(() => {\r\n  if (state !== 'foo') return\r\n  const id = setTimeout(() => setShouldAnimate(true), 300)\r\n  return () => clearTimeout(id)\r\n}, [state])\r\n```\r\nThis might not work as intended. There is an off-chance that the scheduled timeout will fire after the containing component unmounts but before the timer gets disposed.\r\n\r\nCalling `setState` after unmounting was always a sign of broken assumptions in the code or some programming error and React has been warning about it. I was told though that this has been accounted for and the warning is being suppressed now - so it won't pop up for users if `setState` got called in that short timeframe. So at least that's OK.\r\n\r\nI'm worried though that a disposed component can still cause an unwanted side-effect in a parent. One can imagine some scenarios where that would matter.\r\n\r\n1. orchestrating animation - an unmounted component tells the parent to trigger some sort of animation. The reason why the animation should happen is owned by a child, but it's also based on an additional timer because the reason might become invalid if the user performs some invalidating action quickly enough. It's not obvious here that `useLayoutEffect` should be used here to achieve instant cleanup.\r\n2. similar case: orchestrating some in-product tour, triggering tooltips, arrows, whatever in the parent. It becomes even less apparent that this should be `useLayoutEffect`-based to achieve instant clean up as this is not related to layout, even remotely. This is business logic.\r\n\r\nI hope my concerns are not warranted and you could clear up them for me, but right now I'm worried a lot that this is such a small difference for most of the people and that's it's hard to spot in the code that this might become a source of many very subtle bugs. \r\n\r\ncc @gaearon @bvaughn ",
        "remove_template_description": "Hi \ud83d\udc4b     I've been asking about this on Twitter but was told that the issues here might be better to discuss this stuff.    My general concern is that async cleanups might lead to weird race conditions. It may be unwarranted but the concept itself sounds quite alarming to me and I'd like to discuss this, if possible.    If you go with the async cleanups then there is no guarantee that a scheduled work (or just any listeners) would get cleaned up before you get rid of a component instance, so for example:  ```js  useEffect(() => {    if (state !== 'foo') return    const id = setTimeout(() => setShouldAnimate(true), 300)    return () => clearTimeout(id)  }, [state])  ```  This might not work as intended. There is an off-chance that the scheduled timeout will fire after the containing component unmounts but before the timer gets disposed.    Calling `setState` after unmounting was always a sign of broken assumptions in the code or some programming error and React has been warning about it. I was told though that this has been accounted for and the warning is being suppressed now - so it won't pop up for users if `setState` got called in that short timeframe. So at least that's OK.    I'm worried though that a disposed component can still cause an unwanted side-effect in a parent. One can imagine some scenarios where that would matter.    1. orchestrating animation - an unmounted component tells the parent to trigger some sort of animation. The reason why the animation should happen is owned by a child, but it's also based on an additional timer because the reason might become invalid if the user performs some invalidating action quickly enough. It's not obvious here that `useLayoutEffect` should be used here to achieve instant cleanup.  2. similar case: orchestrating some in-product tour, triggering tooltips, arrows, whatever in the parent. It becomes even less apparent that this should be `useLayoutEffect`-based to achieve instant clean up as this is not related to layout, even remotely. This is business logic.    I hope my concerns are not warranted and you could clear up them for me, but right now I'm worried a lot that this is such a small difference for most of the people and that's it's hard to spot in the code that this might become a source of many very subtle bugs.     cc @gaearon @bvaughn",
        "human_words": "Hi \ud83d\udc4b     I've been asking about this on Twitter but was told that the issues here might be better to discuss this stuff.    My general concern is that async cleanups might lead to weird race conditions. It may be unwarranted but the concept itself sounds quite alarming to me and I'd like to discuss this, if possible.    If you go with the async cleanups then there is no guarantee that a scheduled work (or just any listeners) would get cleaned up before you get rid of a component instance, so for example:    This might not work as intended. There is an off-chance that the scheduled timeout will fire after the containing component unmounts but before the timer gets disposed.    Calling `setState` after unmounting was always a sign of broken assumptions in the code or some programming error and React has been warning about it. I was told though that this has been accounted for and the warning is being suppressed now - so it won't pop up for users if `setState` got called in that short timeframe. So at least that's OK.    I'm worried though that a disposed component can still cause an unwanted side-effect in a parent. One can imagine some scenarios where that would matter.    1. orchestrating animation - an unmounted component tells the parent to trigger some sort of animation. The reason why the animation should happen is owned by a child, but it's also based on an additional timer because the reason might become invalid if the user performs some invalidating action quickly enough. It's not obvious here that `useLayoutEffect` should be used here to achieve instant cleanup.  2. similar case: orchestrating some in-product tour, triggering tooltips, arrows, whatever in the parent. It becomes even less apparent that this should be `useLayoutEffect`-based to achieve instant clean up as this is not related to layout, even remotely. This is business logic.    I hope my concerns are not warranted and you could clear up them for me, but right now I'm worried a lot that this is such a small difference for most of the people and that's it's hard to spot in the code that this might become a source of many very subtle bugs.     cc @gaearon @bvaughn",
        "human_words_regrex": "Hi \ud83d\udc4b I've been asking about this on Twitter but was told that the issues here might be better to discuss this stuff. My general concern is that async cleanups might lead to weird race conditions. It may be unwarranted but the concept itself sounds quite alarming to me and I'd like to discuss this, if possible. If you go with the async cleanups then there is no guarantee that a scheduled work (or just any listeners) would get cleaned up before you get rid of a component instance, so for example: This might not work as intended. There is an off-chance that the scheduled timeout will fire after the containing component unmounts but before the timer gets disposed. Calling `setState` after unmounting was always a sign of broken assumptions in the code or some programming error and React has been warning about it. I was told though that this has been accounted for and the warning is being suppressed now - so it won't pop up for users if `setState` got called in that short timeframe. So at least that's OK. I'm worried though that a disposed component can still cause an unwanted side-effect in a parent. One can imagine some scenarios where that would matter. 1. orchestrating animation - an unmounted component tells the parent to trigger some sort of animation. The reason why the animation should happen is owned by a child, but it's also based on an additional timer because the reason might become invalid if the user performs some invalidating action quickly enough. It's not obvious here that `useLayoutEffect` should be used here to achieve instant cleanup. 2. similar case: orchestrating some in-product tour, triggering tooltips, arrows, whatever in the parent. It becomes even less apparent that this should be `useLayoutEffect`-based to achieve instant clean up as this is not related to layout, even remotely. This is business logic. I hope my concerns are not warranted and you could clear up them for me, but right now I'm worried a lot that this is such a small difference for most of the people and that's it's hard to spot in the code that this might become a source of many very subtle bugs. cc @gaearon @bvaughn",
        "human_words_stopwords_removal_lemmatization": "hi \ud83d\udc4b 've asking twitter told issue might better discus stuff . general concern async cleanup might lead weird race condition . may unwarranted concept sound quite alarming 'd like discus , possible . go async cleanup guarantee scheduled work ( listener ) would get cleaned get rid component instance , example : might work intended . off-chance scheduled timeout fire containing component unmounts timer get disposed . calling ` setstate ` unmounting always sign broken assumption code programming error react warning . told though accounted warning suppressed - wo n't pop user ` setstate ` got called short timeframe . least 's ok. 'm worried though disposed component still cause unwanted side-effect parent . one imagine scenario would matter . 1. orchestrating animation - unmounted component tell parent trigger sort animation . reason animation happen owned child , 's also based additional timer reason might become invalid user performs invalidating action quickly enough . 's obvious ` uselayouteffect ` used achieve instant cleanup . 2. similar case : orchestrating in-product tour , triggering tooltips , arrow , whatever parent . becomes even le apparent ` uselayouteffect ` -based achieve instant clean related layout , even remotely . business logic . hope concern warranted could clear , right 'm worried lot small difference people 's 's hard spot code might become source many subtle bug . cc @ gaearon @ bvaughn",
        "title_stopwords_removal_lemmatization": "discussion : async cleanup useeffect"
    },
    {
        "issue_id": 681891694,
        "title": "Touch/Wheel Event Passiveness in React 17",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-08-19T14:35:07Z",
        "status": "closed",
        "description": "Chrome did an [\"intervention\"](https://developers.google.com/web/updates/2017/01/scrolling-intervention) back in the day, breaking all React touch and wheel listeners which used `e.preventDefault()` (https://github.com/facebook/react/issues/14856) because React happened to attach them to the `document`.\r\n\r\nIn React 17, events are no longer attached to the `document`. This happens to \"undo\" Chrome's intervention (https://github.com/facebook/react/issues/6436#issuecomment-676135176). However, since this functionality is already broken in 16 and we haven't patched it up, it seems like this would just be a performance regression for the majority of cases.\r\n\r\nIt seems like we have a few options:\r\n\r\n- In the spirit of Chrome's \"fix\", keep touch listeners passive by default. `e.preventDefault()` is broken, just like it got broken in 16 by Chrome.\r\n  - In this case, it is still a pain point that React offers no native API to intentionally attach an active listener for the case where you *want* to use `e.preventDefault()`.\r\n- Do nothing, in which case Chrome's intervention would effectively be undone for React apps. There is an argument that Chrome itself only felt comfortable doing it for the `document` level and not individual elements \u2014 and conceptually React users *were* putting their handlers on individual elements. Delegation is just an implementation detail.\r\n- Not use delegation for touch/wheel listeners at all (?)\r\n\r\nFiling this to be resolved before 17 final.",
        "remove_template_description": "Chrome did an [\"intervention\"](https://developers.google.com/web/updates/2017/01/scrolling-intervention) back in the day, breaking all React touch and wheel listeners which used `e.preventDefault()` (https://github.com/facebook/react/issues/14856) because React happened to attach them to the `document`.    In React 17, events are no longer attached to the `document`. This happens to \"undo\" Chrome's intervention (https://github.com/facebook/react/issues/6436#issuecomment-676135176). However, since this functionality is already broken in 16 and we haven't patched it up, it seems like this would just be a performance regression for the majority of cases.    It seems like we have a few options:    - In the spirit of Chrome's \"fix\", keep touch listeners passive by default. `e.preventDefault()` is broken, just like it got broken in 16 by Chrome.    - In this case, it is still a pain point that React offers no native API to intentionally attach an active listener for the case where you *want* to use `e.preventDefault()`.  - Do nothing, in which case Chrome's intervention would effectively be undone for React apps. There is an argument that Chrome itself only felt comfortable doing it for the `document` level and not individual elements \u2014 and conceptually React users *were* putting their handlers on individual elements. Delegation is just an implementation detail.  - Not use delegation for touch/wheel listeners at all (?)    Filing this to be resolved before 17 final.",
        "human_words": "Chrome did an [\"intervention\"](https://developers.google.com/web/updates/2017/01/scrolling-intervention) back in the day, breaking all React touch and wheel listeners which used `e.preventDefault()` (https://github.com/facebook/react/issues/14856) because React happened to attach them to the `document`.    In React 17, events are no longer attached to the `document`. This happens to \"undo\" Chrome's intervention (https://github.com/facebook/react/issues/6436#issuecomment-676135176). However, since this functionality is already broken in 16 and we haven't patched it up, it seems like this would just be a performance regression for the majority of cases.    It seems like we have a few options:    - In the spirit of Chrome's \"fix\", keep touch listeners passive by default. `e.preventDefault()` is broken, just like it got broken in 16 by Chrome.    - In this case, it is still a pain point that React offers no native API to intentionally attach an active listener for the case where you *want* to use `e.preventDefault()`.  - Do nothing, in which case Chrome's intervention would effectively be undone for React apps. There is an argument that Chrome itself only felt comfortable doing it for the `document` level and not individual elements \u2014 and conceptually React users *were* putting their handlers on individual elements. Delegation is just an implementation detail.  - Not use delegation for touch/wheel listeners at all (?)    Filing this to be resolved before 17 final.",
        "human_words_regrex": "Chrome did an  back in the day, breaking all React touch and wheel listeners which used `e.preventDefault()` ( because React happened to attach them to the `document`. In React 17, events are no longer attached to the `document`. This happens to \"undo\" Chrome's intervention ( However, since this functionality is already broken in 16 and we haven't patched it up, it seems like this would just be a performance regression for the majority of cases. It seems like we have a few options: - In the spirit of Chrome's \"fix\", keep touch listeners passive by default. `e.preventDefault()` is broken, just like it got broken in 16 by Chrome. - In this case, it is still a pain point that React offers no native API to intentionally attach an active listener for the case where you *want* to use `e.preventDefault()`. - Do nothing, in which case Chrome's intervention would effectively be undone for React apps. There is an argument that Chrome itself only felt comfortable doing it for the `document` level and not individual elements \u2014 and conceptually React users *were* putting their handlers on individual elements. Delegation is just an implementation detail. - Not use delegation for touch/wheel listeners at all (?) Filing this to be resolved before 17 final.",
        "human_words_stopwords_removal_lemmatization": "chrome back day , breaking react touch wheel listener used ` e.preventdefault ( ) ` ( react happened attach ` document ` . react 17 , event longer attached ` document ` . happens `` undo '' chrome 's intervention ( however , since functionality already broken 16 n't patched , seems like would performance regression majority case . seems like option : - spirit chrome 's `` fix '' , keep touch listener passive default . ` e.preventdefault ( ) ` broken , like got broken 16 chrome . - case , still pain point react offer native api intentionally attach active listener case * want * use ` e.preventdefault ( ) ` . - nothing , case chrome 's intervention would effectively undone react apps . argument chrome felt comfortable ` document ` level individual element \u2014 conceptually react user * * putting handler individual element . delegation implementation detail . - use delegation touch/wheel listener ( ? ) filing resolved 17 final .",
        "title_stopwords_removal_lemmatization": "touch/wheel event passiveness react 17"
    },
    {
        "issue_id": 680994677,
        "title": "Portal Event Bubbling Use Cases",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-08-18T12:16:29Z",
        "status": "open",
        "description": "This is a spillover from https://github.com/facebook/react/issues/11387.\r\n\r\nThe goal of this issue is **not** to argue about whether the current React's behavior makes sense in all situations. Rather, it is **collect a list of use cases, both when the current behavior works well, and when it doesn't**, so that they can inform the next iteration of the related APIs. We can't commit to any concrete timeframe on this at the moment, but a list like this will definitely reduce the amount of time that we'd need to spend to get up to speed on the problem space when we're ready to approach it.\r\n\r\nIf you'd like to contribute a use case, please comment with:\r\n\r\n- A name for your pattern (come up with something unique so we can refer to it later)\r\n- A brief description of the UI (but a screenshot is worth a thousand words)\r\n- A small CodeSandbox demo, if you want to make a stronger case\r\n- How React event bubbling behavior breaks (or helps) your case\r\n  - Include any information about other pitfalls you encountered, be very specific\r\n- A workaround you are currently using, if any\r\n  - If you tried some workarounds but they cause issues, let us know which ones\r\n\r\nPlease keep this thread on topic and let's keep general discussion in https://github.com/facebook/react/issues/11387. This is not a good thread for \"+1\" or requests to solve this faster \u2014 it's a thread for gathering research.\r\n\r\nThank you!",
        "remove_template_description": "This is a spillover from https://github.com/facebook/react/issues/11387.    The goal of this issue is **not** to argue about whether the current React's behavior makes sense in all situations. Rather, it is **collect a list of use cases, both when the current behavior works well, and when it doesn't**, so that they can inform the next iteration of the related APIs. We can't commit to any concrete timeframe on this at the moment, but a list like this will definitely reduce the amount of time that we'd need to spend to get up to speed on the problem space when we're ready to approach it.    If you'd like to contribute a use case, please comment with:    - A name for your pattern (come up with something unique so we can refer to it later)  - A brief description of the UI (but a screenshot is worth a thousand words)  - A small CodeSandbox demo, if you want to make a stronger case  - How React event bubbling behavior breaks (or helps) your case    - Include any information about other pitfalls you encountered, be very specific  - A workaround you are currently using, if any    - If you tried some workarounds but they cause issues, let us know which ones    Please keep this thread on topic and let's keep general discussion in https://github.com/facebook/react/issues/11387. This is not a good thread for \"+1\" or requests to solve this faster \u2014 it's a thread for gathering research.    Thank you!",
        "human_words": "This is a spillover from https://github.com/facebook/react/issues/11387.    The goal of this issue is **not** to argue about whether the current React's behavior makes sense in all situations. Rather, it is **collect a list of use cases, both when the current behavior works well, and when it doesn't**, so that they can inform the next iteration of the related APIs. We can't commit to any concrete timeframe on this at the moment, but a list like this will definitely reduce the amount of time that we'd need to spend to get up to speed on the problem space when we're ready to approach it.    If you'd like to contribute a use case, please comment with:    - A name for your pattern (come up with something unique so we can refer to it later)  - A brief description of the UI (but a screenshot is worth a thousand words)  - A small CodeSandbox demo, if you want to make a stronger case  - How React event bubbling behavior breaks (or helps) your case    - Include any information about other pitfalls you encountered, be very specific  - A workaround you are currently using, if any    - If you tried some workarounds but they cause issues, let us know which ones    Please keep this thread on topic and let's keep general discussion in https://github.com/facebook/react/issues/11387. This is not a good thread for \"+1\" or requests to solve this faster \u2014 it's a thread for gathering research.    Thank you!",
        "human_words_regrex": "This is a spillover from  The goal of this issue is **not** to argue about whether the current React's behavior makes sense in all situations. Rather, it is **collect a list of use cases, both when the current behavior works well, and when it doesn't**, so that they can inform the next iteration of the related APIs. We can't commit to any concrete timeframe on this at the moment, but a list like this will definitely reduce the amount of time that we'd need to spend to get up to speed on the problem space when we're ready to approach it. If you'd like to contribute a use case, please comment with: - A name for your pattern (come up with something unique so we can refer to it later) - A brief description of the UI (but a screenshot is worth a thousand words) - A small CodeSandbox demo, if you want to make a stronger case - How React event bubbling behavior breaks (or helps) your case - Include any information about other pitfalls you encountered, be very specific - A workaround you are currently using, if any - If you tried some workarounds but they cause issues, let us know which ones Please keep this thread on topic and let's keep general discussion in  This is not a good thread for \"+1\" or requests to solve this faster \u2014 it's a thread for gathering research. Thank you!",
        "human_words_stopwords_removal_lemmatization": "spillover goal issue * * * * argue whether current react 's behavior make sense situation . rather , * * collect list use case , current behavior work well , n't * * , inform next iteration related apis . ca n't commit concrete timeframe moment , list like definitely reduce amount time 'd need spend get speed problem space 're ready approach . 'd like contribute use case , please comment : - name pattern ( come something unique refer later ) - brief description ui ( screenshot worth thousand word ) - small codesandbox demo , want make stronger case - react event bubbling behavior break ( help ) case - include information pitfall encountered , specific - workaround currently using , - tried workarounds cause issue , let u know one please keep thread topic let 's keep general discussion good thread `` +1 '' request solve faster \u2014 's thread gathering research . thank !",
        "title_stopwords_removal_lemmatization": "portal event bubbling use case"
    },
    {
        "issue_id": 678976321,
        "title": "Bug: click event is attached to createPortal",
        "label": [
            "Component: DOM",
            "Resolution: Needs More Information",
            "Type: Discussion"
        ],
        "date": "2020-08-14T07:57:01Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version:\r\n16.13.1\r\n\r\n## Steps To Reproduce\r\n\r\nuse createPortal will have click event attached to the DOM element automatically\r\n\r\n```\r\nimport { createPortal } from \"react-dom\";\r\n\r\nconst Modal = ({ children, onClose, open }) =>\r\n  open &&\r\n  createPortal(\r\n    <div />,\r\n    document.getElementById(\"modal\")\r\n  );\r\n```\r\n\r\nthis snippet will add click event attached to the element with id = modal\r\nplease open chrome dev tool to check\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example:\r\nhttps://codesandbox.io/s/vibrant-kowalevski-7ginb?file=/src/App.js\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\n\r\n## The current behavior\r\nclick event is added on the element\r\n\r\n## The expected behavior\r\nclick event should not be added\r\n\r\n\r\n## EDIT\r\n------------------------------------------------------------\r\n```\r\ncreatePortal(\r\n    <h1>This is heading</h1>,\r\n    document.getElementById(\"modal\")\r\n  );\r\n```\r\nThe header is read by **jaws** (not sure about nvda) as\r\n**this is heading, heading level one, clickable**",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:  16.13.1        use createPortal will have click event attached to the DOM element automatically    ```  import { createPortal } from \"react-dom\";    const Modal = ({ children, onClose, open }) =>    open &&    createPortal(      <div />,      document.getElementById(\"modal\")    );  ```    this snippet will add click event attached to the element with id = modal  please open chrome dev tool to check    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:  https://codesandbox.io/s/vibrant-kowalevski-7ginb?file=/src/App.js  <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      click event is added on the element      click event should not be added      ## EDIT  ------------------------------------------------------------  ```  createPortal(      <h1>This is heading</h1>,      document.getElementById(\"modal\")    );  ```  The header is read by **jaws** (not sure about nvda) as  **this is heading, heading level one, clickable**",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version:  16.13.1        use createPortal will have click event attached to the DOM element automatically        this snippet will add click event attached to the element with id = modal  please open chrome dev tool to check    <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:  https://codesandbox.io/s/vibrant-kowalevski-7ginb?file=/src/App.js  <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->      click event is added on the element      click event should not be added      ## EDIT  ------------------------------------------------------------    The header is read by **jaws** (not sure about nvda) as  **this is heading, heading level one, clickable**",
        "human_words_regrex": " React version: 16.13.1 use createPortal will have click event attached to the DOM element automatically this snippet will add click event attached to the element with id = modal please open chrome dev tool to check  Link to code example:   click event is added on the element click event should not be added ## EDIT ------------------------------------------------------------ The header is read by **jaws** (not sure about nvda) as **this is heading, heading level one, clickable**",
        "human_words_stopwords_removal_lemmatization": "react version : 16.13.1 use createportal click event attached dom element automatically snippet add click event attached element id = modal please open chrome dev tool check link code example : click event added element click event added # # edit -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- header read * * jaw * * ( sure nvda ) * * heading , heading level one , clickable * *",
        "title_stopwords_removal_lemmatization": "bug : click event attached createportal"
    },
    {
        "issue_id": 673607767,
        "title": "Bug: Overwriting console.log during rendering",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-08-05T15:00:00Z",
        "status": "closed",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version: latest\r\n\r\n## Steps To Reproduce\r\n\r\n```jsx\r\nfunction App() {\r\n  return <h1 onClick={console.log}>h1</h1>;\r\n  // console.log is replaced by \"disableLog\" so I can't log any event.\r\n  return <h1 onClick={x => console.log(x)}>h1</h1>;\r\n  // have to do this\r\n}\r\n```\r\n\r\nPrevious discussion at https://github.com/facebook/react/pull/15894#issuecomment-668542243\r\n",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: latest        ```jsx  function App() {    return <h1 onClick={console.log}>h1</h1>;    // console.log is replaced by \"disableLog\" so I can't log any event.    return <h1 onClick={x => console.log(x)}>h1</h1>;    // have to do this  }  ```    Previous discussion at https://github.com/facebook/react/pull/15894#issuecomment-668542243",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: latest            Previous discussion at https://github.com/facebook/react/pull/15894#issuecomment-668542243",
        "human_words_regrex": " React version: latest Previous discussion at ",
        "human_words_stopwords_removal_lemmatization": "react version : latest previous discussion",
        "title_stopwords_removal_lemmatization": "bug : overwriting console.log rendering"
    },
    {
        "issue_id": 663218543,
        "title": "React DevTools: Display whether render was unnecessary",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-07-21T18:24:27Z",
        "status": "closed",
        "description": "It would be nice if the React DevTools gave some indication that the render didn't result in a commit or side effect callback and was therefore unnecessary. It's possible that I'm missing something on the nuance here that makes this more challenging than practical.",
        "remove_template_description": "It would be nice if the React DevTools gave some indication that the render didn't result in a commit or side effect callback and was therefore unnecessary. It's possible that I'm missing something on the nuance here that makes this more challenging than practical.",
        "human_words": "It would be nice if the React DevTools gave some indication that the render didn't result in a commit or side effect callback and was therefore unnecessary. It's possible that I'm missing something on the nuance here that makes this more challenging than practical.",
        "human_words_regrex": "It would be nice if the React DevTools gave some indication that the render didn't result in a commit or side effect callback and was therefore unnecessary. It's possible that I'm missing something on the nuance here that makes this more challenging than practical.",
        "human_words_stopwords_removal_lemmatization": "would nice react devtools gave indication render n't result commit side effect callback therefore unnecessary . 's possible 'm missing something nuance make challenging practical .",
        "title_stopwords_removal_lemmatization": "react devtools : display whether render unnecessary"
    },
    {
        "issue_id": 661787098,
        "title": "Should act() warnings be deduplicated by component stack?",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2020-07-20T12:52:06Z",
        "status": "open",
        "description": "React version: `16.13.1` (latest) and `0.0.0-7f28234f8` (next)\r\n\r\n## Steps To Reproduce\r\n\r\n1. Create component that has multiple effects (i.e. `useEffect` calls)\r\n2. Render component in a jest test\r\n\r\n\r\nLink to code example: https://codesandbox.io/s/long-sound-xhe5w?file=/package.json\r\n\r\n## The current behavior\r\n\r\nA error is logged for each call of `useEffect`.\r\n\r\n## The expected behavior\r\n\r\nAn error per component calling `useEffect`.\r\n\r\n## Context\r\n\r\nCurrent errror:\r\n```\r\nWarning: An update to Component ran an effect, but was not wrapped in act(...).\r\n\r\nWhen testing, code that causes React state updates should be wrapped into act(...):\r\n\r\nact(() => {\r\n  /* fire events that update state */\r\n});\r\n/* assert on the output */\r\n\r\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act\r\n    at Component (https://xhe5w.csb.app/src/index.test.js:23:20)\r\n    at App (https://xhe5w.csb.app/src/index.test.js:35:20)\r\n```\r\n\r\nThe prescription is to wrap the update in act(). The warning may be unintented because a component with an effect rendered unexpectedly. But due to the rules of hooks it's unlikely that we remove a `useEffect` call: It's easier to prevent rendering a component (wrong branch logic, return early etc) than preventing an effect (which requires moving it to a component we render conditionally).\r\n\r\nFrom my experience most of these cases come down to adding an `act()` and not changing component implementation. In these cases firing errors for each effect makes the console output unreadable. Especially if you compose custom hooks and end up with 4+ effects per component.\r\n\r\nAn alternate solution would be to only fire an error if the effect was actually scheduled (see #19318).\r\n",
        "remove_template_description": "React version: `16.13.1` (latest) and `0.0.0-7f28234f8` (next)        1. Create component that has multiple effects (i.e. `useEffect` calls)  2. Render component in a jest test      Link to code example: https://codesandbox.io/s/long-sound-xhe5w?file=/package.json        A error is logged for each call of `useEffect`.        An error per component calling `useEffect`.    ## Context    Current errror:  ```  Warning: An update to Component ran an effect, but was not wrapped in act(...).    When testing, code that causes React state updates should be wrapped into act(...):    act(() => {    /* fire events that update state */  });  /* assert on the output */    This ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act      at Component (https://xhe5w.csb.app/src/index.test.js:23:20)      at App (https://xhe5w.csb.app/src/index.test.js:35:20)  ```    The prescription is to wrap the update in act(). The warning may be unintented because a component with an effect rendered unexpectedly. But due to the rules of hooks it's unlikely that we remove a `useEffect` call: It's easier to prevent rendering a component (wrong branch logic, return early etc) than preventing an effect (which requires moving it to a component we render conditionally).    From my experience most of these cases come down to adding an `act()` and not changing component implementation. In these cases firing errors for each effect makes the console output unreadable. Especially if you compose custom hooks and end up with 4+ effects per component.    An alternate solution would be to only fire an error if the effect was actually scheduled (see #19318).",
        "human_words": "React version: `16.13.1` (latest) and `0.0.0-7f28234f8` (next)        1. Create component that has multiple effects (i.e. `useEffect` calls)  2. Render component in a jest test      Link to code example: https://codesandbox.io/s/long-sound-xhe5w?file=/package.json        A error is logged for each call of `useEffect`.        An error per component calling `useEffect`.    ## Context    Current errror:      The prescription is to wrap the update in act(). The warning may be unintented because a component with an effect rendered unexpectedly. But due to the rules of hooks it's unlikely that we remove a `useEffect` call: It's easier to prevent rendering a component (wrong branch logic, return early etc) than preventing an effect (which requires moving it to a component we render conditionally).    From my experience most of these cases come down to adding an `act()` and not changing component implementation. In these cases firing errors for each effect makes the console output unreadable. Especially if you compose custom hooks and end up with 4+ effects per component.    An alternate solution would be to only fire an error if the effect was actually scheduled (see #19318).",
        "human_words_regrex": "React version: `16.13.1` (latest) and `0.0.0-7f28234f8` (next) 1. Create component that has multiple effects (i.e. `useEffect` calls) 2. Render component in a jest test Link to code example:  A error is logged for each call of `useEffect`. An error per component calling `useEffect`. ## Context Current errror: The prescription is to wrap the update in act(). The warning may be unintented because a component with an effect rendered unexpectedly. But due to the rules of hooks it's unlikely that we remove a `useEffect` call: It's easier to prevent rendering a component (wrong branch logic, return early etc) than preventing an effect (which requires moving it to a component we render conditionally). From my experience most of these cases come down to adding an `act()` and not changing component implementation. In these cases firing errors for each effect makes the console output unreadable. Especially if you compose custom hooks and end up with 4+ effects per component. An alternate solution would be to only fire an error if the effect was actually scheduled (see #19318).",
        "human_words_stopwords_removal_lemmatization": "react version : ` 16.13.1 ` ( latest ) ` 0.0.0-7f28234f8 ` ( next ) 1. create component multiple effect ( i.e . ` useeffect ` call ) 2. render component jest test link code example : error logged call ` useeffect ` . error per component calling ` useeffect ` . # # context current errror : prescription wrap update act ( ) . warning may unintented component effect rendered unexpectedly . due rule hook 's unlikely remove ` useeffect ` call : 's easier prevent rendering component ( wrong branch logic , return early etc ) preventing effect ( requires moving component render conditionally ) . experience case come adding ` act ( ) ` changing component implementation . case firing error effect make console output unreadable . especially compose custom hook end 4+ effect per component . alternate solution would fire error effect actually scheduled ( see # 19318 ) .",
        "title_stopwords_removal_lemmatization": "act ( ) warning deduplicated component stack ?"
    },
    {
        "issue_id": 655203184,
        "title": "Bug: act warning misleading if an effect wasn't run",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2020-07-11T12:51:11Z",
        "status": "closed",
        "description": "\r\nReact version: 16.13.1 and `next`\r\n\r\n## Steps To Reproduce\r\n\r\n1. Re-render a component where an effect wasn't run because dependencies didn't change\r\n2. Receive missing act warning\r\n\r\n\r\nLink to code example: https://codesandbox.io/s/missing-act-on-every-effect-ldy3b?file=/src/index.test.js\r\n\r\n## The current behavior\r\n\r\nReact creates warnings for each call of React.useEffect regardless of whether an effect was actually scheduled i.e. the effect was run.\r\n\r\n## The expected behavior\r\n\r\nIf it is impossible for an effect to be run I shouldn't have to wrap it in act. Changing the behavior would help identifying what effects were unexpectedly scheduled. Right now we receive warnings for effects that are unrelated to a specific update.\r\n\r\nI consider the current warning misleading and unnecessary because the [documentation](https://reactjs.org/docs/testing-recipes.html#act) talks about \"all updates related to these \u201cunits\u201d\" which is not the case here in my opinion. The act warning says \"When testing, code that causes React state updates should be wrapped into act(...):\" which also doesn't apply here: The code in question could not cause a state update from an effect.\r\n",
        "remove_template_description": "React version: 16.13.1 and `next`        1. Re-render a component where an effect wasn't run because dependencies didn't change  2. Receive missing act warning      Link to code example: https://codesandbox.io/s/missing-act-on-every-effect-ldy3b?file=/src/index.test.js        React creates warnings for each call of React.useEffect regardless of whether an effect was actually scheduled i.e. the effect was run.        If it is impossible for an effect to be run I shouldn't have to wrap it in act. Changing the behavior would help identifying what effects were unexpectedly scheduled. Right now we receive warnings for effects that are unrelated to a specific update.    I consider the current warning misleading and unnecessary because the [documentation](https://reactjs.org/docs/testing-recipes.html#act) talks about \"all updates related to these \u201cunits\u201d\" which is not the case here in my opinion. The act warning says \"When testing, code that causes React state updates should be wrapped into act(...):\" which also doesn't apply here: The code in question could not cause a state update from an effect.",
        "human_words": "React version: 16.13.1 and `next`        1. Re-render a component where an effect wasn't run because dependencies didn't change  2. Receive missing act warning      Link to code example: https://codesandbox.io/s/missing-act-on-every-effect-ldy3b?file=/src/index.test.js        React creates warnings for each call of React.useEffect regardless of whether an effect was actually scheduled i.e. the effect was run.        If it is impossible for an effect to be run I shouldn't have to wrap it in act. Changing the behavior would help identifying what effects were unexpectedly scheduled. Right now we receive warnings for effects that are unrelated to a specific update.    I consider the current warning misleading and unnecessary because the [documentation](https://reactjs.org/docs/testing-recipes.html#act) talks about \"all updates related to these \u201cunits\u201d\" which is not the case here in my opinion. The act warning says \"When testing, code that causes React state updates should be wrapped into act(...):\" which also doesn't apply here: The code in question could not cause a state update from an effect.",
        "human_words_regrex": "React version: 16.13.1 and `next` 1. Re-render a component where an effect wasn't run because dependencies didn't change 2. Receive missing act warning Link to code example:  React creates warnings for each call of React.useEffect regardless of whether an effect was actually scheduled i.e. the effect was run. If it is impossible for an effect to be run I shouldn't have to wrap it in act. Changing the behavior would help identifying what effects were unexpectedly scheduled. Right now we receive warnings for effects that are unrelated to a specific update. I consider the current warning misleading and unnecessary because the  talks about \"all updates related to these \u201cunits\u201d\" which is not the case here in my opinion. The act warning says \"When testing, code that causes React state updates should be wrapped into act(...):\" which also doesn't apply here: The code in question could not cause a state update from an effect.",
        "human_words_stopwords_removal_lemmatization": "react version : 16.13.1 ` next ` 1. re-render component effect n't run dependency n't change 2. receive missing act warning link code example : react creates warning call react.useeffect regardless whether effect actually scheduled i.e . effect run . impossible effect run n't wrap act . changing behavior would help identifying effect unexpectedly scheduled . right receive warning effect unrelated specific update . consider current warning misleading unnecessary talk `` update related \u201c unit \u201d '' case opinion . act warning say `` testing , code cause react state update wrapped act ( ... ) : '' also n't apply : code question could cause state update effect .",
        "title_stopwords_removal_lemmatization": "bug : act warning misleading effect n't run"
    },
    {
        "issue_id": 648258250,
        "title": "Profiler dev tools suggestion: in \"ranked\" view, add a way to group/aggregate component instances",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-06-30T15:10:54Z",
        "status": "open",
        "description": "(Deleted template as this is a suggestion, not a bug.)\r\n\r\nIn the profiler's \"ranked\" view, when there are many instances of a single component, there's no way to answer the question \"how much time did this component spend rendering _across all instances_.\r\n\r\nFor example, here I have a component called `PhotoLink` which is used in many places across the tree. The \"ranked\" view shows us that each render is very cheap, but it does not tell us the aggregate cost of this component.\r\n\r\nPerhaps we could add something to dev tools to group/aggregate component instances?\r\n\r\n![image](https://user-images.githubusercontent.com/921609/86143237-170d0980-baec-11ea-891e-636bbe73d3f5.png)\r\n",
        "remove_template_description": "(Deleted template as this is a suggestion, not a bug.)    In the profiler's \"ranked\" view, when there are many instances of a single component, there's no way to answer the question \"how much time did this component spend rendering _across all instances_.    For example, here I have a component called `PhotoLink` which is used in many places across the tree. The \"ranked\" view shows us that each render is very cheap, but it does not tell us the aggregate cost of this component.    Perhaps we could add something to dev tools to group/aggregate component instances?    ![image](https://user-images.githubusercontent.com/921609/86143237-170d0980-baec-11ea-891e-636bbe73d3f5.png)",
        "human_words": "(Deleted template as this is a suggestion, not a bug.)    In the profiler's \"ranked\" view, when there are many instances of a single component, there's no way to answer the question \"how much time did this component spend rendering _across all instances_.    For example, here I have a component called `PhotoLink` which is used in many places across the tree. The \"ranked\" view shows us that each render is very cheap, but it does not tell us the aggregate cost of this component.    Perhaps we could add something to dev tools to group/aggregate component instances?    ![image](https://user-images.githubusercontent.com/921609/86143237-170d0980-baec-11ea-891e-636bbe73d3f5.png)",
        "human_words_regrex": "(Deleted template as this is a suggestion, not a bug.) In the profiler's \"ranked\" view, when there are many instances of a single component, there's no way to answer the question \"how much time did this component spend rendering _across all instances_. For example, here I have a component called `PhotoLink` which is used in many places across the tree. The \"ranked\" view shows us that each render is very cheap, but it does not tell us the aggregate cost of this component. Perhaps we could add something to dev tools to group/aggregate component instances? !",
        "human_words_stopwords_removal_lemmatization": "( deleted template suggestion , bug . ) profiler 's `` ranked '' view , many instance single component , 's way answer question `` much time component spend rendering _across instances_ . example , component called ` photolink ` used many place across tree . `` ranked '' view show u render cheap , tell u aggregate cost component . perhaps could add something dev tool group/aggregate component instance ? !",
        "title_stopwords_removal_lemmatization": "profiler dev tool suggestion : `` ranked '' view , add way group/aggregate component instance"
    },
    {
        "issue_id": 648174199,
        "title": "Feature proposal(eslint-react-hooks): don't require empty dependency useCallback in another dependency array",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2020-06-30T13:27:19Z",
        "status": "closed",
        "description": "Consider the following:\r\n\r\n```js\r\n  const [mouseDown, setMouseDown] = useState(false);\r\n  const onMouseDown = useCallback(() => { \r\n    setMouseDown(true);\r\n  }, []);\r\n  const onMouseMove = useCallback(e => { /* ... */ }, []);\r\n  const onMouseUp = useCallback(() => {\r\n    setMouseDown(false);\r\n  }, []);\r\n  useEffect(() => {\r\n    if (mouseDown) {\r\n      document.addEventListener('mousemove', onMouseMove);\r\n      document.addEventListener('mouseup', onMouseUp);\r\n      return () => {\r\n        document.removeEventListener('mousemove', onMouseMove);\r\n        document.removeEventListener('mouseup', onMouseUp);\r\n      }\r\n    }\r\n  }, [mouseDown]);\r\n```\r\n\r\nAbove the `useEffect()` will complain that it didn't receive `onMouseMove` and `onMouseUp` in its dependency array and it's correct. But it could be smarter, because they were all defined by `useCallback(() => {}, [])` meaning they will all remain the same value throughout the lifetime of this component.\r\n\r\nGiven this information I could write \r\n```js\r\n  useEffect(() => {\r\n    if (mouseDown) {\r\n      document.addEventListener('mousemove', onMouseMove);\r\n      document.addEventListener('mouseup', onMouseUp);\r\n      return () => {\r\n        document.removeEventListener('mousemove', onMouseMove);\r\n        document.removeEventListener('mouseup', onMouseUp);\r\n      }\r\n    }\r\n  }, [mouseDown, onMouseMove, onMouseUp]);\r\n```\r\nTo satisfy the linter and that would work but only because I know they were defined by `useCallback(() => {}, [])`. If someone were to change the dependency array for `onMouseMove` or `onMouseUp` this would now break (the event listeners won't be removed and readded if `onMouseMove` changes for instance), but the linter will be happy.\r\n\r\nHowever if I was able to specify it like I did in the first example it is the same as saying, this works as long as these specific variables don't change, if someone unwittingly changes the dependency array of `onMouseMove` the linter would shout at them again and they would have to rewrite this into something more flexible.\r\n\r\nThis is similar to the way `useCallback` doesn't complain about my usage of `setMouseDown` as it knows it can't change.",
        "remove_template_description": "Consider the following:    ```js    const [mouseDown, setMouseDown] = useState(false);    const onMouseDown = useCallback(() => {       setMouseDown(true);    }, []);    const onMouseMove = useCallback(e => { /* ... */ }, []);    const onMouseUp = useCallback(() => {      setMouseDown(false);    }, []);    useEffect(() => {      if (mouseDown) {        document.addEventListener('mousemove', onMouseMove);        document.addEventListener('mouseup', onMouseUp);        return () => {          document.removeEventListener('mousemove', onMouseMove);          document.removeEventListener('mouseup', onMouseUp);        }      }    }, [mouseDown]);  ```    Above the `useEffect()` will complain that it didn't receive `onMouseMove` and `onMouseUp` in its dependency array and it's correct. But it could be smarter, because they were all defined by `useCallback(() => {}, [])` meaning they will all remain the same value throughout the lifetime of this component.    Given this information I could write   ```js    useEffect(() => {      if (mouseDown) {        document.addEventListener('mousemove', onMouseMove);        document.addEventListener('mouseup', onMouseUp);        return () => {          document.removeEventListener('mousemove', onMouseMove);          document.removeEventListener('mouseup', onMouseUp);        }      }    }, [mouseDown, onMouseMove, onMouseUp]);  ```  To satisfy the linter and that would work but only because I know they were defined by `useCallback(() => {}, [])`. If someone were to change the dependency array for `onMouseMove` or `onMouseUp` this would now break (the event listeners won't be removed and readded if `onMouseMove` changes for instance), but the linter will be happy.    However if I was able to specify it like I did in the first example it is the same as saying, this works as long as these specific variables don't change, if someone unwittingly changes the dependency array of `onMouseMove` the linter would shout at them again and they would have to rewrite this into something more flexible.    This is similar to the way `useCallback` doesn't complain about my usage of `setMouseDown` as it knows it can't change.",
        "human_words": "Consider the following:        Above the `useEffect()` will complain that it didn't receive `onMouseMove` and `onMouseUp` in its dependency array and it's correct. But it could be smarter, because they were all defined by `useCallback(() => {}, [])` meaning they will all remain the same value throughout the lifetime of this component.    Given this information I could write     To satisfy the linter and that would work but only because I know they were defined by `useCallback(() => {}, [])`. If someone were to change the dependency array for `onMouseMove` or `onMouseUp` this would now break (the event listeners won't be removed and readded if `onMouseMove` changes for instance), but the linter will be happy.    However if I was able to specify it like I did in the first example it is the same as saying, this works as long as these specific variables don't change, if someone unwittingly changes the dependency array of `onMouseMove` the linter would shout at them again and they would have to rewrite this into something more flexible.    This is similar to the way `useCallback` doesn't complain about my usage of `setMouseDown` as it knows it can't change.",
        "human_words_regrex": "Consider the following: Above the `useEffect()` will complain that it didn't receive `onMouseMove` and `onMouseUp` in its dependency array and it's correct. But it could be smarter, because they were all defined by `useCallback(() => {}, [])` meaning they will all remain the same value throughout the lifetime of this component. Given this information I could write To satisfy the linter and that would work but only because I know they were defined by `useCallback(() => {}, [])`. If someone were to change the dependency array for `onMouseMove` or `onMouseUp` this would now break (the event listeners won't be removed and readded if `onMouseMove` changes for instance), but the linter will be happy. However if I was able to specify it like I did in the first example it is the same as saying, this works as long as these specific variables don't change, if someone unwittingly changes the dependency array of `onMouseMove` the linter would shout at them again and they would have to rewrite this into something more flexible. This is similar to the way `useCallback` doesn't complain about my usage of `setMouseDown` as it knows it can't change.",
        "human_words_stopwords_removal_lemmatization": "consider following : ` useeffect ( ) ` complain n't receive ` onmousemove ` ` onmouseup ` dependency array 's correct . could smarter , defined ` usecallback ( ( ) = > { } , [ ] ) ` meaning remain value throughout lifetime component . given information could write satisfy linter would work know defined ` usecallback ( ( ) = > { } , [ ] ) ` . someone change dependency array ` onmousemove ` ` onmouseup ` would break ( event listener wo n't removed readded ` onmousemove ` change instance ) , linter happy . however able specify like first example saying , work long specific variable n't change , someone unwittingly change dependency array ` onmousemove ` linter would shout would rewrite something flexible . similar way ` usecallback ` n't complain usage ` setmousedown ` know ca n't change .",
        "title_stopwords_removal_lemmatization": "feature proposal ( eslint-react-hooks ) : n't require empty dependency usecallback another dependency array"
    },
    {
        "issue_id": 642268438,
        "title": "Failed to compile error when a new project is created ",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-06-20T00:03:32Z",
        "status": "closed",
        "description": "Getting following error when I attempt to run a newly created project using following command\r\nnpx create-react-app my-app\r\ncd my-app\r\n\r\nWhen I pass this --> npm start command, I get following error in browser.\r\n\r\n```Failed to compile\r\n./src/index.css (./node_modules/css-loader/dist/cjs.js??ref--6-oneOf-3-1!./node_modules/postcss-loader/src??postcss!./src/index.css)\r\nError: Package exports for '..\\node_modules\\autoprefixer\\node_modules\\kleur' do not define a valid './colors' target\r\n```\r\n![image](https://user-images.githubusercontent.com/65842419/85186486-49567580-b267-11ea-91c9-00eab2827be0.png)\r\n\r\nI did google and tried running following commands but no luck.\r\nnpm I autoprefixer\r\nnpm install node-saas-@latest..\r\n\r\nI have following versions listed as dependencies\r\n    \"autoprefixer\": \"^9.8.1\",\r\n    \"react\": \"^16.13.1\",\r\n    \"react-dom\": \"^16.13.1\",\r\n    \"react-scripts\": \"3.4.1\"\r\n\r\nNote: I tried running old project and that works fine... having issue only when I create a new project from scratch and run.\r\nplease advise.",
        "remove_template_description": "Getting following error when I attempt to run a newly created project using following command  npx create-react-app my-app  cd my-app    When I pass this --> npm start command, I get following error in browser.    ```Failed to compile  ./src/index.css (./node_modules/css-loader/dist/cjs.js??ref--6-oneOf-3-1!./node_modules/postcss-loader/src??postcss!./src/index.css)  Error: Package exports for '..\\node_modules\\autoprefixer\\node_modules\\kleur' do not define a valid './colors' target  ```  ![image](https://user-images.githubusercontent.com/65842419/85186486-49567580-b267-11ea-91c9-00eab2827be0.png)    I did google and tried running following commands but no luck.  npm I autoprefixer  npm install node-saas-@latest..    I have following versions listed as dependencies      \"autoprefixer\": \"^9.8.1\",      \"react\": \"^16.13.1\",      \"react-dom\": \"^16.13.1\",      \"react-scripts\": \"3.4.1\"    Note: I tried running old project and that works fine... having issue only when I create a new project from scratch and run.  please advise.",
        "human_words": "Getting following error when I attempt to run a newly created project using following command  npx create-react-app my-app  cd my-app    When I pass this --> npm start command, I get following error in browser.      ![image](https://user-images.githubusercontent.com/65842419/85186486-49567580-b267-11ea-91c9-00eab2827be0.png)    I did google and tried running following commands but no luck.  npm I autoprefixer  npm install node-saas-@latest..    I have following versions listed as dependencies      \"autoprefixer\": \"^9.8.1\",      \"react\": \"^16.13.1\",      \"react-dom\": \"^16.13.1\",      \"react-scripts\": \"3.4.1\"    Note: I tried running old project and that works fine... having issue only when I create a new project from scratch and run.  please advise.",
        "human_words_regrex": "Getting following error when I attempt to run a newly created project using following command npx create-react-app my-app cd my-app When I pass this --> npm start command, I get following error in browser. ! I did google and tried running following commands but no luck. npm I autoprefixer npm install node-saas-@latest.. I have following versions listed as dependencies \"autoprefixer\": \"^9.8.1\", \"react\": \"^16.13.1\", \"react-dom\": \"^16.13.1\", \"react-scripts\": \"3.4.1\" Note: I tried running old project and that works fine... having issue only when I create a new project from scratch and run. please advise.",
        "human_words_stopwords_removal_lemmatization": "getting following error attempt run newly created project using following command npx create-react-app my-app cd my-app pas -- > npm start command , get following error browser . ! google tried running following command luck . npm autoprefixer npm install node-saas- @ latest .. following version listed dependency `` autoprefixer '' : `` ^9.8.1 '' , `` react '' : `` ^16.13.1 '' , `` react-dom '' : `` ^16.13.1 '' , `` react-scripts '' : `` 3.4.1 '' note : tried running old project work fine ... issue create new project scratch run . please advise .",
        "title_stopwords_removal_lemmatization": "failed compile error new project created"
    },
    {
        "issue_id": 641999829,
        "title": "Hiding MUI Components inside React Developer Tools",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-06-19T14:12:47Z",
        "status": "open",
        "description": "Hello, recently we've overhauled a client's website with the usage of [Material UI](https://material-ui.com/). It's been an enjoyable experience, however one thing that really irks me - given the project is pretty large and there's multiple people working on it, sometimes it gets chaotic which component is exactly what and you need to find out which component you should be working on.\r\n\r\nMy general fallback was using the [React Develeloper Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) extension, however given MUI consists of ready-made JSX components, it essentially spams and halts the usefulness of the 'Components' tab.\r\n\r\n![image](https://user-images.githubusercontent.com/17268815/85140844-25cf0300-b246-11ea-98ec-e0d37aea2707.png)\r\n\r\nIs there perhaps any way that would allow for filtering of specific packages / jsx elements inside the React Developer Tools?\r\n\r\nI know I could technically user regex to filter out a list of all the known MUI Components, but that seems bit overkill.  I sadly suspect such a thing is not supported, but you never know unless you ask.\r\n",
        "remove_template_description": "Hello, recently we've overhauled a client's website with the usage of [Material UI](https://material-ui.com/). It's been an enjoyable experience, however one thing that really irks me - given the project is pretty large and there's multiple people working on it, sometimes it gets chaotic which component is exactly what and you need to find out which component you should be working on.    My general fallback was using the [React Develeloper Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) extension, however given MUI consists of ready-made JSX components, it essentially spams and halts the usefulness of the 'Components' tab.    ![image](https://user-images.githubusercontent.com/17268815/85140844-25cf0300-b246-11ea-98ec-e0d37aea2707.png)    Is there perhaps any way that would allow for filtering of specific packages / jsx elements inside the React Developer Tools?    I know I could technically user regex to filter out a list of all the known MUI Components, but that seems bit overkill.  I sadly suspect such a thing is not supported, but you never know unless you ask.",
        "human_words": "Hello, recently we've overhauled a client's website with the usage of [Material UI](https://material-ui.com/). It's been an enjoyable experience, however one thing that really irks me - given the project is pretty large and there's multiple people working on it, sometimes it gets chaotic which component is exactly what and you need to find out which component you should be working on.    My general fallback was using the [React Develeloper Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) extension, however given MUI consists of ready-made JSX components, it essentially spams and halts the usefulness of the 'Components' tab.    ![image](https://user-images.githubusercontent.com/17268815/85140844-25cf0300-b246-11ea-98ec-e0d37aea2707.png)    Is there perhaps any way that would allow for filtering of specific packages / jsx elements inside the React Developer Tools?    I know I could technically user regex to filter out a list of all the known MUI Components, but that seems bit overkill.  I sadly suspect such a thing is not supported, but you never know unless you ask.",
        "human_words_regrex": "Hello, recently we've overhauled a client's website with the usage of . It's been an enjoyable experience, however one thing that really irks me - given the project is pretty large and there's multiple people working on it, sometimes it gets chaotic which component is exactly what and you need to find out which component you should be working on. My general fallback was using the  extension, however given MUI consists of ready-made JSX components, it essentially spams and halts the usefulness of the 'Components' tab. ! Is there perhaps any way that would allow for filtering of specific packages / jsx elements inside the React Developer Tools? I know I could technically user regex to filter out a list of all the known MUI Components, but that seems bit overkill. I sadly suspect such a thing is not supported, but you never know unless you ask.",
        "human_words_stopwords_removal_lemmatization": "hello , recently 've overhauled client 's website usage . 's enjoyable experience , however one thing really irks - given project pretty large 's multiple people working , sometimes get chaotic component exactly need find component working . general fallback using extension , however given mui consists ready-made jsx component , essentially spam halt usefulness 'components ' tab . ! perhaps way would allow filtering specific package / jsx element inside react developer tool ? know could technically user regex filter list known mui component , seems bit overkill . sadly suspect thing supported , never know unless ask .",
        "title_stopwords_removal_lemmatization": "hiding mui component inside react developer tool"
    },
    {
        "issue_id": 640942091,
        "title": "Issue: No privacy policy for React Developer Tools Chrome extension",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-06-18T06:21:56Z",
        "status": "closed",
        "description": "React Developer Tools version: 4.7.0\r\n\r\n## Steps To Reproduce\r\n\r\n1. Visit [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) on Chrome Web Store and look for a privacy policy under 'Additional Information' and 'Overview'\r\n2. Visit [React Developer Tools](https://github.com/facebook/react/tree/master/packages/react-devtools-extensions) on github and check for a privacy policy.\r\n\r\n## The current behaviour\r\n\r\nNo privacy policy available detailing if the browser extension uses any user data and, if yes, how. This is more important considering that the extension requires permission to access data on all tabs and websites.\r\n\r\n## The expected behavior\r\n\r\nProvide a privacy policy, preferably both here in the repository and on the Chrome Web Store, explaining how the user data is used, specially if any data is transferred off the machine.",
        "remove_template_description": "React Developer Tools version: 4.7.0        1. Visit [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) on Chrome Web Store and look for a privacy policy under 'Additional Information' and 'Overview'  2. Visit [React Developer Tools](https://github.com/facebook/react/tree/master/packages/react-devtools-extensions) on github and check for a privacy policy.    ## The current behaviour    No privacy policy available detailing if the browser extension uses any user data and, if yes, how. This is more important considering that the extension requires permission to access data on all tabs and websites.        Provide a privacy policy, preferably both here in the repository and on the Chrome Web Store, explaining how the user data is used, specially if any data is transferred off the machine.",
        "human_words": "React Developer Tools version: 4.7.0        1. Visit [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) on Chrome Web Store and look for a privacy policy under 'Additional Information' and 'Overview'  2. Visit [React Developer Tools](https://github.com/facebook/react/tree/master/packages/react-devtools-extensions) on github and check for a privacy policy.    ## The current behaviour    No privacy policy available detailing if the browser extension uses any user data and, if yes, how. This is more important considering that the extension requires permission to access data on all tabs and websites.        Provide a privacy policy, preferably both here in the repository and on the Chrome Web Store, explaining how the user data is used, specially if any data is transferred off the machine.",
        "human_words_regrex": "React Developer Tools version: 4.7.0 1. Visit  on Chrome Web Store and look for a privacy policy under 'Additional Information' and 'Overview' 2. Visit  on github and check for a privacy policy. ## The current behaviour No privacy policy available detailing if the browser extension uses any user data and, if yes, how. This is more important considering that the extension requires permission to access data on all tabs and websites. Provide a privacy policy, preferably both here in the repository and on the Chrome Web Store, explaining how the user data is used, specially if any data is transferred off the machine.",
        "human_words_stopwords_removal_lemmatization": "react developer tool version : 4.7.0 1. visit chrome web store look privacy policy 'additional information ' 'overview ' 2. visit github check privacy policy . # # current behaviour privacy policy available detailing browser extension us user data , yes , . important considering extension requires permission access data tab website . provide privacy policy , preferably repository chrome web store , explaining user data used , specially data transferred machine .",
        "title_stopwords_removal_lemmatization": "issue : privacy policy react developer tool chrome extension"
    },
    {
        "issue_id": 638531130,
        "title": "Could you please rename master branch and remove any problematic references?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-06-15T04:25:20Z",
        "status": "closed",
        "description": "There are many people doing the same in light of BLM and deep racist history associated with words such as blacklist, whitelist, slave, master and many others which see wide use in CS and code.\r\n\r\nThere are many big projects doing the same - golang, rustlang, python.\r\n\r\nHere is a note from github CEO - https://twitter.com/natfriedman/status/1271253144442253312\r\n\r\nCould you please remove racism from code?\r\n\r\nPS - Historical context for main - https://www.nakasendoway.com/the-japanese-family-system/\r\n\r\nPlease consider alternatives such as canary, develop or edge.",
        "remove_template_description": "There are many people doing the same in light of BLM and deep racist history associated with words such as blacklist, whitelist, slave, master and many others which see wide use in CS and code.    There are many big projects doing the same - golang, rustlang, python.    Here is a note from github CEO - https://twitter.com/natfriedman/status/1271253144442253312    Could you please remove racism from code?    PS - Historical context for main - https://www.nakasendoway.com/the-japanese-family-system/    Please consider alternatives such as canary, develop or edge.",
        "human_words": "There are many people doing the same in light of BLM and deep racist history associated with words such as blacklist, whitelist, slave, master and many others which see wide use in CS and code.    There are many big projects doing the same - golang, rustlang, python.    Here is a note from github CEO - https://twitter.com/natfriedman/status/1271253144442253312    Could you please remove racism from code?    PS - Historical context for main - https://www.nakasendoway.com/the-japanese-family-system/    Please consider alternatives such as canary, develop or edge.",
        "human_words_regrex": "There are many people doing the same in light of BLM and deep racist history associated with words such as blacklist, whitelist, slave, master and many others which see wide use in CS and code. There are many big projects doing the same - golang, rustlang, python. Here is a note from github CEO -  Could you please remove racism from code? PS - Historical context for main -  Please consider alternatives such as canary, develop or edge.",
        "human_words_stopwords_removal_lemmatization": "many people light blm deep racist history associated word blacklist , whitelist , slave , master many others see wide use c code . many big project - golang , rustlang , python . note github ceo - could please remove racism code ? p - historical context main - please consider alternative canary , develop edge .",
        "title_stopwords_removal_lemmatization": "could please rename master branch remove problematic reference ?"
    },
    {
        "issue_id": 638039818,
        "title": "eslint rules: mark certain values as having a stable identity",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2020-06-12T22:54:36Z",
        "status": "closed",
        "description": "eslint-plugin-react-hooks version: 4.0.4\r\n\r\nI have the following custom hook:\r\n\r\n```js\r\nexport function useForceUpdate() {\r\n  const [, setValue] = useState(0);\r\n  return useCallback(() => setValue((v) => v + 1), []);\r\n}\r\n```\r\n\r\nBut when I use it:\r\n\r\n```js\r\nfunction MyComponent(props) {\r\n  const forceUpdate = useForceUpdate();\r\n\r\n  // ... snip ...\r\n\r\n  useEffect(() => {\r\n    // do stuff\r\n    forceUpdate();\r\n  }, [foo, bar]);\r\n\r\n  // ... continue\r\n}\r\n```\r\n\r\nThe linter complains (rightfully so):\r\n\r\n```\r\nwarning  React Hook useEffect has a missing dependency: 'forceUpdate'. Either include it or remove the dependency array\r\n```\r\n\r\nIt would useful to have a configuration option to tell the linter that `forceUpdate` is guaranteed to have a stable identity, so it can give it the same treatment as e.g. `useState`'s callback. Otherwise, I have to disable the rule every time I use the hook!",
        "remove_template_description": "eslint-plugin-react-hooks version: 4.0.4    I have the following custom hook:    ```js  export function useForceUpdate() {    const [, setValue] = useState(0);    return useCallback(() => setValue((v) => v + 1), []);  }  ```    But when I use it:    ```js  function MyComponent(props) {    const forceUpdate = useForceUpdate();      // ... snip ...      useEffect(() => {      // do stuff      forceUpdate();    }, [foo, bar]);      // ... continue  }  ```    The linter complains (rightfully so):    ```  warning  React Hook useEffect has a missing dependency: 'forceUpdate'. Either include it or remove the dependency array  ```    It would useful to have a configuration option to tell the linter that `forceUpdate` is guaranteed to have a stable identity, so it can give it the same treatment as e.g. `useState`'s callback. Otherwise, I have to disable the rule every time I use the hook!",
        "human_words": "eslint-plugin-react-hooks version: 4.0.4    I have the following custom hook:        But when I use it:        The linter complains (rightfully so):        It would useful to have a configuration option to tell the linter that `forceUpdate` is guaranteed to have a stable identity, so it can give it the same treatment as e.g. `useState`'s callback. Otherwise, I have to disable the rule every time I use the hook!",
        "human_words_regrex": "eslint-plugin-react-hooks version: 4.0.4 I have the following custom hook: But when I use it: The linter complains (rightfully so): It would useful to have a configuration option to tell the linter that `forceUpdate` is guaranteed to have a stable identity, so it can give it the same treatment as e.g. `useState`'s callback. Otherwise, I have to disable the rule every time I use the hook!",
        "human_words_stopwords_removal_lemmatization": "eslint-plugin-react-hooks version : 4.0.4 following custom hook : use : linter complains ( rightfully ) : would useful configuration option tell linter ` forceupdate ` guaranteed stable identity , give treatment e.g . ` usestate ` 's callback . otherwise , disable rule every time use hook !",
        "title_stopwords_removal_lemmatization": "eslint rule : mark certain value stable identity"
    },
    {
        "issue_id": 635089054,
        "title": "Rename `Invalid` to something that is not offensive",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-06-09T03:50:47Z",
        "status": "closed",
        "description": "I found 155 occurrences of **\"invalid\"** in React's repository. It might be not obvious for non-russian speakers but this word means \"disable\" with highly offensive context in russian language. For the sake of inclusivity and diversity we should rename all occurrences   to something that is not disparaging.\r\n\r\nI also find it extremely inappropriate to use [\"invalid child\"](https://github.com/facebook/react/blob/6498f62edcdf0bcc02ed96efdad92b7e89330d8a/packages/react-dom/src/client/ReactDOMOption.js#L14) as it means wrong or defective child. I believe it's extremely offensive towards kids with disabilities as it reminds them about numerous prejudices they are facing in society.\r\n\r\nThanks for your attention and for your understanding. I hope this issue will be fixed ASAP and together we can make world a better place to live.",
        "remove_template_description": "I found 155 occurrences of **\"invalid\"** in React's repository. It might be not obvious for non-russian speakers but this word means \"disable\" with highly offensive context in russian language. For the sake of inclusivity and diversity we should rename all occurrences   to something that is not disparaging.    I also find it extremely inappropriate to use [\"invalid child\"](https://github.com/facebook/react/blob/6498f62edcdf0bcc02ed96efdad92b7e89330d8a/packages/react-dom/src/client/ReactDOMOption.js#L14) as it means wrong or defective child. I believe it's extremely offensive towards kids with disabilities as it reminds them about numerous prejudices they are facing in society.    Thanks for your attention and for your understanding. I hope this issue will be fixed ASAP and together we can make world a better place to live.",
        "human_words": "I found 155 occurrences of **\"invalid\"** in React's repository. It might be not obvious for non-russian speakers but this word means \"disable\" with highly offensive context in russian language. For the sake of inclusivity and diversity we should rename all occurrences   to something that is not disparaging.    I also find it extremely inappropriate to use [\"invalid child\"](https://github.com/facebook/react/blob/6498f62edcdf0bcc02ed96efdad92b7e89330d8a/packages/react-dom/src/client/ReactDOMOption.js#L14) as it means wrong or defective child. I believe it's extremely offensive towards kids with disabilities as it reminds them about numerous prejudices they are facing in society.    Thanks for your attention and for your understanding. I hope this issue will be fixed ASAP and together we can make world a better place to live.",
        "human_words_regrex": "I found 155 occurrences of **\"invalid\"** in React's repository. It might be not obvious for non-russian speakers but this word means \"disable\" with highly offensive context in russian language. For the sake of inclusivity and diversity we should rename all occurrences to something that is not disparaging. I also find it extremely inappropriate to use  as it means wrong or defective child. I believe it's extremely offensive towards kids with disabilities as it reminds them about numerous prejudices they are facing in society. Thanks for your attention and for your understanding. I hope this issue will be fixed ASAP and together we can make world a better place to live.",
        "human_words_stopwords_removal_lemmatization": "found 155 occurrence * * '' invalid '' * * react 's repository . might obvious non-russian speaker word mean `` disable '' highly offensive context russian language . sake inclusivity diversity rename occurrence something disparaging . also find extremely inappropriate use mean wrong defective child . believe 's extremely offensive towards kid disability reminds numerous prejudice facing society . thanks attention understanding . hope issue fixed asap together make world better place live .",
        "title_stopwords_removal_lemmatization": "rename ` invalid ` something offensive"
    },
    {
        "issue_id": 626540055,
        "title": "exhaustive-deps: custom effects should support async functions",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2020-05-28T14:10:11Z",
        "status": "open",
        "description": "We have a custom hook, `useAsyncEffect`, which works like `useEffect` except it accepts an async function. We would like to check the deps of this function using `exhaustive-deps`, but that lint rule is going a bit beyond its name and also checking the type of function we pass.\r\n\r\nThe `exhaustive-deps` rule can't know anything about the semantics of arbitrary third-party hooks, so I think it's overstepping its bounds a bit (at least if you take the name \"exhaustive deps\" literally)\r\n\r\nReact version: 16.13.1\r\neslint version: 7.0.0\r\neslint-plugin-react-hooks version: 4.0.3\r\n\r\n## Steps To Reproduce\r\n\r\nSource:\r\n\r\n```\r\nimport React from 'react';\r\nimport { useAsyncEffect } from './utilities/react';\r\n\r\nfunction MyComponent() {\r\n  useAsyncEffect(async () => {\r\n    await Promise.resolve()\r\n  }, []);\r\n  return <div />;\r\n}\r\n```\r\n\r\n`.eslintrc.json`:\r\n\r\n```\r\n{\r\n  \"parserOptions\": {\r\n    \"ecmaVersion\": 2020,\r\n    \"sourceType\": \"module\",\r\n    \"ecmaFeatures\": {\r\n      \"jsx\": true\r\n    }\r\n  },\r\n  \"plugins\": [\"react-hooks\"],\r\n  \"rules\": {\r\n    \"react-hooks/exhaustive-deps\": [\r\n      \"error\",\r\n      {\r\n        \"additionalHooks\": \"^useAsyncEffect$\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nThen run:\r\n\r\n```\r\nnode_modules/.bin/eslint --ext jsx src/file.jsx\r\n```\r\n\r\n## The current behavior\r\n\r\n```\r\n  5:18  error  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\r\n\r\n<snip>\r\n\r\n\u2716 1 problem (1 error, 0 warnings)\r\n```\r\n\r\n## The expected behavior\r\n\r\nThere should be no lint error",
        "remove_template_description": "We have a custom hook, `useAsyncEffect`, which works like `useEffect` except it accepts an async function. We would like to check the deps of this function using `exhaustive-deps`, but that lint rule is going a bit beyond its name and also checking the type of function we pass.    The `exhaustive-deps` rule can't know anything about the semantics of arbitrary third-party hooks, so I think it's overstepping its bounds a bit (at least if you take the name \"exhaustive deps\" literally)    React version: 16.13.1  eslint version: 7.0.0  eslint-plugin-react-hooks version: 4.0.3        Source:    ```  import React from 'react';  import { useAsyncEffect } from './utilities/react';    function MyComponent() {    useAsyncEffect(async () => {      await Promise.resolve()    }, []);    return <div />;  }  ```    `.eslintrc.json`:    ```  {    \"parserOptions\": {      \"ecmaVersion\": 2020,      \"sourceType\": \"module\",      \"ecmaFeatures\": {        \"jsx\": true      }    },    \"plugins\": [\"react-hooks\"],    \"rules\": {      \"react-hooks/exhaustive-deps\": [        \"error\",        {          \"additionalHooks\": \"^useAsyncEffect$\"        }      ]    }  }  ```    Then run:    ```  node_modules/.bin/eslint --ext jsx src/file.jsx  ```        ```    5:18  error  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:    <snip>    \u2716 1 problem (1 error, 0 warnings)  ```        There should be no lint error",
        "human_words": "We have a custom hook, `useAsyncEffect`, which works like `useEffect` except it accepts an async function. We would like to check the deps of this function using `exhaustive-deps`, but that lint rule is going a bit beyond its name and also checking the type of function we pass.    The `exhaustive-deps` rule can't know anything about the semantics of arbitrary third-party hooks, so I think it's overstepping its bounds a bit (at least if you take the name \"exhaustive deps\" literally)    React version: 16.13.1  eslint version: 7.0.0  eslint-plugin-react-hooks version: 4.0.3        Source:        `.eslintrc.json`:        Then run:                    There should be no lint error",
        "human_words_regrex": "We have a custom hook, `useAsyncEffect`, which works like `useEffect` except it accepts an async function. We would like to check the deps of this function using `exhaustive-deps`, but that lint rule is going a bit beyond its name and also checking the type of function we pass. The `exhaustive-deps` rule can't know anything about the semantics of arbitrary third-party hooks, so I think it's overstepping its bounds a bit (at least if you take the name \"exhaustive deps\" literally) React version: 16.13.1 eslint version: 7.0.0 eslint-plugin-react-hooks version: 4.0.3 Source: `.eslintrc.json`: Then run: There should be no lint error",
        "human_words_stopwords_removal_lemmatization": "custom hook , ` useasynceffect ` , work like ` useeffect ` except accepts async function . would like check deps function using ` exhaustive-deps ` , lint rule going bit beyond name also checking type function pas . ` exhaustive-deps ` rule ca n't know anything semantics arbitrary third-party hook , think 's overstepping bound bit ( least take name `` exhaustive deps '' literally ) react version : 16.13.1 eslint version : 7.0.0 eslint-plugin-react-hooks version : 4.0.3 source : ` .eslintrc.json ` : run : lint error",
        "title_stopwords_removal_lemmatization": "exhaustive-deps : custom effect support async function"
    },
    {
        "issue_id": 622091468,
        "title": "Bug: React throws warning on browser default function",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2020-05-20T21:20:02Z",
        "status": "open",
        "description": "I'm receiving the following \"Warning\"\r\n```\r\nWarning: Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\r\n    in option (created by styled.option)\r\n    in styled.option (created by Menu)\r\n    in select (created by styled.select)\r\n    in styled.select (created by Menu)\r\n    in div (created by styled.div)\r\n    in styled.div (created by Menu)\r\n````\r\n\r\nReact version:\r\n\r\n## Steps To Reproduce\r\n\r\n1. create a select with options\r\n```\r\nreturn (<select>\r\n  <option>a</option>\r\n  <option selected>b</option>\r\n</select>);\r\n```\r\nas usecase: the selected property is defined outside the state of the select component, it is set by navigating the site. As of now it is only a warning, so it works if I use this, but the customer whom I build the application, has strict standards, so as for this warning, it kills the audit of the  application, even we stated that it is a React specific warning, not a standard, caused by some coding error.\r\n2. see the warnning whowing up *RED* in your browser that a simple already built-in function of all browser if overriden and damned eternally.\r\n\r\nCode does not have any outside dependencies.\r\n\r\n## The current behavior\r\n\r\nIt throws the warning in development.\r\n\r\n## The expected behavior\r\n\r\nIt is a standard behavior of all modern browsers, that you can tell the select dropdown or multiselect, that it has one ora other selected by code even from context.\r\n\r\nThis should not be a warning, as it is a w3c standard feature of the select dropdown. Please remove warnings and what-so-ever that you are forcing developers to do, to avoid using w3c standards.",
        "remove_template_description": "I'm receiving the following \"Warning\"  ```  Warning: Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.      in option (created by styled.option)      in styled.option (created by Menu)      in select (created by styled.select)      in styled.select (created by Menu)      in div (created by styled.div)      in styled.div (created by Menu)  ````    React version:        1. create a select with options  ```  return (<select>    <option>a</option>    <option selected>b</option>  </select>);  ```  as usecase: the selected property is defined outside the state of the select component, it is set by navigating the site. As of now it is only a warning, so it works if I use this, but the customer whom I build the application, has strict standards, so as for this warning, it kills the audit of the  application, even we stated that it is a React specific warning, not a standard, caused by some coding error.  2. see the warnning whowing up *RED* in your browser that a simple already built-in function of all browser if overriden and damned eternally.    Code does not have any outside dependencies.        It throws the warning in development.        It is a standard behavior of all modern browsers, that you can tell the select dropdown or multiselect, that it has one ora other selected by code even from context.    This should not be a warning, as it is a w3c standard feature of the select dropdown. Please remove warnings and what-so-ever that you are forcing developers to do, to avoid using w3c standards.",
        "human_words": "I'm receiving the following \"Warning\"  `    React version:        1. create a select with options    as usecase: the selected property is defined outside the state of the select component, it is set by navigating the site. As of now it is only a warning, so it works if I use this, but the customer whom I build the application, has strict standards, so as for this warning, it kills the audit of the  application, even we stated that it is a React specific warning, not a standard, caused by some coding error.  2. see the warnning whowing up *RED* in your browser that a simple already built-in function of all browser if overriden and damned eternally.    Code does not have any outside dependencies.        It throws the warning in development.        It is a standard behavior of all modern browsers, that you can tell the select dropdown or multiselect, that it has one ora other selected by code even from context.    This should not be a warning, as it is a w3c standard feature of the select dropdown. Please remove warnings and what-so-ever that you are forcing developers to do, to avoid using w3c standards.",
        "human_words_regrex": "I'm receiving the following \"Warning\" ` React version: 1. create a select with options as usecase: the selected property is defined outside the state of the select component, it is set by navigating the site. As of now it is only a warning, so it works if I use this, but the customer whom I build the application, has strict standards, so as for this warning, it kills the audit of the application, even we stated that it is a React specific warning, not a standard, caused by some coding error. 2. see the warnning whowing up *RED* in your browser that a simple already built-in function of all browser if overriden and damned eternally. Code does not have any outside dependencies. It throws the warning in development. It is a standard behavior of all modern browsers, that you can tell the select dropdown or multiselect, that it has one ora other selected by code even from context. This should not be a warning, as it is a w3c standard feature of the select dropdown. Please remove warnings and what-so-ever that you are forcing developers to do, to avoid using w3c standards.",
        "human_words_stopwords_removal_lemmatization": "'m receiving following `` warning '' ` react version : 1. create select option usecase : selected property defined outside state select component , set navigating site . warning , work use , customer build application , strict standard , warning , kill audit application , even stated react specific warning , standard , caused coding error . 2. see warnning whowing * red * browser simple already built-in function browser overriden damned eternally . code outside dependency . throw warning development . standard behavior modern browser , tell select dropdown multiselect , one os selected code even context . warning , w3c standard feature select dropdown . please remove warning what-so-ever forcing developer , avoid using w3c standard .",
        "title_stopwords_removal_lemmatization": "bug : react throw warning browser default function"
    },
    {
        "issue_id": 620103151,
        "title": "Double-render in development could be opt-in",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-05-18T10:40:26Z",
        "status": "closed",
        "description": "Today React double-renders with `StrictMode` and `ConcurrentMode` to help developers detect impure renderings. \r\n\r\nIt helps with class-heavy codebases, but with function/hooks codebases, the use-case looks unclear to me. \r\n\r\n- it adds noise to logging.\r\n- it bites developers that look for a hook stability issue in their codebases before they find the relevant documentation (happened to me, and from SO/Issue tracker I am not alone).\r\n\r\nCan we consider making the behaviour opt-in or optional at the least, esp. in `ConcurrentMode` where there is no alternative?\r\n",
        "remove_template_description": "Today React double-renders with `StrictMode` and `ConcurrentMode` to help developers detect impure renderings.     It helps with class-heavy codebases, but with function/hooks codebases, the use-case looks unclear to me.     - it adds noise to logging.  - it bites developers that look for a hook stability issue in their codebases before they find the relevant documentation (happened to me, and from SO/Issue tracker I am not alone).    Can we consider making the behaviour opt-in or optional at the least, esp. in `ConcurrentMode` where there is no alternative?",
        "human_words": "Today React double-renders with `StrictMode` and `ConcurrentMode` to help developers detect impure renderings.     It helps with class-heavy codebases, but with function/hooks codebases, the use-case looks unclear to me.     - it adds noise to logging.  - it bites developers that look for a hook stability issue in their codebases before they find the relevant documentation (happened to me, and from SO/Issue tracker I am not alone).    Can we consider making the behaviour opt-in or optional at the least, esp. in `ConcurrentMode` where there is no alternative?",
        "human_words_regrex": "Today React double-renders with `StrictMode` and `ConcurrentMode` to help developers detect impure renderings. It helps with class-heavy codebases, but with function/hooks codebases, the use-case looks unclear to me. - it adds noise to logging. - it bites developers that look for a hook stability issue in their codebases before they find the relevant documentation (happened to me, and from SO/Issue tracker I am not alone). Can we consider making the behaviour opt-in or optional at the least, esp. in `ConcurrentMode` where there is no alternative?",
        "human_words_stopwords_removal_lemmatization": "today react double-renders ` strictmode ` ` concurrentmode ` help developer detect impure rendering . help class-heavy codebases , function/hooks codebases , use-case look unclear . - add noise logging . - bite developer look hook stability issue codebases find relevant documentation ( happened , so/issue tracker alone ) . consider making behaviour opt-in optional least , esp . ` concurrentmode ` alternative ?",
        "title_stopwords_removal_lemmatization": "double-render development could opt-in"
    },
    {
        "issue_id": 601806594,
        "title": "[Flight] Make react-flight works between UI thread and webworkers",
        "label": [
            "Type: Discussion",
            "Component: Flight"
        ],
        "date": "2020-04-17T08:44:25Z",
        "status": "closed",
        "description": "I am really exited about [react flight](https://github.com/facebook/react/tree/master/packages/react-server) that you are working on right now. But I notice you are focusing on UI cooperation between client and server. How about also make it works **between UI thread and webworkers**?\r\n\r\nSo, instead of:\r\n- react-server\r\n- react-client\r\n\r\nWe should probably rename them into:\r\n- react-producer. Used by producer of UI data. For example, server, webworker.\r\n- react-consumer. Used by consumer of UI data. For example, UI thread consume UI data and render it to DOM. In complex situations, a producer could also consume another UI data stream, so the UI data flow like this: `producer1 -> producer2 -> main thread`. Main thread don't notice the existence of producer1, which is a beautiful abstraction nature.\r\n\r\nSo we abstract the idea of \"react-flight\" into \"**UI transmission and cooperation between diffetent threads**\". **This idea is basically \"parallel rendering\", which is a beautiful evolution from \"concurrent rendering\"!**\r\n\r\n**We could run react inside a webworker to calculate the UI(which is just data), and send it back to UI thread to render the real DOM. This could really unlock the power of webworkers!**\r\n\r\nSince \"UI is just data\", it is not necessary to make a distinction between them! \"UI transmission and cooperation between diffetent threads\" should be as simple as  \"data transmission and cooperation between diffetent threads\".\r\n\r\n# Use cases\r\n\r\n- Move components with heavy calculation out of the main thread.\r\n- Safely render third-party component, sandboxed in another thread. (I'm not sure. Let's discuss!)\r\n\r\n# How it works\r\nHere is my guess about how react-flight works. Correct me if I am wrong!\r\n- Consumer(react-client) request producer(react-server) for a UI stream.\r\n- Producer render UI as virtual dom. Serialize it. Send it back to consumer. producer could throw an error(which will serialized into a special signal) to make consumer suspend.\r\n- When dom event happens in client, the event is sent to producer. Producer locate the event target and trigger event capture/bubble. So event handler will be called inside producer.\r\n-  Event handler inside producer can call `setState()`, which will trigger re-render and send the new UI to consumer. consumer will render the new UI into DOM.\r\n\r\nI guess this is how you guys are plainning to implement react-flight between client and server. This model should also work between UI thread and webworkers.",
        "remove_template_description": "I am really exited about [react flight](https://github.com/facebook/react/tree/master/packages/react-server) that you are working on right now. But I notice you are focusing on UI cooperation between client and server. How about also make it works **between UI thread and webworkers**?    So, instead of:  - react-server  - react-client    We should probably rename them into:  - react-producer. Used by producer of UI data. For example, server, webworker.  - react-consumer. Used by consumer of UI data. For example, UI thread consume UI data and render it to DOM. In complex situations, a producer could also consume another UI data stream, so the UI data flow like this: `producer1 -> producer2 -> main thread`. Main thread don't notice the existence of producer1, which is a beautiful abstraction nature.    So we abstract the idea of \"react-flight\" into \"**UI transmission and cooperation between diffetent threads**\". **This idea is basically \"parallel rendering\", which is a beautiful evolution from \"concurrent rendering\"!**    **We could run react inside a webworker to calculate the UI(which is just data), and send it back to UI thread to render the real DOM. This could really unlock the power of webworkers!**    Since \"UI is just data\", it is not necessary to make a distinction between them! \"UI transmission and cooperation between diffetent threads\" should be as simple as  \"data transmission and cooperation between diffetent threads\".    # Use cases    - Move components with heavy calculation out of the main thread.  - Safely render third-party component, sandboxed in another thread. (I'm not sure. Let's discuss!)    # How it works  Here is my guess about how react-flight works. Correct me if I am wrong!  - Consumer(react-client) request producer(react-server) for a UI stream.  - Producer render UI as virtual dom. Serialize it. Send it back to consumer. producer could throw an error(which will serialized into a special signal) to make consumer suspend.  - When dom event happens in client, the event is sent to producer. Producer locate the event target and trigger event capture/bubble. So event handler will be called inside producer.  -  Event handler inside producer can call `setState()`, which will trigger re-render and send the new UI to consumer. consumer will render the new UI into DOM.    I guess this is how you guys are plainning to implement react-flight between client and server. This model should also work between UI thread and webworkers.",
        "human_words": "I am really exited about [react flight](https://github.com/facebook/react/tree/master/packages/react-server) that you are working on right now. But I notice you are focusing on UI cooperation between client and server. How about also make it works **between UI thread and webworkers**?    So, instead of:  - react-server  - react-client    We should probably rename them into:  - react-producer. Used by producer of UI data. For example, server, webworker.  - react-consumer. Used by consumer of UI data. For example, UI thread consume UI data and render it to DOM. In complex situations, a producer could also consume another UI data stream, so the UI data flow like this: `producer1 -> producer2 -> main thread`. Main thread don't notice the existence of producer1, which is a beautiful abstraction nature.    So we abstract the idea of \"react-flight\" into \"**UI transmission and cooperation between diffetent threads**\". **This idea is basically \"parallel rendering\", which is a beautiful evolution from \"concurrent rendering\"!**    **We could run react inside a webworker to calculate the UI(which is just data), and send it back to UI thread to render the real DOM. This could really unlock the power of webworkers!**    Since \"UI is just data\", it is not necessary to make a distinction between them! \"UI transmission and cooperation between diffetent threads\" should be as simple as  \"data transmission and cooperation between diffetent threads\".    # Use cases    - Move components with heavy calculation out of the main thread.  - Safely render third-party component, sandboxed in another thread. (I'm not sure. Let's discuss!)    # How it works  Here is my guess about how react-flight works. Correct me if I am wrong!  - Consumer(react-client) request producer(react-server) for a UI stream.  - Producer render UI as virtual dom. Serialize it. Send it back to consumer. producer could throw an error(which will serialized into a special signal) to make consumer suspend.  - When dom event happens in client, the event is sent to producer. Producer locate the event target and trigger event capture/bubble. So event handler will be called inside producer.  -  Event handler inside producer can call `setState()`, which will trigger re-render and send the new UI to consumer. consumer will render the new UI into DOM.    I guess this is how you guys are plainning to implement react-flight between client and server. This model should also work between UI thread and webworkers.",
        "human_words_regrex": "I am really exited about  that you are working on right now. But I notice you are focusing on UI cooperation between client and server. How about also make it works **between UI thread and webworkers**? So, instead of: - react-server - react-client We should probably rename them into: - react-producer. Used by producer of UI data. For example, server, webworker. - react-consumer. Used by consumer of UI data. For example, UI thread consume UI data and render it to DOM. In complex situations, a producer could also consume another UI data stream, so the UI data flow like this: `producer1 -> producer2 -> main thread`. Main thread don't notice the existence of producer1, which is a beautiful abstraction nature. So we abstract the idea of \"react-flight\" into \"**UI transmission and cooperation between diffetent threads**\". **This idea is basically \"parallel rendering\", which is a beautiful evolution from \"concurrent rendering\"!** **We could run react inside a webworker to calculate the UI(which is just data), and send it back to UI thread to render the real DOM. This could really unlock the power of webworkers!** Since \"UI is just data\", it is not necessary to make a distinction between them! \"UI transmission and cooperation between diffetent threads\" should be as simple as \"data transmission and cooperation between diffetent threads\". # Use cases - Move components with heavy calculation out of the main thread. - Safely render third-party component, sandboxed in another thread. (I'm not sure. Let's discuss!) # How it works Here is my guess about how react-flight works. Correct me if I am wrong! - Consumer(react-client) request producer(react-server) for a UI stream. - Producer render UI as virtual dom. Serialize it. Send it back to consumer. producer could throw an error(which will serialized into a special signal) to make consumer suspend. - When dom event happens in client, the event is sent to producer. Producer locate the event target and trigger event capture/bubble. So event handler will be called inside producer. - Event handler inside producer can call `setState()`, which will trigger re-render and send the new UI to consumer. consumer will render the new UI into DOM. I guess this is how you guys are plainning to implement react-flight between client and server. This model should also work between UI thread and webworkers.",
        "human_words_stopwords_removal_lemmatization": "really exited working right . notice focusing ui cooperation client server . also make work * * ui thread webworkers * * ? , instead : - react-server - react-client probably rename : - react-producer . used producer ui data . example , server , webworker . - react-consumer . used consumer ui data . example , ui thread consume ui data render dom . complex situation , producer could also consume another ui data stream , ui data flow like : ` producer1 - > producer2 - > main thread ` . main thread n't notice existence producer1 , beautiful abstraction nature . abstract idea `` react-flight '' `` * * ui transmission cooperation diffetent thread * * '' . * * idea basically `` parallel rendering '' , beautiful evolution `` concurrent rendering '' ! * * * * could run react inside webworker calculate ui ( data ) , send back ui thread render real dom . could really unlock power webworkers ! * * since `` ui data '' , necessary make distinction ! `` ui transmission cooperation diffetent thread '' simple `` data transmission cooperation diffetent thread '' . # use case - move component heavy calculation main thread . - safely render third-party component , sandboxed another thread . ( 'm sure . let 's discus ! ) # work guess react-flight work . correct wrong ! - consumer ( react-client ) request producer ( react-server ) ui stream . - producer render ui virtual dom . serialize . send back consumer . producer could throw error ( serialized special signal ) make consumer suspend . - dom event happens client , event sent producer . producer locate event target trigger event capture/bubble . event handler called inside producer . - event handler inside producer call ` setstate ( ) ` , trigger re-render send new ui consumer . consumer render new ui dom . guess guy plainning implement react-flight client server . model also work ui thread webworkers .",
        "title_stopwords_removal_lemmatization": "[ flight ] make react-flight work ui thread webworkers"
    },
    {
        "issue_id": 600537991,
        "title": "Bug: window as new portal will break event delegation",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-04-15T19:32:36Z",
        "status": "open",
        "description": "<!--\r\n  Please provide a clear and concise description of what the bug is. Include\r\n  screenshots if needed. Please test using the latest version of the relevant\r\n  React packages to make sure your issue has not already been fixed.\r\n-->\r\n\r\nReact version: any?\r\n\r\n## Steps To Reproduce\r\n\r\n1. Button attach to a window portal with window.open\r\n2. Event not triggering\r\n\r\n\r\n<!--\r\n  Your bug will get fixed much faster if we can run your code and it doesn't\r\n  have dependencies other than React. Issues without reproduction steps or\r\n  code examples may be immediately closed as not actionable.\r\n-->\r\n\r\nLink to code example:\r\n```javascript\r\nconst { useState, useEffect } = React;\r\n\r\n\r\nfunction WindowPortal({ children }) {\r\n  const [container, setContainer] = useState(document.createElement('div'));\r\n  useEffect(() => { \r\n    const newWindow = window.open('', '', 'width=600,height=400,left=200,top=200');\r\n    newWindow.document.body.appendChild(container);\r\n  });\r\n  return ReactDOM.createPortal(children, container);\r\n}\r\nfunction App() {\r\n  const [value, setValue] = useState('unclicked');\r\n  const handleClick = () => setValue('clicked'); \r\n  return (\r\n    <div>\r\n      <div>Portal Test</div>\r\n      <WindowPortal>\r\n        <button onClick={handleClick}>{value}</button>\r\n      </WindowPortal>\r\n    </div>\r\n  );\r\n}\r\n\r\nReactDOM.render(\r\n  React.createElement(App),\r\n  document.getElementById('root')\r\n);\r\n```\r\n<!--\r\n  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a\r\n  repository on GitHub, or provide a minimal code example that reproduces the\r\n  problem. You may provide a screenshot of the application if you think it is\r\n  relevant to your bug report. Here are some tips for providing a minimal\r\n  example: https://stackoverflow.com/help/mcve.\r\n-->\r\nAny event in the new window will not be triggered since all events are bind to the original window. I think react can support a new mode for using native event binding rather than event delegation if it makes sense. [Preact](https://github.com/preactjs/preact) actually uses native browser event and don't use react event delegation system.\r\n## The current behavior\r\nEvent not trigger for components in new window\r\n\r\n## The expected behavior\r\nEvent will trigger",
        "remove_template_description": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: any?        1. Button attach to a window portal with window.open  2. Event not triggering      <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:  ```javascript  const { useState, useEffect } = React;      function WindowPortal({ children }) {    const [container, setContainer] = useState(document.createElement('div'));    useEffect(() => {       const newWindow = window.open('', '', 'width=600,height=400,left=200,top=200');      newWindow.document.body.appendChild(container);    });    return ReactDOM.createPortal(children, container);  }  function App() {    const [value, setValue] = useState('unclicked');    const handleClick = () => setValue('clicked');     return (      <div>        <div>Portal Test</div>        <WindowPortal>          <button onClick={handleClick}>{value}</button>        </WindowPortal>      </div>    );  }    ReactDOM.render(    React.createElement(App),    document.getElementById('root')  );  ```  <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->  Any event in the new window will not be triggered since all events are bind to the original window. I think react can support a new mode for using native event binding rather than event delegation if it makes sense. [Preact](https://github.com/preactjs/preact) actually uses native browser event and don't use react event delegation system.    Event not trigger for components in new window      Event will trigger",
        "human_words": "<!--    Please provide a clear and concise description of what the bug is. Include    screenshots if needed. Please test using the latest version of the relevant    React packages to make sure your issue has not already been fixed.  -->    React version: any?        1. Button attach to a window portal with window.open  2. Event not triggering      <!--    Your bug will get fixed much faster if we can run your code and it doesn't    have dependencies other than React. Issues without reproduction steps or    code examples may be immediately closed as not actionable.  -->    Link to code example:    <!--    Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a    repository on GitHub, or provide a minimal code example that reproduces the    problem. You may provide a screenshot of the application if you think it is    relevant to your bug report. Here are some tips for providing a minimal    example: https://stackoverflow.com/help/mcve.  -->  Any event in the new window will not be triggered since all events are bind to the original window. I think react can support a new mode for using native event binding rather than event delegation if it makes sense. [Preact](https://github.com/preactjs/preact) actually uses native browser event and don't use react event delegation system.    Event not trigger for components in new window      Event will trigger",
        "human_words_regrex": " React version: any? 1. Button attach to a window portal with window.open 2. Event not triggering  Link to code example:  Any event in the new window will not be triggered since all events are bind to the original window. I think react can support a new mode for using native event binding rather than event delegation if it makes sense.  actually uses native browser event and don't use react event delegation system. Event not trigger for components in new window Event will trigger",
        "human_words_stopwords_removal_lemmatization": "react version : ? 1. button attach window portal window.open 2. event triggering link code example : event new window triggered since event bind original window . think react support new mode using native event binding rather event delegation make sense . actually us native browser event n't use react event delegation system . event trigger component new window event trigger",
        "title_stopwords_removal_lemmatization": "bug : window new portal break event delegation"
    },
    {
        "issue_id": 597605011,
        "title": "useOpaqueIdentifier and multiple React cases",
        "label": [
            "Component: Server Rendering",
            "Type: Discussion"
        ],
        "date": "2020-04-09T23:12:06Z",
        "status": "closed",
        "description": "React version: experimental\r\n\r\nThis is a theoretical issue, and is not proven to be a real issue. Written after #17322\r\n\r\n## Steps To Reproduce\r\n\r\n1. Use multiple independent version of react\r\n2. Get a clash of `id`s\r\n\r\n## The current behavior\r\n\r\nEvery React instance is generating `ids` based on a single counter, which increments every time new `id` is generated.\r\nThat `counter` is stored inside `react-dom` and it's lifetime is bound to React instance lifetime causing:\r\n- `undefined behaviour` in tests/mocks, which might clear nodejs module cache by different reasons.\r\n- `unpredictable` results with `lambda` as a backend, as long as many different renderers are working in a parallel, and their lifetime is limited.\r\n- potentially `broken` state when more than one lambda is used to generate server response (multiple roots during SSR to speedup/parallelise rendering)\r\n- guaranteed `broken` state on the client, with multiple react roots using different React instances, which could occur when the host application is not written in react, or when those \"multiple\" root as self-contained (aka widgets) and modules resolution is not hoisting a single React version to the top (for example parent application is just \"old\").\r\n\r\n## The expected behavior\r\n\r\nLet's imagine a static site generator. \r\n- You run it once and got 1000 HTML files. \r\n- You run it twice, and all those 1000 files got updated. \r\n- \ud83d\ude40, you haven't changed anything!\r\n\r\n\ud83d\udc49 So the expected behavior  is to get the same result no matter on server up time. This means that `counter` should be \"per-render\", or \"per-react-root\".\r\n\r\n--- \r\n\r\nLet's imagine there is a old legacy Java site, and we are adding two (non iframe based) widgets to it, both are self-contained (ie just \"bundled\"), and both are using the same React version.\r\nThen they would generate the same `ids` in the same order.\r\n\r\n\ud83d\udc49 this is purely frontend issue, and both React instances, even if separated, are living in the same DOM/window. They should somehow talk to eachother, and probably prefix their `ids` with some `uuid`s\r\n\r\n---\r\n\r\nLet's image the microfrontend, but old (or new, aka fragment cache) SSR-only application. For example I do have one very old, initially php-based application, where  every \"block\" is generated by a subsequent network request. Nowadays some of those \"blocks\" are using React, just for a better SSR experience (because, well, I am not using php that much for last 10years). \r\n\ud83d\udc49 every time you render App it shall produce the same Ids, to mend static site generators, however, what if different apps could prefix their `ids` differently?\r\n\r\n---\r\n\r\nTo be honest - there 3 points sounds like CAP theorem - you never gonna have all 3 at once.",
        "remove_template_description": "React version: experimental    This is a theoretical issue, and is not proven to be a real issue. Written after #17322        1. Use multiple independent version of react  2. Get a clash of `id`s        Every React instance is generating `ids` based on a single counter, which increments every time new `id` is generated.  That `counter` is stored inside `react-dom` and it's lifetime is bound to React instance lifetime causing:  - `undefined behaviour` in tests/mocks, which might clear nodejs module cache by different reasons.  - `unpredictable` results with `lambda` as a backend, as long as many different renderers are working in a parallel, and their lifetime is limited.  - potentially `broken` state when more than one lambda is used to generate server response (multiple roots during SSR to speedup/parallelise rendering)  - guaranteed `broken` state on the client, with multiple react roots using different React instances, which could occur when the host application is not written in react, or when those \"multiple\" root as self-contained (aka widgets) and modules resolution is not hoisting a single React version to the top (for example parent application is just \"old\").        Let's imagine a static site generator.   - You run it once and got 1000 HTML files.   - You run it twice, and all those 1000 files got updated.   - \ud83d\ude40, you haven't changed anything!    \ud83d\udc49 So the expected behavior  is to get the same result no matter on server up time. This means that `counter` should be \"per-render\", or \"per-react-root\".    ---     Let's imagine there is a old legacy Java site, and we are adding two (non iframe based) widgets to it, both are self-contained (ie just \"bundled\"), and both are using the same React version.  Then they would generate the same `ids` in the same order.    \ud83d\udc49 this is purely frontend issue, and both React instances, even if separated, are living in the same DOM/window. They should somehow talk to eachother, and probably prefix their `ids` with some `uuid`s    ---    Let's image the microfrontend, but old (or new, aka fragment cache) SSR-only application. For example I do have one very old, initially php-based application, where  every \"block\" is generated by a subsequent network request. Nowadays some of those \"blocks\" are using React, just for a better SSR experience (because, well, I am not using php that much for last 10years).   \ud83d\udc49 every time you render App it shall produce the same Ids, to mend static site generators, however, what if different apps could prefix their `ids` differently?    ---    To be honest - there 3 points sounds like CAP theorem - you never gonna have all 3 at once.",
        "human_words": "React version: experimental    This is a theoretical issue, and is not proven to be a real issue. Written after #17322        1. Use multiple independent version of react  2. Get a clash of `id`s        Every React instance is generating `ids` based on a single counter, which increments every time new `id` is generated.  That `counter` is stored inside `react-dom` and it's lifetime is bound to React instance lifetime causing:  - `undefined behaviour` in tests/mocks, which might clear nodejs module cache by different reasons.  - `unpredictable` results with `lambda` as a backend, as long as many different renderers are working in a parallel, and their lifetime is limited.  - potentially `broken` state when more than one lambda is used to generate server response (multiple roots during SSR to speedup/parallelise rendering)  - guaranteed `broken` state on the client, with multiple react roots using different React instances, which could occur when the host application is not written in react, or when those \"multiple\" root as self-contained (aka widgets) and modules resolution is not hoisting a single React version to the top (for example parent application is just \"old\").        Let's imagine a static site generator.   - You run it once and got 1000 HTML files.   - You run it twice, and all those 1000 files got updated.   - \ud83d\ude40, you haven't changed anything!    \ud83d\udc49 So the expected behavior  is to get the same result no matter on server up time. This means that `counter` should be \"per-render\", or \"per-react-root\".    ---     Let's imagine there is a old legacy Java site, and we are adding two (non iframe based) widgets to it, both are self-contained (ie just \"bundled\"), and both are using the same React version.  Then they would generate the same `ids` in the same order.    \ud83d\udc49 this is purely frontend issue, and both React instances, even if separated, are living in the same DOM/window. They should somehow talk to eachother, and probably prefix their `ids` with some `uuid`s    ---    Let's image the microfrontend, but old (or new, aka fragment cache) SSR-only application. For example I do have one very old, initially php-based application, where  every \"block\" is generated by a subsequent network request. Nowadays some of those \"blocks\" are using React, just for a better SSR experience (because, well, I am not using php that much for last 10years).   \ud83d\udc49 every time you render App it shall produce the same Ids, to mend static site generators, however, what if different apps could prefix their `ids` differently?    ---    To be honest - there 3 points sounds like CAP theorem - you never gonna have all 3 at once.",
        "human_words_regrex": "React version: experimental This is a theoretical issue, and is not proven to be a real issue. Written after #17322 1. Use multiple independent version of react 2. Get a clash of `id`s Every React instance is generating `ids` based on a single counter, which increments every time new `id` is generated. That `counter` is stored inside `react-dom` and it's lifetime is bound to React instance lifetime causing: - `undefined behaviour` in tests/mocks, which might clear nodejs module cache by different reasons. - `unpredictable` results with `lambda` as a backend, as long as many different renderers are working in a parallel, and their lifetime is limited. - potentially `broken` state when more than one lambda is used to generate server response (multiple roots during SSR to speedup/parallelise rendering) - guaranteed `broken` state on the client, with multiple react roots using different React instances, which could occur when the host application is not written in react, or when those \"multiple\" root as self-contained (aka widgets) and modules resolution is not hoisting a single React version to the top (for example parent application is just \"old\"). Let's imagine a static site generator. - You run it once and got 1000 HTML files. - You run it twice, and all those 1000 files got updated. - \ud83d\ude40, you haven't changed anything! \ud83d\udc49 So the expected behavior is to get the same result no matter on server up time. This means that `counter` should be \"per-render\", or \"per-react-root\". --- Let's imagine there is a old legacy Java site, and we are adding two (non iframe based) widgets to it, both are self-contained (ie just \"bundled\"), and both are using the same React version. Then they would generate the same `ids` in the same order. \ud83d\udc49 this is purely frontend issue, and both React instances, even if separated, are living in the same DOM/window. They should somehow talk to eachother, and probably prefix their `ids` with some `uuid`s --- Let's image the microfrontend, but old (or new, aka fragment cache) SSR-only application. For example I do have one very old, initially php-based application, where every \"block\" is generated by a subsequent network request. Nowadays some of those \"blocks\" are using React, just for a better SSR experience (because, well, I am not using php that much for last 10years). \ud83d\udc49 every time you render App it shall produce the same Ids, to mend static site generators, however, what if different apps could prefix their `ids` differently? --- To be honest - there 3 points sounds like CAP theorem - you never gonna have all 3 at once.",
        "human_words_stopwords_removal_lemmatization": "react version : experimental theoretical issue , proven real issue . written # 17322 1. use multiple independent version react 2. get clash ` id ` every react instance generating ` id ` based single counter , increment every time new ` id ` generated . ` counter ` stored inside ` react-dom ` 's lifetime bound react instance lifetime causing : - ` undefined behaviour ` tests/mocks , might clear nodejs module cache different reason . - ` unpredictable ` result ` lambda ` backend , long many different renderers working parallel , lifetime limited . - potentially ` broken ` state one lambda used generate server response ( multiple root ssr speedup/parallelise rendering ) - guaranteed ` broken ` state client , multiple react root using different react instance , could occur host application written react , `` multiple '' root self-contained ( aka widget ) module resolution hoisting single react version top ( example parent application `` old '' ) . let 's imagine static site generator . - run got 1000 html file . - run twice , 1000 file got updated . - \ud83d\ude40 , n't changed anything ! \ud83d\udc49 expected behavior get result matter server time . mean ` counter ` `` per-render '' , `` per-react-root '' . -- - let 's imagine old legacy java site , adding two ( non iframe based ) widget , self-contained ( ie `` bundled '' ) , using react version . would generate ` id ` order . \ud83d\udc49 purely frontend issue , react instance , even separated , living dom/window . somehow talk eachother , probably prefix ` id ` ` uuid ` -- - let 's image microfrontend , old ( new , aka fragment cache ) ssr-only application . example one old , initially php-based application , every `` block '' generated subsequent network request . nowadays `` block '' using react , better ssr experience ( , well , using php much last 10years ) . \ud83d\udc49 every time render app shall produce id , mend static site generator , however , different apps could prefix ` id ` differently ? -- - honest - 3 point sound like cap theorem - never gon na 3 .",
        "title_stopwords_removal_lemmatization": "useopaqueidentifier multiple react case"
    },
    {
        "issue_id": 596211389,
        "title": "[react-hooks/exhaustive-deps] should have special case for props callbacks",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2020-04-07T23:31:41Z",
        "status": "closed",
        "description": "`react-hooks/exhaustive-deps` attempts to be 100% accurate, and flags the following:\r\n\r\n```javascript\r\nconst c = useCallback((value: number) => {\r\n    props.onChange(value);\r\n}, [props.onChange]);         // <-- ERROR: Should be [props]\r\n```\r\n\r\nIt helpfully recommends that we should do this:\r\n\r\n```javascript\r\nconst {\r\n    onChange\r\n} = props;\r\n\r\nconst c = useCallback((value: number) => {\r\n    onChange(value);\r\n}, [onChange]);\r\n```\r\n\r\nUnfortunately, I can't bring myself to actually write my code this way. It adds pointless boilerplate code, makes my IDE \"find usages\" feature on my props send me through another level of indirection i have to follow, and i have this ugly object destructure inside every react component I write only for the callback props that is plain ugly noise.\r\n\r\nI've been using this technique lately:\r\n\r\n```javascript\r\nuseCallback((value: number) => {\r\n    props.onChange.call(null, value);\r\n}, [props.onChange]);        // <-- now the linter is happy!\r\n```\r\n\r\nWhich is a bit better, but still ugly, and sadly the autocomplete experience for the call arguments is much worse.\r\n\r\nI understand that if I were to write something like `car.drive()` then the linter would be correct that I should depend on `car` since `car` is being passed as `this` to drive, and `car` might change.\r\n\r\nBut \"props\" specifically is different. No matter how hard I try, I cannot think of a legitimate case where someone would set a prop callback such that it is expecting the actual props as the `this` argument. It makes no sense, and all of the official react documentation explain how you should use \"bind\" or whatever so that you have a locked-down `this` (if `this` is even needed at all). And the react team apparently agrees with me here, because this very lint rule suggests to destructure the prop, which would anyway break any such code that expects to have `props` passed back as `this`!\r\n\r\n**Recommendation: the lint rule should treat any function call of the form `props.xxx(...)` such that the expected dependency is `props.xxx` (instead of `props`). Just to be clear: this should only be done specifically for `props`, any other \"method\" style function call on an object other than `props` should continue to be linted in the current way.**\r\n\r\nThank you",
        "remove_template_description": "`react-hooks/exhaustive-deps` attempts to be 100% accurate, and flags the following:    ```javascript  const c = useCallback((value: number) => {      props.onChange(value);  }, [props.onChange]);         // <-- ERROR: Should be [props]  ```    It helpfully recommends that we should do this:    ```javascript  const {      onChange  } = props;    const c = useCallback((value: number) => {      onChange(value);  }, [onChange]);  ```    Unfortunately, I can't bring myself to actually write my code this way. It adds pointless boilerplate code, makes my IDE \"find usages\" feature on my props send me through another level of indirection i have to follow, and i have this ugly object destructure inside every react component I write only for the callback props that is plain ugly noise.    I've been using this technique lately:    ```javascript  useCallback((value: number) => {      props.onChange.call(null, value);  }, [props.onChange]);        // <-- now the linter is happy!  ```    Which is a bit better, but still ugly, and sadly the autocomplete experience for the call arguments is much worse.    I understand that if I were to write something like `car.drive()` then the linter would be correct that I should depend on `car` since `car` is being passed as `this` to drive, and `car` might change.    But \"props\" specifically is different. No matter how hard I try, I cannot think of a legitimate case where someone would set a prop callback such that it is expecting the actual props as the `this` argument. It makes no sense, and all of the official react documentation explain how you should use \"bind\" or whatever so that you have a locked-down `this` (if `this` is even needed at all). And the react team apparently agrees with me here, because this very lint rule suggests to destructure the prop, which would anyway break any such code that expects to have `props` passed back as `this`!    **Recommendation: the lint rule should treat any function call of the form `props.xxx(...)` such that the expected dependency is `props.xxx` (instead of `props`). Just to be clear: this should only be done specifically for `props`, any other \"method\" style function call on an object other than `props` should continue to be linted in the current way.**    Thank you",
        "human_words": "`react-hooks/exhaustive-deps` attempts to be 100% accurate, and flags the following:        It helpfully recommends that we should do this:        Unfortunately, I can't bring myself to actually write my code this way. It adds pointless boilerplate code, makes my IDE \"find usages\" feature on my props send me through another level of indirection i have to follow, and i have this ugly object destructure inside every react component I write only for the callback props that is plain ugly noise.    I've been using this technique lately:        Which is a bit better, but still ugly, and sadly the autocomplete experience for the call arguments is much worse.    I understand that if I were to write something like `car.drive()` then the linter would be correct that I should depend on `car` since `car` is being passed as `this` to drive, and `car` might change.    But \"props\" specifically is different. No matter how hard I try, I cannot think of a legitimate case where someone would set a prop callback such that it is expecting the actual props as the `this` argument. It makes no sense, and all of the official react documentation explain how you should use \"bind\" or whatever so that you have a locked-down `this` (if `this` is even needed at all). And the react team apparently agrees with me here, because this very lint rule suggests to destructure the prop, which would anyway break any such code that expects to have `props` passed back as `this`!    **Recommendation: the lint rule should treat any function call of the form `props.xxx(...)` such that the expected dependency is `props.xxx` (instead of `props`). Just to be clear: this should only be done specifically for `props`, any other \"method\" style function call on an object other than `props` should continue to be linted in the current way.**    Thank you",
        "human_words_regrex": "`react-hooks/exhaustive-deps` attempts to be 100% accurate, and flags the following: It helpfully recommends that we should do this: Unfortunately, I can't bring myself to actually write my code this way. It adds pointless boilerplate code, makes my IDE \"find usages\" feature on my props send me through another level of indirection i have to follow, and i have this ugly object destructure inside every react component I write only for the callback props that is plain ugly noise. I've been using this technique lately: Which is a bit better, but still ugly, and sadly the autocomplete experience for the call arguments is much worse. I understand that if I were to write something like `car.drive()` then the linter would be correct that I should depend on `car` since `car` is being passed as `this` to drive, and `car` might change. But \"props\" specifically is different. No matter how hard I try, I cannot think of a legitimate case where someone would set a prop callback such that it is expecting the actual props as the `this` argument. It makes no sense, and all of the official react documentation explain how you should use \"bind\" or whatever so that you have a locked-down `this` (if `this` is even needed at all). And the react team apparently agrees with me here, because this very lint rule suggests to destructure the prop, which would anyway break any such code that expects to have `props` passed back as `this`! **Recommendation: the lint rule should treat any function call of the form `props.xxx(...)` such that the expected dependency is `props.xxx` (instead of `props`). Just to be clear: this should only be done specifically for `props`, any other \"method\" style function call on an object other than `props` should continue to be linted in the current way.** Thank you",
        "human_words_stopwords_removal_lemmatization": "` react-hooks/exhaustive-deps ` attempt 100 % accurate , flag following : helpfully recommends : unfortunately , ca n't bring actually write code way . add pointless boilerplate code , make ide `` find usage '' feature prop send another level indirection follow , ugly object destructure inside every react component write callback prop plain ugly noise . 've using technique lately : bit better , still ugly , sadly autocomplete experience call argument much worse . understand write something like ` car.drive ( ) ` linter would correct depend ` car ` since ` car ` passed ` ` drive , ` car ` might change . `` prop '' specifically different . matter hard try , think legitimate case someone would set prop callback expecting actual prop ` ` argument . make sense , official react documentation explain use `` bind '' whatever locked-down ` ` ( ` ` even needed ) . react team apparently agrees , lint rule suggests destructure prop , would anyway break code expects ` prop ` passed back ` ` ! * * recommendation : lint rule treat function call form ` props.xxx ( ... ) ` expected dependency ` props.xxx ` ( instead ` prop ` ) . clear : done specifically ` prop ` , `` method '' style function call object ` prop ` continue linted current way . * * thank",
        "title_stopwords_removal_lemmatization": "[ react-hooks/exhaustive-deps ] special case prop callback"
    },
    {
        "issue_id": 589059162,
        "title": "Batching makes it difficult to perform imperative actions like focus",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-03-27T11:12:19Z",
        "status": "open",
        "description": "React version: 16.9.5\r\n\r\n## Steps To Reproduce\r\n\r\n1. Overwrite batched updates with the following code: `ReactDOM.unstable_batchedUpdates = callback => callback()`\r\n2. Batched updates aren't actually overwritten.\r\n\r\n## Reasoning\r\n\r\nI recognize that this may not be classified as bug because it isn't a documented feature but I have tried to search for a different solution but to no avail. Fixing this behavior can open a new way of using React. I tried writing on [Stack Overflow](https://stackoverflow.com/questions/60852219/disable-unstable-batchedupdates-on-event-handlers-in-react) and writing to [@gaearon](https://twitter.com/antoniostoilkov/status/1242789762307588097).\r\n\r\nI have a number of arguments which support the disabling of batched updates in event handlers and in effects initialization. If anybody is willing to read a document and consider this scenario I am willing to write an RFC.",
        "remove_template_description": "React version: 16.9.5        1. Overwrite batched updates with the following code: `ReactDOM.unstable_batchedUpdates = callback => callback()`  2. Batched updates aren't actually overwritten.    ## Reasoning    I recognize that this may not be classified as bug because it isn't a documented feature but I have tried to search for a different solution but to no avail. Fixing this behavior can open a new way of using React. I tried writing on [Stack Overflow](https://stackoverflow.com/questions/60852219/disable-unstable-batchedupdates-on-event-handlers-in-react) and writing to [@gaearon](https://twitter.com/antoniostoilkov/status/1242789762307588097).    I have a number of arguments which support the disabling of batched updates in event handlers and in effects initialization. If anybody is willing to read a document and consider this scenario I am willing to write an RFC.",
        "human_words": "React version: 16.9.5        1. Overwrite batched updates with the following code: `ReactDOM.unstable_batchedUpdates = callback => callback()`  2. Batched updates aren't actually overwritten.    ## Reasoning    I recognize that this may not be classified as bug because it isn't a documented feature but I have tried to search for a different solution but to no avail. Fixing this behavior can open a new way of using React. I tried writing on [Stack Overflow](https://stackoverflow.com/questions/60852219/disable-unstable-batchedupdates-on-event-handlers-in-react) and writing to [@gaearon](https://twitter.com/antoniostoilkov/status/1242789762307588097).    I have a number of arguments which support the disabling of batched updates in event handlers and in effects initialization. If anybody is willing to read a document and consider this scenario I am willing to write an RFC.",
        "human_words_regrex": "React version: 16.9.5 1. Overwrite batched updates with the following code: `ReactDOM.unstable_batchedUpdates = callback => callback()` 2. Batched updates aren't actually overwritten. ## Reasoning I recognize that this may not be classified as bug because it isn't a documented feature but I have tried to search for a different solution but to no avail. Fixing this behavior can open a new way of using React. I tried writing on  and writing to . I have a number of arguments which support the disabling of batched updates in event handlers and in effects initialization. If anybody is willing to read a document and consider this scenario I am willing to write an RFC.",
        "human_words_stopwords_removal_lemmatization": "react version : 16.9.5 1. overwrite batched update following code : ` reactdom.unstable_batchedupdates = callback = > callback ( ) ` 2. batched update n't actually overwritten . # # reasoning recognize may classified bug n't documented feature tried search different solution avail . fixing behavior open new way using react . tried writing writing . number argument support disabling batched update event handler effect initialization . anybody willing read document consider scenario willing write rfc .",
        "title_stopwords_removal_lemmatization": "batching make difficult perform imperative action like focus"
    },
    {
        "issue_id": 578146174,
        "title": "Bug: renderToStaticMarkup throw warning about SVG PascalCase and camelCase naming",
        "label": [
            "SVG",
            "Type: Discussion"
        ],
        "date": "2020-03-09T19:40:32Z",
        "status": "closed",
        "description": "React version: 16.12.0\r\n\r\nError: `Warning: <linearGradient /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.`\r\n\r\n## The current behavior\r\nAny `SVG`-inside node(`LinearGradient`, `feDropShadow`, etc), that should be in PascalCase/camelCase inside HTML indeed, throw me a warning above through React's `import { renderToStaticMarkup } from 'react-dom/server'`  `renderToStaticMarkup` method. \r\n\r\nI use renderToStaticMarkup to parse and then insert its DOM inside global HTML (don't ask me why :) ) on client-side, not SSR.\r\n\r\n## The expected behavior\r\nShould not throw any warnings and render SVG-in tags in PascalCase without any efforts and tears in fact.\r\n\r\nThanks.\r\n\r\nP.S.\r\nI saw this report, but it seems like it doesn't fix for some reason https://github.com/facebook/react/issues/10415 ...",
        "remove_template_description": "React version: 16.12.0    Error: `Warning: <linearGradient /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.`      Any `SVG`-inside node(`LinearGradient`, `feDropShadow`, etc), that should be in PascalCase/camelCase inside HTML indeed, throw me a warning above through React's `import { renderToStaticMarkup } from 'react-dom/server'`  `renderToStaticMarkup` method.     I use renderToStaticMarkup to parse and then insert its DOM inside global HTML (don't ask me why :) ) on client-side, not SSR.      Should not throw any warnings and render SVG-in tags in PascalCase without any efforts and tears in fact.    Thanks.    P.S.  I saw this report, but it seems like it doesn't fix for some reason https://github.com/facebook/react/issues/10415 ...",
        "human_words": "React version: 16.12.0    Error: `Warning: <linearGradient /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.`      Any `SVG`-inside node(`LinearGradient`, `feDropShadow`, etc), that should be in PascalCase/camelCase inside HTML indeed, throw me a warning above through React's `import { renderToStaticMarkup } from 'react-dom/server'`  `renderToStaticMarkup` method.     I use renderToStaticMarkup to parse and then insert its DOM inside global HTML (don't ask me why :) ) on client-side, not SSR.      Should not throw any warnings and render SVG-in tags in PascalCase without any efforts and tears in fact.    Thanks.    P.S.  I saw this report, but it seems like it doesn't fix for some reason https://github.com/facebook/react/issues/10415 ...",
        "human_words_regrex": "React version: 16.12.0 Error: `Warning:  is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.` Any `SVG`-inside node(`LinearGradient`, `feDropShadow`, etc), that should be in PascalCase/camelCase inside HTML indeed, throw me a warning above through React's `import { renderToStaticMarkup } from 'react-dom/server'` `renderToStaticMarkup` method. I use renderToStaticMarkup to parse and then insert its DOM inside global HTML (don't ask me why :) ) on client-side, not SSR. Should not throw any warnings and render SVG-in tags in PascalCase without any efforts and tears in fact. Thanks. P.S. I saw this report, but it seems like it doesn't fix for some reason  ...",
        "human_words_stopwords_removal_lemmatization": "react version : 16.12.0 error : ` warning : using incorrect casing . use pascalcase react component , lowercase html elements. ` ` svg ` -inside node ( ` lineargradient ` , ` fedropshadow ` , etc ) , pascalcase/camelcase inside html indeed , throw warning react 's ` import { rendertostaticmarkup } 'react-dom/server ' ` ` rendertostaticmarkup ` method . use rendertostaticmarkup parse insert dom inside global html ( n't ask : ) ) client-side , ssr . throw warning render svg-in tag pascalcase without effort tear fact . thanks . p.s . saw report , seems like n't fix reason ...",
        "title_stopwords_removal_lemmatization": "bug : rendertostaticmarkup throw warning svg pascalcase camelcase naming"
    },
    {
        "issue_id": 572818021,
        "title": "Bug: too hard to fix \"Cannot update a component from inside the function body of a different component.\"",
        "label": [
            "Type: Discussion"
        ],
        "date": "2020-02-28T15:15:25Z",
        "status": "closed",
        "description": "#  Note: React 16.13.1 fixed some cases where this was overfiring. If upgrading React and ReactDOM to 16.13.1 doesn't fix the warning, read this: https://github.com/facebook/react/issues/18178#issuecomment-595846312\r\n----\r\n\r\nReact version:\r\n\r\n16.13.0\r\n\r\n## Steps To Reproduce\r\n\r\n1. Build a time machine.\r\n2. Go to the year 2017.\r\n3. Build a huge application of 10K lines of code.\r\n4. Get 80 (!) dependencies at package.json file including ones that become no longer maintained.\r\n5. Update React to the latest version at February 27, 2020.\r\n6. Get tons of errors that you don't know how to fix.\r\n7. Tell your client that fixes are going to take unknown time and it's going to cost $$$ + days or weeks of investigation or we're going to get stuck with the outdated version of React and related libraries forever which will cost more $$$ but later.\r\n\r\nBeing serious, the business I work for isn't interested on that at all. Obviously I'd never made it happen to get such warnings to appear if I'd get them earlier. Currently that's impossibly hard to make the errors to be fixed because I get them at many different cases and with a huge stack trace. I tried to fix at least one of the appearing errors and it already took a lot of time. I tried to debug some of used libraries but got no luck. \r\n\r\nJust one example:\r\n\r\n![image](https://user-images.githubusercontent.com/1082083/75559100-8fcf5c80-5a4b-11ea-8173-4f0a62cc5de3.png)\r\n\r\nThere we can notice the use of an outdated react-router, an outdated redux-connect (which I had to put to the project source to fix errors of outdated `componentWillReceiveProps` method), some HOCs created by recompose etc. It isn't just a simple virtual DOM tree where I can walk thru components developed by me and search by `setState` string to fix the bug, that's way more complicated than that.\r\n\r\nPlease make an \"UNSAFE\" option to disable this error or provide a simpler way to find where the error is thrown \ud83d\ude4f\r\n\r\n",
        "remove_template_description": "#  Note: React 16.13.1 fixed some cases where this was overfiring. If upgrading React and ReactDOM to 16.13.1 doesn't fix the warning, read this: https://github.com/facebook/react/issues/18178#issuecomment-595846312  ----    React version:    16.13.0        1. Build a time machine.  2. Go to the year 2017.  3. Build a huge application of 10K lines of code.  4. Get 80 (!) dependencies at package.json file including ones that become no longer maintained.  5. Update React to the latest version at February 27, 2020.  6. Get tons of errors that you don't know how to fix.  7. Tell your client that fixes are going to take unknown time and it's going to cost $$$ + days or weeks of investigation or we're going to get stuck with the outdated version of React and related libraries forever which will cost more $$$ but later.    Being serious, the business I work for isn't interested on that at all. Obviously I'd never made it happen to get such warnings to appear if I'd get them earlier. Currently that's impossibly hard to make the errors to be fixed because I get them at many different cases and with a huge stack trace. I tried to fix at least one of the appearing errors and it already took a lot of time. I tried to debug some of used libraries but got no luck.     Just one example:    ![image](https://user-images.githubusercontent.com/1082083/75559100-8fcf5c80-5a4b-11ea-8173-4f0a62cc5de3.png)    There we can notice the use of an outdated react-router, an outdated redux-connect (which I had to put to the project source to fix errors of outdated `componentWillReceiveProps` method), some HOCs created by recompose etc. It isn't just a simple virtual DOM tree where I can walk thru components developed by me and search by `setState` string to fix the bug, that's way more complicated than that.    Please make an \"UNSAFE\" option to disable this error or provide a simpler way to find where the error is thrown \ud83d\ude4f",
        "human_words": "#  Note: React 16.13.1 fixed some cases where this was overfiring. If upgrading React and ReactDOM to 16.13.1 doesn't fix the warning, read this: https://github.com/facebook/react/issues/18178#issuecomment-595846312  ----    React version:    16.13.0        1. Build a time machine.  2. Go to the year 2017.  3. Build a huge application of 10K lines of code.  4. Get 80 (!) dependencies at package.json file including ones that become no longer maintained.  5. Update React to the latest version at February 27, 2020.  6. Get tons of errors that you don't know how to fix.  7. Tell your client that fixes are going to take unknown time and it's going to cost $$$ + days or weeks of investigation or we're going to get stuck with the outdated version of React and related libraries forever which will cost more $$$ but later.    Being serious, the business I work for isn't interested on that at all. Obviously I'd never made it happen to get such warnings to appear if I'd get them earlier. Currently that's impossibly hard to make the errors to be fixed because I get them at many different cases and with a huge stack trace. I tried to fix at least one of the appearing errors and it already took a lot of time. I tried to debug some of used libraries but got no luck.     Just one example:    ![image](https://user-images.githubusercontent.com/1082083/75559100-8fcf5c80-5a4b-11ea-8173-4f0a62cc5de3.png)    There we can notice the use of an outdated react-router, an outdated redux-connect (which I had to put to the project source to fix errors of outdated `componentWillReceiveProps` method), some HOCs created by recompose etc. It isn't just a simple virtual DOM tree where I can walk thru components developed by me and search by `setState` string to fix the bug, that's way more complicated than that.    Please make an \"UNSAFE\" option to disable this error or provide a simpler way to find where the error is thrown \ud83d\ude4f",
        "human_words_regrex": "# Note: React 16.13.1 fixed some cases where this was overfiring. If upgrading React and ReactDOM to 16.13.1 doesn't fix the warning, read this:  ---- React version: 16.13.0 1. Build a time machine. 2. Go to the year 2017. 3. Build a huge application of 10K lines of code. 4. Get 80 (!) dependencies at package.json file including ones that become no longer maintained. 5. Update React to the latest version at February 27, 2020. 6. Get tons of errors that you don't know how to fix. 7. Tell your client that fixes are going to take unknown time and it's going to cost $$$ + days or weeks of investigation or we're going to get stuck with the outdated version of React and related libraries forever which will cost more $$$ but later. Being serious, the business I work for isn't interested on that at all. Obviously I'd never made it happen to get such warnings to appear if I'd get them earlier. Currently that's impossibly hard to make the errors to be fixed because I get them at many different cases and with a huge stack trace. I tried to fix at least one of the appearing errors and it already took a lot of time. I tried to debug some of used libraries but got no luck. Just one example: ! There we can notice the use of an outdated react-router, an outdated redux-connect (which I had to put to the project source to fix errors of outdated `componentWillReceiveProps` method), some HOCs created by recompose etc. It isn't just a simple virtual DOM tree where I can walk thru components developed by me and search by `setState` string to fix the bug, that's way more complicated than that. Please make an \"UNSAFE\" option to disable this error or provide a simpler way to find where the error is thrown \ud83d\ude4f",
        "human_words_stopwords_removal_lemmatization": "# note : react 16.13.1 fixed case overfiring . upgrading react reactdom 16.13.1 n't fix warning , read : -- -- react version : 16.13.0 1. build time machine . 2. go year 2017 . 3. build huge application 10k line code . 4. get 80 ( ! ) dependency package.json file including one become longer maintained . 5. update react latest version february 27 , 2020 . 6. get ton error n't know fix . 7. tell client fix going take unknown time 's going cost $ $ $ + day week investigation 're going get stuck outdated version react related library forever cost $ $ $ later . serious , business work n't interested . obviously 'd never made happen get warning appear 'd get earlier . currently 's impossibly hard make error fixed get many different case huge stack trace . tried fix least one appearing error already took lot time . tried debug used library got luck . one example : ! notice use outdated react-router , outdated redux-connect ( put project source fix error outdated ` componentwillreceiveprops ` method ) , hocs created recompose etc . n't simple virtual dom tree walk thru component developed search ` setstate ` string fix bug , 's way complicated . please make `` unsafe '' option disable error provide simpler way find error thrown \ud83d\ude4f",
        "title_stopwords_removal_lemmatization": "bug : hard fix `` update component inside function body different component . ''"
    },
    {
        "issue_id": 554247999,
        "title": "Bug: styles object using css variables and both a shorthand and a specific property renders incorrectly",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2020-01-23T15:58:13Z",
        "status": "open",
        "description": "React does not produce the correct css inline styles when using css variables for both the shorthand property and another specific one (like `padding` and `paddingRight`).\r\n\r\nThe styles object:\r\n\r\n```js\r\n{\r\n  padding: \"calc(var(--spacing) * 1)\",\r\n  paddingRight: \"calc(var(--spacing) * 3)\",\r\n  paddingBottom: \"calc(var(--spacing) * 4)\"\r\n};\r\n```\r\nproduces the following styles:\r\n\r\n![image](https://user-images.githubusercontent.com/23476208/72995030-1d39e400-3df0-11ea-9235-0e6ad00718b2.png)\r\n\r\nand the following html:\r\n```html\r\n<span style=\"padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;\">App</span>\r\n```\r\n\r\neven though the computed properties tab of the dev-tools appear to be correct and the padding is properly rendered in the screen:\r\n\r\n![image](https://user-images.githubusercontent.com/23476208/72995225-6e49d800-3df0-11ea-9770-98f062008ca3.png)\r\n\r\nIf I remove the css-variable, everything works as expected.\r\n\r\n**React version**: From v15.0.0 to 16.12.0\r\n\r\n_Note_: Below v15.0.0 the styles are correctly produced:\r\n\r\n```html\r\n<span style=\"padding:calc(var(--spacing) * 1);padding-right:calc(var(--spacing) * 3);padding-bottom:calc(var(--spacing) * 4);\">App</span>\r\n```\r\n\r\n\r\n## Steps To Reproduce\r\n\r\n1. Add a style object to a component that has both a property shorthand and a specific one (like `padding` and `paddingRight`) and uses a css variable (like `var(--spacing)`.\r\n2. Render that component and inspect using dev-tools.\r\n\r\nLink to code example: https://codesandbox.io/s/heuristic-wood-bjr1y\r\n\r\nstyles object:\r\n```js\r\n{\r\n  padding: \"calc(var(--spacing) * 1)\",\r\n  paddingRight: \"calc(var(--spacing) * 3)\",\r\n  paddingBottom: \"calc(var(--spacing) * 4)\"\r\n};\r\n```\r\n## The current behavior\r\n\r\nReact does not produces the correct css inline styles when using css variables for both the shorthand property and another specific one:\r\n\r\n```html\r\n<span style=\"padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;\">App</span>\r\n```\r\n\r\n## The expected behavior\r\n\r\nInline styles using css variables that have both a shorthand and a specific one should produce the correct styles.\r\n```html\r\n<span style=\"padding: calc(var(--spacing) * 1); padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4);\">App</span>\r\n```",
        "remove_template_description": "React does not produce the correct css inline styles when using css variables for both the shorthand property and another specific one (like `padding` and `paddingRight`).    The styles object:    ```js  {    padding: \"calc(var(--spacing) * 1)\",    paddingRight: \"calc(var(--spacing) * 3)\",    paddingBottom: \"calc(var(--spacing) * 4)\"  };  ```  produces the following styles:    ![image](https://user-images.githubusercontent.com/23476208/72995030-1d39e400-3df0-11ea-9235-0e6ad00718b2.png)    and the following html:  ```html  <span style=\"padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;\">App</span>  ```    even though the computed properties tab of the dev-tools appear to be correct and the padding is properly rendered in the screen:    ![image](https://user-images.githubusercontent.com/23476208/72995225-6e49d800-3df0-11ea-9770-98f062008ca3.png)    If I remove the css-variable, everything works as expected.    **React version**: From v15.0.0 to 16.12.0    _Note_: Below v15.0.0 the styles are correctly produced:    ```html  <span style=\"padding:calc(var(--spacing) * 1);padding-right:calc(var(--spacing) * 3);padding-bottom:calc(var(--spacing) * 4);\">App</span>  ```          1. Add a style object to a component that has both a property shorthand and a specific one (like `padding` and `paddingRight`) and uses a css variable (like `var(--spacing)`.  2. Render that component and inspect using dev-tools.    Link to code example: https://codesandbox.io/s/heuristic-wood-bjr1y    styles object:  ```js  {    padding: \"calc(var(--spacing) * 1)\",    paddingRight: \"calc(var(--spacing) * 3)\",    paddingBottom: \"calc(var(--spacing) * 4)\"  };  ```      React does not produces the correct css inline styles when using css variables for both the shorthand property and another specific one:    ```html  <span style=\"padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;\">App</span>  ```        Inline styles using css variables that have both a shorthand and a specific one should produce the correct styles.  ```html  <span style=\"padding: calc(var(--spacing) * 1); padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4);\">App</span>  ```",
        "human_words": "React does not produce the correct css inline styles when using css variables for both the shorthand property and another specific one (like `padding` and `paddingRight`).    The styles object:      produces the following styles:    ![image](https://user-images.githubusercontent.com/23476208/72995030-1d39e400-3df0-11ea-9235-0e6ad00718b2.png)    and the following html:      even though the computed properties tab of the dev-tools appear to be correct and the padding is properly rendered in the screen:    ![image](https://user-images.githubusercontent.com/23476208/72995225-6e49d800-3df0-11ea-9770-98f062008ca3.png)    If I remove the css-variable, everything works as expected.    **React version**: From v15.0.0 to 16.12.0    _Note_: Below v15.0.0 the styles are correctly produced:              1. Add a style object to a component that has both a property shorthand and a specific one (like `padding` and `paddingRight`) and uses a css variable (like `var(--spacing)`.  2. Render that component and inspect using dev-tools.    Link to code example: https://codesandbox.io/s/heuristic-wood-bjr1y    styles object:        React does not produces the correct css inline styles when using css variables for both the shorthand property and another specific one:            Inline styles using css variables that have both a shorthand and a specific one should produce the correct styles.  ",
        "human_words_regrex": "React does not produce the correct css inline styles when using css variables for both the shorthand property and another specific one (like `padding` and `paddingRight`). The styles object: produces the following styles: ! and the following html: even though the computed properties tab of the dev-tools appear to be correct and the padding is properly rendered in the screen: ! If I remove the css-variable, everything works as expected. **React version**: From v15.0.0 to 16.12.0 _Note_: Below v15.0.0 the styles are correctly produced: 1. Add a style object to a component that has both a property shorthand and a specific one (like `padding` and `paddingRight`) and uses a css variable (like `var(--spacing)`. 2. Render that component and inspect using dev-tools. Link to code example:  styles object: React does not produces the correct css inline styles when using css variables for both the shorthand property and another specific one: Inline styles using css variables that have both a shorthand and a specific one should produce the correct styles. ",
        "human_words_stopwords_removal_lemmatization": "react produce correct cs inline style using cs variable shorthand property another specific one ( like ` padding ` ` paddingright ` ) . style object : produce following style : ! following html : even though computed property tab dev-tools appear correct padding properly rendered screen : ! remove css-variable , everything work expected . * * react version * * : v15.0.0 16.12.0 _note_ : v15.0.0 style correctly produced : 1. add style object component property shorthand specific one ( like ` padding ` ` paddingright ` ) us cs variable ( like ` var ( -- spacing ) ` . 2. render component inspect using dev-tools . link code example : style object : react produce correct cs inline style using cs variable shorthand property another specific one : inline style using cs variable shorthand specific one produce correct style .",
        "title_stopwords_removal_lemmatization": "bug : style object using cs variable shorthand specific property render incorrectly"
    },
    {
        "issue_id": 551971613,
        "title": "Bug: React.Node should not have `true`, or PropTypes.node warns it",
        "label": [
            "Status: Unconfirmed",
            "Type: Discussion"
        ],
        "date": "2020-01-19T19:30:36Z",
        "status": "closed",
        "description": "React version: 16.8.6\r\n\r\n## Steps To Reproduce\r\n\r\n```js\r\nimport PropTypes from 'prop-types';\r\n\r\ntype Props = {\r\n  component: React.Node\r\n};\r\n\r\nfunction Container(props: Props) {\r\n  return ...;\r\n}\r\n\r\nContainer.propTypes = {\r\n  component: PropTypes.node\r\n}\r\n\r\n<Container component={true} />\r\n```\r\n\r\n## The current behavior\r\n\r\nFlow does not emit error (as React.Node accepts `true`), but PropTypes.node emits below runtime error in browser's console.\r\n\r\n```\r\nInvalid prop `component` supplied to `Container`, expected a ReactNode.\r\n```\r\n\r\n## The expected behavior\r\n\r\nFlow emits type error.\r\n\r\n----\r\n\r\n[According to a maintainer of prop-types](https://github.com/facebook/prop-types/issues/310#issuecomment-574986751), formerly React itself did not accept `true` for JSX node (in flow `React.Node`) (so not changing prop-types for now), is it right?",
        "remove_template_description": "React version: 16.8.6        ```js  import PropTypes from 'prop-types';    type Props = {    component: React.Node  };    function Container(props: Props) {    return ...;  }    Container.propTypes = {    component: PropTypes.node  }    <Container component={true} />  ```        Flow does not emit error (as React.Node accepts `true`), but PropTypes.node emits below runtime error in browser's console.    ```  Invalid prop `component` supplied to `Container`, expected a ReactNode.  ```        Flow emits type error.    ----    [According to a maintainer of prop-types](https://github.com/facebook/prop-types/issues/310#issuecomment-574986751), formerly React itself did not accept `true` for JSX node (in flow `React.Node`) (so not changing prop-types for now), is it right?",
        "human_words": "React version: 16.8.6                Flow does not emit error (as React.Node accepts `true`), but PropTypes.node emits below runtime error in browser's console.            Flow emits type error.    ----    [According to a maintainer of prop-types](https://github.com/facebook/prop-types/issues/310#issuecomment-574986751), formerly React itself did not accept `true` for JSX node (in flow `React.Node`) (so not changing prop-types for now), is it right?",
        "human_words_regrex": "React version: 16.8.6 Flow does not emit error (as React.Node accepts `true`), but PropTypes.node emits below runtime error in browser's console. Flow emits type error. ---- , formerly React itself did not accept `true` for JSX node (in flow `React.Node`) (so not changing prop-types for now), is it right?",
        "human_words_stopwords_removal_lemmatization": "react version : 16.8.6 flow emit error ( react.node accepts ` true ` ) , proptypes.node emits runtime error browser 's console . flow emits type error . -- -- , formerly react accept ` true ` jsx node ( flow ` react.node ` ) ( changing prop-types ) , right ?",
        "title_stopwords_removal_lemmatization": "bug : react.node ` true ` , proptypes.node warns"
    },
    {
        "issue_id": 547566125,
        "title": "Get Dom Element by Component Name",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2020-01-09T15:56:37Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?** Feature\r\n\r\n**What is the current behavior?**\r\n\r\nReact dev tools has the very useful \"inspect dom node\" feature that ties a component in your tree to its particular dom node.\r\n\r\n**What is the expected behavior?**\r\n\r\nIn e2e testing scenarios using tools such as cypress I often find myself sprinkling data test id attributes throughout my code to select certain elements with which to do various assertions. I've found that these test id attributes closely mirror the component hierarchy. Instead of needing to declare this essentially duplicate information it would be useful if there was a utility which allowed me to programmatically retrieve a dom node that corresponds to a particular component's name for testing purposes. Ideally, this would essentially mirror the functionality of the \"inspect dom node\" feature in react dev tools.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?** Feature    **What is the current behavior?**    React dev tools has the very useful \"inspect dom node\" feature that ties a component in your tree to its particular dom node.    **What is the expected behavior?**    In e2e testing scenarios using tools such as cypress I often find myself sprinkling data test id attributes throughout my code to select certain elements with which to do various assertions. I've found that these test id attributes closely mirror the component hierarchy. Instead of needing to declare this essentially duplicate information it would be useful if there was a utility which allowed me to programmatically retrieve a dom node that corresponds to a particular component's name for testing purposes. Ideally, this would essentially mirror the functionality of the \"inspect dom node\" feature in react dev tools.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?** Feature    **What is the current behavior?**    React dev tools has the very useful \"inspect dom node\" feature that ties a component in your tree to its particular dom node.    **What is the expected behavior?**    In e2e testing scenarios using tools such as cypress I often find myself sprinkling data test id attributes throughout my code to select certain elements with which to do various assertions. I've found that these test id attributes closely mirror the component hierarchy. Instead of needing to declare this essentially duplicate information it would be useful if there was a utility which allowed me to programmatically retrieve a dom node that corresponds to a particular component's name for testing purposes. Ideally, this would essentially mirror the functionality of the \"inspect dom node\" feature in react dev tools.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** React dev tools has the very useful \"inspect dom node\" feature that ties a component in your tree to its particular dom node. **What is the expected behavior?** In e2e testing scenarios using tools such as cypress I often find myself sprinkling data test id attributes throughout my code to select certain elements with which to do various assertions. I've found that these test id attributes closely mirror the component hierarchy. Instead of needing to declare this essentially duplicate information it would be useful if there was a utility which allowed me to programmatically retrieve a dom node that corresponds to a particular component's name for testing purposes. Ideally, this would essentially mirror the functionality of the \"inspect dom node\" feature in react dev tools.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * react dev tool useful `` inspect dom node '' feature tie component tree particular dom node . * * expected behavior ? * * e2e testing scenario using tool cypress often find sprinkling data test id attribute throughout code select certain element various assertion . 've found test id attribute closely mirror component hierarchy . instead needing declare essentially duplicate information would useful utility allowed programmatically retrieve dom node corresponds particular component 's name testing purpose . ideally , would essentially mirror functionality `` inspect dom node '' feature react dev tool .",
        "title_stopwords_removal_lemmatization": "get dom element component name"
    },
    {
        "issue_id": 545317342,
        "title": "SuspenseList tail property not working on re-renders",
        "label": [
            "Type: Discussion",
            "Component: Suspense",
            "Component: Concurrent Features"
        ],
        "date": "2020-01-04T18:44:35Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nI am reporting a possible bug or otherwise requesting clarification.\r\n\r\n**What is the current behavior?**\r\n\r\nWhen a component with a SuspenseList re-renders (such as when it is is passed a new resource), the SuspenseList component still  respects the revealOrder=\"forwards\" or revealOrder=\"backwards\" prop but does not respect the tail=\"collapsed\" or tail=\"hidden\" prop.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nhttps://codesandbox.io/s/exciting-cherry-g9uc9\r\n\r\nIn order to see bug: \r\n1) Refresh the Code Sandbox browser and see that \"Loading profile...\" displays and \"Loading posts...\" does not due to the tail being collapsed.  This is the expected behavior.\r\n2) Press the \"Next\" button.  Both \"Loading Profile...\" and \"Loading posts...\" display.  The tail is no longer collapsed.\r\n\r\n**What is the expected behavior?**\r\n\r\nThe expected behavior would be for the tail to be collapsed when pressing the \"Next\" button. \"Loading profile...\" should be displayed, but not \"Loading posts...\"\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nThis affects only the experimental Concurrent Mode build of React.\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    I am reporting a possible bug or otherwise requesting clarification.    **What is the current behavior?**    When a component with a SuspenseList re-renders (such as when it is is passed a new resource), the SuspenseList component still  respects the revealOrder=\"forwards\" or revealOrder=\"backwards\" prop but does not respect the tail=\"collapsed\" or tail=\"hidden\" prop.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/exciting-cherry-g9uc9    In order to see bug:   1) Refresh the Code Sandbox browser and see that \"Loading profile...\" displays and \"Loading posts...\" does not due to the tail being collapsed.  This is the expected behavior.  2) Press the \"Next\" button.  Both \"Loading Profile...\" and \"Loading posts...\" display.  The tail is no longer collapsed.    **What is the expected behavior?**    The expected behavior would be for the tail to be collapsed when pressing the \"Next\" button. \"Loading profile...\" should be displayed, but not \"Loading posts...\"    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This affects only the experimental Concurrent Mode build of React.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    I am reporting a possible bug or otherwise requesting clarification.    **What is the current behavior?**    When a component with a SuspenseList re-renders (such as when it is is passed a new resource), the SuspenseList component still  respects the revealOrder=\"forwards\" or revealOrder=\"backwards\" prop but does not respect the tail=\"collapsed\" or tail=\"hidden\" prop.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/exciting-cherry-g9uc9    In order to see bug:   1) Refresh the Code Sandbox browser and see that \"Loading profile...\" displays and \"Loading posts...\" does not due to the tail being collapsed.  This is the expected behavior.  2) Press the \"Next\" button.  Both \"Loading Profile...\" and \"Loading posts...\" display.  The tail is no longer collapsed.    **What is the expected behavior?**    The expected behavior would be for the tail to be collapsed when pressing the \"Next\" button. \"Loading profile...\" should be displayed, but not \"Loading posts...\"    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This affects only the experimental Concurrent Mode build of React.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** I am reporting a possible bug or otherwise requesting clarification. **What is the current behavior?** When a component with a SuspenseList re-renders (such as when it is is passed a new resource), the SuspenseList component still respects the revealOrder=\"forwards\" or revealOrder=\"backwards\" prop but does not respect the tail=\"collapsed\" or tail=\"hidden\" prop. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:**  In order to see bug: 1) Refresh the Code Sandbox browser and see that \"Loading profile...\" displays and \"Loading posts...\" does not due to the tail being collapsed. This is the expected behavior. 2) Press the \"Next\" button. Both \"Loading Profile...\" and \"Loading posts...\" display. The tail is no longer collapsed. **What is the expected behavior?** The expected behavior would be for the tail to be collapsed when pressing the \"Next\" button. \"Loading profile...\" should be displayed, but not \"Loading posts...\" **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** This affects only the experimental Concurrent Mode build of React.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * reporting possible bug otherwise requesting clarification . * * current behavior ? * * component suspenselist re-renders ( passed new resource ) , suspenselist component still respect revealorder= '' forward '' revealorder= '' backwards '' prop respect tail= '' collapsed '' tail= '' hidden '' prop . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * order see bug : 1 ) refresh code sandbox browser see `` loading profile ... '' display `` loading post ... '' due tail collapsed . expected behavior . 2 ) press `` next '' button . `` loading profile ... '' `` loading post ... '' display . tail longer collapsed . * * expected behavior ? * * expected behavior would tail collapsed pressing `` next '' button . `` loading profile ... '' displayed , `` loading post ... '' * * version react , browser / o affected issue ? work previous version react ? * * affect experimental concurrent mode build react .",
        "title_stopwords_removal_lemmatization": "suspenselist tail property working re-renders"
    },
    {
        "issue_id": 537427200,
        "title": "DevTools: Profiler: Enable correlating console logs to profiler output (and vice versa)",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "Type: Needs Investigation"
        ],
        "date": "2019-12-13T09:01:35Z",
        "status": "open",
        "description": "A challenge with the React DevTools profiler is that it's too hard to correlate profiler results with console logs. This makes diagnosing and fixing render performance issues much more difficult.\r\n\r\nFor example, yesterday I was debugging an app where each render usually took 10ms-20ms except every 20-30 renders it'd take 600-800ms.  It was frustrating that I didn't have a way to correlate the profiler UI (which told me which renders were problematic) with the verbose console log output that might tell me exactly what went wrong during those renders. Instead I had to comb through logs and guess which output came from \"bad\" renders. This was tedious and error-prone.\r\n\r\nAnyway, my proposal is for React DevTools to make it easy to correlate profiler results with console log output.  Both directions would be useful:\r\n1) **navigate from logs to profiler** - if I see a suspicious line in the logs, I'd like to easily navigate to the profiler with the specific component/commit selected that was running when the line was logged.\r\n2) **navigate from profiler to logs** - if I see a suspiciously long commit, I'd like to select it in the profiler pane and have an easy way to see associated logs.\r\n\r\nI don't have a strong opinion about how this should be accomplished, but below are a few ideas to spur discussion.\r\n\r\nA minimal solution could be something like this: \r\na) The profiler assigns a unique ID to each commit\r\nb) The profiler's right pane would show the ID for each commit\r\nc) React would add a new hook that'd return that ID\r\nd) Userland code could include the ID in logs.\r\n\r\nJust this minimal support would be a vast improvement.\r\n\r\nIf we wanted to make it smoother, here's a few ideas that could be layered on top.\r\n\r\n1. **Profiler->Console Links** The ID in the profiler UI could be a hyperlink that'd open the console drawer and put the ID in the console's CMD+F search box. This would be one-click navigation from profiler to logs. I don't know if Chrome allows this kind of cross-pane control, over the console UI so this might not be practical.\r\n\r\n2. **Console -> Profiler Links**  For one-click logging in the other direction., we could have a special URL format (e.g. `react://profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3`) that would enable userland code to emit links in the console that, when clicked, would navigate to the specific commit (in the profile pane) that was active when the logs were emitted. Similar caveat as above: I'm not sure if chrome extensions can be \"deeplinked\" like this. \r\n\r\n3. **Log Components Where** Building on (1) and (2) above, we could enable console<->profiler linking without requiring changes to userland code. We could have a profiler setting (e.g. \"log components where\" with UX like \"hide components where\") that, when active, would emit a line to the console log at the start of each render of a matching component. The output would link back to the profiler, e.g. \r\n`[RDT] Starting MyCoolComponent (react://profiler/commit/2c1056b51be143d4a1051d840cf4f9c3)`.\r\n\r\nWhat do you think? I'm unfamiliar with React and RDT internals so there might be much better ways to solve log<->profiler correlation than my naive ideas above. But at least I wanted to call out the problem and encourage discussion about a solution.\r\n",
        "remove_template_description": "A challenge with the React DevTools profiler is that it's too hard to correlate profiler results with console logs. This makes diagnosing and fixing render performance issues much more difficult.    For example, yesterday I was debugging an app where each render usually took 10ms-20ms except every 20-30 renders it'd take 600-800ms.  It was frustrating that I didn't have a way to correlate the profiler UI (which told me which renders were problematic) with the verbose console log output that might tell me exactly what went wrong during those renders. Instead I had to comb through logs and guess which output came from \"bad\" renders. This was tedious and error-prone.    Anyway, my proposal is for React DevTools to make it easy to correlate profiler results with console log output.  Both directions would be useful:  1) **navigate from logs to profiler** - if I see a suspicious line in the logs, I'd like to easily navigate to the profiler with the specific component/commit selected that was running when the line was logged.  2) **navigate from profiler to logs** - if I see a suspiciously long commit, I'd like to select it in the profiler pane and have an easy way to see associated logs.    I don't have a strong opinion about how this should be accomplished, but below are a few ideas to spur discussion.    A minimal solution could be something like this:   a) The profiler assigns a unique ID to each commit  b) The profiler's right pane would show the ID for each commit  c) React would add a new hook that'd return that ID  d) Userland code could include the ID in logs.    Just this minimal support would be a vast improvement.    If we wanted to make it smoother, here's a few ideas that could be layered on top.    1. **Profiler->Console Links** The ID in the profiler UI could be a hyperlink that'd open the console drawer and put the ID in the console's CMD+F search box. This would be one-click navigation from profiler to logs. I don't know if Chrome allows this kind of cross-pane control, over the console UI so this might not be practical.    2. **Console -> Profiler Links**  For one-click logging in the other direction., we could have a special URL format (e.g. `react://profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3`) that would enable userland code to emit links in the console that, when clicked, would navigate to the specific commit (in the profile pane) that was active when the logs were emitted. Similar caveat as above: I'm not sure if chrome extensions can be \"deeplinked\" like this.     3. **Log Components Where** Building on (1) and (2) above, we could enable console<->profiler linking without requiring changes to userland code. We could have a profiler setting (e.g. \"log components where\" with UX like \"hide components where\") that, when active, would emit a line to the console log at the start of each render of a matching component. The output would link back to the profiler, e.g.   `[RDT] Starting MyCoolComponent (react://profiler/commit/2c1056b51be143d4a1051d840cf4f9c3)`.    What do you think? I'm unfamiliar with React and RDT internals so there might be much better ways to solve log<->profiler correlation than my naive ideas above. But at least I wanted to call out the problem and encourage discussion about a solution.",
        "human_words": "A challenge with the React DevTools profiler is that it's too hard to correlate profiler results with console logs. This makes diagnosing and fixing render performance issues much more difficult.    For example, yesterday I was debugging an app where each render usually took 10ms-20ms except every 20-30 renders it'd take 600-800ms.  It was frustrating that I didn't have a way to correlate the profiler UI (which told me which renders were problematic) with the verbose console log output that might tell me exactly what went wrong during those renders. Instead I had to comb through logs and guess which output came from \"bad\" renders. This was tedious and error-prone.    Anyway, my proposal is for React DevTools to make it easy to correlate profiler results with console log output.  Both directions would be useful:  1) **navigate from logs to profiler** - if I see a suspicious line in the logs, I'd like to easily navigate to the profiler with the specific component/commit selected that was running when the line was logged.  2) **navigate from profiler to logs** - if I see a suspiciously long commit, I'd like to select it in the profiler pane and have an easy way to see associated logs.    I don't have a strong opinion about how this should be accomplished, but below are a few ideas to spur discussion.    A minimal solution could be something like this:   a) The profiler assigns a unique ID to each commit  b) The profiler's right pane would show the ID for each commit  c) React would add a new hook that'd return that ID  d) Userland code could include the ID in logs.    Just this minimal support would be a vast improvement.    If we wanted to make it smoother, here's a few ideas that could be layered on top.    1. **Profiler->Console Links** The ID in the profiler UI could be a hyperlink that'd open the console drawer and put the ID in the console's CMD+F search box. This would be one-click navigation from profiler to logs. I don't know if Chrome allows this kind of cross-pane control, over the console UI so this might not be practical.    2. **Console -> Profiler Links**  For one-click logging in the other direction., we could have a special URL format (e.g. `react://profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3`) that would enable userland code to emit links in the console that, when clicked, would navigate to the specific commit (in the profile pane) that was active when the logs were emitted. Similar caveat as above: I'm not sure if chrome extensions can be \"deeplinked\" like this.     3. **Log Components Where** Building on (1) and (2) above, we could enable console<->profiler linking without requiring changes to userland code. We could have a profiler setting (e.g. \"log components where\" with UX like \"hide components where\") that, when active, would emit a line to the console log at the start of each render of a matching component. The output would link back to the profiler, e.g.   `[RDT] Starting MyCoolComponent (react://profiler/commit/2c1056b51be143d4a1051d840cf4f9c3)`.    What do you think? I'm unfamiliar with React and RDT internals so there might be much better ways to solve log<->profiler correlation than my naive ideas above. But at least I wanted to call out the problem and encourage discussion about a solution.",
        "human_words_regrex": "A challenge with the React DevTools profiler is that it's too hard to correlate profiler results with console logs. This makes diagnosing and fixing render performance issues much more difficult. For example, yesterday I was debugging an app where each render usually took 10ms-20ms except every 20-30 renders it'd take 600-800ms. It was frustrating that I didn't have a way to correlate the profiler UI (which told me which renders were problematic) with the verbose console log output that might tell me exactly what went wrong during those renders. Instead I had to comb through logs and guess which output came from \"bad\" renders. This was tedious and error-prone. Anyway, my proposal is for React DevTools to make it easy to correlate profiler results with console log output. Both directions would be useful: 1) **navigate from logs to profiler** - if I see a suspicious line in the logs, I'd like to easily navigate to the profiler with the specific component/commit selected that was running when the line was logged. 2) **navigate from profiler to logs** - if I see a suspiciously long commit, I'd like to select it in the profiler pane and have an easy way to see associated logs. I don't have a strong opinion about how this should be accomplished, but below are a few ideas to spur discussion. A minimal solution could be something like this: a) The profiler assigns a unique ID to each commit b) The profiler's right pane would show the ID for each commit c) React would add a new hook that'd return that ID d) Userland code could include the ID in logs. Just this minimal support would be a vast improvement. If we wanted to make it smoother, here's a few ideas that could be layered on top. 1. **Profiler->Console Links** The ID in the profiler UI could be a hyperlink that'd open the console drawer and put the ID in the console's CMD+F search box. This would be one-click navigation from profiler to logs. I don't know if Chrome allows this kind of cross-pane control, over the console UI so this might not be practical. 2. **Console -> Profiler Links** For one-click logging in the other direction., we could have a special URL format (e.g. `react://profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3`) that would enable userland code to emit links in the console that, when clicked, would navigate to the specific commit (in the profile pane) that was active when the logs were emitted. Similar caveat as above: I'm not sure if chrome extensions can be \"deeplinked\" like this. 3. **Log Components Where** Building on (1) and (2) above, we could enable consoleprofiler linking without requiring changes to userland code. We could have a profiler setting (e.g. \"log components where\" with UX like \"hide components where\") that, when active, would emit a line to the console log at the start of each render of a matching component. The output would link back to the profiler, e.g. `[RDT] Starting MyCoolComponent (react://profiler/commit/2c1056b51be143d4a1051d840cf4f9c3)`. What do you think? I'm unfamiliar with React and RDT internals so there might be much better ways to solve logprofiler correlation than my naive ideas above. But at least I wanted to call out the problem and encourage discussion about a solution.",
        "human_words_stopwords_removal_lemmatization": "challenge react devtools profiler 's hard correlate profiler result console log . make diagnosing fixing render performance issue much difficult . example , yesterday debugging app render usually took 10ms-20ms except every 20-30 render 'd take 600-800ms . frustrating n't way correlate profiler ui ( told render problematic ) verbose console log output might tell exactly went wrong render . instead comb log guess output came `` bad '' render . tedious error-prone . anyway , proposal react devtools make easy correlate profiler result console log output . direction would useful : 1 ) * * navigate log profiler * * - see suspicious line log , 'd like easily navigate profiler specific component/commit selected running line logged . 2 ) * * navigate profiler log * * - see suspiciously long commit , 'd like select profiler pane easy way see associated log . n't strong opinion accomplished , idea spur discussion . minimal solution could something like : ) profiler assigns unique id commit b ) profiler 's right pane would show id commit c ) react would add new hook 'd return id ) userland code could include id log . minimal support would vast improvement . wanted make smoother , 's idea could layered top . 1 . * * profiler- > console link * * id profiler ui could hyperlink 'd open console drawer put id console 's cmd+f search box . would one-click navigation profiler log . n't know chrome allows kind cross-pane control , console ui might practical . 2 . * * console - > profiler link * * one-click logging direction. , could special url format ( e.g . ` react : //profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3 ` ) would enable userland code emit link console , clicked , would navigate specific commit ( profile pane ) active log emitted . similar caveat : 'm sure chrome extension `` deeplinked '' like . 3 . * * log component * * building ( 1 ) ( 2 ) , could enable consoleprofiler linking without requiring change userland code . could profiler setting ( e.g . `` log component '' ux like `` hide component '' ) , active , would emit line console log start render matching component . output would link back profiler , e.g . ` [ rdt ] starting mycoolcomponent ( react : //profiler/commit/2c1056b51be143d4a1051d840cf4f9c3 ) ` . think ? 'm unfamiliar react rdt internals might much better way solve logprofiler correlation naive idea . least wanted call problem encourage discussion solution .",
        "title_stopwords_removal_lemmatization": "devtools : profiler : enable correlating console log profiler output ( vice versa )"
    },
    {
        "issue_id": 532696818,
        "title": "Triggering suspense with rejected promise causes re-render instead of error boundary",
        "label": [
            "Type: Discussion",
            "Component: Suspense"
        ],
        "date": "2019-12-04T13:49:31Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nThis *might* be a bug. @gaearon and @sebmarkbage shared differing opinions on it [in this twitter thread](https://twitter.com/dan_abramov/status/1202045662189228032)\r\n\r\n**What is the current behavior?**\r\n\r\nIf you throw a promise that rejects from a react component's render function, that rejection will be completely ignored. It will not show up in browser console, nor will it trigger a React error boundary. Instead, it will trigger a re-render (the same as if the promise had resolved).\r\n\r\n[Codepen example](https://codepen.io/joeldenning/pen/bGNNQJb?editors=1010)\r\n\r\n**What is the expected behavior?**\r\n\r\nMy expectation was that the error boundary would be hit and the component would not re-render. [Sebastian's tweet](https://twitter.com/sebmarkbage/status/1202055557718216705?s=20) indicates that that is not the desired behavior, though.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nThis impacts `react@experimental`, and also `react@>=16.9.0`",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    This *might* be a bug. @gaearon and @sebmarkbage shared differing opinions on it [in this twitter thread](https://twitter.com/dan_abramov/status/1202045662189228032)    **What is the current behavior?**    If you throw a promise that rejects from a react component's render function, that rejection will be completely ignored. It will not show up in browser console, nor will it trigger a React error boundary. Instead, it will trigger a re-render (the same as if the promise had resolved).    [Codepen example](https://codepen.io/joeldenning/pen/bGNNQJb?editors=1010)    **What is the expected behavior?**    My expectation was that the error boundary would be hit and the component would not re-render. [Sebastian's tweet](https://twitter.com/sebmarkbage/status/1202055557718216705?s=20) indicates that that is not the desired behavior, though.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This impacts `react@experimental`, and also `react@>=16.9.0`",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    This *might* be a bug. @gaearon and @sebmarkbage shared differing opinions on it [in this twitter thread](https://twitter.com/dan_abramov/status/1202045662189228032)    **What is the current behavior?**    If you throw a promise that rejects from a react component's render function, that rejection will be completely ignored. It will not show up in browser console, nor will it trigger a React error boundary. Instead, it will trigger a re-render (the same as if the promise had resolved).    [Codepen example](https://codepen.io/joeldenning/pen/bGNNQJb?editors=1010)    **What is the expected behavior?**    My expectation was that the error boundary would be hit and the component would not re-render. [Sebastian's tweet](https://twitter.com/sebmarkbage/status/1202055557718216705?s=20) indicates that that is not the desired behavior, though.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This impacts `react@experimental`, and also `react@>=16.9.0`",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** This *might* be a bug. @gaearon and @sebmarkbage shared differing opinions on it  **What is the current behavior?** If you throw a promise that rejects from a react component's render function, that rejection will be completely ignored. It will not show up in browser console, nor will it trigger a React error boundary. Instead, it will trigger a re-render (the same as if the promise had resolved).  **What is the expected behavior?** My expectation was that the error boundary would be hit and the component would not re-render.  indicates that that is not the desired behavior, though. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** This impacts `react@experimental`, and also `react@>=16.9.0`",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * * might * bug . @ gaearon @ sebmarkbage shared differing opinion * * current behavior ? * * throw promise reject react component 's render function , rejection completely ignored . show browser console , trigger react error boundary . instead , trigger re-render ( promise resolved ) . * * expected behavior ? * * expectation error boundary would hit component would re-render . indicates desired behavior , though . * * version react , browser / o affected issue ? work previous version react ? * * impact ` react @ experimental ` , also ` react @ > =16.9.0 `",
        "title_stopwords_removal_lemmatization": "triggering suspense rejected promise cause re-render instead error boundary"
    },
    {
        "issue_id": 529667125,
        "title": "Idea: extract \u201cstatic\u201d component subtrees to HTML during build",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-11-28T03:05:50Z",
        "status": "closed",
        "description": "This came up in a [twitter thread](https://twitter.com/devongovett/status/1199862177559171072?s=21) with @gaearon and @aweary and we decided to move the discussion here. I\u2019ll try to summarize the conversation so far below.\n\nThe basic question was whether a build tool could extract the static parts of a component tree ahead of time into HTML, and ship smaller JS to the client with only the dynamic parts. This could have benefits for code size and hydration performance for statically generated sites. It would likely have a smaller impact on dynamically generated server rendered sites, but it\u2019s possible there are static parts that could be extracted there too (e.g. header, footer, article content, etc.).\n\nThere are a couple potential ways to go about this, each with various tradeoffs.\n\n1. Do something like what ember and other template compilers do and generate some kind of IR from components and inject dynamic content into slots at runtime. This would likely require a lot of changes to React itself. @aweary seems to be working on some kind of [compiler](https://twitter.com/aweary/status/1199867044532903937?s=21) to do just that.\n2. Rewrite the JS with something like prepack, similar to what @trueadm did [here](https://github.com/trueadm/ssr-with-prepack-hackathon) (though it sounded like the output was quite variable in size).\n3. Rewrite the component tree to generate a different but equivalent tree with the static parts hoisted out. Similar to this [babel plugin](https://github.com/jamiebuilds/babel-react-optimize) but taken much farther to work at a whole tree level instead of a component level. Also to remove the static parts from JS altogether and generate static HTML to avoid duplicate content in JS and unnecessary hydration cost. Some way to allow static HTML in the middle of a tree to be reused might be needed, but maybe compiling to multiple roots would work?\n\nObviously a lot more thought is needed here. As @gaearon noted, a solid definition of \u201cstatic\u201d will be important for this discussion. Mine is that it could be rendered to HTML and never updated by JS, but perhaps people have other ideas.",
        "remove_template_description": "This came up in a [twitter thread](https://twitter.com/devongovett/status/1199862177559171072?s=21) with @gaearon and @aweary and we decided to move the discussion here. I\u2019ll try to summarize the conversation so far below.  The basic question was whether a build tool could extract the static parts of a component tree ahead of time into HTML, and ship smaller JS to the client with only the dynamic parts. This could have benefits for code size and hydration performance for statically generated sites. It would likely have a smaller impact on dynamically generated server rendered sites, but it\u2019s possible there are static parts that could be extracted there too (e.g. header, footer, article content, etc.).  There are a couple potential ways to go about this, each with various tradeoffs.  1. Do something like what ember and other template compilers do and generate some kind of IR from components and inject dynamic content into slots at runtime. This would likely require a lot of changes to React itself. @aweary seems to be working on some kind of [compiler](https://twitter.com/aweary/status/1199867044532903937?s=21) to do just that. 2. Rewrite the JS with something like prepack, similar to what @trueadm did [here](https://github.com/trueadm/ssr-with-prepack-hackathon) (though it sounded like the output was quite variable in size). 3. Rewrite the component tree to generate a different but equivalent tree with the static parts hoisted out. Similar to this [babel plugin](https://github.com/jamiebuilds/babel-react-optimize) but taken much farther to work at a whole tree level instead of a component level. Also to remove the static parts from JS altogether and generate static HTML to avoid duplicate content in JS and unnecessary hydration cost. Some way to allow static HTML in the middle of a tree to be reused might be needed, but maybe compiling to multiple roots would work?  Obviously a lot more thought is needed here. As @gaearon noted, a solid definition of \u201cstatic\u201d will be important for this discussion. Mine is that it could be rendered to HTML and never updated by JS, but perhaps people have other ideas.",
        "human_words": "This came up in a [twitter thread](https://twitter.com/devongovett/status/1199862177559171072?s=21) with @gaearon and @aweary and we decided to move the discussion here. I\u2019ll try to summarize the conversation so far below.  The basic question was whether a build tool could extract the static parts of a component tree ahead of time into HTML, and ship smaller JS to the client with only the dynamic parts. This could have benefits for code size and hydration performance for statically generated sites. It would likely have a smaller impact on dynamically generated server rendered sites, but it\u2019s possible there are static parts that could be extracted there too (e.g. header, footer, article content, etc.).  There are a couple potential ways to go about this, each with various tradeoffs.  1. Do something like what ember and other template compilers do and generate some kind of IR from components and inject dynamic content into slots at runtime. This would likely require a lot of changes to React itself. @aweary seems to be working on some kind of [compiler](https://twitter.com/aweary/status/1199867044532903937?s=21) to do just that. 2. Rewrite the JS with something like prepack, similar to what @trueadm did [here](https://github.com/trueadm/ssr-with-prepack-hackathon) (though it sounded like the output was quite variable in size). 3. Rewrite the component tree to generate a different but equivalent tree with the static parts hoisted out. Similar to this [babel plugin](https://github.com/jamiebuilds/babel-react-optimize) but taken much farther to work at a whole tree level instead of a component level. Also to remove the static parts from JS altogether and generate static HTML to avoid duplicate content in JS and unnecessary hydration cost. Some way to allow static HTML in the middle of a tree to be reused might be needed, but maybe compiling to multiple roots would work?  Obviously a lot more thought is needed here. As @gaearon noted, a solid definition of \u201cstatic\u201d will be important for this discussion. Mine is that it could be rendered to HTML and never updated by JS, but perhaps people have other ideas.",
        "human_words_regrex": "This came up in a  with @gaearon and @aweary and we decided to move the discussion here. I\u2019ll try to summarize the conversation so far below. The basic question was whether a build tool could extract the static parts of a component tree ahead of time into HTML, and ship smaller JS to the client with only the dynamic parts. This could have benefits for code size and hydration performance for statically generated sites. It would likely have a smaller impact on dynamically generated server rendered sites, but it\u2019s possible there are static parts that could be extracted there too (e.g. header, footer, article content, etc.). There are a couple potential ways to go about this, each with various tradeoffs. 1. Do something like what ember and other template compilers do and generate some kind of IR from components and inject dynamic content into slots at runtime. This would likely require a lot of changes to React itself. @aweary seems to be working on some kind of  to do just that. 2. Rewrite the JS with something like prepack, similar to what @trueadm did  (though it sounded like the output was quite variable in size). 3. Rewrite the component tree to generate a different but equivalent tree with the static parts hoisted out. Similar to this  but taken much farther to work at a whole tree level instead of a component level. Also to remove the static parts from JS altogether and generate static HTML to avoid duplicate content in JS and unnecessary hydration cost. Some way to allow static HTML in the middle of a tree to be reused might be needed, but maybe compiling to multiple roots would work? Obviously a lot more thought is needed here. As @gaearon noted, a solid definition of \u201cstatic\u201d will be important for this discussion. Mine is that it could be rendered to HTML and never updated by JS, but perhaps people have other ideas.",
        "human_words_stopwords_removal_lemmatization": "came @ gaearon @ aweary decided move discussion . \u2019 try summarize conversation far . basic question whether build tool could extract static part component tree ahead time html , ship smaller j client dynamic part . could benefit code size hydration performance statically generated site . would likely smaller impact dynamically generated server rendered site , \u2019 possible static part could extracted ( e.g . header , footer , article content , etc. ) . couple potential way go , various tradeoff . 1. something like ember template compiler generate kind ir component inject dynamic content slot runtime . would likely require lot change react . @ aweary seems working kind . 2. rewrite j something like prepack , similar @ trueadm ( though sounded like output quite variable size ) . 3. rewrite component tree generate different equivalent tree static part hoisted . similar taken much farther work whole tree level instead component level . also remove static part j altogether generate static html avoid duplicate content j unnecessary hydration cost . way allow static html middle tree reused might needed , maybe compiling multiple root would work ? obviously lot thought needed . @ gaearon noted , solid definition \u201c static \u201d important discussion . mine could rendered html never updated j , perhaps people idea .",
        "title_stopwords_removal_lemmatization": "idea : extract \u201c static \u201d component subtrees html build"
    },
    {
        "issue_id": 527289117,
        "title": "What will suspense look like for the streaming case?",
        "label": [
            "Type: Discussion",
            "Component: Suspense"
        ],
        "date": "2019-11-22T16:19:21Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA discussion, at the request of @gaearon. \r\n\r\n### Questions\r\n\r\nI'm very curious what the public API will be for Suspense in streaming cases. The work I do or have pretty much always done in React involves dealing with streams of data, generally coming over a web socket. What will it look like? Will it be easy for users to implement/use? Is a promise/thenable an appropriate type for dealing with this even internally, given that the first value may never show up?\r\n\r\n### Desire\r\n\r\nThe ability to leverage suspense to \"suspend\" until the first of many values arrives from a stream of data coming from any source. For the sake of conversation, we'll say a web socket.\r\n\r\n\r\n### Constraints\r\n\r\n- The first value may never arrive\r\n- The source may close without error, having never provided a value\r\n- There must be an ergonomic teardown mechanism, for example how developers can currently teardown in the returned function of `useEffect` or in `componentWillUnmount`.\r\n- There may be more than one value returned by the streaming source\r\n\r\n### Optional constraints\r\n\r\n- The first N values form the source may be synchronous (followed by asynchronous values)\r\n\r\n### Scenario\r\n\r\nA simple app with two routes, one where the app needs to open a web socket connection and collect streaming data, and the other where the socket connection should be closed. The values from the web socket may take long enough that the developer will want to move to that routed component right away and show some spinner with suspense until the first bit of data arrives. If the user navigates to the first route, then leaves before the first value arrives, what happens?\r\n\r\nMy concern is, that if, even internally, the mechanism is a promise or thenable, there is a chance leaks will be created in the event that the source of that first value is torn down before the first value arrives. The only way, with a thenable or promise, to avoid that chance would be to make sure that the teardown mechanism was somehow tied to the thenable, so that the thenable to be rejected (or resolved) with a known value, such that it will be \"settled\".",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A discussion, at the request of @gaearon.     ### Questions    I'm very curious what the public API will be for Suspense in streaming cases. The work I do or have pretty much always done in React involves dealing with streams of data, generally coming over a web socket. What will it look like? Will it be easy for users to implement/use? Is a promise/thenable an appropriate type for dealing with this even internally, given that the first value may never show up?    ### Desire    The ability to leverage suspense to \"suspend\" until the first of many values arrives from a stream of data coming from any source. For the sake of conversation, we'll say a web socket.      ### Constraints    - The first value may never arrive  - The source may close without error, having never provided a value  - There must be an ergonomic teardown mechanism, for example how developers can currently teardown in the returned function of `useEffect` or in `componentWillUnmount`.  - There may be more than one value returned by the streaming source    ### Optional constraints    - The first N values form the source may be synchronous (followed by asynchronous values)    ### Scenario    A simple app with two routes, one where the app needs to open a web socket connection and collect streaming data, and the other where the socket connection should be closed. The values from the web socket may take long enough that the developer will want to move to that routed component right away and show some spinner with suspense until the first bit of data arrives. If the user navigates to the first route, then leaves before the first value arrives, what happens?    My concern is, that if, even internally, the mechanism is a promise or thenable, there is a chance leaks will be created in the event that the source of that first value is torn down before the first value arrives. The only way, with a thenable or promise, to avoid that chance would be to make sure that the teardown mechanism was somehow tied to the thenable, so that the thenable to be rejected (or resolved) with a known value, such that it will be \"settled\".",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A discussion, at the request of @gaearon.     ### Questions    I'm very curious what the public API will be for Suspense in streaming cases. The work I do or have pretty much always done in React involves dealing with streams of data, generally coming over a web socket. What will it look like? Will it be easy for users to implement/use? Is a promise/thenable an appropriate type for dealing with this even internally, given that the first value may never show up?    ### Desire    The ability to leverage suspense to \"suspend\" until the first of many values arrives from a stream of data coming from any source. For the sake of conversation, we'll say a web socket.      ### Constraints    - The first value may never arrive  - The source may close without error, having never provided a value  - There must be an ergonomic teardown mechanism, for example how developers can currently teardown in the returned function of `useEffect` or in `componentWillUnmount`.  - There may be more than one value returned by the streaming source    ### Optional constraints    - The first N values form the source may be synchronous (followed by asynchronous values)    ### Scenario    A simple app with two routes, one where the app needs to open a web socket connection and collect streaming data, and the other where the socket connection should be closed. The values from the web socket may take long enough that the developer will want to move to that routed component right away and show some spinner with suspense until the first bit of data arrives. If the user navigates to the first route, then leaves before the first value arrives, what happens?    My concern is, that if, even internally, the mechanism is a promise or thenable, there is a chance leaks will be created in the event that the source of that first value is torn down before the first value arrives. The only way, with a thenable or promise, to avoid that chance would be to make sure that the teardown mechanism was somehow tied to the thenable, so that the thenable to be rejected (or resolved) with a known value, such that it will be \"settled\".",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** A discussion, at the request of @gaearon. ### Questions I'm very curious what the public API will be for Suspense in streaming cases. The work I do or have pretty much always done in React involves dealing with streams of data, generally coming over a web socket. What will it look like? Will it be easy for users to implement/use? Is a promise/thenable an appropriate type for dealing with this even internally, given that the first value may never show up? ### Desire The ability to leverage suspense to \"suspend\" until the first of many values arrives from a stream of data coming from any source. For the sake of conversation, we'll say a web socket. ### Constraints - The first value may never arrive - The source may close without error, having never provided a value - There must be an ergonomic teardown mechanism, for example how developers can currently teardown in the returned function of `useEffect` or in `componentWillUnmount`. - There may be more than one value returned by the streaming source ### Optional constraints - The first N values form the source may be synchronous (followed by asynchronous values) ### Scenario A simple app with two routes, one where the app needs to open a web socket connection and collect streaming data, and the other where the socket connection should be closed. The values from the web socket may take long enough that the developer will want to move to that routed component right away and show some spinner with suspense until the first bit of data arrives. If the user navigates to the first route, then leaves before the first value arrives, what happens? My concern is, that if, even internally, the mechanism is a promise or thenable, there is a chance leaks will be created in the event that the source of that first value is torn down before the first value arrives. The only way, with a thenable or promise, to avoid that chance would be to make sure that the teardown mechanism was somehow tied to the thenable, so that the thenable to be rejected (or resolved) with a known value, such that it will be \"settled\".",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * discussion , request @ gaearon . # # # question 'm curious public api suspense streaming case . work pretty much always done react involves dealing stream data , generally coming web socket . look like ? easy user implement/use ? promise/thenable appropriate type dealing even internally , given first value may never show ? # # # desire ability leverage suspense `` suspend '' first many value arrives stream data coming source . sake conversation , 'll say web socket . # # # constraint - first value may never arrive - source may close without error , never provided value - must ergonomic teardown mechanism , example developer currently teardown returned function ` useeffect ` ` componentwillunmount ` . - may one value returned streaming source # # # optional constraint - first n value form source may synchronous ( followed asynchronous value ) # # # scenario simple app two route , one app need open web socket connection collect streaming data , socket connection closed . value web socket may take long enough developer want move routed component right away show spinner suspense first bit data arrives . user navigates first route , leaf first value arrives , happens ? concern , , even internally , mechanism promise thenable , chance leak created event source first value torn first value arrives . way , thenable promise , avoid chance would make sure teardown mechanism somehow tied thenable , thenable rejected ( resolved ) known value , `` settled '' .",
        "title_stopwords_removal_lemmatization": "suspense look like streaming case ?"
    },
    {
        "issue_id": 526435830,
        "title": "React.createRoot(container).render(<App />) doesn't remove existing container children",
        "label": [
            "Type: Discussion",
            "Component: Concurrent Features"
        ],
        "date": "2019-11-21T08:22:52Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nI guess it's a bug.\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using `ReactDom.createRoot(container).render(<App />)`, if the container has child elements, then these don't get removed when the App component is rendered into the container.\r\n\r\n**CodeSandbox example**\r\n\r\nhttps://codesandbox.io/s/recursing-euler-b3oj7\r\n\r\n**What is the expected behavior?**\r\n\r\nI expect it to behave like `ReactDom.render(<App />, container)`, which clears the contents of the container when the App component is rendered into it.\r\n\r\n**Which versions of React?**\r\n\r\nLatest experimental, see CodeSandbox example.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    I guess it's a bug.    **What is the current behavior?**    When using `ReactDom.createRoot(container).render(<App />)`, if the container has child elements, then these don't get removed when the App component is rendered into the container.    **CodeSandbox example**    https://codesandbox.io/s/recursing-euler-b3oj7    **What is the expected behavior?**    I expect it to behave like `ReactDom.render(<App />, container)`, which clears the contents of the container when the App component is rendered into it.    **Which versions of React?**    Latest experimental, see CodeSandbox example.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    I guess it's a bug.    **What is the current behavior?**    When using `ReactDom.createRoot(container).render(<App />)`, if the container has child elements, then these don't get removed when the App component is rendered into the container.    **CodeSandbox example**    https://codesandbox.io/s/recursing-euler-b3oj7    **What is the expected behavior?**    I expect it to behave like `ReactDom.render(<App />, container)`, which clears the contents of the container when the App component is rendered into it.    **Which versions of React?**    Latest experimental, see CodeSandbox example.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** I guess it's a bug. **What is the current behavior?** When using `ReactDom.createRoot(container).render()`, if the container has child elements, then these don't get removed when the App component is rendered into the container. **CodeSandbox example**  **What is the expected behavior?** I expect it to behave like `ReactDom.render(, container)`, which clears the contents of the container when the App component is rendered into it. **Which versions of React?** Latest experimental, see CodeSandbox example.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * guess 's bug . * * current behavior ? * * using ` reactdom.createroot ( container ) .render ( ) ` , container child element , n't get removed app component rendered container . * * codesandbox example * * * * expected behavior ? * * expect behave like ` reactdom.render ( , container ) ` , clear content container app component rendered . * * version react ? * * latest experimental , see codesandbox example .",
        "title_stopwords_removal_lemmatization": "react.createroot ( container ) .render ( < app / > ) n't remove existing container child"
    },
    {
        "issue_id": 526276180,
        "title": "SuspenseList gotcha with React.lazy",
        "label": [
            "Type: Discussion",
            "Component: Suspense",
            "Component: Concurrent Features"
        ],
        "date": "2019-11-20T23:33:34Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nSuspense is still experimental, so it's neither \ud83d\ude43\r\n\r\n**What is the current behavior?**\r\n\r\nIt's best described via a code example in this codesandbox: https://codesandbox.io/s/react-suspenselist-problem-8g7c1\r\n\r\nHere's a summary:\r\n\r\nWhen \"forwards\" is used for the `revealOrder` of a SuspenseList, React does not even try to render components in suspense boundaries after the most \"forward\" suspense boundary. This should be fine, but it can be a problem when used with React.lazy because the dynamic import isn't started until the lazy component is rendered so adding a SuspenseList to an existing set of lazily loaded components results in a slower overall loading experience thanks to a waterfall effect.\r\n\r\nFor completeness I'll just add that this same thing applies to \"backwards\" as an option as well.\r\n\r\nI understand why SuspenseList doesn't bother rendering components in Suspense Boundaries until they're ready to be shown. It's because we should be firing requests for things before we try to render the components that need those resources. However, React.lazy is a bit of a special case because it doesn't suspend until it's rendered the first time and for the developer to fire that request eagerly requires extra work on the part of the developer (there's a comment in the code showing the workaround).\r\n\r\n**What is the expected behavior?**\r\n\r\nBecause React.lazy is a special case and people are likely to run into this gotcha a lot when implementing Suspense Lists around lazy components, I think something should be done for these to start loading the module eagerly without workarounds. I'm not sure what to suggest to do about it though.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nVersion `0.0.0-experimental-b53ea6ca0` and I don't think this ever worked in a previous version.",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Suspense is still experimental, so it's neither \ud83d\ude43    **What is the current behavior?**    It's best described via a code example in this codesandbox: https://codesandbox.io/s/react-suspenselist-problem-8g7c1    Here's a summary:    When \"forwards\" is used for the `revealOrder` of a SuspenseList, React does not even try to render components in suspense boundaries after the most \"forward\" suspense boundary. This should be fine, but it can be a problem when used with React.lazy because the dynamic import isn't started until the lazy component is rendered so adding a SuspenseList to an existing set of lazily loaded components results in a slower overall loading experience thanks to a waterfall effect.    For completeness I'll just add that this same thing applies to \"backwards\" as an option as well.    I understand why SuspenseList doesn't bother rendering components in Suspense Boundaries until they're ready to be shown. It's because we should be firing requests for things before we try to render the components that need those resources. However, React.lazy is a bit of a special case because it doesn't suspend until it's rendered the first time and for the developer to fire that request eagerly requires extra work on the part of the developer (there's a comment in the code showing the workaround).    **What is the expected behavior?**    Because React.lazy is a special case and people are likely to run into this gotcha a lot when implementing Suspense Lists around lazy components, I think something should be done for these to start loading the module eagerly without workarounds. I'm not sure what to suggest to do about it though.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Version `0.0.0-experimental-b53ea6ca0` and I don't think this ever worked in a previous version.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Suspense is still experimental, so it's neither \ud83d\ude43    **What is the current behavior?**    It's best described via a code example in this codesandbox: https://codesandbox.io/s/react-suspenselist-problem-8g7c1    Here's a summary:    When \"forwards\" is used for the `revealOrder` of a SuspenseList, React does not even try to render components in suspense boundaries after the most \"forward\" suspense boundary. This should be fine, but it can be a problem when used with React.lazy because the dynamic import isn't started until the lazy component is rendered so adding a SuspenseList to an existing set of lazily loaded components results in a slower overall loading experience thanks to a waterfall effect.    For completeness I'll just add that this same thing applies to \"backwards\" as an option as well.    I understand why SuspenseList doesn't bother rendering components in Suspense Boundaries until they're ready to be shown. It's because we should be firing requests for things before we try to render the components that need those resources. However, React.lazy is a bit of a special case because it doesn't suspend until it's rendered the first time and for the developer to fire that request eagerly requires extra work on the part of the developer (there's a comment in the code showing the workaround).    **What is the expected behavior?**    Because React.lazy is a special case and people are likely to run into this gotcha a lot when implementing Suspense Lists around lazy components, I think something should be done for these to start loading the module eagerly without workarounds. I'm not sure what to suggest to do about it though.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Version `0.0.0-experimental-b53ea6ca0` and I don't think this ever worked in a previous version.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Suspense is still experimental, so it's neither \ud83d\ude43 **What is the current behavior?** It's best described via a code example in this codesandbox:  Here's a summary: When \"forwards\" is used for the `revealOrder` of a SuspenseList, React does not even try to render components in suspense boundaries after the most \"forward\" suspense boundary. This should be fine, but it can be a problem when used with React.lazy because the dynamic import isn't started until the lazy component is rendered so adding a SuspenseList to an existing set of lazily loaded components results in a slower overall loading experience thanks to a waterfall effect. For completeness I'll just add that this same thing applies to \"backwards\" as an option as well. I understand why SuspenseList doesn't bother rendering components in Suspense Boundaries until they're ready to be shown. It's because we should be firing requests for things before we try to render the components that need those resources. However, React.lazy is a bit of a special case because it doesn't suspend until it's rendered the first time and for the developer to fire that request eagerly requires extra work on the part of the developer (there's a comment in the code showing the workaround). **What is the expected behavior?** Because React.lazy is a special case and people are likely to run into this gotcha a lot when implementing Suspense Lists around lazy components, I think something should be done for these to start loading the module eagerly without workarounds. I'm not sure what to suggest to do about it though. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** Version `0.0.0-experimental-b53ea6ca0` and I don't think this ever worked in a previous version.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * suspense still experimental , 's neither \ud83d\ude43 * * current behavior ? * * 's best described via code example codesandbox : 's summary : `` forward '' used ` revealorder ` suspenselist , react even try render component suspense boundary `` forward '' suspense boundary . fine , problem used react.lazy dynamic import n't started lazy component rendered adding suspenselist existing set lazily loaded component result slower overall loading experience thanks waterfall effect . completeness 'll add thing applies `` backwards '' option well . understand suspenselist n't bother rendering component suspense boundary 're ready shown . 's firing request thing try render component need resource . however , react.lazy bit special case n't suspend 's rendered first time developer fire request eagerly requires extra work part developer ( 's comment code showing workaround ) . * * expected behavior ? * * react.lazy special case people likely run gotcha lot implementing suspense list around lazy component , think something done start loading module eagerly without workarounds . 'm sure suggest though . * * version react , browser / o affected issue ? work previous version react ? * * version ` 0.0.0-experimental-b53ea6ca0 ` n't think ever worked previous version .",
        "title_stopwords_removal_lemmatization": "suspenselist gotcha react.lazy"
    },
    {
        "issue_id": 523851078,
        "title": "Feature Request: Soft Component",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-11-16T14:23:06Z",
        "status": "open",
        "description": "```\r\nimport React, {useState} from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nfunction PageLayout({title, children}) {\r\n  return <div>\r\n    <h1>{title}</h1>\r\n    <input type=\"text\"/>\r\n    {children}\r\n  </div>;\r\n}\r\nfunction Page2({setPage}) {\r\n  return <PageLayout title=\"Page2\">\r\n    <button onClick={() => {setPage(() => Page1);}}>Test</button>\r\n  </PageLayout>\r\n}\r\nfunction Page1({setPage}) {\r\n  return <PageLayout title=\"Page1\">\r\n    <button onClick={() => {setPage(() => Page2);}}>Test</button>\r\n  </PageLayout>\r\n}\r\nfunction App() {\r\n  let [Page, setPage] = useState(() => Page1);\r\n  return <Page setPage={setPage}/>; \r\n}\r\nReactDOM.render(<App />, document.getElementById('app'));\r\n```\r\n\r\nhttps://codesandbox.io/embed/serene-browser-tehj4?fontsize=14\r\n\r\nThe above code is most intuitive pattern for build multiple page web app. -- Don't mind the setPage. Just focus Page component returns PageLayout instance.\r\n\r\nBut react's diff algorithm is not optimized for that pattern.  If you click \"Test\" button. The text you inputed in input will lost.\r\n\r\nSo I proposal \"Soft Component\" concept. Two soft component will be treated as same component in diff algorithm. In the example, we change Page1 and Page2 to soft components. Thus solve the problem I shown above.",
        "remove_template_description": "```  import React, {useState} from 'react';  import ReactDOM from 'react-dom';    function PageLayout({title, children}) {    return <div>      <h1>{title}</h1>      <input type=\"text\"/>      {children}    </div>;  }  function Page2({setPage}) {    return <PageLayout title=\"Page2\">      <button onClick={() => {setPage(() => Page1);}}>Test</button>    </PageLayout>  }  function Page1({setPage}) {    return <PageLayout title=\"Page1\">      <button onClick={() => {setPage(() => Page2);}}>Test</button>    </PageLayout>  }  function App() {    let [Page, setPage] = useState(() => Page1);    return <Page setPage={setPage}/>;   }  ReactDOM.render(<App />, document.getElementById('app'));  ```    https://codesandbox.io/embed/serene-browser-tehj4?fontsize=14    The above code is most intuitive pattern for build multiple page web app. -- Don't mind the setPage. Just focus Page component returns PageLayout instance.    But react's diff algorithm is not optimized for that pattern.  If you click \"Test\" button. The text you inputed in input will lost.    So I proposal \"Soft Component\" concept. Two soft component will be treated as same component in diff algorithm. In the example, we change Page1 and Page2 to soft components. Thus solve the problem I shown above.",
        "human_words": "    https://codesandbox.io/embed/serene-browser-tehj4?fontsize=14    The above code is most intuitive pattern for build multiple page web app. -- Don't mind the setPage. Just focus Page component returns PageLayout instance.    But react's diff algorithm is not optimized for that pattern.  If you click \"Test\" button. The text you inputed in input will lost.    So I proposal \"Soft Component\" concept. Two soft component will be treated as same component in diff algorithm. In the example, we change Page1 and Page2 to soft components. Thus solve the problem I shown above.",
        "human_words_regrex": "  The above code is most intuitive pattern for build multiple page web app. -- Don't mind the setPage. Just focus Page component returns PageLayout instance. But react's diff algorithm is not optimized for that pattern. If you click \"Test\" button. The text you inputed in input will lost. So I proposal \"Soft Component\" concept. Two soft component will be treated as same component in diff algorithm. In the example, we change Page1 and Page2 to soft components. Thus solve the problem I shown above.",
        "human_words_stopwords_removal_lemmatization": "code intuitive pattern build multiple page web app . -- n't mind setpage . focus page component return pagelayout instance . react 's diff algorithm optimized pattern . click `` test '' button . text inputed input lost . proposal `` soft component '' concept . two soft component treated component diff algorithm . example , change page1 page2 soft component . thus solve problem shown .",
        "title_stopwords_removal_lemmatization": "feature request : soft component"
    },
    {
        "issue_id": 522734282,
        "title": "Devtools: higlight updated items in Components tree",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2019-11-14T09:37:40Z",
        "status": "closed",
        "description": "*feature request*\r\n\r\nIs it possible to higlight updated items in Components tree as well?",
        "remove_template_description": "*feature request*    Is it possible to higlight updated items in Components tree as well?",
        "human_words": "*feature request*    Is it possible to higlight updated items in Components tree as well?",
        "human_words_regrex": "*feature request* Is it possible to higlight updated items in Components tree as well?",
        "human_words_stopwords_removal_lemmatization": "* feature request * possible higlight updated item component tree well ?",
        "title_stopwords_removal_lemmatization": "devtools : higlight updated item component tree"
    },
    {
        "issue_id": 520251612,
        "title": "[Shallow Renderer] Plan forward",
        "label": [
            "Component: Shallow Renderer",
            "Type: Discussion",
            "React Core Team"
        ],
        "date": "2019-11-08T21:54:52Z",
        "status": "closed",
        "description": "Let's discuss what to do with the shallow renderer here. As I mentioned in https://github.com/facebook/react/pull/16168#issuecomment-518344985, we aren't using it much and don't consider it a best practice. So we aren't going to be very good stewards of its API going forward.\r\n\r\nMy proposal was for Enzyme or folks interested in it to copy the code into another repo, and continue maintaining it there under a difference package name. It would make sense to Enzyme to start depending on that fork. We would then deprecate `react-test-renderer/shallow` in favor of the community-maintained fork.\r\n\r\nIf you'd like to volunteer to set up a repo, please let us know in this issue!\r\n\r\ncc @davidmarkclements regarding the proposed `react-shallow-renderer` package name.",
        "remove_template_description": "Let's discuss what to do with the shallow renderer here. As I mentioned in https://github.com/facebook/react/pull/16168#issuecomment-518344985, we aren't using it much and don't consider it a best practice. So we aren't going to be very good stewards of its API going forward.    My proposal was for Enzyme or folks interested in it to copy the code into another repo, and continue maintaining it there under a difference package name. It would make sense to Enzyme to start depending on that fork. We would then deprecate `react-test-renderer/shallow` in favor of the community-maintained fork.    If you'd like to volunteer to set up a repo, please let us know in this issue!    cc @davidmarkclements regarding the proposed `react-shallow-renderer` package name.",
        "human_words": "Let's discuss what to do with the shallow renderer here. As I mentioned in https://github.com/facebook/react/pull/16168#issuecomment-518344985, we aren't using it much and don't consider it a best practice. So we aren't going to be very good stewards of its API going forward.    My proposal was for Enzyme or folks interested in it to copy the code into another repo, and continue maintaining it there under a difference package name. It would make sense to Enzyme to start depending on that fork. We would then deprecate `react-test-renderer/shallow` in favor of the community-maintained fork.    If you'd like to volunteer to set up a repo, please let us know in this issue!    cc @davidmarkclements regarding the proposed `react-shallow-renderer` package name.",
        "human_words_regrex": "Let's discuss what to do with the shallow renderer here. As I mentioned in  we aren't using it much and don't consider it a best practice. So we aren't going to be very good stewards of its API going forward. My proposal was for Enzyme or folks interested in it to copy the code into another repo, and continue maintaining it there under a difference package name. It would make sense to Enzyme to start depending on that fork. We would then deprecate `react-test-renderer/shallow` in favor of the community-maintained fork. If you'd like to volunteer to set up a repo, please let us know in this issue! cc @davidmarkclements regarding the proposed `react-shallow-renderer` package name.",
        "human_words_stopwords_removal_lemmatization": "let 's discus shallow renderer . mentioned n't using much n't consider best practice . n't going good steward api going forward . proposal enzyme folk interested copy code another repo , continue maintaining difference package name . would make sense enzyme start depending fork . would deprecate ` react-test-renderer/shallow ` favor community-maintained fork . 'd like volunteer set repo , please let u know issue ! cc @ davidmarkclements regarding proposed ` react-shallow-renderer ` package name .",
        "title_stopwords_removal_lemmatization": "[ shallow renderer ] plan forward"
    },
    {
        "issue_id": 519568472,
        "title": "State is carried between components inside and outside of fragments",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-11-07T23:18:52Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nIf a component rendered in a Fragment and then outside of it it is considered the same instance by React.\r\n\r\nThis means that:\r\n\r\n```jsx\r\n<Fragment>\r\n  <Component />\r\n</Fragment>\r\n```\r\n\r\nshares state with:\r\n\r\n```jsx\r\n<Component />\r\n```\r\n\r\nI see how this could be seen as beneficial behavior and can be easily fixed with keys.\r\n\r\nWhen I was conditionally rendering either one Material UI Button or two inside a fragment would cause the ripple effect from the first Button in the fragment to be \"transferred\" to the single Button which is odd since the JSX structure is different.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nhttps://github.com/dacioromero/react-unexpected-state-fragments\r\n\r\n**What is the expected behavior?**\r\n\r\nFragments should be a factor that React considers when determining if instances of a component is the same. Components should be different instances between renders if one is placed inside a Fragment and another is not.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReact 16.11.0, Firefox Developer Edition 71.0b7, Ubuntu 19.10.\r\n\r\nNot sure if this worked as I would expect in previous versions.\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    If a component rendered in a Fragment and then outside of it it is considered the same instance by React.    This means that:    ```jsx  <Fragment>    <Component />  </Fragment>  ```    shares state with:    ```jsx  <Component />  ```    I see how this could be seen as beneficial behavior and can be easily fixed with keys.    When I was conditionally rendering either one Material UI Button or two inside a fragment would cause the ripple effect from the first Button in the fragment to be \"transferred\" to the single Button which is odd since the JSX structure is different.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://github.com/dacioromero/react-unexpected-state-fragments    **What is the expected behavior?**    Fragments should be a factor that React considers when determining if instances of a component is the same. Components should be different instances between renders if one is placed inside a Fragment and another is not.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.11.0, Firefox Developer Edition 71.0b7, Ubuntu 19.10.    Not sure if this worked as I would expect in previous versions.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    If a component rendered in a Fragment and then outside of it it is considered the same instance by React.    This means that:        shares state with:        I see how this could be seen as beneficial behavior and can be easily fixed with keys.    When I was conditionally rendering either one Material UI Button or two inside a fragment would cause the ripple effect from the first Button in the fragment to be \"transferred\" to the single Button which is odd since the JSX structure is different.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://github.com/dacioromero/react-unexpected-state-fragments    **What is the expected behavior?**    Fragments should be a factor that React considers when determining if instances of a component is the same. Components should be different instances between renders if one is placed inside a Fragment and another is not.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.11.0, Firefox Developer Edition 71.0b7, Ubuntu 19.10.    Not sure if this worked as I would expect in previous versions.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** If a component rendered in a Fragment and then outside of it it is considered the same instance by React. This means that: shares state with: I see how this could be seen as beneficial behavior and can be easily fixed with keys. When I was conditionally rendering either one Material UI Button or two inside a fragment would cause the ripple effect from the first Button in the fragment to be \"transferred\" to the single Button which is odd since the JSX structure is different. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:**  **What is the expected behavior?** Fragments should be a factor that React considers when determining if instances of a component is the same. Components should be different instances between renders if one is placed inside a Fragment and another is not. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.11.0, Firefox Developer Edition 71.0b7, Ubuntu 19.10. Not sure if this worked as I would expect in previous versions.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * component rendered fragment outside considered instance react . mean : share state : see could seen beneficial behavior easily fixed key . conditionally rendering either one material ui button two inside fragment would cause ripple effect first button fragment `` transferred '' single button odd since jsx structure different . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * fragment factor react considers determining instance component . component different instance render one placed inside fragment another . * * version react , browser / o affected issue ? work previous version react ? * * react 16.11.0 , firefox developer edition 71.0b7 , ubuntu 19.10. sure worked would expect previous version .",
        "title_stopwords_removal_lemmatization": "state carried component inside outside fragment"
    },
    {
        "issue_id": 518001617,
        "title": "react-refresh: Dependent functions/data don't trigger refresh",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-11-05T20:13:09Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBoth/neither?\r\n\r\n**What is the current behavior?**\r\n\r\nCurrently, react-refresh marks each component whose `type` and/or `signature` has changed as \"dirty\" and will either re-render or re-mount those components selectively.\r\n\r\nThe problem occurs when the dev tooling (webpack, parcel, etc.) loads a module that exports functions or data that are used inside of components, but aren't registered components themselves. For example, a utility function that concatenates a string:\r\n\r\n```js\r\nexport greet(name) {\r\n  return `Hello, ${name}!`;\r\n}\r\n```\r\n\r\nChanging the returned string to `Yo, ${name}!` would trigger this module to reload in the browser, but because components which depended on it don't reload, the old greeting will persist \r\nuntil the next render of each dependent component.\r\n\r\n(BTW in actuality, some tooling will reload immediate dependents of modules that are reloaded in order to get around similar problems. You can extend the dependency chain from two to three modules, where `a.js` depends on `b.js` depends on `c.js`, and you will get the same result when editing `c.js`)\r\n\r\nWhat this forces tooling to do is apply a heuristic to try and guess whether a given module should be refreshed, vs. completely restart the app in order to cause all components to re-mount and pick up any changes that wouldn't be picked up by react-refresh.\r\n\r\nThe problems with the heuristic approach is:\r\n- each dev tool needs to implement this logic, leading to more potential for bugs\r\n- it leads to a degradation of hot reloading capabilities based on what your module exports. not obvious at all on it's face and will lead people to twisting their code base to route around this\r\n- It's very unfriendly to compile-to-JS languages like ReasonML, ClojureScript, etc. which might have different default semantics for what is public / private, different conventions for naming components, etc. which make it difficult to detect whether a module is \"safe\" to refresh\r\n\r\n**What is the expected behavior?**\r\n\r\nThat components depended on newly loaded code will pick up those changes correctly, without losing state.\r\n\r\nA potential (maybe naive?) solution to this in react-refresh is, instead of only re-rendering the components marked as dirty (due to a different `type` being registered), to _re-render from the root_ while maintaining hooks state. If components' signatures have changed, then re-mount.\r\n\r\nI've read through and kind of grok most of the code in react-refresh, but I'm not sure how this would impact the way that the reconciler currently handles the HMR stuff. This is as much of a question, as it is a request: could this be a viable solution?\r\n\r\nI appreciate your time and energy in reading through this. I'm very excited about having first-class support for hot reloading in React, as it's been something that I've loved ever since seeing the first demo of it. I hope that this issue can help create a way to provide a consistently excellent dev experience across tools/platforms/languages!\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReact 16.11",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Both/neither?    **What is the current behavior?**    Currently, react-refresh marks each component whose `type` and/or `signature` has changed as \"dirty\" and will either re-render or re-mount those components selectively.    The problem occurs when the dev tooling (webpack, parcel, etc.) loads a module that exports functions or data that are used inside of components, but aren't registered components themselves. For example, a utility function that concatenates a string:    ```js  export greet(name) {    return `Hello, ${name}!`;  }  ```    Changing the returned string to `Yo, ${name}!` would trigger this module to reload in the browser, but because components which depended on it don't reload, the old greeting will persist   until the next render of each dependent component.    (BTW in actuality, some tooling will reload immediate dependents of modules that are reloaded in order to get around similar problems. You can extend the dependency chain from two to three modules, where `a.js` depends on `b.js` depends on `c.js`, and you will get the same result when editing `c.js`)    What this forces tooling to do is apply a heuristic to try and guess whether a given module should be refreshed, vs. completely restart the app in order to cause all components to re-mount and pick up any changes that wouldn't be picked up by react-refresh.    The problems with the heuristic approach is:  - each dev tool needs to implement this logic, leading to more potential for bugs  - it leads to a degradation of hot reloading capabilities based on what your module exports. not obvious at all on it's face and will lead people to twisting their code base to route around this  - It's very unfriendly to compile-to-JS languages like ReasonML, ClojureScript, etc. which might have different default semantics for what is public / private, different conventions for naming components, etc. which make it difficult to detect whether a module is \"safe\" to refresh    **What is the expected behavior?**    That components depended on newly loaded code will pick up those changes correctly, without losing state.    A potential (maybe naive?) solution to this in react-refresh is, instead of only re-rendering the components marked as dirty (due to a different `type` being registered), to _re-render from the root_ while maintaining hooks state. If components' signatures have changed, then re-mount.    I've read through and kind of grok most of the code in react-refresh, but I'm not sure how this would impact the way that the reconciler currently handles the HMR stuff. This is as much of a question, as it is a request: could this be a viable solution?    I appreciate your time and energy in reading through this. I'm very excited about having first-class support for hot reloading in React, as it's been something that I've loved ever since seeing the first demo of it. I hope that this issue can help create a way to provide a consistently excellent dev experience across tools/platforms/languages!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.11",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Both/neither?    **What is the current behavior?**    Currently, react-refresh marks each component whose `type` and/or `signature` has changed as \"dirty\" and will either re-render or re-mount those components selectively.    The problem occurs when the dev tooling (webpack, parcel, etc.) loads a module that exports functions or data that are used inside of components, but aren't registered components themselves. For example, a utility function that concatenates a string:        Changing the returned string to `Yo, ${name}!` would trigger this module to reload in the browser, but because components which depended on it don't reload, the old greeting will persist   until the next render of each dependent component.    (BTW in actuality, some tooling will reload immediate dependents of modules that are reloaded in order to get around similar problems. You can extend the dependency chain from two to three modules, where `a.js` depends on `b.js` depends on `c.js`, and you will get the same result when editing `c.js`)    What this forces tooling to do is apply a heuristic to try and guess whether a given module should be refreshed, vs. completely restart the app in order to cause all components to re-mount and pick up any changes that wouldn't be picked up by react-refresh.    The problems with the heuristic approach is:  - each dev tool needs to implement this logic, leading to more potential for bugs  - it leads to a degradation of hot reloading capabilities based on what your module exports. not obvious at all on it's face and will lead people to twisting their code base to route around this  - It's very unfriendly to compile-to-JS languages like ReasonML, ClojureScript, etc. which might have different default semantics for what is public / private, different conventions for naming components, etc. which make it difficult to detect whether a module is \"safe\" to refresh    **What is the expected behavior?**    That components depended on newly loaded code will pick up those changes correctly, without losing state.    A potential (maybe naive?) solution to this in react-refresh is, instead of only re-rendering the components marked as dirty (due to a different `type` being registered), to _re-render from the root_ while maintaining hooks state. If components' signatures have changed, then re-mount.    I've read through and kind of grok most of the code in react-refresh, but I'm not sure how this would impact the way that the reconciler currently handles the HMR stuff. This is as much of a question, as it is a request: could this be a viable solution?    I appreciate your time and energy in reading through this. I'm very excited about having first-class support for hot reloading in React, as it's been something that I've loved ever since seeing the first demo of it. I hope that this issue can help create a way to provide a consistently excellent dev experience across tools/platforms/languages!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.11",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Both/neither? **What is the current behavior?** Currently, react-refresh marks each component whose `type` and/or `signature` has changed as \"dirty\" and will either re-render or re-mount those components selectively. The problem occurs when the dev tooling (webpack, parcel, etc.) loads a module that exports functions or data that are used inside of components, but aren't registered components themselves. For example, a utility function that concatenates a string: Changing the returned string to `Yo, ${name}!` would trigger this module to reload in the browser, but because components which depended on it don't reload, the old greeting will persist until the next render of each dependent component. (BTW in actuality, some tooling will reload immediate dependents of modules that are reloaded in order to get around similar problems. You can extend the dependency chain from two to three modules, where `a.js` depends on `b.js` depends on `c.js`, and you will get the same result when editing `c.js`) What this forces tooling to do is apply a heuristic to try and guess whether a given module should be refreshed, vs. completely restart the app in order to cause all components to re-mount and pick up any changes that wouldn't be picked up by react-refresh. The problems with the heuristic approach is: - each dev tool needs to implement this logic, leading to more potential for bugs - it leads to a degradation of hot reloading capabilities based on what your module exports. not obvious at all on it's face and will lead people to twisting their code base to route around this - It's very unfriendly to compile-to-JS languages like ReasonML, ClojureScript, etc. which might have different default semantics for what is public / private, different conventions for naming components, etc. which make it difficult to detect whether a module is \"safe\" to refresh **What is the expected behavior?** That components depended on newly loaded code will pick up those changes correctly, without losing state. A potential (maybe naive?) solution to this in react-refresh is, instead of only re-rendering the components marked as dirty (due to a different `type` being registered), to _re-render from the root_ while maintaining hooks state. If components' signatures have changed, then re-mount. I've read through and kind of grok most of the code in react-refresh, but I'm not sure how this would impact the way that the reconciler currently handles the HMR stuff. This is as much of a question, as it is a request: could this be a viable solution? I appreciate your time and energy in reading through this. I'm very excited about having first-class support for hot reloading in React, as it's been something that I've loved ever since seeing the first demo of it. I hope that this issue can help create a way to provide a consistently excellent dev experience across tools/platforms/languages! **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.11",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * both/neither ? * * current behavior ? * * currently , react-refresh mark component whose ` type ` and/or ` signature ` changed `` dirty '' either re-render re-mount component selectively . problem occurs dev tooling ( webpack , parcel , etc . ) load module export function data used inside component , n't registered component . example , utility function concatenates string : changing returned string ` yo , $ { name } ! ` would trigger module reload browser , component depended n't reload , old greeting persist next render dependent component . ( btw actuality , tooling reload immediate dependent module reloaded order get around similar problem . extend dependency chain two three module , ` a.js ` depends ` b.js ` depends ` c.js ` , get result editing ` c.js ` ) force tooling apply heuristic try guess whether given module refreshed , vs. completely restart app order cause component re-mount pick change would n't picked react-refresh . problem heuristic approach : - dev tool need implement logic , leading potential bug - lead degradation hot reloading capability based module export . obvious 's face lead people twisting code base route around - 's unfriendly compile-to-js language like reasonml , clojurescript , etc . might different default semantics public / private , different convention naming component , etc . make difficult detect whether module `` safe '' refresh * * expected behavior ? * * component depended newly loaded code pick change correctly , without losing state . potential ( maybe naive ? ) solution react-refresh , instead re-rendering component marked dirty ( due different ` type ` registered ) , _re-render root_ maintaining hook state . component ' signature changed , re-mount . 've read kind grok code react-refresh , 'm sure would impact way reconciler currently handle hmr stuff . much question , request : could viable solution ? appreciate time energy reading . 'm excited first-class support hot reloading react , 's something 've loved ever since seeing first demo . hope issue help create way provide consistently excellent dev experience across tools/platforms/languages ! * * version react , browser / o affected issue ? work previous version react ? * * react 16.11",
        "title_stopwords_removal_lemmatization": "react-refresh : dependent functions/data n't trigger refresh"
    },
    {
        "issue_id": 517644391,
        "title": "Unexpected value order with useTransition",
        "label": [
            "Type: Discussion",
            "Component: Concurrent Features"
        ],
        "date": "2019-11-05T09:17:35Z",
        "status": "closed",
        "description": "The order of returned values in useTransition is opposite to what I consider to be an established pattern of `[value, function]`.\r\n\r\nCurrent: `const [startTransition, isPending] = useTransition()`.\r\nExpected: `const [isPending, startTransition] = useTransition()`.\r\nAlso fine: `const { startTransition, isPending } = useTransition()`.\r\n\r\n## Rationale\r\n\r\nThe order is in my opinion inconsistent with other hooks, built-in and community hooks, and this inconsistency is somewhat bothersome on the aesthetic level.\r\n\r\nUsers without tooling support (TypeScript et al) will see `Uncaught TypeError: startTransition is not a function` error whenever they get the order wrong.\r\n\r\nHaving this insonsistency risks reducing the strength of the convention in the community, making hooks less convenient to use overall.\r\n\r\n## Built-in hooks\r\n\r\n```js\r\nconst [state, setState] = useState();\r\nconst [state, dispatch] = useReducer();\r\nconst [startTransition, isPending] = useTransition();\r\n```\r\n\r\n## Community examples\r\n\r\nI have done a quick overview of positional returned values from hooks in the community. Hooks that use `[value, function]` pattern:\r\n\r\n[useImmer](https://github.com/immerjs/use-immer#useimmer), [streamich/react-use](https://github.com/streamich/react-use) ([useTimeout](https://github.com/streamich/react-use/blob/master/docs/useTimeout.md), [useSessionStorage](https://github.com/streamich/react-use/blob/master/docs/useSessionStorage.md), [useLockBodyScroll](https://github.com/streamich/react-use/blob/master/docs/useLockBodyScroll.md), [useLocalStorage](https://github.com/streamich/react-use/blob/master/docs/useLocalStorage.md), [useToggle](https://github.com/streamich/react-use/blob/master/docs/useToggle.md)) [bdbch/react-localstorage](https://github.com/bdbch/react-localstorage), [rehooks/local-storage](https://github.com/rehooks/local-storage), [react-rekindle/use-request](https://github.com/react-rekindle/use-request).\r\n\r\nHooks that use `[function, value]` pattern: none.\r\n\r\n## Is second value optional?\r\n\r\nOne could argue that, unlike with other examples, useTransition does not require the user to care about the `isPending` value. However, not using isPending creates a poor UX that the extisting React docs explicitly call out as a problem. We\u2019re supposed to care about isPending. ([docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#adding-a-pending-indicator-adding-a-pending-indicator)).\r\n\r\nBesides, even with corrected value order, the user can still ignore isPending at a low cost of an explicit parameter skip (`const [, startTransition] = useTransition()`).\r\n\r\n## Can we return an object?\r\n\r\nuseState returns a list for convenient aliasing:\r\n\r\n```ts\r\nconst [color, setColor] = useState();\r\nconst [position, setPosition] = useState();\r\n```\r\n\r\nFor hooks that a single component uses only once the benefit is significantly reduced and the community often chooses to return an object with named values instead. This removes the problem of getting positioned values incorrectly and is more inline with the broader JavaScript ecosystem.\r\n\r\nI am speculating here, but it seems like a component will often only have one transition, like [the Button example in the docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#baking-transitions-into-the-design-system-baking-transitions-into-the-design-system). In that case it seems beneficial to return named values and reserve the positioned return values for cases where it really matters.\r\n",
        "remove_template_description": "The order of returned values in useTransition is opposite to what I consider to be an established pattern of `[value, function]`.    Current: `const [startTransition, isPending] = useTransition()`.  Expected: `const [isPending, startTransition] = useTransition()`.  Also fine: `const { startTransition, isPending } = useTransition()`.    ## Rationale    The order is in my opinion inconsistent with other hooks, built-in and community hooks, and this inconsistency is somewhat bothersome on the aesthetic level.    Users without tooling support (TypeScript et al) will see `Uncaught TypeError: startTransition is not a function` error whenever they get the order wrong.    Having this insonsistency risks reducing the strength of the convention in the community, making hooks less convenient to use overall.    ## Built-in hooks    ```js  const [state, setState] = useState();  const [state, dispatch] = useReducer();  const [startTransition, isPending] = useTransition();  ```    ## Community examples    I have done a quick overview of positional returned values from hooks in the community. Hooks that use `[value, function]` pattern:    [useImmer](https://github.com/immerjs/use-immer#useimmer), [streamich/react-use](https://github.com/streamich/react-use) ([useTimeout](https://github.com/streamich/react-use/blob/master/docs/useTimeout.md), [useSessionStorage](https://github.com/streamich/react-use/blob/master/docs/useSessionStorage.md), [useLockBodyScroll](https://github.com/streamich/react-use/blob/master/docs/useLockBodyScroll.md), [useLocalStorage](https://github.com/streamich/react-use/blob/master/docs/useLocalStorage.md), [useToggle](https://github.com/streamich/react-use/blob/master/docs/useToggle.md)) [bdbch/react-localstorage](https://github.com/bdbch/react-localstorage), [rehooks/local-storage](https://github.com/rehooks/local-storage), [react-rekindle/use-request](https://github.com/react-rekindle/use-request).    Hooks that use `[function, value]` pattern: none.    ## Is second value optional?    One could argue that, unlike with other examples, useTransition does not require the user to care about the `isPending` value. However, not using isPending creates a poor UX that the extisting React docs explicitly call out as a problem. We\u2019re supposed to care about isPending. ([docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#adding-a-pending-indicator-adding-a-pending-indicator)).    Besides, even with corrected value order, the user can still ignore isPending at a low cost of an explicit parameter skip (`const [, startTransition] = useTransition()`).    ## Can we return an object?    useState returns a list for convenient aliasing:    ```ts  const [color, setColor] = useState();  const [position, setPosition] = useState();  ```    For hooks that a single component uses only once the benefit is significantly reduced and the community often chooses to return an object with named values instead. This removes the problem of getting positioned values incorrectly and is more inline with the broader JavaScript ecosystem.    I am speculating here, but it seems like a component will often only have one transition, like [the Button example in the docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#baking-transitions-into-the-design-system-baking-transitions-into-the-design-system). In that case it seems beneficial to return named values and reserve the positioned return values for cases where it really matters.",
        "human_words": "The order of returned values in useTransition is opposite to what I consider to be an established pattern of `[value, function]`.    Current: `const [startTransition, isPending] = useTransition()`.  Expected: `const [isPending, startTransition] = useTransition()`.  Also fine: `const { startTransition, isPending } = useTransition()`.    ## Rationale    The order is in my opinion inconsistent with other hooks, built-in and community hooks, and this inconsistency is somewhat bothersome on the aesthetic level.    Users without tooling support (TypeScript et al) will see `Uncaught TypeError: startTransition is not a function` error whenever they get the order wrong.    Having this insonsistency risks reducing the strength of the convention in the community, making hooks less convenient to use overall.    ## Built-in hooks        ## Community examples    I have done a quick overview of positional returned values from hooks in the community. Hooks that use `[value, function]` pattern:    [useImmer](https://github.com/immerjs/use-immer#useimmer), [streamich/react-use](https://github.com/streamich/react-use) ([useTimeout](https://github.com/streamich/react-use/blob/master/docs/useTimeout.md), [useSessionStorage](https://github.com/streamich/react-use/blob/master/docs/useSessionStorage.md), [useLockBodyScroll](https://github.com/streamich/react-use/blob/master/docs/useLockBodyScroll.md), [useLocalStorage](https://github.com/streamich/react-use/blob/master/docs/useLocalStorage.md), [useToggle](https://github.com/streamich/react-use/blob/master/docs/useToggle.md)) [bdbch/react-localstorage](https://github.com/bdbch/react-localstorage), [rehooks/local-storage](https://github.com/rehooks/local-storage), [react-rekindle/use-request](https://github.com/react-rekindle/use-request).    Hooks that use `[function, value]` pattern: none.    ## Is second value optional?    One could argue that, unlike with other examples, useTransition does not require the user to care about the `isPending` value. However, not using isPending creates a poor UX that the extisting React docs explicitly call out as a problem. We\u2019re supposed to care about isPending. ([docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#adding-a-pending-indicator-adding-a-pending-indicator)).    Besides, even with corrected value order, the user can still ignore isPending at a low cost of an explicit parameter skip (`const [, startTransition] = useTransition()`).    ## Can we return an object?    useState returns a list for convenient aliasing:        For hooks that a single component uses only once the benefit is significantly reduced and the community often chooses to return an object with named values instead. This removes the problem of getting positioned values incorrectly and is more inline with the broader JavaScript ecosystem.    I am speculating here, but it seems like a component will often only have one transition, like [the Button example in the docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#baking-transitions-into-the-design-system-baking-transitions-into-the-design-system). In that case it seems beneficial to return named values and reserve the positioned return values for cases where it really matters.",
        "human_words_regrex": "The order of returned values in useTransition is opposite to what I consider to be an established pattern of `,  (, , , , ) , , . Hooks that use `). Besides, even with corrected value order, the user can still ignore isPending at a low cost of an explicit parameter skip (`const . In that case it seems beneficial to return named values and reserve the positioned return values for cases where it really matters.",
        "human_words_stopwords_removal_lemmatization": "order returned value usetransition opposite consider established pattern ` , ( , , , , ) , , . hook use ` ) . besides , even corrected value order , user still ignore ispending low cost explicit parameter skip ( ` const . case seems beneficial return named value reserve positioned return value case really matter .",
        "title_stopwords_removal_lemmatization": "unexpected value order usetransition"
    },
    {
        "issue_id": 516563176,
        "title": "React DevTools w/ Electron: Profiler \"Reload and start profiling\" doesn't work due to XMLHttpRequest 'null' origin",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2019-11-02T10:44:08Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nAn error gets thrown when using DevTools Profiler on **Electron** with the \"**Reload and start profiling**\" feature that leaves Profiler in an unexpected state - the profiling session does not end.\r\n\r\nI initially opened [the issue over at Electron](https://github.com/electron/electron/issues/20915), but [got asked to get your opinion first](https://github.com/electron/electron/issues/20915#issuecomment-548996868).\r\n\r\n**What is the current behavior?**\r\n\r\n- Open React DevTools Profiler in **Electron**\r\n- Click \"Reload and start profiling\"\r\n- Await reload\r\n- Do actions\r\n- Click \"Stop profiling\" - does not work\r\n- Because there are errors in console (actually thrown immediately after reload, don't have to do any extra actions):\r\n  ```\r\n  Access to XMLHttpRequest at 'chrome-extension://react-developer-tools/build/renderer.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, https.\r\n  ```\r\n  ```\r\n  Uncaught DOMException: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'chrome-extension://react-developer-tools/build/renderer.js'.\r\n  ```\r\n\r\n![Errors after triggering profiler](https://user-images.githubusercontent.com/1030080/68028419-81e81580-fcbd-11e9-85ae-58b8437df6d8.png)\r\n\r\n![The respective code in React DevTools](https://user-images.githubusercontent.com/1030080/68028680-1ce0ef80-fcbe-11e9-9b63-4fa0494af0dd.png)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nYou'll have to use [Electron Fiddle](https://github.com/electron/fiddle) for this one with this gist: https://gist.github.com/joltmode/82574cab4970def210dac0c68d4c34b8\r\n\r\n**What is the expected behavior?**\r\n\r\n- Open React DevTools Profiler\r\n- Click \"Reload and start profiling\"\r\n- Await reload\r\n- Do actions\r\n- Click \"Stop profiling\"\r\n- See profiler results\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n- React 16.11.0\r\n- Latest version of DevTools\r\n- Electron 6.1.2",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    An error gets thrown when using DevTools Profiler on **Electron** with the \"**Reload and start profiling**\" feature that leaves Profiler in an unexpected state - the profiling session does not end.    I initially opened [the issue over at Electron](https://github.com/electron/electron/issues/20915), but [got asked to get your opinion first](https://github.com/electron/electron/issues/20915#issuecomment-548996868).    **What is the current behavior?**    - Open React DevTools Profiler in **Electron**  - Click \"Reload and start profiling\"  - Await reload  - Do actions  - Click \"Stop profiling\" - does not work  - Because there are errors in console (actually thrown immediately after reload, don't have to do any extra actions):    ```    Access to XMLHttpRequest at 'chrome-extension://react-developer-tools/build/renderer.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, https.    ```    ```    Uncaught DOMException: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'chrome-extension://react-developer-tools/build/renderer.js'.    ```    ![Errors after triggering profiler](https://user-images.githubusercontent.com/1030080/68028419-81e81580-fcbd-11e9-85ae-58b8437df6d8.png)    ![The respective code in React DevTools](https://user-images.githubusercontent.com/1030080/68028680-1ce0ef80-fcbe-11e9-9b63-4fa0494af0dd.png)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    You'll have to use [Electron Fiddle](https://github.com/electron/fiddle) for this one with this gist: https://gist.github.com/joltmode/82574cab4970def210dac0c68d4c34b8    **What is the expected behavior?**    - Open React DevTools Profiler  - Click \"Reload and start profiling\"  - Await reload  - Do actions  - Click \"Stop profiling\"  - See profiler results    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    - React 16.11.0  - Latest version of DevTools  - Electron 6.1.2",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    An error gets thrown when using DevTools Profiler on **Electron** with the \"**Reload and start profiling**\" feature that leaves Profiler in an unexpected state - the profiling session does not end.    I initially opened [the issue over at Electron](https://github.com/electron/electron/issues/20915), but [got asked to get your opinion first](https://github.com/electron/electron/issues/20915#issuecomment-548996868).    **What is the current behavior?**    - Open React DevTools Profiler in **Electron**  - Click \"Reload and start profiling\"  - Await reload  - Do actions  - Click \"Stop profiling\" - does not work  - Because there are errors in console (actually thrown immediately after reload, don't have to do any extra actions):            ![Errors after triggering profiler](https://user-images.githubusercontent.com/1030080/68028419-81e81580-fcbd-11e9-85ae-58b8437df6d8.png)    ![The respective code in React DevTools](https://user-images.githubusercontent.com/1030080/68028680-1ce0ef80-fcbe-11e9-9b63-4fa0494af0dd.png)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    You'll have to use [Electron Fiddle](https://github.com/electron/fiddle) for this one with this gist: https://gist.github.com/joltmode/82574cab4970def210dac0c68d4c34b8    **What is the expected behavior?**    - Open React DevTools Profiler  - Click \"Reload and start profiling\"  - Await reload  - Do actions  - Click \"Stop profiling\"  - See profiler results    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    - React 16.11.0  - Latest version of DevTools  - Electron 6.1.2",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** An error gets thrown when using DevTools Profiler on **Electron** with the \"**Reload and start profiling**\" feature that leaves Profiler in an unexpected state - the profiling session does not end. I initially opened , but . **What is the current behavior?** - Open React DevTools Profiler in **Electron** - Click \"Reload and start profiling\" - Await reload - Do actions - Click \"Stop profiling\" - does not work - Because there are errors in console (actually thrown immediately after reload, don't have to do any extra actions): ! ! **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** You'll have to use  for this one with this gist:  **What is the expected behavior?** - Open React DevTools Profiler - Click \"Reload and start profiling\" - Await reload - Do actions - Click \"Stop profiling\" - See profiler results **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** - React 16.11.0 - Latest version of DevTools - Electron 6.1.2",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * error get thrown using devtools profiler * * electron * * `` * * reload start profiling * * '' feature leaf profiler unexpected state - profiling session end . initially opened , . * * current behavior ? * * - open react devtools profiler * * electron * * - click `` reload start profiling '' - await reload - action - click `` stop profiling '' - work - error console ( actually thrown immediately reload , n't extra action ) : ! ! * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * 'll use one gist : * * expected behavior ? * * - open react devtools profiler - click `` reload start profiling '' - await reload - action - click `` stop profiling '' - see profiler result * * version react , browser / o affected issue ? work previous version react ? * * - react 16.11.0 - latest version devtools - electron 6.1.2",
        "title_stopwords_removal_lemmatization": "react devtools w/ electron : profiler `` reload start profiling '' n't work due xmlhttprequest 'null ' origin"
    },
    {
        "issue_id": 512813254,
        "title": "useTransition hook name already exits in the ecosystem",
        "label": [
            "Type: Discussion",
            "Component: Concurrent Features"
        ],
        "date": "2019-10-26T09:22:05Z",
        "status": "closed",
        "description": "The new concurrent mode provides a new hook - [`useTransition`](https://reactjs.org/docs/concurrent-mode-reference.html#usetransition). However the name of it is confusing. The word \u201ctransition\u201d in web development already refers to animations and css [transition](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions) property. There also exist [useTransition hook](https://www.react-spring.io/docs/hooks/use-transition) provided by react-spring library. So people who will use both concurrent mode and react-spring in their projects will be confused by clashing names.\r\n\r\nDid you consider different names for concurrent transitions? For example, `useTransaction` is not present in the ecosystems and can be used to describe concurrent updates.",
        "remove_template_description": "The new concurrent mode provides a new hook - [`useTransition`](https://reactjs.org/docs/concurrent-mode-reference.html#usetransition). However the name of it is confusing. The word \u201ctransition\u201d in web development already refers to animations and css [transition](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions) property. There also exist [useTransition hook](https://www.react-spring.io/docs/hooks/use-transition) provided by react-spring library. So people who will use both concurrent mode and react-spring in their projects will be confused by clashing names.    Did you consider different names for concurrent transitions? For example, `useTransaction` is not present in the ecosystems and can be used to describe concurrent updates.",
        "human_words": "The new concurrent mode provides a new hook - [`useTransition`](https://reactjs.org/docs/concurrent-mode-reference.html#usetransition). However the name of it is confusing. The word \u201ctransition\u201d in web development already refers to animations and css [transition](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions) property. There also exist [useTransition hook](https://www.react-spring.io/docs/hooks/use-transition) provided by react-spring library. So people who will use both concurrent mode and react-spring in their projects will be confused by clashing names.    Did you consider different names for concurrent transitions? For example, `useTransaction` is not present in the ecosystems and can be used to describe concurrent updates.",
        "human_words_regrex": "The new concurrent mode provides a new hook - . However the name of it is confusing. The word \u201ctransition\u201d in web development already refers to animations and css  property. There also exist  provided by react-spring library. So people who will use both concurrent mode and react-spring in their projects will be confused by clashing names. Did you consider different names for concurrent transitions? For example, `useTransaction` is not present in the ecosystems and can be used to describe concurrent updates.",
        "human_words_stopwords_removal_lemmatization": "new concurrent mode provides new hook - . however name confusing . word \u201c transition \u201d web development already refers animation cs property . also exist provided react-spring library . people use concurrent mode react-spring project confused clashing name . consider different name concurrent transition ? example , ` usetransaction ` present ecosystem used describe concurrent update .",
        "title_stopwords_removal_lemmatization": "usetransition hook name already exit ecosystem"
    },
    {
        "issue_id": 512359091,
        "title": "Suggestion: Block unsafe javascript: URLs in Concurrent and Blocking Modes",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-10-25T07:48:03Z",
        "status": "closed",
        "description": "In 16.9.0, a warning was added about `javascript:` URLs. This check is very, very important, as it's incredibly easy to forget about just once place where potential user data is passed onto DOM way. And of course, allowing a javascript: URL to be injected into DOM is a very serious XSS issue.\r\n\r\nI griped before that this is too important to be just a warning, and suggested that a semver-compatible solution is to provide an exported function that allows a runtime opt-in to the new safe behavior. This suggestion was dismissed, since if I want this, I can just make my own build of react with the flag enabled. (Of course, almost no one will do this, because it's just too much of a pain to make your own dependency builds with every release)\r\n\r\nI'd like to make a similar suggestion again. Since Concurrent and Blocking modes are coming soon(ish), and make many breaking changes anyway, why not take this opportunity to also block unsafe javascript: URLs when the mode is enabled? I know that URLs have nothing to do with concurrent mode (unlike unsafe lifecycle methods, etc.), but since many people will want to jump onto this new feature anyway and are willing to deal with some migration required anyway, why not add this vital security precaution as well?\r\n\r\nWaiting until React 17 to protect\u2026\u00a0well, probably countless React apps that don't properly sanitize URLs, just doesn't seem reasonable, when the feature is already implemented, only disabled under a feature flag.\r\n\r\ncc @gaearon @sebmarkbage ",
        "remove_template_description": "In 16.9.0, a warning was added about `javascript:` URLs. This check is very, very important, as it's incredibly easy to forget about just once place where potential user data is passed onto DOM way. And of course, allowing a javascript: URL to be injected into DOM is a very serious XSS issue.    I griped before that this is too important to be just a warning, and suggested that a semver-compatible solution is to provide an exported function that allows a runtime opt-in to the new safe behavior. This suggestion was dismissed, since if I want this, I can just make my own build of react with the flag enabled. (Of course, almost no one will do this, because it's just too much of a pain to make your own dependency builds with every release)    I'd like to make a similar suggestion again. Since Concurrent and Blocking modes are coming soon(ish), and make many breaking changes anyway, why not take this opportunity to also block unsafe javascript: URLs when the mode is enabled? I know that URLs have nothing to do with concurrent mode (unlike unsafe lifecycle methods, etc.), but since many people will want to jump onto this new feature anyway and are willing to deal with some migration required anyway, why not add this vital security precaution as well?    Waiting until React 17 to protect\u2026\u00a0well, probably countless React apps that don't properly sanitize URLs, just doesn't seem reasonable, when the feature is already implemented, only disabled under a feature flag.    cc @gaearon @sebmarkbage",
        "human_words": "In 16.9.0, a warning was added about `javascript:` URLs. This check is very, very important, as it's incredibly easy to forget about just once place where potential user data is passed onto DOM way. And of course, allowing a javascript: URL to be injected into DOM is a very serious XSS issue.    I griped before that this is too important to be just a warning, and suggested that a semver-compatible solution is to provide an exported function that allows a runtime opt-in to the new safe behavior. This suggestion was dismissed, since if I want this, I can just make my own build of react with the flag enabled. (Of course, almost no one will do this, because it's just too much of a pain to make your own dependency builds with every release)    I'd like to make a similar suggestion again. Since Concurrent and Blocking modes are coming soon(ish), and make many breaking changes anyway, why not take this opportunity to also block unsafe javascript: URLs when the mode is enabled? I know that URLs have nothing to do with concurrent mode (unlike unsafe lifecycle methods, etc.), but since many people will want to jump onto this new feature anyway and are willing to deal with some migration required anyway, why not add this vital security precaution as well?    Waiting until React 17 to protect\u2026\u00a0well, probably countless React apps that don't properly sanitize URLs, just doesn't seem reasonable, when the feature is already implemented, only disabled under a feature flag.    cc @gaearon @sebmarkbage",
        "human_words_regrex": "In 16.9.0, a warning was added about `javascript:` URLs. This check is very, very important, as it's incredibly easy to forget about just once place where potential user data is passed onto DOM way. And of course, allowing a javascript: URL to be injected into DOM is a very serious XSS issue. I griped before that this is too important to be just a warning, and suggested that a semver-compatible solution is to provide an exported function that allows a runtime opt-in to the new safe behavior. This suggestion was dismissed, since if I want this, I can just make my own build of react with the flag enabled. (Of course, almost no one will do this, because it's just too much of a pain to make your own dependency builds with every release) I'd like to make a similar suggestion again. Since Concurrent and Blocking modes are coming soon(ish), and make many breaking changes anyway, why not take this opportunity to also block unsafe javascript: URLs when the mode is enabled? I know that URLs have nothing to do with concurrent mode (unlike unsafe lifecycle methods, etc.), but since many people will want to jump onto this new feature anyway and are willing to deal with some migration required anyway, why not add this vital security precaution as well? Waiting until React 17 to protect\u2026 well, probably countless React apps that don't properly sanitize URLs, just doesn't seem reasonable, when the feature is already implemented, only disabled under a feature flag. cc @gaearon @sebmarkbage",
        "human_words_stopwords_removal_lemmatization": "16.9.0 , warning added ` javascript : ` url . check , important , 's incredibly easy forget place potential user data passed onto dom way . course , allowing javascript : url injected dom serious x issue . griped important warning , suggested semver-compatible solution provide exported function allows runtime opt-in new safe behavior . suggestion dismissed , since want , make build react flag enabled . ( course , almost one , 's much pain make dependency build every release ) 'd like make similar suggestion . since concurrent blocking mode coming soon ( ish ) , make many breaking change anyway , take opportunity also block unsafe javascript : url mode enabled ? know url nothing concurrent mode ( unlike unsafe lifecycle method , etc . ) , since many people want jump onto new feature anyway willing deal migration required anyway , add vital security precaution well ? waiting react 17 protect\u2026 well , probably countless react apps n't properly sanitize url , n't seem reasonable , feature already implemented , disabled feature flag . cc @ gaearon @ sebmarkbage",
        "title_stopwords_removal_lemmatization": "suggestion : block unsafe javascript : url concurrent blocking mode"
    },
    {
        "issue_id": 500206671,
        "title": "Design decision: why do we need the stale closure problem in the first place?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-09-30T11:07:44Z",
        "status": "open",
        "description": "Hi,\r\n\r\nI initially asked this on Twitter and @gaearon suggested me to open an issue instead.\r\nThe original thread is here: https://twitter.com/sebastienlorber/status/1178328607376232449?s=19\r\nMore easy to read here: https://threadreaderapp.com/thread/1178328607376232449.html\r\nBut will try to make this issue more clear and structured about my args and questions.\r\n\r\nDon't get me wrong, I really like hooks, but wonder if we can't have smarter abstractions and official patterns that make dealing with them more easy for authors and consumers.\r\n\r\n--------------------------------------\r\n\r\n## Workaround for the stale closure\r\n\r\nAfter using hooks for a while, and being familiar with the stale closure problem, I don't really understand why we need to handle closure dependencies, instead of just doing something like the following code, which always executes latest provided closure (capturing fresh variables)\r\n\r\n![image](https://user-images.githubusercontent.com/749374/65869094-f7d52600-e379-11e9-9634-1ab06b41e3ca.png)\r\n\r\nCoupling the dependencies of the closure and the conditions to trigger effect re-execution does not make much sense to me. For me it's perfectly valid to want to capture some variables in the closure, yet when those variables change we don't necessarily want to re-execute.\r\n\r\nThere are many cases where people are using refs to \"stabilize\" some value that should not trigger re-execution, or to access fresh values in closures.\r\n\r\nExamples in major libs includes:\r\n- Formik (code is pretty similar to my \"useSafeEffect\" above): https://github.com/jaredpalmer/formik/blob/master/src/Formik.tsx#L975\r\n- React-redux, which uses refs to access fresh props: https://github.com/reduxjs/react-redux/blob/b6b47995acfb8c1ff5d04a31c14aa75f112a47ab/src/components/connectAdvanced.js#L286\r\n\r\nAlso @Andarist (who maintains a few important React libs for a while): \r\n\r\n![image](https://user-images.githubusercontent.com/749374/65872332-9d8b9380-e380-11e9-90b3-bf294991bb82.png)\r\n\r\n\r\nWe often find in such codebase the \"useIsomorphicLayoutEffect\" hook which permits to ensure that the ref is set the earliest, and try to avoid the useLayoutEffect warning (see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85). What we are doing here seems unrelated to layout and makes me a bit uncomfortable btw.\r\n\r\n\r\n\r\n## Do we need an ESLint rule?\r\n\r\nThe ESLint rule looks to me only useful to avoid the stale closure problem. Without the stale closure problem (which the trick above solves), you can just focus on crafting the array/conditions for effect re-execution and don't need ESLint for that.\r\n\r\nAlso this would make it easier to wrap useEffect in userland without the fear to exposing users to stale closure problem, because eslint plugin won't notice missing dependencies for custom hooks.\r\n\r\nHere's some code for react-navigation (alpha/v5). To me this is weird to have to ask the user to \"useCallback\" just to stabilize the closure of useFocusEffect, just to ensure the effect only runs on messageId change.\r\n\r\n![image](https://user-images.githubusercontent.com/749374/65869719-3d462300-e37b-11e9-94d2-5200481588bc.png)\r\n\r\nNot sure to understand why we can't simply use the following instead. For which I don't see the point of using any ESLint rule. I just want the effect to run on messageId change, this is explicit enough for me and there's no \"trap\"\r\n\r\n![image](https://user-images.githubusercontent.com/749374/65869777-564ed400-e37b-11e9-8570-12534e5f2a53.png)\r\n\r\nI've heard that the [React team recommends rather the later](https://twitter.com/satya164/status/1178571088172896256), asking the user to useCallback, instead of building custom hooks taking a dependency array, why exactly? Also heard that the ESLint plugin now was able to detect missing deps in a custom hook, if you add the [hook name to ESLint conf](https://twitter.com/n1rual/status/1178568248062877701). Not, sure what to think we are supposed to do in the end.\r\n\r\n## Are we safe using workarounds?\r\n\r\nIt's still a bit hard for me to be sure which kind of code is \"safe\" regarding React's upcoming features, particularly Concurrent Mode. \r\n\r\nIf I use the `useEffectSafe` above or something equivalent relying on refs, I am safe and future proof?\r\n\r\nIf this is safe, and makes my life easier, why do I have to build this abstraction myself? \r\n\r\nWouldn't it make sense to make this kind of pattern more \"official\" / documented?\r\n\r\nI keep adding this kind of code to every project I work with:\r\n\r\n```tsx \r\nconst useGetter = <S>(value: S): (() => S) => {\r\n  const ref = useRef(value);\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = value;\r\n  });\r\n  return useCallback(() => ref.current, [ref]);\r\n};\r\n```\r\n(including important community projects like [react-navigation-hooks](https://github.com/react-navigation/hooks/blob/master/src/Hooks.ts#L46))\r\n\r\n## Is it a strategy to teach users?\r\n\r\nIs it a choice of the React team to not ship safer abstractions officially and make sure the users hit the closure problem early and get familiar with it? \r\n\r\nBecause anyway, even when using getters, we still can't prevent the user to capture some value. This has been documented by @sebmarkbage [here](https://gist.github.com/sebmarkbage/a5ef436427437a98408672108df01919) with async code, even with a getter, we can't prevent the user to do things like:\r\n\r\n```tsx\r\nonMount(async () => {\r\n  let isEligible = getIsEligible();\r\n  let data = await fetch(...);\r\n  // at this point, isEligible might has changed: we should rather use `getIsEligible()` again instead of storing a boolean in the closure (might depend on the usecase though, but maybe we can imagine isEligible => isMounted)\r\n  if (isEligible) {\r\n    doStuff(data);\r\n  }\r\n});\r\n```  \r\nAs far as I understand, this might be the case:\r\n\r\n> So you can easily get into the same situation even with a mutable source value. React just makes you always deal with it so that you don't get too far down the road before you have to refactor you code to deal with these cases anyway. I'm really glad how well the React community has dealt with this since the release of hooks because it really sets us up to predictably deal with more complex scenario and for doing more things in the future.\r\n\r\n\r\n## A concrete problem\r\n\r\nA react-navigation-hooks user reported that his effect run too much, using the following code:\r\n\r\n![image](https://user-images.githubusercontent.com/749374/65870979-bf374b80-e37d-11e9-8a6c-1f7df8503c18.png)\r\n\r\nIn practice, this is because react-navigation core does not provide stable `navigate` function, and thus the hooks too. The core does not necessarily want to \"stabilize\" the navigate function and guarantee that contract in its API.\r\n\r\nIt's not clear to me what should I do, between officially stabilizing the `navigate` function in the hooks project (relying on core, so core can still return distinct navigate functions), or if I should ask the user to stabilize the function himself in userland, leading to pain and boilerplate for many users trying to use the API.\r\n\r\nI don't understand why you can't simply dissociate the closure dependencies to the effect's triggering, and simply omitting the `navigate` function here:\r\n\r\n![image](https://user-images.githubusercontent.com/749374/65871264-51d7ea80-e37e-11e9-837d-291775853b2e.png)\r\n\r\n\r\nWhat bothers me is that somehow as hooks lib authors we now have to think about whether what we return to the user is stable or not, ie safe to use in an effect dependency array without unwanted effect re-executions.\r\n\r\nReturning a stable value in v1 and unstable in v2 is a breaking change that might break users apps in nasty ways, and we have to document this too in our api doc, or ask the user to not trust us, and do the memoization work themselves, which is quite error prone and verbose. Now as lib authors we have to think not only about the inputs/outputs, but also about preserving identities or not (it's probably not a new problem, because we already need to in userland for optimisations anyway).\r\n\r\nAsking users to do this memoization themselves is error prone and verbose. And intuitively some people will maybe want to `useMemo` (just because of the naming) which actually can tricks them by not offering the same guarantees than `useCallback`.\r\n\r\n\r\n## A tradeoff between different usecases in the name of a consistent API?\r\n\r\n@satya164 also mentionned that there are also usecases where the [ESLint plugin saved him](https://twitter.com/satya164/status/1178395620236759043) more than once because he forgot some dependency, and for him, it's more easy to fix an effect re-executing too much than to find out about some cached value not updating. \r\n\r\nI see how the ESLint plugin is really handy for usecases such as building a stable object to optimize renders or provide a stable context value. \r\n\r\nBut for useEffect, when capturing functions, sometimes executing 2 functions with distinct identities actually lead to the same result. Having to add those functions to dependencies is quite annoying in such case. \r\n\r\nBut I totally understand we want to guarantee some kind of consistency across all hooks API.\r\n\r\n## Conclusion\r\n\r\nI try to understand some of the tradeoffs being made in the API. Not sure to understand yet the whole picture, and I'm probably not alone. \r\n\r\n@gaearon said to open an issue with a comment: `It's more nuanced`. I'm here to discuss all the nuances if possible :)\r\n\r\nWhat particularly bothers me currently is not necessarily the existing API. It's rather:\r\n- the dogmatism of absolutely wanting to conform the ESLint rules (for which I don't agree with for all usecases). Currently I think users are really afraid to not follow the rules.\r\n- the lack of official patterns on how we are supposed to handle some specific hooks cases. And I think the \"getter\" pattern should be a thing that every hooks users know about and learn very early. Eventually adding such pattern in core would make it even more visible. Currently it's more lib authors and tech leads that all find out about this pattern in userland with small implementation variations.\r\n\r\nThose are the solutions that I think of. As I said I may miss something important and may change my opinions according to the answers.\r\n\r\nAs an author of a few React libs, I feel a bit frustrated to not be 100% sure what kind of API contract I should offer to my lib's users. I'm also not sure about the hooks patterns I can recommend or not. I plan to open-source something soon but don't even know if that's a good idea, and if it goes in the direction the React team want to go with hooks.\r\n\r\nThanks\r\n\r\n\r\n",
        "remove_template_description": "Hi,    I initially asked this on Twitter and @gaearon suggested me to open an issue instead.  The original thread is here: https://twitter.com/sebastienlorber/status/1178328607376232449?s=19  More easy to read here: https://threadreaderapp.com/thread/1178328607376232449.html  But will try to make this issue more clear and structured about my args and questions.    Don't get me wrong, I really like hooks, but wonder if we can't have smarter abstractions and official patterns that make dealing with them more easy for authors and consumers.    --------------------------------------    ## Workaround for the stale closure    After using hooks for a while, and being familiar with the stale closure problem, I don't really understand why we need to handle closure dependencies, instead of just doing something like the following code, which always executes latest provided closure (capturing fresh variables)    ![image](https://user-images.githubusercontent.com/749374/65869094-f7d52600-e379-11e9-9634-1ab06b41e3ca.png)    Coupling the dependencies of the closure and the conditions to trigger effect re-execution does not make much sense to me. For me it's perfectly valid to want to capture some variables in the closure, yet when those variables change we don't necessarily want to re-execute.    There are many cases where people are using refs to \"stabilize\" some value that should not trigger re-execution, or to access fresh values in closures.    Examples in major libs includes:  - Formik (code is pretty similar to my \"useSafeEffect\" above): https://github.com/jaredpalmer/formik/blob/master/src/Formik.tsx#L975  - React-redux, which uses refs to access fresh props: https://github.com/reduxjs/react-redux/blob/b6b47995acfb8c1ff5d04a31c14aa75f112a47ab/src/components/connectAdvanced.js#L286    Also @Andarist (who maintains a few important React libs for a while):     ![image](https://user-images.githubusercontent.com/749374/65872332-9d8b9380-e380-11e9-90b3-bf294991bb82.png)      We often find in such codebase the \"useIsomorphicLayoutEffect\" hook which permits to ensure that the ref is set the earliest, and try to avoid the useLayoutEffect warning (see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85). What we are doing here seems unrelated to layout and makes me a bit uncomfortable btw.        ## Do we need an ESLint rule?    The ESLint rule looks to me only useful to avoid the stale closure problem. Without the stale closure problem (which the trick above solves), you can just focus on crafting the array/conditions for effect re-execution and don't need ESLint for that.    Also this would make it easier to wrap useEffect in userland without the fear to exposing users to stale closure problem, because eslint plugin won't notice missing dependencies for custom hooks.    Here's some code for react-navigation (alpha/v5). To me this is weird to have to ask the user to \"useCallback\" just to stabilize the closure of useFocusEffect, just to ensure the effect only runs on messageId change.    ![image](https://user-images.githubusercontent.com/749374/65869719-3d462300-e37b-11e9-94d2-5200481588bc.png)    Not sure to understand why we can't simply use the following instead. For which I don't see the point of using any ESLint rule. I just want the effect to run on messageId change, this is explicit enough for me and there's no \"trap\"    ![image](https://user-images.githubusercontent.com/749374/65869777-564ed400-e37b-11e9-8570-12534e5f2a53.png)    I've heard that the [React team recommends rather the later](https://twitter.com/satya164/status/1178571088172896256), asking the user to useCallback, instead of building custom hooks taking a dependency array, why exactly? Also heard that the ESLint plugin now was able to detect missing deps in a custom hook, if you add the [hook name to ESLint conf](https://twitter.com/n1rual/status/1178568248062877701). Not, sure what to think we are supposed to do in the end.    ## Are we safe using workarounds?    It's still a bit hard for me to be sure which kind of code is \"safe\" regarding React's upcoming features, particularly Concurrent Mode.     If I use the `useEffectSafe` above or something equivalent relying on refs, I am safe and future proof?    If this is safe, and makes my life easier, why do I have to build this abstraction myself?     Wouldn't it make sense to make this kind of pattern more \"official\" / documented?    I keep adding this kind of code to every project I work with:    ```tsx   const useGetter = <S>(value: S): (() => S) => {    const ref = useRef(value);    useIsomorphicLayoutEffect(() => {      ref.current = value;    });    return useCallback(() => ref.current, [ref]);  };  ```  (including important community projects like [react-navigation-hooks](https://github.com/react-navigation/hooks/blob/master/src/Hooks.ts#L46))    ## Is it a strategy to teach users?    Is it a choice of the React team to not ship safer abstractions officially and make sure the users hit the closure problem early and get familiar with it?     Because anyway, even when using getters, we still can't prevent the user to capture some value. This has been documented by @sebmarkbage [here](https://gist.github.com/sebmarkbage/a5ef436427437a98408672108df01919) with async code, even with a getter, we can't prevent the user to do things like:    ```tsx  onMount(async () => {    let isEligible = getIsEligible();    let data = await fetch(...);    // at this point, isEligible might has changed: we should rather use `getIsEligible()` again instead of storing a boolean in the closure (might depend on the usecase though, but maybe we can imagine isEligible => isMounted)    if (isEligible) {      doStuff(data);    }  });  ```    As far as I understand, this might be the case:    > So you can easily get into the same situation even with a mutable source value. React just makes you always deal with it so that you don't get too far down the road before you have to refactor you code to deal with these cases anyway. I'm really glad how well the React community has dealt with this since the release of hooks because it really sets us up to predictably deal with more complex scenario and for doing more things in the future.      ## A concrete problem    A react-navigation-hooks user reported that his effect run too much, using the following code:    ![image](https://user-images.githubusercontent.com/749374/65870979-bf374b80-e37d-11e9-8a6c-1f7df8503c18.png)    In practice, this is because react-navigation core does not provide stable `navigate` function, and thus the hooks too. The core does not necessarily want to \"stabilize\" the navigate function and guarantee that contract in its API.    It's not clear to me what should I do, between officially stabilizing the `navigate` function in the hooks project (relying on core, so core can still return distinct navigate functions), or if I should ask the user to stabilize the function himself in userland, leading to pain and boilerplate for many users trying to use the API.    I don't understand why you can't simply dissociate the closure dependencies to the effect's triggering, and simply omitting the `navigate` function here:    ![image](https://user-images.githubusercontent.com/749374/65871264-51d7ea80-e37e-11e9-837d-291775853b2e.png)      What bothers me is that somehow as hooks lib authors we now have to think about whether what we return to the user is stable or not, ie safe to use in an effect dependency array without unwanted effect re-executions.    Returning a stable value in v1 and unstable in v2 is a breaking change that might break users apps in nasty ways, and we have to document this too in our api doc, or ask the user to not trust us, and do the memoization work themselves, which is quite error prone and verbose. Now as lib authors we have to think not only about the inputs/outputs, but also about preserving identities or not (it's probably not a new problem, because we already need to in userland for optimisations anyway).    Asking users to do this memoization themselves is error prone and verbose. And intuitively some people will maybe want to `useMemo` (just because of the naming) which actually can tricks them by not offering the same guarantees than `useCallback`.      ## A tradeoff between different usecases in the name of a consistent API?    @satya164 also mentionned that there are also usecases where the [ESLint plugin saved him](https://twitter.com/satya164/status/1178395620236759043) more than once because he forgot some dependency, and for him, it's more easy to fix an effect re-executing too much than to find out about some cached value not updating.     I see how the ESLint plugin is really handy for usecases such as building a stable object to optimize renders or provide a stable context value.     But for useEffect, when capturing functions, sometimes executing 2 functions with distinct identities actually lead to the same result. Having to add those functions to dependencies is quite annoying in such case.     But I totally understand we want to guarantee some kind of consistency across all hooks API.    ## Conclusion    I try to understand some of the tradeoffs being made in the API. Not sure to understand yet the whole picture, and I'm probably not alone.     @gaearon said to open an issue with a comment: `It's more nuanced`. I'm here to discuss all the nuances if possible :)    What particularly bothers me currently is not necessarily the existing API. It's rather:  - the dogmatism of absolutely wanting to conform the ESLint rules (for which I don't agree with for all usecases). Currently I think users are really afraid to not follow the rules.  - the lack of official patterns on how we are supposed to handle some specific hooks cases. And I think the \"getter\" pattern should be a thing that every hooks users know about and learn very early. Eventually adding such pattern in core would make it even more visible. Currently it's more lib authors and tech leads that all find out about this pattern in userland with small implementation variations.    Those are the solutions that I think of. As I said I may miss something important and may change my opinions according to the answers.    As an author of a few React libs, I feel a bit frustrated to not be 100% sure what kind of API contract I should offer to my lib's users. I'm also not sure about the hooks patterns I can recommend or not. I plan to open-source something soon but don't even know if that's a good idea, and if it goes in the direction the React team want to go with hooks.    Thanks",
        "human_words": "Hi,    I initially asked this on Twitter and @gaearon suggested me to open an issue instead.  The original thread is here: https://twitter.com/sebastienlorber/status/1178328607376232449?s=19  More easy to read here: https://threadreaderapp.com/thread/1178328607376232449.html  But will try to make this issue more clear and structured about my args and questions.    Don't get me wrong, I really like hooks, but wonder if we can't have smarter abstractions and official patterns that make dealing with them more easy for authors and consumers.    --------------------------------------    ## Workaround for the stale closure    After using hooks for a while, and being familiar with the stale closure problem, I don't really understand why we need to handle closure dependencies, instead of just doing something like the following code, which always executes latest provided closure (capturing fresh variables)    ![image](https://user-images.githubusercontent.com/749374/65869094-f7d52600-e379-11e9-9634-1ab06b41e3ca.png)    Coupling the dependencies of the closure and the conditions to trigger effect re-execution does not make much sense to me. For me it's perfectly valid to want to capture some variables in the closure, yet when those variables change we don't necessarily want to re-execute.    There are many cases where people are using refs to \"stabilize\" some value that should not trigger re-execution, or to access fresh values in closures.    Examples in major libs includes:  - Formik (code is pretty similar to my \"useSafeEffect\" above): https://github.com/jaredpalmer/formik/blob/master/src/Formik.tsx#L975  - React-redux, which uses refs to access fresh props: https://github.com/reduxjs/react-redux/blob/b6b47995acfb8c1ff5d04a31c14aa75f112a47ab/src/components/connectAdvanced.js#L286    Also @Andarist (who maintains a few important React libs for a while):     ![image](https://user-images.githubusercontent.com/749374/65872332-9d8b9380-e380-11e9-90b3-bf294991bb82.png)      We often find in such codebase the \"useIsomorphicLayoutEffect\" hook which permits to ensure that the ref is set the earliest, and try to avoid the useLayoutEffect warning (see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85). What we are doing here seems unrelated to layout and makes me a bit uncomfortable btw.        ## Do we need an ESLint rule?    The ESLint rule looks to me only useful to avoid the stale closure problem. Without the stale closure problem (which the trick above solves), you can just focus on crafting the array/conditions for effect re-execution and don't need ESLint for that.    Also this would make it easier to wrap useEffect in userland without the fear to exposing users to stale closure problem, because eslint plugin won't notice missing dependencies for custom hooks.    Here's some code for react-navigation (alpha/v5). To me this is weird to have to ask the user to \"useCallback\" just to stabilize the closure of useFocusEffect, just to ensure the effect only runs on messageId change.    ![image](https://user-images.githubusercontent.com/749374/65869719-3d462300-e37b-11e9-94d2-5200481588bc.png)    Not sure to understand why we can't simply use the following instead. For which I don't see the point of using any ESLint rule. I just want the effect to run on messageId change, this is explicit enough for me and there's no \"trap\"    ![image](https://user-images.githubusercontent.com/749374/65869777-564ed400-e37b-11e9-8570-12534e5f2a53.png)    I've heard that the [React team recommends rather the later](https://twitter.com/satya164/status/1178571088172896256), asking the user to useCallback, instead of building custom hooks taking a dependency array, why exactly? Also heard that the ESLint plugin now was able to detect missing deps in a custom hook, if you add the [hook name to ESLint conf](https://twitter.com/n1rual/status/1178568248062877701). Not, sure what to think we are supposed to do in the end.    ## Are we safe using workarounds?    It's still a bit hard for me to be sure which kind of code is \"safe\" regarding React's upcoming features, particularly Concurrent Mode.     If I use the `useEffectSafe` above or something equivalent relying on refs, I am safe and future proof?    If this is safe, and makes my life easier, why do I have to build this abstraction myself?     Wouldn't it make sense to make this kind of pattern more \"official\" / documented?    I keep adding this kind of code to every project I work with:      (including important community projects like [react-navigation-hooks](https://github.com/react-navigation/hooks/blob/master/src/Hooks.ts#L46))    ## Is it a strategy to teach users?    Is it a choice of the React team to not ship safer abstractions officially and make sure the users hit the closure problem early and get familiar with it?     Because anyway, even when using getters, we still can't prevent the user to capture some value. This has been documented by @sebmarkbage [here](https://gist.github.com/sebmarkbage/a5ef436427437a98408672108df01919) with async code, even with a getter, we can't prevent the user to do things like:        As far as I understand, this might be the case:    > So you can easily get into the same situation even with a mutable source value. React just makes you always deal with it so that you don't get too far down the road before you have to refactor you code to deal with these cases anyway. I'm really glad how well the React community has dealt with this since the release of hooks because it really sets us up to predictably deal with more complex scenario and for doing more things in the future.      ## A concrete problem    A react-navigation-hooks user reported that his effect run too much, using the following code:    ![image](https://user-images.githubusercontent.com/749374/65870979-bf374b80-e37d-11e9-8a6c-1f7df8503c18.png)    In practice, this is because react-navigation core does not provide stable `navigate` function, and thus the hooks too. The core does not necessarily want to \"stabilize\" the navigate function and guarantee that contract in its API.    It's not clear to me what should I do, between officially stabilizing the `navigate` function in the hooks project (relying on core, so core can still return distinct navigate functions), or if I should ask the user to stabilize the function himself in userland, leading to pain and boilerplate for many users trying to use the API.    I don't understand why you can't simply dissociate the closure dependencies to the effect's triggering, and simply omitting the `navigate` function here:    ![image](https://user-images.githubusercontent.com/749374/65871264-51d7ea80-e37e-11e9-837d-291775853b2e.png)      What bothers me is that somehow as hooks lib authors we now have to think about whether what we return to the user is stable or not, ie safe to use in an effect dependency array without unwanted effect re-executions.    Returning a stable value in v1 and unstable in v2 is a breaking change that might break users apps in nasty ways, and we have to document this too in our api doc, or ask the user to not trust us, and do the memoization work themselves, which is quite error prone and verbose. Now as lib authors we have to think not only about the inputs/outputs, but also about preserving identities or not (it's probably not a new problem, because we already need to in userland for optimisations anyway).    Asking users to do this memoization themselves is error prone and verbose. And intuitively some people will maybe want to `useMemo` (just because of the naming) which actually can tricks them by not offering the same guarantees than `useCallback`.      ## A tradeoff between different usecases in the name of a consistent API?    @satya164 also mentionned that there are also usecases where the [ESLint plugin saved him](https://twitter.com/satya164/status/1178395620236759043) more than once because he forgot some dependency, and for him, it's more easy to fix an effect re-executing too much than to find out about some cached value not updating.     I see how the ESLint plugin is really handy for usecases such as building a stable object to optimize renders or provide a stable context value.     But for useEffect, when capturing functions, sometimes executing 2 functions with distinct identities actually lead to the same result. Having to add those functions to dependencies is quite annoying in such case.     But I totally understand we want to guarantee some kind of consistency across all hooks API.    ## Conclusion    I try to understand some of the tradeoffs being made in the API. Not sure to understand yet the whole picture, and I'm probably not alone.     @gaearon said to open an issue with a comment: `It's more nuanced`. I'm here to discuss all the nuances if possible :)    What particularly bothers me currently is not necessarily the existing API. It's rather:  - the dogmatism of absolutely wanting to conform the ESLint rules (for which I don't agree with for all usecases). Currently I think users are really afraid to not follow the rules.  - the lack of official patterns on how we are supposed to handle some specific hooks cases. And I think the \"getter\" pattern should be a thing that every hooks users know about and learn very early. Eventually adding such pattern in core would make it even more visible. Currently it's more lib authors and tech leads that all find out about this pattern in userland with small implementation variations.    Those are the solutions that I think of. As I said I may miss something important and may change my opinions according to the answers.    As an author of a few React libs, I feel a bit frustrated to not be 100% sure what kind of API contract I should offer to my lib's users. I'm also not sure about the hooks patterns I can recommend or not. I plan to open-source something soon but don't even know if that's a good idea, and if it goes in the direction the React team want to go with hooks.    Thanks",
        "human_words_regrex": "Hi, I initially asked this on Twitter and @gaearon suggested me to open an issue instead. The original thread is here:  More easy to read here:  But will try to make this issue more clear and structured about my args and questions. Don't get me wrong, I really like hooks, but wonder if we can't have smarter abstractions and official patterns that make dealing with them more easy for authors and consumers. -------------------------------------- ## Workaround for the stale closure After using hooks for a while, and being familiar with the stale closure problem, I don't really understand why we need to handle closure dependencies, instead of just doing something like the following code, which always executes latest provided closure (capturing fresh variables) ! Coupling the dependencies of the closure and the conditions to trigger effect re-execution does not make much sense to me. For me it's perfectly valid to want to capture some variables in the closure, yet when those variables change we don't necessarily want to re-execute. There are many cases where people are using refs to \"stabilize\" some value that should not trigger re-execution, or to access fresh values in closures. Examples in major libs includes: - Formik (code is pretty similar to my \"useSafeEffect\" above):  - React-redux, which uses refs to access fresh props:  Also @Andarist (who maintains a few important React libs for a while): ! We often find in such codebase the \"useIsomorphicLayoutEffect\" hook which permits to ensure that the ref is set the earliest, and try to avoid the useLayoutEffect warning (see  What we are doing here seems unrelated to layout and makes me a bit uncomfortable btw. ## Do we need an ESLint rule? The ESLint rule looks to me only useful to avoid the stale closure problem. Without the stale closure problem (which the trick above solves), you can just focus on crafting the array/conditions for effect re-execution and don't need ESLint for that. Also this would make it easier to wrap useEffect in userland without the fear to exposing users to stale closure problem, because eslint plugin won't notice missing dependencies for custom hooks. Here's some code for react-navigation (alpha/v5). To me this is weird to have to ask the user to \"useCallback\" just to stabilize the closure of useFocusEffect, just to ensure the effect only runs on messageId change. ! Not sure to understand why we can't simply use the following instead. For which I don't see the point of using any ESLint rule. I just want the effect to run on messageId change, this is explicit enough for me and there's no \"trap\" ! I've heard that the , asking the user to useCallback, instead of building custom hooks taking a dependency array, why exactly? Also heard that the ESLint plugin now was able to detect missing deps in a custom hook, if you add the . Not, sure what to think we are supposed to do in the end. ## Are we safe using workarounds? It's still a bit hard for me to be sure which kind of code is \"safe\" regarding React's upcoming features, particularly Concurrent Mode. If I use the `useEffectSafe` above or something equivalent relying on refs, I am safe and future proof? If this is safe, and makes my life easier, why do I have to build this abstraction myself? Wouldn't it make sense to make this kind of pattern more \"official\" / documented? I keep adding this kind of code to every project I work with: (including important community projects like ) ## Is it a strategy to teach users? Is it a choice of the React team to not ship safer abstractions officially and make sure the users hit the closure problem early and get familiar with it? Because anyway, even when using getters, we still can't prevent the user to capture some value. This has been documented by @sebmarkbage  with async code, even with a getter, we can't prevent the user to do things like: As far as I understand, this might be the case: > So you can easily get into the same situation even with a mutable source value. React just makes you always deal with it so that you don't get too far down the road before you have to refactor you code to deal with these cases anyway. I'm really glad how well the React community has dealt with this since the release of hooks because it really sets us up to predictably deal with more complex scenario and for doing more things in the future. ## A concrete problem A react-navigation-hooks user reported that his effect run too much, using the following code: ! In practice, this is because react-navigation core does not provide stable `navigate` function, and thus the hooks too. The core does not necessarily want to \"stabilize\" the navigate function and guarantee that contract in its API. It's not clear to me what should I do, between officially stabilizing the `navigate` function in the hooks project (relying on core, so core can still return distinct navigate functions), or if I should ask the user to stabilize the function himself in userland, leading to pain and boilerplate for many users trying to use the API. I don't understand why you can't simply dissociate the closure dependencies to the effect's triggering, and simply omitting the `navigate` function here: ! What bothers me is that somehow as hooks lib authors we now have to think about whether what we return to the user is stable or not, ie safe to use in an effect dependency array without unwanted effect re-executions. Returning a stable value in v1 and unstable in v2 is a breaking change that might break users apps in nasty ways, and we have to document this too in our api doc, or ask the user to not trust us, and do the memoization work themselves, which is quite error prone and verbose. Now as lib authors we have to think not only about the inputs/outputs, but also about preserving identities or not (it's probably not a new problem, because we already need to in userland for optimisations anyway). Asking users to do this memoization themselves is error prone and verbose. And intuitively some people will maybe want to `useMemo` (just because of the naming) which actually can tricks them by not offering the same guarantees than `useCallback`. ## A tradeoff between different usecases in the name of a consistent API? @satya164 also mentionned that there are also usecases where the  more than once because he forgot some dependency, and for him, it's more easy to fix an effect re-executing too much than to find out about some cached value not updating. I see how the ESLint plugin is really handy for usecases such as building a stable object to optimize renders or provide a stable context value. But for useEffect, when capturing functions, sometimes executing 2 functions with distinct identities actually lead to the same result. Having to add those functions to dependencies is quite annoying in such case. But I totally understand we want to guarantee some kind of consistency across all hooks API. ## Conclusion I try to understand some of the tradeoffs being made in the API. Not sure to understand yet the whole picture, and I'm probably not alone. @gaearon said to open an issue with a comment: `It's more nuanced`. I'm here to discuss all the nuances if possible :) What particularly bothers me currently is not necessarily the existing API. It's rather: - the dogmatism of absolutely wanting to conform the ESLint rules (for which I don't agree with for all usecases). Currently I think users are really afraid to not follow the rules. - the lack of official patterns on how we are supposed to handle some specific hooks cases. And I think the \"getter\" pattern should be a thing that every hooks users know about and learn very early. Eventually adding such pattern in core would make it even more visible. Currently it's more lib authors and tech leads that all find out about this pattern in userland with small implementation variations. Those are the solutions that I think of. As I said I may miss something important and may change my opinions according to the answers. As an author of a few React libs, I feel a bit frustrated to not be 100% sure what kind of API contract I should offer to my lib's users. I'm also not sure about the hooks patterns I can recommend or not. I plan to open-source something soon but don't even know if that's a good idea, and if it goes in the direction the React team want to go with hooks. Thanks",
        "human_words_stopwords_removal_lemmatization": "hi , initially asked twitter @ gaearon suggested open issue instead . original thread : easy read : try make issue clear structured args question . n't get wrong , really like hook , wonder ca n't smarter abstraction official pattern make dealing easy author consumer . -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- # # workaround stale closure using hook , familiar stale closure problem , n't really understand need handle closure dependency , instead something like following code , always executes latest provided closure ( capturing fresh variable ) ! coupling dependency closure condition trigger effect re-execution make much sense . 's perfectly valid want capture variable closure , yet variable change n't necessarily want re-execute . many case people using ref `` stabilize '' value trigger re-execution , access fresh value closure . example major libs includes : - formik ( code pretty similar `` usesafeeffect '' ) : - react-redux , us ref access fresh prop : also @ andarist ( maintains important react libs ) : ! often find codebase `` useisomorphiclayouteffect '' hook permit ensure ref set earliest , try avoid uselayouteffect warning ( see seems unrelated layout make bit uncomfortable btw . # # need eslint rule ? eslint rule look useful avoid stale closure problem . without stale closure problem ( trick solves ) , focus crafting array/conditions effect re-execution n't need eslint . also would make easier wrap useeffect userland without fear exposing user stale closure problem , eslint plugin wo n't notice missing dependency custom hook . 's code react-navigation ( alpha/v5 ) . weird ask user `` usecallback '' stabilize closure usefocuseffect , ensure effect run messageid change . ! sure understand ca n't simply use following instead . n't see point using eslint rule . want effect run messageid change , explicit enough 's `` trap '' ! 've heard , asking user usecallback , instead building custom hook taking dependency array , exactly ? also heard eslint plugin able detect missing deps custom hook , add . , sure think supposed end . # # safe using workarounds ? 's still bit hard sure kind code `` safe '' regarding react 's upcoming feature , particularly concurrent mode . use ` useeffectsafe ` something equivalent relying ref , safe future proof ? safe , make life easier , build abstraction ? would n't make sense make kind pattern `` official '' / documented ? keep adding kind code every project work : ( including important community project like ) # # strategy teach user ? choice react team ship safer abstraction officially make sure user hit closure problem early get familiar ? anyway , even using getters , still ca n't prevent user capture value . documented @ sebmarkbage async code , even getter , ca n't prevent user thing like : far understand , might case : > easily get situation even mutable source value . react make always deal n't get far road refactor code deal case anyway . 'm really glad well react community dealt since release hook really set u predictably deal complex scenario thing future . # # concrete problem react-navigation-hooks user reported effect run much , using following code : ! practice , react-navigation core provide stable ` navigate ` function , thus hook . core necessarily want `` stabilize '' navigate function guarantee contract api . 's clear , officially stabilizing ` navigate ` function hook project ( relying core , core still return distinct navigate function ) , ask user stabilize function userland , leading pain boilerplate many user trying use api . n't understand ca n't simply dissociate closure dependency effect 's triggering , simply omitting ` navigate ` function : ! bother somehow hook lib author think whether return user stable , ie safe use effect dependency array without unwanted effect re-executions . returning stable value v1 unstable v2 breaking change might break user apps nasty way , document api doc , ask user trust u , memoization work , quite error prone verbose . lib author think inputs/outputs , also preserving identity ( 's probably new problem , already need userland optimisation anyway ) . asking user memoization error prone verbose . intuitively people maybe want ` usememo ` ( naming ) actually trick offering guarantee ` usecallback ` . # # tradeoff different usecases name consistent api ? @ satya164 also mentionned also usecases forgot dependency , , 's easy fix effect re-executing much find cached value updating . see eslint plugin really handy usecases building stable object optimize render provide stable context value . useeffect , capturing function , sometimes executing 2 function distinct identity actually lead result . add function dependency quite annoying case . totally understand want guarantee kind consistency across hook api . # # conclusion try understand tradeoff made api . sure understand yet whole picture , 'm probably alone . @ gaearon said open issue comment : ` 's nuanced ` . 'm discus nuance possible : ) particularly bother currently necessarily existing api . 's rather : - dogmatism absolutely wanting conform eslint rule ( n't agree usecases ) . currently think user really afraid follow rule . - lack official pattern supposed handle specific hook case . think `` getter '' pattern thing every hook user know learn early . eventually adding pattern core would make even visible . currently 's lib author tech lead find pattern userland small implementation variation . solution think . said may miss something important may change opinion according answer . author react libs , feel bit frustrated 100 % sure kind api contract offer lib 's user . 'm also sure hook pattern recommend . plan open-source something soon n't even know 's good idea , go direction react team want go hook . thanks",
        "title_stopwords_removal_lemmatization": "design decision : need stale closure problem first place ?"
    },
    {
        "issue_id": 498916121,
        "title": "More time between releasing @next and @latest",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-09-26T14:18:06Z",
        "status": "closed",
        "description": "As a library author, I test against both the `@next` and `@latest` versions of `react` and `react-dom` (as well as 16.3, the oldest version we support). The rationale for that is to know up front if the upcoming version of React is going to break our library. I think this is good practice for everyone involved.\r\n\r\nUnfortunately, when 16.9 was released, there was only 1 week between promoting the RC to `@next`, and promoting that to `@latest`. Because the last RC broke the way `act` works, I had only 1 week to fix our unit test suite, which was all the sudden mostly failing. In fact we had to wait for `react-testing-library` to be updated to deal with this change.\r\n\r\nLuckily I was able to scramble and find time to fix this before the final release, but this won't always be the case. I imagine other library authors may struggle with this too. As such I would like to see at least a 2 week window between `next` and `latest`. I hope that's feasible.\r\n\r\nPlease advise if there's a better way to test for future compatibility.",
        "remove_template_description": "As a library author, I test against both the `@next` and `@latest` versions of `react` and `react-dom` (as well as 16.3, the oldest version we support). The rationale for that is to know up front if the upcoming version of React is going to break our library. I think this is good practice for everyone involved.    Unfortunately, when 16.9 was released, there was only 1 week between promoting the RC to `@next`, and promoting that to `@latest`. Because the last RC broke the way `act` works, I had only 1 week to fix our unit test suite, which was all the sudden mostly failing. In fact we had to wait for `react-testing-library` to be updated to deal with this change.    Luckily I was able to scramble and find time to fix this before the final release, but this won't always be the case. I imagine other library authors may struggle with this too. As such I would like to see at least a 2 week window between `next` and `latest`. I hope that's feasible.    Please advise if there's a better way to test for future compatibility.",
        "human_words": "As a library author, I test against both the `@next` and `@latest` versions of `react` and `react-dom` (as well as 16.3, the oldest version we support). The rationale for that is to know up front if the upcoming version of React is going to break our library. I think this is good practice for everyone involved.    Unfortunately, when 16.9 was released, there was only 1 week between promoting the RC to `@next`, and promoting that to `@latest`. Because the last RC broke the way `act` works, I had only 1 week to fix our unit test suite, which was all the sudden mostly failing. In fact we had to wait for `react-testing-library` to be updated to deal with this change.    Luckily I was able to scramble and find time to fix this before the final release, but this won't always be the case. I imagine other library authors may struggle with this too. As such I would like to see at least a 2 week window between `next` and `latest`. I hope that's feasible.    Please advise if there's a better way to test for future compatibility.",
        "human_words_regrex": "As a library author, I test against both the `@next` and `@latest` versions of `react` and `react-dom` (as well as 16.3, the oldest version we support). The rationale for that is to know up front if the upcoming version of React is going to break our library. I think this is good practice for everyone involved. Unfortunately, when 16.9 was released, there was only 1 week between promoting the RC to `@next`, and promoting that to `@latest`. Because the last RC broke the way `act` works, I had only 1 week to fix our unit test suite, which was all the sudden mostly failing. In fact we had to wait for `react-testing-library` to be updated to deal with this change. Luckily I was able to scramble and find time to fix this before the final release, but this won't always be the case. I imagine other library authors may struggle with this too. As such I would like to see at least a 2 week window between `next` and `latest`. I hope that's feasible. Please advise if there's a better way to test for future compatibility.",
        "human_words_stopwords_removal_lemmatization": "library author , test ` @ next ` ` @ latest ` version ` react ` ` react-dom ` ( well 16.3 , oldest version support ) . rationale know front upcoming version react going break library . think good practice everyone involved . unfortunately , 16.9 released , 1 week promoting rc ` @ next ` , promoting ` @ latest ` . last rc broke way ` act ` work , 1 week fix unit test suite , sudden mostly failing . fact wait ` react-testing-library ` updated deal change . luckily able scramble find time fix final release , wo n't always case . imagine library author may struggle . would like see least 2 week window ` next ` ` latest ` . hope 's feasible . please advise 's better way test future compatibility .",
        "title_stopwords_removal_lemmatization": "time releasing @ next @ latest"
    },
    {
        "issue_id": 482702938,
        "title": "Chrome's Custom Formatters",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools"
        ],
        "date": "2019-08-20T07:56:30Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nFeature\r\n\r\n_Transferring feature request from the old repo https://github.com/facebook/react-devtools/issues/989_\r\n\r\nHi! Is there any plans on supporting [Chrome's custom formatters](https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview) to display custom data structures in readable format in React dev tools?\r\n\r\nFor example when debugging ClojureScript's immutable data structures we have a custom formatter that outputs data into the console in readable and inspectable format.\r\n\r\nHere how it looks like\r\n![screen shot 2018-02-19 at 3 02 32 pm](https://user-images.githubusercontent.com/1355501/36379156-39e8a882-1586-11e8-8973-7e6d3772cb4e.png)\r\n\r\nAnd here's how data looks like in React Dev Tools inspector (basically underlying implementation of a data structure as seen in plain JS)\r\n![screen shot 2018-02-19 at 2 59 04 pm](https://user-images.githubusercontent.com/1355501/36379177-4b280d90-1586-11e8-808d-ea7f2cebb274.png)\r\n\r\nI think this can be done for React Dev Tools since once Custom Formatters are defined they are applied everywhere in Chrome's Dev Tools where it's possible to inspect data.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Feature    _Transferring feature request from the old repo https://github.com/facebook/react-devtools/issues/989_    Hi! Is there any plans on supporting [Chrome's custom formatters](https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview) to display custom data structures in readable format in React dev tools?    For example when debugging ClojureScript's immutable data structures we have a custom formatter that outputs data into the console in readable and inspectable format.    Here how it looks like  ![screen shot 2018-02-19 at 3 02 32 pm](https://user-images.githubusercontent.com/1355501/36379156-39e8a882-1586-11e8-8973-7e6d3772cb4e.png)    And here's how data looks like in React Dev Tools inspector (basically underlying implementation of a data structure as seen in plain JS)  ![screen shot 2018-02-19 at 2 59 04 pm](https://user-images.githubusercontent.com/1355501/36379177-4b280d90-1586-11e8-808d-ea7f2cebb274.png)    I think this can be done for React Dev Tools since once Custom Formatters are defined they are applied everywhere in Chrome's Dev Tools where it's possible to inspect data.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Feature    _Transferring feature request from the old repo https://github.com/facebook/react-devtools/issues/989_    Hi! Is there any plans on supporting [Chrome's custom formatters](https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview) to display custom data structures in readable format in React dev tools?    For example when debugging ClojureScript's immutable data structures we have a custom formatter that outputs data into the console in readable and inspectable format.    Here how it looks like  ![screen shot 2018-02-19 at 3 02 32 pm](https://user-images.githubusercontent.com/1355501/36379156-39e8a882-1586-11e8-8973-7e6d3772cb4e.png)    And here's how data looks like in React Dev Tools inspector (basically underlying implementation of a data structure as seen in plain JS)  ![screen shot 2018-02-19 at 2 59 04 pm](https://user-images.githubusercontent.com/1355501/36379177-4b280d90-1586-11e8-808d-ea7f2cebb274.png)    I think this can be done for React Dev Tools since once Custom Formatters are defined they are applied everywhere in Chrome's Dev Tools where it's possible to inspect data.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature _Transferring feature request from the old repo  Hi! Is there any plans on supporting  to display custom data structures in readable format in React dev tools? For example when debugging ClojureScript's immutable data structures we have a custom formatter that outputs data into the console in readable and inspectable format. Here how it looks like ! And here's how data looks like in React Dev Tools inspector (basically underlying implementation of a data structure as seen in plain JS) ! I think this can be done for React Dev Tools since once Custom Formatters are defined they are applied everywhere in Chrome's Dev Tools where it's possible to inspect data.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature _transferring feature request old repo hi ! plan supporting display custom data structure readable format react dev tool ? example debugging clojurescript 's immutable data structure custom formatter output data console readable inspectable format . look like ! 's data look like react dev tool inspector ( basically underlying implementation data structure seen plain j ) ! think done react dev tool since custom formatters defined applied everywhere chrome 's dev tool 's possible inspect data .",
        "title_stopwords_removal_lemmatization": "chrome 's custom formatters"
    },
    {
        "issue_id": 482545095,
        "title": "Named hooks: MVP support",
        "label": [
            "Type: Enhancement",
            "Type: Discussion",
            "Component: Developer Tools",
            "React Core Team"
        ],
        "date": "2019-08-19T21:50:31Z",
        "status": "closed",
        "description": "**Note** this issue is outdated. The current thinking is that the alternative, \"*load source code (with source maps) and parse for name*\", is probably the best course of action.\r\n\r\n---\r\n\r\n## The problem\r\n\r\nOne common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  const [bar, setBar] = useState(false);\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nCurrently in DevTools the above component would be displayed as follows:\r\n```\r\nSomeCustomHook:\r\n  State: true\r\n  State: false\r\n```\r\n\r\nThis information isn't as rich as we would prefer. \u2639\ufe0f\r\n\r\nThe next question is often: \"can you use the name of the variable the hook return value is assigned to?\" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?)\r\n\r\n## The proposal\r\n\r\nThe solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook (https://github.com/facebook/react/pull/14559), we might introduce a new no-op hook e.g. `useDebugName`.\r\n\r\nThe above example could make use of this hook like so:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  useDebugName(\"foo\"); // injected by Babel transform\r\n  const [bar, setBar] = useState(false);\r\n  useDebugName(\"bar\"); // injected by Babel transform\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nDevTools could then display something like:\r\n```\r\nSomeCustomHook:\r\n  State (foo): true\r\n  State (bar): true\r\n```\r\n\r\n## Implementation details\r\n\r\nThe new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released [`react-debug-hooks` package](https://github.com/facebook/react/blob/master/packages/react-debug-tools/)). The key concerns would be that:\r\n1. It has no effect (and adds no overhead) when DevTools is not present.\r\n2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything.\r\n\r\nDevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook.\r\n\r\nFor example, the following code should only result in one named hook (the second `useState` call).\r\n```js\r\nconst [foo, setFoo] = useState(true);\r\nconst [bar, setBar] = useState(false);\r\nuseDebugName(\"bar\"); // injected by Babel transform\r\nconst [baz, setBaz] = useState(true);\r\n```\r\n\r\nBeing able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata).\r\n\r\nA code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like https://github.com/facebook/react/pull/15939).\r\n\r\n## Further considerations\r\n\r\n### Custom hooks?\r\n\r\nIn some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook (https://github.com/facebook/react/pull/15022):\r\n```js\r\nfunction Example() {\r\n  const foo = useSubscription(...);\r\n  const bar = useSubscription(...);\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nCurrently in DevTools the above component would be displayed as follows:\r\n```\r\nSubscription: \"some value\"\r\n  State: Object\r\nSubscription: \"some other  value\"\r\n  State: Object\r\n```\r\n\r\nMaybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well?\r\n\r\nI think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks.\r\n\r\nFor example, consider the following code:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  useDebugName(\"foo\");\r\n  useDebugName(\"effectively ignored\");\r\n  const [bar, setBar] = useState(false);\r\n  const [baz, setBaz] = useState(false);\r\n  useDebugName(\"baz\");\r\n\r\n  // ...\r\n}\r\n````\r\n\r\nThe proposed implementation of `useDebugName` would be robust enough to handle naming \"foo\" and \"baz\" states and leaving \"bar\" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage.\r\n\r\nPerhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature.\r\n\r\n## Alternatives considered\r\n\r\n### Pass debug name as an additional (unused) parameter\r\n\r\nAn alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true, \"foo\");\r\n  const [bar, setBar] = useState(false, \"bar\");\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\n**Pros**:\r\n* Less code.\r\n* Does not introduce a new hook.\r\n\r\n**Cons**:\r\n* It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error.\r\n* It would not be possible to support naming custom hooks (if that's something we decided to do).\r\n\r\n### Load source code (with source maps) and parse for name\r\nWe could use an extension API like [`Resource.getContent`](https://developer.chrome.com/extensions/devtools_inspectedWindow#method-Resource-getContent) to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime.\r\n\r\n**Pros**:\r\n* Does not require a Babel transform step. (\"Just works\")\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n\r\n**Cons**:\r\n* Adds additional async loading (complexity) to suspense cache used for hooks inspection.\r\n* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser.\r\n\r\n### Call `toString` on the function component and parse for name\r\nA possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks.\r\n\r\n**Pros**:\r\n* Does not require a Babel transform step. (\"Just works\")\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n* Does not require any additional asynchronous code.\r\n\r\n**Cons**:\r\n* Only supports top-level hooks (used directly within the function).\r\n* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser.\r\n\r\n### Use a Babel transform to leave an inline comment (and call `toString` to search for it)\r\nRather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.:\r\n```js\r\nfunction Example() {\r\n  /* hook:foo:Example.react.js:3 */\r\n  const foo = useSubscription(...);\r\n  /* hook:bar:Example.react.js:5 */\r\n  const bar = useSubscription(...);\r\n\r\n  // ...\r\n}\r\n```\r\n\r\n**Pros**:\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n* Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform).\r\n\r\n**Cons**:\r\n* Only supports top-level hooks (used directly within the function).\r\n* Still requires an explicit transform step.\r\n\r\n---\r\nOriginally reported via https://github.com/bvaughn/react-devtools-experimental/issues/323",
        "remove_template_description": "**Note** this issue is outdated. The current thinking is that the alternative, \"*load source code (with source maps) and parse for name*\", is probably the best course of action.    ---    ## The problem    One common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example:  ```js  function useSomeCustomHook() {    const [foo, setFoo] = useState(true);    const [bar, setBar] = useState(false);      // ...  }    function Example() {    const baz = useSomeCustomHook();      // ...  }  ```    Currently in DevTools the above component would be displayed as follows:  ```  SomeCustomHook:    State: true    State: false  ```    This information isn't as rich as we would prefer. \u2639\ufe0f    The next question is often: \"can you use the name of the variable the hook return value is assigned to?\" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?)    ## The proposal    The solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook (https://github.com/facebook/react/pull/14559), we might introduce a new no-op hook e.g. `useDebugName`.    The above example could make use of this hook like so:  ```js  function useSomeCustomHook() {    const [foo, setFoo] = useState(true);    useDebugName(\"foo\"); // injected by Babel transform    const [bar, setBar] = useState(false);    useDebugName(\"bar\"); // injected by Babel transform      // ...  }    function Example() {    const baz = useSomeCustomHook();      // ...  }  ```    DevTools could then display something like:  ```  SomeCustomHook:    State (foo): true    State (bar): true  ```    ## Implementation details    The new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released [`react-debug-hooks` package](https://github.com/facebook/react/blob/master/packages/react-debug-tools/)). The key concerns would be that:  1. It has no effect (and adds no overhead) when DevTools is not present.  2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything.    DevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook.    For example, the following code should only result in one named hook (the second `useState` call).  ```js  const [foo, setFoo] = useState(true);  const [bar, setBar] = useState(false);  useDebugName(\"bar\"); // injected by Babel transform  const [baz, setBaz] = useState(true);  ```    Being able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata).    A code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like https://github.com/facebook/react/pull/15939).    ## Further considerations    ### Custom hooks?    In some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook (https://github.com/facebook/react/pull/15022):  ```js  function Example() {    const foo = useSubscription(...);    const bar = useSubscription(...);      // ...  }  ```    Currently in DevTools the above component would be displayed as follows:  ```  Subscription: \"some value\"    State: Object  Subscription: \"some other  value\"    State: Object  ```    Maybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well?    I think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks.    For example, consider the following code:  ```js  function useSomeCustomHook() {    const [foo, setFoo] = useState(true);    useDebugName(\"foo\");    useDebugName(\"effectively ignored\");    const [bar, setBar] = useState(false);    const [baz, setBaz] = useState(false);    useDebugName(\"baz\");      // ...  }  ````    The proposed implementation of `useDebugName` would be robust enough to handle naming \"foo\" and \"baz\" states and leaving \"bar\" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage.    Perhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature.    ## Alternatives considered    ### Pass debug name as an additional (unused) parameter    An alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.:  ```js  function useSomeCustomHook() {    const [foo, setFoo] = useState(true, \"foo\");    const [bar, setBar] = useState(false, \"bar\");      // ...  }    function Example() {    const baz = useSomeCustomHook();      // ...  }  ```    **Pros**:  * Less code.  * Does not introduce a new hook.    **Cons**:  * It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error.  * It would not be possible to support naming custom hooks (if that's something we decided to do).    ### Load source code (with source maps) and parse for name  We could use an extension API like [`Resource.getContent`](https://developer.chrome.com/extensions/devtools_inspectedWindow#method-Resource-getContent) to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime.    **Pros**:  * Does not require a Babel transform step. (\"Just works\")  * Does not potentially bloat production builds (if transform is used incorrectly).    **Cons**:  * Adds additional async loading (complexity) to suspense cache used for hooks inspection.  * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser.    ### Call `toString` on the function component and parse for name  A possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks.    **Pros**:  * Does not require a Babel transform step. (\"Just works\")  * Does not potentially bloat production builds (if transform is used incorrectly).  * Does not require any additional asynchronous code.    **Cons**:  * Only supports top-level hooks (used directly within the function).  * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser.    ### Use a Babel transform to leave an inline comment (and call `toString` to search for it)  Rather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.:  ```js  function Example() {    /* hook:foo:Example.react.js:3 */    const foo = useSubscription(...);    /* hook:bar:Example.react.js:5 */    const bar = useSubscription(...);      // ...  }  ```    **Pros**:  * Does not potentially bloat production builds (if transform is used incorrectly).  * Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform).    **Cons**:  * Only supports top-level hooks (used directly within the function).  * Still requires an explicit transform step.    ---  Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/323",
        "human_words": "**Note** this issue is outdated. The current thinking is that the alternative, \"*load source code (with source maps) and parse for name*\", is probably the best course of action.    ---    ## The problem    One common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example:      Currently in DevTools the above component would be displayed as follows:      This information isn't as rich as we would prefer. \u2639\ufe0f    The next question is often: \"can you use the name of the variable the hook return value is assigned to?\" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?)    ## The proposal    The solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook (https://github.com/facebook/react/pull/14559), we might introduce a new no-op hook e.g. `useDebugName`.    The above example could make use of this hook like so:      DevTools could then display something like:      ## Implementation details    The new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released [`react-debug-hooks` package](https://github.com/facebook/react/blob/master/packages/react-debug-tools/)). The key concerns would be that:  1. It has no effect (and adds no overhead) when DevTools is not present.  2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything.    DevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook.    For example, the following code should only result in one named hook (the second `useState` call).      Being able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata).    A code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like https://github.com/facebook/react/pull/15939).    ## Further considerations    ### Custom hooks?    In some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook (https://github.com/facebook/react/pull/15022):      Currently in DevTools the above component would be displayed as follows:      Maybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well?    I think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks.    For example, consider the following code:  `    The proposed implementation of `useDebugName` would be robust enough to handle naming \"foo\" and \"baz\" states and leaving \"bar\" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage.    Perhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature.    ## Alternatives considered    ### Pass debug name as an additional (unused) parameter    An alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.:      **Pros**:  * Less code.  * Does not introduce a new hook.    **Cons**:  * It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error.  * It would not be possible to support naming custom hooks (if that's something we decided to do).    ### Load source code (with source maps) and parse for name  We could use an extension API like [`Resource.getContent`](https://developer.chrome.com/extensions/devtools_inspectedWindow#method-Resource-getContent) to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime.    **Pros**:  * Does not require a Babel transform step. (\"Just works\")  * Does not potentially bloat production builds (if transform is used incorrectly).    **Cons**:  * Adds additional async loading (complexity) to suspense cache used for hooks inspection.  * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser.    ### Call `toString` on the function component and parse for name  A possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks.    **Pros**:  * Does not require a Babel transform step. (\"Just works\")  * Does not potentially bloat production builds (if transform is used incorrectly).  * Does not require any additional asynchronous code.    **Cons**:  * Only supports top-level hooks (used directly within the function).  * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser.    ### Use a Babel transform to leave an inline comment (and call `toString` to search for it)  Rather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.:      **Pros**:  * Does not potentially bloat production builds (if transform is used incorrectly).  * Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform).    **Cons**:  * Only supports top-level hooks (used directly within the function).  * Still requires an explicit transform step.    ---  Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/323",
        "human_words_regrex": "**Note** this issue is outdated. The current thinking is that the alternative, \"*load source code (with source maps) and parse for name*\", is probably the best course of action. --- ## The problem One common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example: Currently in DevTools the above component would be displayed as follows: This information isn't as rich as we would prefer. \u2639\ufe0f The next question is often: \"can you use the name of the variable the hook return value is assigned to?\" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?) ## The proposal The solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook ( we might introduce a new no-op hook e.g. `useDebugName`. The above example could make use of this hook like so: DevTools could then display something like: ## Implementation details The new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released ). The key concerns would be that: 1. It has no effect (and adds no overhead) when DevTools is not present. 2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything. DevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook. For example, the following code should only result in one named hook (the second `useState` call). Being able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata). A code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like  ## Further considerations ### Custom hooks? In some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook ( Currently in DevTools the above component would be displayed as follows: Maybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well? I think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks. For example, consider the following code: ` The proposed implementation of `useDebugName` would be robust enough to handle naming \"foo\" and \"baz\" states and leaving \"bar\" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage. Perhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature. ## Alternatives considered ### Pass debug name as an additional (unused) parameter An alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.: **Pros**: * Less code. * Does not introduce a new hook. **Cons**: * It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error. * It would not be possible to support naming custom hooks (if that's something we decided to do). ### Load source code (with source maps) and parse for name We could use an extension API like  to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime. **Pros**: * Does not require a Babel transform step. (\"Just works\") * Does not potentially bloat production builds (if transform is used incorrectly). **Cons**: * Adds additional async loading (complexity) to suspense cache used for hooks inspection. * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser. ### Call `toString` on the function component and parse for name A possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks. **Pros**: * Does not require a Babel transform step. (\"Just works\") * Does not potentially bloat production builds (if transform is used incorrectly). * Does not require any additional asynchronous code. **Cons**: * Only supports top-level hooks (used directly within the function). * May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser. ### Use a Babel transform to leave an inline comment (and call `toString` to search for it) Rather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.: **Pros**: * Does not potentially bloat production builds (if transform is used incorrectly). * Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform). **Cons**: * Only supports top-level hooks (used directly within the function). * Still requires an explicit transform step. --- Originally reported via ",
        "human_words_stopwords_removal_lemmatization": "* * note * * issue outdated . current thinking alternative , `` * load source code ( source map ) parse name * '' , probably best course action . -- - # # problem one common piece feedback devtools hook integration hook name confusing . consider following example : currently devtools component would displayed follows : information n't rich would prefer . \u2639\ufe0f next question often : `` use name variable hook return value assigned ? '' tricky devtools n't actually way access variable . ( even devtools handle ` example ` function , would access ` usesomecustomhook ` function ? ) # # proposal solution would form user-defined metadata ( preferably generated code transform ) . building precedent ` usedebugvalue ` hook ( might introduce new no-op hook e.g . ` usedebugname ` . example could make use hook like : devtools could display something like : # # implementation detail new ` usedebugname ` hook might noop hook provided react ( similar ` usedebugvalue ` ) _or_ could even export ( soon released ) . key concern would : 1. effect ( add overhead ) devtools present . 2. calling ( calling _some_ hook ) break corrupt anything . devtools could override no-op ` usedebugname ` implementation inspecting component automatically associate provided name recently called native hook . example , following code result one named hook ( second ` usestate ` call ) . able support sparse name metadata would important third party code ( might transformed supply metadata ) . code transform would ideal scenario manual annotation would probably cumbersome . could also marketed * * dev-only transform * * bloat production bundle display name . might even try detect env throw n't dev ( like # # consideration # # # custom hook ? case , custom hook might also ambiguous . consider ` usesubscription ` hook ( currently devtools component would displayed follows : maybe value alone ( provided ` usedebugvalue ` ) could enough uniquely identify hook , suspect many case might sufficient . use ` usedebugname ` custom hook well ? think would fragile given way custom hook detection logic implemented . custom hook identified component finished rendering . order u associate name custom hook , would need maintain stack name . could lead potential mismatch though event ` usedebugname ` called ( fewer ) time custom hook . example , consider following code : ` proposed implementation ` usedebugname ` would robust enough handle naming `` foo '' `` baz '' state leaving `` bar '' anonymous state hook . maintaining stack name however , discrepency would difficult manage . perhaps clever solution problem . would probably suggest leaving initial implementation though revisiting determine 's necessary feature . # # alternative considered # # # pas debug name additional ( unused ) parameter alternative approach calling separate hook naming purpose would pas display name additional parameter native hook , e.g . : * * pro * * : * le code . * introduce new hook . * * con * * : * requires knowledge arity native hook . ror example ` usereducer ` optional parameter transform ( manual code ) would need aware avoid runtime error . * would possible support naming custom hook ( 's something decided ) . # # # load source code ( source map ) parse name could use extension api like load source code ( including custom hook ) parse determine hook/variable name . essentially would work like proposed transform , runtime . * * pro * * : * require babel transform step . ( `` work '' ) * potentially bloat production build ( transform used incorrectly ) . * * con * * : * add additional async loading ( complexity ) suspense cache used hook inspection . * may difficulty parsing certain code pattern ( e.g . babel 's destructuring transform ) unless embed full parser . # # # call ` tostring ` function component parse name possible 80/20 variant proposal would simply call ` tostring ` function component parse top-level hook . * * pro * * : * require babel transform step . ( `` work '' ) * potentially bloat production build ( transform used incorrectly ) . * require additional asynchronous code . * * con * * : * support top-level hook ( used directly within function ) . * may difficulty parsing certain code pattern ( e.g . babel 's destructuring transform ) unless embed fullp parser . # # # use babel transform leave inline comment ( call ` tostring ` search ) rather inserting call new custom hook , code transform could insert inline comment name . could parse code find inline comment , e.g . : * * pro * * : * potentially bloat production build ( transform used incorrectly ) . * potentially sidestep difficulty parsing certain code pattern ( e.g . babel 's destructuring transform ) . * * con * * : * support top-level hook ( used directly within function ) . * still requires explicit transform step . -- - originally reported via",
        "title_stopwords_removal_lemmatization": "named hook : mvp support"
    },
    {
        "issue_id": 482542595,
        "title": "Remember saved component filters by url or in bookmarks",
        "label": [
            "Type: Discussion",
            "Component: Developer Tools",
            "React Core Team"
        ],
        "date": "2019-08-19T21:43:09Z",
        "status": "open",
        "description": "It would be cool if it will support saving filter based on url or some bookmarks. I think it will be really useful for switching between different projects. And seems that bookmarks is better solution because usually people have some different stages like production/pre-production/local development.\r\n\r\n---\r\nOriginally reported by @7rulnik via https://github.com/bvaughn/react-devtools-experimental/issues/359",
        "remove_template_description": "It would be cool if it will support saving filter based on url or some bookmarks. I think it will be really useful for switching between different projects. And seems that bookmarks is better solution because usually people have some different stages like production/pre-production/local development.    ---  Originally reported by @7rulnik via https://github.com/bvaughn/react-devtools-experimental/issues/359",
        "human_words": "It would be cool if it will support saving filter based on url or some bookmarks. I think it will be really useful for switching between different projects. And seems that bookmarks is better solution because usually people have some different stages like production/pre-production/local development.    ---  Originally reported by @7rulnik via https://github.com/bvaughn/react-devtools-experimental/issues/359",
        "human_words_regrex": "It would be cool if it will support saving filter based on url or some bookmarks. I think it will be really useful for switching between different projects. And seems that bookmarks is better solution because usually people have some different stages like production/pre-production/local development. --- Originally reported by @7rulnik via ",
        "human_words_stopwords_removal_lemmatization": "would cool support saving filter based url bookmark . think really useful switching different project . seems bookmark better solution usually people different stage like production/pre-production/local development . -- - originally reported @ 7rulnik via",
        "title_stopwords_removal_lemmatization": "remember saved component filter url bookmark"
    },
    {
        "issue_id": 475084284,
        "title": "Warning for 'exhaustive-deps' keeps asking for the full 'props' object instead of allowing single 'props' properties as dependencies",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2019-07-31T11:18:04Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBUG (possible) in `eslint-plugin-react-hooks`\r\n\r\n**What is the current behavior?**\r\n\r\nWhen I'm in CodeSanbox using a React Sandbox I can use single properties of the `props` object as dependencies for the `useEffect` hook:\r\n\r\nExample 1:\r\n\r\n```\r\nuseEffect(()=>{\r\n    console.log('Running useEffect...');\r\n    console.log(typeof(props.myProp));\r\n  },[ ]);\r\n```\r\n\r\nThe example 1 gives me the following warning in CodeSandbox environment:\r\n\r\n>React Hook useEffect has a missing dependency: '**props.myProp'**. Either include it or remove the dependency array. (react-hooks/exhaustive-deps) eslint\r\n\r\nAnd if I add `[props.myProp]` to the array, the warning goes away.\r\n\r\nBut the same example 1 in my local environment in VSCode, I get the following warning:\r\n\r\n>React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.eslint(react-hooks/exhaustive-deps)\r\n\r\n**What is the expected behavior?**\r\n\r\nI would expect that I would get the same behavior that I get on CodeSandbox in my local environment in VSCode.\r\n\r\nBut, if I add `[props.myProp]` to the array, the warning DOES NOT go away. Although the code works as intended.\r\n\r\nWhat could be happening? Does CodeSandbox uses a different version of the plugin? Is there any configuration I can make to change this behavior?\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nVersions I'm using:\r\n\r\nDEV:\r\n```\r\n\"eslint\": \"^5.10.0\",\r\n\"eslint-plugin-react\": \"^7.11.1\",\r\n\"eslint-plugin-react-hooks\": \"^1.6.1\",\r\n```\r\n\r\nREGULAR\r\n```\r\n\"react\": \"^16.8.6\",\r\n\"react-dom\": \"^16.8.6\",\r\n```\r\n\r\nVSCODE (probably not causing this issue)\r\n\r\nVersion: 1.32.3 (user setup)\r\nCommit: a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4\r\nDate: 2019-03-14T23:43:35.476Z\r\nElectron: 3.1.6\r\nChrome: 66.0.3359.181\r\nNode.js: 10.2.0\r\nV8: 6.6.346.32\r\nOS: Windows_NT x64 10.0.17763\r\n\r\n**.eslintrc.json**\r\n\r\n```\r\n{\r\n  \"root\"  :true,\r\n  \"env\": {\r\n    \"browser\": true,\r\n    \"commonjs\": true,\r\n    \"es6\": true,\r\n    \"node\": true\r\n  },\r\n  \"extends\": [\r\n    \"eslint:recommended\",\r\n    \"plugin:react/recommended\",\r\n    \"plugin:import/errors\"\r\n  ],\r\n  \"parser\":\"babel-eslint\",\r\n  \"parserOptions\": {\r\n    \"ecmaVersion\": 2018,\r\n    \"sourceType\": \"module\",\r\n    \"ecmaFeatures\": {\r\n      \"jsx\":true\r\n    }\r\n  },\r\n  \"plugins\":[\r\n    \"react\",\r\n    \"react-hooks\"\r\n  ],\r\n  \"rules\": {\r\n    \"react/prop-types\": 0,\r\n    \"semi\": \"error\",\r\n    \"no-console\": 0,\r\n    \"react-hooks/rules-of-hooks\": \"error\",\r\n    \"react-hooks/exhaustive-deps\": \"warn\"\r\n  },\r\n  \"settings\": {\r\n    \"import/resolver\" : {\r\n      \"alias\" : {\r\n        \"map\" : [\r\n          [\"@components\",\"./src/components\"],\r\n          [\"@constants\",\"./src/constants\"],\r\n          [\"@helpers\",\"./src/helpers\"]\r\n        ],\r\n        \"extensions\": [\".js\"]\r\n      }\r\n    },\r\n    \"react\" : {\r\n      \"version\": \"detect\"\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    BUG (possible) in `eslint-plugin-react-hooks`    **What is the current behavior?**    When I'm in CodeSanbox using a React Sandbox I can use single properties of the `props` object as dependencies for the `useEffect` hook:    Example 1:    ```  useEffect(()=>{      console.log('Running useEffect...');      console.log(typeof(props.myProp));    },[ ]);  ```    The example 1 gives me the following warning in CodeSandbox environment:    >React Hook useEffect has a missing dependency: '**props.myProp'**. Either include it or remove the dependency array. (react-hooks/exhaustive-deps) eslint    And if I add `[props.myProp]` to the array, the warning goes away.    But the same example 1 in my local environment in VSCode, I get the following warning:    >React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.eslint(react-hooks/exhaustive-deps)    **What is the expected behavior?**    I would expect that I would get the same behavior that I get on CodeSandbox in my local environment in VSCode.    But, if I add `[props.myProp]` to the array, the warning DOES NOT go away. Although the code works as intended.    What could be happening? Does CodeSandbox uses a different version of the plugin? Is there any configuration I can make to change this behavior?    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Versions I'm using:    DEV:  ```  \"eslint\": \"^5.10.0\",  \"eslint-plugin-react\": \"^7.11.1\",  \"eslint-plugin-react-hooks\": \"^1.6.1\",  ```    REGULAR  ```  \"react\": \"^16.8.6\",  \"react-dom\": \"^16.8.6\",  ```    VSCODE (probably not causing this issue)    Version: 1.32.3 (user setup)  Commit: a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4  Date: 2019-03-14T23:43:35.476Z  Electron: 3.1.6  Chrome: 66.0.3359.181  Node.js: 10.2.0  V8: 6.6.346.32  OS: Windows_NT x64 10.0.17763    **.eslintrc.json**    ```  {    \"root\"  :true,    \"env\": {      \"browser\": true,      \"commonjs\": true,      \"es6\": true,      \"node\": true    },    \"extends\": [      \"eslint:recommended\",      \"plugin:react/recommended\",      \"plugin:import/errors\"    ],    \"parser\":\"babel-eslint\",    \"parserOptions\": {      \"ecmaVersion\": 2018,      \"sourceType\": \"module\",      \"ecmaFeatures\": {        \"jsx\":true      }    },    \"plugins\":[      \"react\",      \"react-hooks\"    ],    \"rules\": {      \"react/prop-types\": 0,      \"semi\": \"error\",      \"no-console\": 0,      \"react-hooks/rules-of-hooks\": \"error\",      \"react-hooks/exhaustive-deps\": \"warn\"    },    \"settings\": {      \"import/resolver\" : {        \"alias\" : {          \"map\" : [            [\"@components\",\"./src/components\"],            [\"@constants\",\"./src/constants\"],            [\"@helpers\",\"./src/helpers\"]          ],          \"extensions\": [\".js\"]        }      },      \"react\" : {        \"version\": \"detect\"      }    }  }    ```",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    BUG (possible) in `eslint-plugin-react-hooks`    **What is the current behavior?**    When I'm in CodeSanbox using a React Sandbox I can use single properties of the `props` object as dependencies for the `useEffect` hook:    Example 1:        The example 1 gives me the following warning in CodeSandbox environment:    >React Hook useEffect has a missing dependency: '**props.myProp'**. Either include it or remove the dependency array. (react-hooks/exhaustive-deps) eslint    And if I add `[props.myProp]` to the array, the warning goes away.    But the same example 1 in my local environment in VSCode, I get the following warning:    >React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.eslint(react-hooks/exhaustive-deps)    **What is the expected behavior?**    I would expect that I would get the same behavior that I get on CodeSandbox in my local environment in VSCode.    But, if I add `[props.myProp]` to the array, the warning DOES NOT go away. Although the code works as intended.    What could be happening? Does CodeSandbox uses a different version of the plugin? Is there any configuration I can make to change this behavior?    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Versions I'm using:    DEV:      REGULAR      VSCODE (probably not causing this issue)    Version: 1.32.3 (user setup)  Commit: a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4  Date: 2019-03-14T23:43:35.476Z  Electron: 3.1.6  Chrome: 66.0.3359.181  Node.js: 10.2.0  V8: 6.6.346.32  OS: Windows_NT x64 10.0.17763    **.eslintrc.json**    ",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** BUG (possible) in `eslint-plugin-react-hooks` **What is the current behavior?** When I'm in CodeSanbox using a React Sandbox I can use single properties of the `props` object as dependencies for the `useEffect` hook: Example 1: The example 1 gives me the following warning in CodeSandbox environment: >React Hook useEffect has a missing dependency: '**props.myProp'**. Either include it or remove the dependency array. (react-hooks/exhaustive-deps) eslint And if I add `[props.myProp]` to the array, the warning goes away. But the same example 1 in my local environment in VSCode, I get the following warning: >React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.eslint(react-hooks/exhaustive-deps) **What is the expected behavior?** I would expect that I would get the same behavior that I get on CodeSandbox in my local environment in VSCode. But, if I add `[props.myProp]` to the array, the warning DOES NOT go away. Although the code works as intended. What could be happening? Does CodeSandbox uses a different version of the plugin? Is there any configuration I can make to change this behavior? **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** Versions I'm using: DEV: REGULAR VSCODE (probably not causing this issue) Version: 1.32.3 (user setup) Commit: a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4 Date: 2019-03-14T23:43:35.476Z Electron: 3.1.6 Chrome: 66.0.3359.181 Node.js: 10.2.0 V8: 6.6.346.32 OS: Windows_NT x64 10.0.17763 **.eslintrc.json** ",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug ( possible ) ` eslint-plugin-react-hooks ` * * current behavior ? * * 'm codesanbox using react sandbox use single property ` prop ` object dependency ` useeffect ` hook : example 1 : example 1 give following warning codesandbox environment : > react hook useeffect missing dependency : ' * * props.myprop ' * * . either include remove dependency array . ( react-hooks/exhaustive-deps ) eslint add ` [ props.myprop ] ` array , warning go away . example 1 local environment vscode , get following warning : > react hook useeffect missing dependency : 'props ' . either include remove dependency array . however , 'props ' change * * prop change , preferred fix destructure 'props ' object outside useeffect call refer specific prop inside useeffect.eslint ( react-hooks/exhaustive-deps ) * * expected behavior ? * * would expect would get behavior get codesandbox local environment vscode . , add ` [ props.myprop ] ` array , warning go away . although code work intended . could happening ? codesandbox us different version plugin ? configuration make change behavior ? * * version react , browser / o affected issue ? work previous version react ? * * version 'm using : dev : regular vscode ( probably causing issue ) version : 1.32.3 ( user setup ) commit : a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4 date : 2019-03-14t23:43:35.476z electron : 3.1.6 chrome : 66.0.3359.181 node.js : 10.2.0 v8 : 6.6.346.32 o : windows_nt x64 10.0.17763 * * .eslintrc.json * *",
        "title_stopwords_removal_lemmatization": "warning 'exhaustive-deps ' keep asking full 'props ' object instead allowing single 'props ' property dependency"
    },
    {
        "issue_id": 447903009,
        "title": "Improving the component logging/debugging experience",
        "label": [
            "Type: Discussion",
            "React Core Team"
        ],
        "date": "2019-05-23T22:37:15Z",
        "status": "open",
        "description": "# Backstory\r\n\r\nDevTools re-renders function components that use hooks in order to build up metadata to display in the selected element panel. This may cause confusion, since these re-renders will trigger breakpoints and cause unexpected console logging (see [this comment](https://github.com/facebook/react-devtools/issues/1215#issuecomment-495382645)). We avoid unnecessary re-renders by caching data (see [PR 289](https://github.com/bvaughn/react-devtools-experimental/pull/289)) but even so this is likely to be a point of confusion.\r\n\r\n# Solution\r\n\r\nIt would be nice if the shallow re-rendering done by DevTools were less observable (e.g. console logs were suppressed to avoid cluttering the console). Breakpoints would still be hit, but that seems like a less common use case. \r\n\r\nWhile we are considering logging, we might also consider if there are additional improvements that could be made, e.g.\r\n\r\n1. Add a new section to the Components tree that shows the most recently logged messages for a given component.\r\n2. Add an option to coalesce render-time logs into a single message that's printed at commit (or error) time to make debug logging easier to read. (Perhaps we could use `console.group` to also indicate the nested structure of these logs.)\r\n\r\nThe proposals below address both (a) collecting per-component logging info and (b) temporarily disabling console logging while re-rendering for inspection purposes.\r\n\r\n# API Proposals\r\n\r\n## 1: Modify built-in `console` methods\r\n\r\nDevTools could spy on the built-in `console` methods and disable the pass-through functionality when re-rendering.\r\n\r\n### Pros\r\n* Requires no effort / code changes for developers to opt in and benefit from this.\r\n* \"Just works\" for advanced methods like `console.group` and `console.table`.\r\n* \"Just works\" for third party libraries that may not even be React-specific.\r\n### Cons\r\n* Feels questionable to modify native browser APIs.\r\n\r\n## 2: Add `React.log` and `React.info` API\r\n\r\nReact will be adding two new logging methods in the upcoming v16.9 release- `React.warn` and `React.error` (see #15170). These methods decorate `console.warn` and `console.error` and append the current component stack to any logged messages. We could extend this pattern and add additional `log` and `info` methods. These APIs could be extended by DevTools as needed.\r\n\r\n### Pros\r\n* Does not require mutating global APIs.\r\n### Cons\r\n* Requires code changes to opt-in.\r\n* Would not cover (or would be a hassle to cover) all `console` methods (e.g. `group`)\r\n* Would not work for third party components or non-React utility code.\r\n\r\n## 3: Add `React.debug(callback)` API\r\n\r\nReact could add a new `debug` API that accepts a callback for general debug operations (most commonly `console` logging, but also potentially breakpoints or other things).\r\n\r\n### Pros\r\n* Works with breakpoints.\r\n* Covers more complex use cases (e.g. pushing to an array for debug purposes).\r\n* Single method rather than mirroring (or spying on) multiple `console` APIs.\r\n### Cons\r\n* Requires code changes to opt-in.\r\n* Requires more boilerplate for simple logging use cases.\r\n",
        "remove_template_description": "# Backstory    DevTools re-renders function components that use hooks in order to build up metadata to display in the selected element panel. This may cause confusion, since these re-renders will trigger breakpoints and cause unexpected console logging (see [this comment](https://github.com/facebook/react-devtools/issues/1215#issuecomment-495382645)). We avoid unnecessary re-renders by caching data (see [PR 289](https://github.com/bvaughn/react-devtools-experimental/pull/289)) but even so this is likely to be a point of confusion.    # Solution    It would be nice if the shallow re-rendering done by DevTools were less observable (e.g. console logs were suppressed to avoid cluttering the console). Breakpoints would still be hit, but that seems like a less common use case.     While we are considering logging, we might also consider if there are additional improvements that could be made, e.g.    1. Add a new section to the Components tree that shows the most recently logged messages for a given component.  2. Add an option to coalesce render-time logs into a single message that's printed at commit (or error) time to make debug logging easier to read. (Perhaps we could use `console.group` to also indicate the nested structure of these logs.)    The proposals below address both (a) collecting per-component logging info and (b) temporarily disabling console logging while re-rendering for inspection purposes.    # API Proposals    ## 1: Modify built-in `console` methods    DevTools could spy on the built-in `console` methods and disable the pass-through functionality when re-rendering.    ### Pros  * Requires no effort / code changes for developers to opt in and benefit from this.  * \"Just works\" for advanced methods like `console.group` and `console.table`.  * \"Just works\" for third party libraries that may not even be React-specific.  ### Cons  * Feels questionable to modify native browser APIs.    ## 2: Add `React.log` and `React.info` API    React will be adding two new logging methods in the upcoming v16.9 release- `React.warn` and `React.error` (see #15170). These methods decorate `console.warn` and `console.error` and append the current component stack to any logged messages. We could extend this pattern and add additional `log` and `info` methods. These APIs could be extended by DevTools as needed.    ### Pros  * Does not require mutating global APIs.  ### Cons  * Requires code changes to opt-in.  * Would not cover (or would be a hassle to cover) all `console` methods (e.g. `group`)  * Would not work for third party components or non-React utility code.    ## 3: Add `React.debug(callback)` API    React could add a new `debug` API that accepts a callback for general debug operations (most commonly `console` logging, but also potentially breakpoints or other things).    ### Pros  * Works with breakpoints.  * Covers more complex use cases (e.g. pushing to an array for debug purposes).  * Single method rather than mirroring (or spying on) multiple `console` APIs.  ### Cons  * Requires code changes to opt-in.  * Requires more boilerplate for simple logging use cases.",
        "human_words": "# Backstory    DevTools re-renders function components that use hooks in order to build up metadata to display in the selected element panel. This may cause confusion, since these re-renders will trigger breakpoints and cause unexpected console logging (see [this comment](https://github.com/facebook/react-devtools/issues/1215#issuecomment-495382645)). We avoid unnecessary re-renders by caching data (see [PR 289](https://github.com/bvaughn/react-devtools-experimental/pull/289)) but even so this is likely to be a point of confusion.    # Solution    It would be nice if the shallow re-rendering done by DevTools were less observable (e.g. console logs were suppressed to avoid cluttering the console). Breakpoints would still be hit, but that seems like a less common use case.     While we are considering logging, we might also consider if there are additional improvements that could be made, e.g.    1. Add a new section to the Components tree that shows the most recently logged messages for a given component.  2. Add an option to coalesce render-time logs into a single message that's printed at commit (or error) time to make debug logging easier to read. (Perhaps we could use `console.group` to also indicate the nested structure of these logs.)    The proposals below address both (a) collecting per-component logging info and (b) temporarily disabling console logging while re-rendering for inspection purposes.    # API Proposals    ## 1: Modify built-in `console` methods    DevTools could spy on the built-in `console` methods and disable the pass-through functionality when re-rendering.    ### Pros  * Requires no effort / code changes for developers to opt in and benefit from this.  * \"Just works\" for advanced methods like `console.group` and `console.table`.  * \"Just works\" for third party libraries that may not even be React-specific.  ### Cons  * Feels questionable to modify native browser APIs.    ## 2: Add `React.log` and `React.info` API    React will be adding two new logging methods in the upcoming v16.9 release- `React.warn` and `React.error` (see #15170). These methods decorate `console.warn` and `console.error` and append the current component stack to any logged messages. We could extend this pattern and add additional `log` and `info` methods. These APIs could be extended by DevTools as needed.    ### Pros  * Does not require mutating global APIs.  ### Cons  * Requires code changes to opt-in.  * Would not cover (or would be a hassle to cover) all `console` methods (e.g. `group`)  * Would not work for third party components or non-React utility code.    ## 3: Add `React.debug(callback)` API    React could add a new `debug` API that accepts a callback for general debug operations (most commonly `console` logging, but also potentially breakpoints or other things).    ### Pros  * Works with breakpoints.  * Covers more complex use cases (e.g. pushing to an array for debug purposes).  * Single method rather than mirroring (or spying on) multiple `console` APIs.  ### Cons  * Requires code changes to opt-in.  * Requires more boilerplate for simple logging use cases.",
        "human_words_regrex": "# Backstory DevTools re-renders function components that use hooks in order to build up metadata to display in the selected element panel. This may cause confusion, since these re-renders will trigger breakpoints and cause unexpected console logging (see ). We avoid unnecessary re-renders by caching data (see ) but even so this is likely to be a point of confusion. # Solution It would be nice if the shallow re-rendering done by DevTools were less observable (e.g. console logs were suppressed to avoid cluttering the console). Breakpoints would still be hit, but that seems like a less common use case. While we are considering logging, we might also consider if there are additional improvements that could be made, e.g. 1. Add a new section to the Components tree that shows the most recently logged messages for a given component. 2. Add an option to coalesce render-time logs into a single message that's printed at commit (or error) time to make debug logging easier to read. (Perhaps we could use `console.group` to also indicate the nested structure of these logs.) The proposals below address both (a) collecting per-component logging info and (b) temporarily disabling console logging while re-rendering for inspection purposes. # API Proposals ## 1: Modify built-in `console` methods DevTools could spy on the built-in `console` methods and disable the pass-through functionality when re-rendering. ### Pros * Requires no effort / code changes for developers to opt in and benefit from this. * \"Just works\" for advanced methods like `console.group` and `console.table`. * \"Just works\" for third party libraries that may not even be React-specific. ### Cons * Feels questionable to modify native browser APIs. ## 2: Add `React.log` and `React.info` API React will be adding two new logging methods in the upcoming v16.9 release- `React.warn` and `React.error` (see #15170). These methods decorate `console.warn` and `console.error` and append the current component stack to any logged messages. We could extend this pattern and add additional `log` and `info` methods. These APIs could be extended by DevTools as needed. ### Pros * Does not require mutating global APIs. ### Cons * Requires code changes to opt-in. * Would not cover (or would be a hassle to cover) all `console` methods (e.g. `group`) * Would not work for third party components or non-React utility code. ## 3: Add `React.debug(callback)` API React could add a new `debug` API that accepts a callback for general debug operations (most commonly `console` logging, but also potentially breakpoints or other things). ### Pros * Works with breakpoints. * Covers more complex use cases (e.g. pushing to an array for debug purposes). * Single method rather than mirroring (or spying on) multiple `console` APIs. ### Cons * Requires code changes to opt-in. * Requires more boilerplate for simple logging use cases.",
        "human_words_stopwords_removal_lemmatization": "# backstory devtools re-renders function component use hook order build metadata display selected element panel . may cause confusion , since re-renders trigger breakpoints cause unexpected console logging ( see ) . avoid unnecessary re-renders caching data ( see ) even likely point confusion . # solution would nice shallow re-rendering done devtools le observable ( e.g . console log suppressed avoid cluttering console ) . breakpoints would still hit , seems like le common use case . considering logging , might also consider additional improvement could made , e.g . 1. add new section component tree show recently logged message given component . 2. add option coalesce render-time log single message 's printed commit ( error ) time make debug logging easier read . ( perhaps could use ` console.group ` also indicate nested structure log . ) proposal address ( ) collecting per-component logging info ( b ) temporarily disabling console logging re-rendering inspection purpose . # api proposal # # 1 : modify built-in ` console ` method devtools could spy built-in ` console ` method disable pass-through functionality re-rendering . # # # pro * requires effort / code change developer opt benefit . * `` work '' advanced method like ` console.group ` ` console.table ` . * `` work '' third party library may even react-specific . # # # con * feel questionable modify native browser apis . # # 2 : add ` react.log ` ` react.info ` api react adding two new logging method upcoming v16.9 release- ` react.warn ` ` react.error ` ( see # 15170 ) . method decorate ` console.warn ` ` console.error ` append current component stack logged message . could extend pattern add additional ` log ` ` info ` method . apis could extended devtools needed . # # # pro * require mutating global apis . # # # con * requires code change opt-in . * would cover ( would hassle cover ) ` console ` method ( e.g . ` group ` ) * would work third party component non-react utility code . # # 3 : add ` react.debug ( callback ) ` api react could add new ` debug ` api accepts callback general debug operation ( commonly ` console ` logging , also potentially breakpoints thing ) . # # # pro * work breakpoints . * cover complex use case ( e.g . pushing array debug purpose ) . * single method rather mirroring ( spying ) multiple ` console ` apis . # # # con * requires code change opt-in . * requires boilerplate simple logging use case .",
        "title_stopwords_removal_lemmatization": "improving component logging/debugging experience"
    },
    {
        "issue_id": 429168725,
        "title": "[Concurrent] Safely disposing uncommitted objects",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-04-04T09:17:29Z",
        "status": "open",
        "description": "## How to safely keep a reference to uncommitted objects and dispose of them on unmount? \r\n\r\nFor a MobX world, we are trying to [prepare for the Concurrent mode](https://github.com/mobxjs/mobx-react-lite/issues/53). In short, there is a [Reaction object being created](https://github.com/mobxjs/mobx-react-lite/blob/231be100e6ba458f40642adb9f0bc77aa4d366ce/src/useObserver.ts#L32\r\n) to track for observables and it is stored within `useRef`.\r\n\r\nThe major problem is, that we can't just `useEffect` to create it in a safe way later. We need it to start tracking the observables on a first render otherwise we might miss some updates and cause inconsistent behavior.\r\n\r\nWe do have a [semi-working solution](https://github.com/mobxjs/mobx-react-lite/pull/121), basically, a custom made garbage collector based on `setTimeout`. However, it's unreliable as it can accidentally dispose of Reactions that are actually being used but weren't committed yet.\r\n\r\nWould love to hear we are overlooking some obvious solution there.",
        "remove_template_description": "## How to safely keep a reference to uncommitted objects and dispose of them on unmount?     For a MobX world, we are trying to [prepare for the Concurrent mode](https://github.com/mobxjs/mobx-react-lite/issues/53). In short, there is a [Reaction object being created](https://github.com/mobxjs/mobx-react-lite/blob/231be100e6ba458f40642adb9f0bc77aa4d366ce/src/useObserver.ts#L32  ) to track for observables and it is stored within `useRef`.    The major problem is, that we can't just `useEffect` to create it in a safe way later. We need it to start tracking the observables on a first render otherwise we might miss some updates and cause inconsistent behavior.    We do have a [semi-working solution](https://github.com/mobxjs/mobx-react-lite/pull/121), basically, a custom made garbage collector based on `setTimeout`. However, it's unreliable as it can accidentally dispose of Reactions that are actually being used but weren't committed yet.    Would love to hear we are overlooking some obvious solution there.",
        "human_words": "## How to safely keep a reference to uncommitted objects and dispose of them on unmount?     For a MobX world, we are trying to [prepare for the Concurrent mode](https://github.com/mobxjs/mobx-react-lite/issues/53). In short, there is a [Reaction object being created](https://github.com/mobxjs/mobx-react-lite/blob/231be100e6ba458f40642adb9f0bc77aa4d366ce/src/useObserver.ts#L32  ) to track for observables and it is stored within `useRef`.    The major problem is, that we can't just `useEffect` to create it in a safe way later. We need it to start tracking the observables on a first render otherwise we might miss some updates and cause inconsistent behavior.    We do have a [semi-working solution](https://github.com/mobxjs/mobx-react-lite/pull/121), basically, a custom made garbage collector based on `setTimeout`. However, it's unreliable as it can accidentally dispose of Reactions that are actually being used but weren't committed yet.    Would love to hear we are overlooking some obvious solution there.",
        "human_words_regrex": "## How to safely keep a reference to uncommitted objects and dispose of them on unmount? For a MobX world, we are trying to . In short, there is a  to track for observables and it is stored within `useRef`. The major problem is, that we can't just `useEffect` to create it in a safe way later. We need it to start tracking the observables on a first render otherwise we might miss some updates and cause inconsistent behavior. We do have a , basically, a custom made garbage collector based on `setTimeout`. However, it's unreliable as it can accidentally dispose of Reactions that are actually being used but weren't committed yet. Would love to hear we are overlooking some obvious solution there.",
        "human_words_stopwords_removal_lemmatization": "# # safely keep reference uncommitted object dispose unmount ? mobx world , trying . short , track observables stored within ` useref ` . major problem , ca n't ` useeffect ` create safe way later . need start tracking observables first render otherwise might miss update cause inconsistent behavior . , basically , custom made garbage collector based ` settimeout ` . however , 's unreliable accidentally dispose reaction actually used n't committed yet . would love hear overlooking obvious solution .",
        "title_stopwords_removal_lemmatization": "[ concurrent ] safely disposing uncommitted object"
    },
    {
        "issue_id": 428032141,
        "title": "Is it recommended to fetch in effect or should it be imperative",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2019-04-02T05:34:28Z",
        "status": "open",
        "description": "In out team we encountered a explosive discussion on how we should handle the relationship of a fetch and its parameters, after searching in community I still find various solutions to this, I'd like to raise this discussion to find a best practive.\r\n\r\n## Background\r\n\r\nSuppose we have a simple list view like:\r\n\r\n<img width=\"687\" alt=\"Jietu20190402-130206@2x\" src=\"https://user-images.githubusercontent.com/639549/55377435-87268b80-5547-11e9-97a8-313a5713ced3.png\">\r\n\r\nWhenever user types keyword in textbox and clicks \"Search\" button, or they change the page number, we should fetch a new list from remote and render it in table.\r\n\r\nWe use redux to manage global state of this simple app, the store is structured as:\r\n\r\n```js\r\n{\r\n    filter: '',\r\n    pageIndex: 0,\r\n    results: []\r\n}\r\n```\r\n\r\nWe developed a total of 3 solutions to demonstrate how the change of `filter` and `pageIndex` should cause a fetch of `results`.\r\n\r\n## Use effect and separation of view and logic\r\n\r\nThis is the first demo: https://codesandbox.io/s/20x1m39w00\r\n\r\nIn this implementation we tried to:\r\n\r\n1. Utilize `useEffect` to trigger a fetch when any parameter changes.\r\n2. Do not pass any parameter as prop to `components/List` component.\r\n\r\nIn my point of view, I like this solution best because:\r\n\r\n1. It have a very clear separation of view and logic, `components/List` does not receive any redundant props such as `filter` or `pageIndex`.\r\n2. It theoretically treat a callback prop as a normal one, make it a dependency of `useEffect`.\r\n3. It works in a **reactive** way, which means \"we trigger a fetch not because the action taken from user, only because the change of state\".\r\n\r\nStill we have concerns about it:\r\n\r\n1. It obviously triggers more render and updates because change of `filter` or `pageIndex` does not dispatch `FETCH_RESULTS` immediately, this cause a sync dispatch in effect which we previously avoided by `no-set-state-did-update` rule.\r\n2. We create a state update from another state update, this \"chaining\" is not clear enough for developers and may cause unwanted infinite loop.\r\n\r\n## Use effect and params together\r\n\r\nThe second demo is much like the first one: https://codesandbox.io/s/54o1rjvyv4\r\n\r\nThe only change is we pass `filter` and `pageIndex` to `components/List`, in this case we believe **effect is a part of component** so that every dependencies used to form an effect should be passed as prop.\r\n\r\nThis solution gives a more clear view of what is used to fetch data in `components/List`, this is \r\n a highly adopted solution in community, however we're not sure this is recommended officially.\r\n\r\n## Imperative action to fetch data\r\n\r\nAs opposed to previous, this is our third demo: https://codesandbox.io/s/p5yv48x97x\r\n\r\nIn this solution we changed our thought and implement the app in a more \"redux way\":\r\n\r\n1. We trigger the fetch on user interactions, either click on \"Search\" button or change the page number, however either interaction only provides its own parameter, we don't provide `pageIndex` when \"Search\" button is clicked.\r\n2. We have a thunk which computes a new parameter object based on current state using `getState()` function, a `FETCH_RESULTS` action is dispatched.\r\n3. We have several reducers to observe `FETCH_RESULTS` action and updates corresponding parameter in global state.\r\n4. Fetched list is connected to `components/List` component, this component now is a pure presentational component, no lifecycle effect is involved.\r\n5. To solve the first fetch when application is mounted, we create an `containers/App` container component.\r\n\r\nBy doing these we eliminated the \"chaining state update\" issue, however it introduces several concerns:\r\n\r\n1. If we add more user interactions in the future, the `loadResults` thunk could be more and more complex.\r\n2. The use of `getState` in `redux-thunk` is not highly recommended in community, we found some articles stating that developers should avoid to use it in most cases.\r\n3. We can't explain the exist of the `containers/App` container only to trigger a fetch on mount, thee `useEffect` take no dependencies and `exhaustive-deps` rules complains about it, not paring mount and update is also a big uncomfortable point to us.\r\n4. Trigger fetch from user interactions is what we called \"imperative\", we're confused about whether a reactive framework like react recommends imperative programming.\r\n\r\n------\r\n\r\nSince we are not able to get a conclusion for a very long time, we decide to raise this issue for more discussion to find a better solution to these very common use cases.",
        "remove_template_description": "In out team we encountered a explosive discussion on how we should handle the relationship of a fetch and its parameters, after searching in community I still find various solutions to this, I'd like to raise this discussion to find a best practive.    ## Background    Suppose we have a simple list view like:    <img width=\"687\" alt=\"Jietu20190402-130206@2x\" src=\"https://user-images.githubusercontent.com/639549/55377435-87268b80-5547-11e9-97a8-313a5713ced3.png\">    Whenever user types keyword in textbox and clicks \"Search\" button, or they change the page number, we should fetch a new list from remote and render it in table.    We use redux to manage global state of this simple app, the store is structured as:    ```js  {      filter: '',      pageIndex: 0,      results: []  }  ```    We developed a total of 3 solutions to demonstrate how the change of `filter` and `pageIndex` should cause a fetch of `results`.    ## Use effect and separation of view and logic    This is the first demo: https://codesandbox.io/s/20x1m39w00    In this implementation we tried to:    1. Utilize `useEffect` to trigger a fetch when any parameter changes.  2. Do not pass any parameter as prop to `components/List` component.    In my point of view, I like this solution best because:    1. It have a very clear separation of view and logic, `components/List` does not receive any redundant props such as `filter` or `pageIndex`.  2. It theoretically treat a callback prop as a normal one, make it a dependency of `useEffect`.  3. It works in a **reactive** way, which means \"we trigger a fetch not because the action taken from user, only because the change of state\".    Still we have concerns about it:    1. It obviously triggers more render and updates because change of `filter` or `pageIndex` does not dispatch `FETCH_RESULTS` immediately, this cause a sync dispatch in effect which we previously avoided by `no-set-state-did-update` rule.  2. We create a state update from another state update, this \"chaining\" is not clear enough for developers and may cause unwanted infinite loop.    ## Use effect and params together    The second demo is much like the first one: https://codesandbox.io/s/54o1rjvyv4    The only change is we pass `filter` and `pageIndex` to `components/List`, in this case we believe **effect is a part of component** so that every dependencies used to form an effect should be passed as prop.    This solution gives a more clear view of what is used to fetch data in `components/List`, this is    a highly adopted solution in community, however we're not sure this is recommended officially.    ## Imperative action to fetch data    As opposed to previous, this is our third demo: https://codesandbox.io/s/p5yv48x97x    In this solution we changed our thought and implement the app in a more \"redux way\":    1. We trigger the fetch on user interactions, either click on \"Search\" button or change the page number, however either interaction only provides its own parameter, we don't provide `pageIndex` when \"Search\" button is clicked.  2. We have a thunk which computes a new parameter object based on current state using `getState()` function, a `FETCH_RESULTS` action is dispatched.  3. We have several reducers to observe `FETCH_RESULTS` action and updates corresponding parameter in global state.  4. Fetched list is connected to `components/List` component, this component now is a pure presentational component, no lifecycle effect is involved.  5. To solve the first fetch when application is mounted, we create an `containers/App` container component.    By doing these we eliminated the \"chaining state update\" issue, however it introduces several concerns:    1. If we add more user interactions in the future, the `loadResults` thunk could be more and more complex.  2. The use of `getState` in `redux-thunk` is not highly recommended in community, we found some articles stating that developers should avoid to use it in most cases.  3. We can't explain the exist of the `containers/App` container only to trigger a fetch on mount, thee `useEffect` take no dependencies and `exhaustive-deps` rules complains about it, not paring mount and update is also a big uncomfortable point to us.  4. Trigger fetch from user interactions is what we called \"imperative\", we're confused about whether a reactive framework like react recommends imperative programming.    ------    Since we are not able to get a conclusion for a very long time, we decide to raise this issue for more discussion to find a better solution to these very common use cases.",
        "human_words": "In out team we encountered a explosive discussion on how we should handle the relationship of a fetch and its parameters, after searching in community I still find various solutions to this, I'd like to raise this discussion to find a best practive.    ## Background    Suppose we have a simple list view like:    <img width=\"687\" alt=\"Jietu20190402-130206@2x\" src=\"https://user-images.githubusercontent.com/639549/55377435-87268b80-5547-11e9-97a8-313a5713ced3.png\">    Whenever user types keyword in textbox and clicks \"Search\" button, or they change the page number, we should fetch a new list from remote and render it in table.    We use redux to manage global state of this simple app, the store is structured as:        We developed a total of 3 solutions to demonstrate how the change of `filter` and `pageIndex` should cause a fetch of `results`.    ## Use effect and separation of view and logic    This is the first demo: https://codesandbox.io/s/20x1m39w00    In this implementation we tried to:    1. Utilize `useEffect` to trigger a fetch when any parameter changes.  2. Do not pass any parameter as prop to `components/List` component.    In my point of view, I like this solution best because:    1. It have a very clear separation of view and logic, `components/List` does not receive any redundant props such as `filter` or `pageIndex`.  2. It theoretically treat a callback prop as a normal one, make it a dependency of `useEffect`.  3. It works in a **reactive** way, which means \"we trigger a fetch not because the action taken from user, only because the change of state\".    Still we have concerns about it:    1. It obviously triggers more render and updates because change of `filter` or `pageIndex` does not dispatch `FETCH_RESULTS` immediately, this cause a sync dispatch in effect which we previously avoided by `no-set-state-did-update` rule.  2. We create a state update from another state update, this \"chaining\" is not clear enough for developers and may cause unwanted infinite loop.    ## Use effect and params together    The second demo is much like the first one: https://codesandbox.io/s/54o1rjvyv4    The only change is we pass `filter` and `pageIndex` to `components/List`, in this case we believe **effect is a part of component** so that every dependencies used to form an effect should be passed as prop.    This solution gives a more clear view of what is used to fetch data in `components/List`, this is    a highly adopted solution in community, however we're not sure this is recommended officially.    ## Imperative action to fetch data    As opposed to previous, this is our third demo: https://codesandbox.io/s/p5yv48x97x    In this solution we changed our thought and implement the app in a more \"redux way\":    1. We trigger the fetch on user interactions, either click on \"Search\" button or change the page number, however either interaction only provides its own parameter, we don't provide `pageIndex` when \"Search\" button is clicked.  2. We have a thunk which computes a new parameter object based on current state using `getState()` function, a `FETCH_RESULTS` action is dispatched.  3. We have several reducers to observe `FETCH_RESULTS` action and updates corresponding parameter in global state.  4. Fetched list is connected to `components/List` component, this component now is a pure presentational component, no lifecycle effect is involved.  5. To solve the first fetch when application is mounted, we create an `containers/App` container component.    By doing these we eliminated the \"chaining state update\" issue, however it introduces several concerns:    1. If we add more user interactions in the future, the `loadResults` thunk could be more and more complex.  2. The use of `getState` in `redux-thunk` is not highly recommended in community, we found some articles stating that developers should avoid to use it in most cases.  3. We can't explain the exist of the `containers/App` container only to trigger a fetch on mount, thee `useEffect` take no dependencies and `exhaustive-deps` rules complains about it, not paring mount and update is also a big uncomfortable point to us.  4. Trigger fetch from user interactions is what we called \"imperative\", we're confused about whether a reactive framework like react recommends imperative programming.    ------    Since we are not able to get a conclusion for a very long time, we decide to raise this issue for more discussion to find a better solution to these very common use cases.",
        "human_words_regrex": "In out team we encountered a explosive discussion on how we should handle the relationship of a fetch and its parameters, after searching in community I still find various solutions to this, I'd like to raise this discussion to find a best practive. ## Background Suppose we have a simple list view like: <img width=\"687\" alt=\"Jietu20190402-130206@2x\" src=\" Whenever user types keyword in textbox and clicks \"Search\" button, or they change the page number, we should fetch a new list from remote and render it in table. We use redux to manage global state of this simple app, the store is structured as: We developed a total of 3 solutions to demonstrate how the change of `filter` and `pageIndex` should cause a fetch of `results`. ## Use effect and separation of view and logic This is the first demo:  In this implementation we tried to: 1. Utilize `useEffect` to trigger a fetch when any parameter changes. 2. Do not pass any parameter as prop to `components/List` component. In my point of view, I like this solution best because: 1. It have a very clear separation of view and logic, `components/List` does not receive any redundant props such as `filter` or `pageIndex`. 2. It theoretically treat a callback prop as a normal one, make it a dependency of `useEffect`. 3. It works in a **reactive** way, which means \"we trigger a fetch not because the action taken from user, only because the change of state\". Still we have concerns about it: 1. It obviously triggers more render and updates because change of `filter` or `pageIndex` does not dispatch `FETCH_RESULTS` immediately, this cause a sync dispatch in effect which we previously avoided by `no-set-state-did-update` rule. 2. We create a state update from another state update, this \"chaining\" is not clear enough for developers and may cause unwanted infinite loop. ## Use effect and params together The second demo is much like the first one:  The only change is we pass `filter` and `pageIndex` to `components/List`, in this case we believe **effect is a part of component** so that every dependencies used to form an effect should be passed as prop. This solution gives a more clear view of what is used to fetch data in `components/List`, this is a highly adopted solution in community, however we're not sure this is recommended officially. ## Imperative action to fetch data As opposed to previous, this is our third demo:  In this solution we changed our thought and implement the app in a more \"redux way\": 1. We trigger the fetch on user interactions, either click on \"Search\" button or change the page number, however either interaction only provides its own parameter, we don't provide `pageIndex` when \"Search\" button is clicked. 2. We have a thunk which computes a new parameter object based on current state using `getState()` function, a `FETCH_RESULTS` action is dispatched. 3. We have several reducers to observe `FETCH_RESULTS` action and updates corresponding parameter in global state. 4. Fetched list is connected to `components/List` component, this component now is a pure presentational component, no lifecycle effect is involved. 5. To solve the first fetch when application is mounted, we create an `containers/App` container component. By doing these we eliminated the \"chaining state update\" issue, however it introduces several concerns: 1. If we add more user interactions in the future, the `loadResults` thunk could be more and more complex. 2. The use of `getState` in `redux-thunk` is not highly recommended in community, we found some articles stating that developers should avoid to use it in most cases. 3. We can't explain the exist of the `containers/App` container only to trigger a fetch on mount, thee `useEffect` take no dependencies and `exhaustive-deps` rules complains about it, not paring mount and update is also a big uncomfortable point to us. 4. Trigger fetch from user interactions is what we called \"imperative\", we're confused about whether a reactive framework like react recommends imperative programming. ------ Since we are not able to get a conclusion for a very long time, we decide to raise this issue for more discussion to find a better solution to these very common use cases.",
        "human_words_stopwords_removal_lemmatization": "team encountered explosive discussion handle relationship fetch parameter , searching community still find various solution , 'd like raise discussion find best practive . # # background suppose simple list view like : < img width= '' 687 '' alt= '' jietu20190402-130206 @ 2x '' src= '' whenever user type keyword textbox click `` search '' button , change page number , fetch new list remote render table . use redux manage global state simple app , store structured : developed total 3 solution demonstrate change ` filter ` ` pageindex ` cause fetch ` result ` . # # use effect separation view logic first demo : implementation tried : 1. utilize ` useeffect ` trigger fetch parameter change . 2. pas parameter prop ` components/list ` component . point view , like solution best : 1. clear separation view logic , ` components/list ` receive redundant prop ` filter ` ` pageindex ` . 2. theoretically treat callback prop normal one , make dependency ` useeffect ` . 3. work * * reactive * * way , mean `` trigger fetch action taken user , change state '' . still concern : 1. obviously trigger render update change ` filter ` ` pageindex ` dispatch ` fetch_results ` immediately , cause sync dispatch effect previously avoided ` no-set-state-did-update ` rule . 2. create state update another state update , `` chaining '' clear enough developer may cause unwanted infinite loop . # # use effect params together second demo much like first one : change pas ` filter ` ` pageindex ` ` components/list ` , case believe * * effect part component * * every dependency used form effect passed prop . solution give clear view used fetch data ` components/list ` , highly adopted solution community , however 're sure recommended officially . # # imperative action fetch data opposed previous , third demo : solution changed thought implement app `` redux way '' : 1. trigger fetch user interaction , either click `` search '' button change page number , however either interaction provides parameter , n't provide ` pageindex ` `` search '' button clicked . 2. thunk computes new parameter object based current state using ` getstate ( ) ` function , ` fetch_results ` action dispatched . 3. several reducer observe ` fetch_results ` action update corresponding parameter global state . 4. fetched list connected ` components/list ` component , component pure presentational component , lifecycle effect involved . 5. solve first fetch application mounted , create ` containers/app ` container component . eliminated `` chaining state update '' issue , however introduces several concern : 1. add user interaction future , ` loadresults ` thunk could complex . 2. use ` getstate ` ` redux-thunk ` highly recommended community , found article stating developer avoid use case . 3. ca n't explain exist ` containers/app ` container trigger fetch mount , thee ` useeffect ` take dependency ` exhaustive-deps ` rule complains , paring mount update also big uncomfortable point u . 4. trigger fetch user interaction called `` imperative '' , 're confused whether reactive framework like react recommends imperative programming . -- -- -- since able get conclusion long time , decide raise issue discussion find better solution common use case .",
        "title_stopwords_removal_lemmatization": "recommended fetch effect imperative"
    },
    {
        "issue_id": 427453460,
        "title": "useMemo / useCallback cache busting opt out",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-31T22:12:07Z",
        "status": "open",
        "description": "According to the `React` docs, `useMemo` and `useCallback` are subject to cache purging:\r\n\r\n> You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \u201cforget\u201d some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo \u2014 and then add it to optimize performance. [source](https://reactjs.org/docs/hooks-reference.html#usememo)\r\n\r\nI am working on moving `react-beautiful-dnd` over to using hooks https://github.com/atlassian/react-beautiful-dnd/issues/871. I have the whole thing working and tested \ud83d\udc4d \r\n\r\nIt leans quite heavily on `useMemo` and `useCallback` right now. If the memoization cache for is cleared for a dragging item, the result will be a cancelled drag. This is not good. \r\n\r\nMy understanding is that `useMemo` and `useCallback` are currently *not* subject to cache purging based on this language:\r\n\r\n> In the **future**, React may choose to \u201cforget\u201d\r\n\r\n**Request 1**: Is it possible to opt-out of this cache purging? Perhaps a third `options` argument to `useMemo` and `useCallback`:\r\n\r\n```js\r\nconst value = useMemo(() => ({ hello: 'world' }), [], { usePersistantCache: true });\r\n```\r\n\r\n(Naming up for grabs, but this is just the big idea)\r\n\r\nA work around is to use a custom memoization toolset such as a `useMemoOne` which reimplements `useMemo` and `useCallback` just using `ref`s [see example](https://twitter.com/alexandereardon/status/1108488559881641986)\r\n\r\nI am keen to avoid the work around if possible.\r\n\r\n**Request 2**: While *request 1* is favourable, it would be good to know the exact conditions in which the memoization caches are purged",
        "remove_template_description": "According to the `React` docs, `useMemo` and `useCallback` are subject to cache purging:    > You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \u201cforget\u201d some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo \u2014 and then add it to optimize performance. [source](https://reactjs.org/docs/hooks-reference.html#usememo)    I am working on moving `react-beautiful-dnd` over to using hooks https://github.com/atlassian/react-beautiful-dnd/issues/871. I have the whole thing working and tested \ud83d\udc4d     It leans quite heavily on `useMemo` and `useCallback` right now. If the memoization cache for is cleared for a dragging item, the result will be a cancelled drag. This is not good.     My understanding is that `useMemo` and `useCallback` are currently *not* subject to cache purging based on this language:    > In the **future**, React may choose to \u201cforget\u201d    **Request 1**: Is it possible to opt-out of this cache purging? Perhaps a third `options` argument to `useMemo` and `useCallback`:    ```js  const value = useMemo(() => ({ hello: 'world' }), [], { usePersistantCache: true });  ```    (Naming up for grabs, but this is just the big idea)    A work around is to use a custom memoization toolset such as a `useMemoOne` which reimplements `useMemo` and `useCallback` just using `ref`s [see example](https://twitter.com/alexandereardon/status/1108488559881641986)    I am keen to avoid the work around if possible.    **Request 2**: While *request 1* is favourable, it would be good to know the exact conditions in which the memoization caches are purged",
        "human_words": "According to the `React` docs, `useMemo` and `useCallback` are subject to cache purging:    > You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \u201cforget\u201d some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo \u2014 and then add it to optimize performance. [source](https://reactjs.org/docs/hooks-reference.html#usememo)    I am working on moving `react-beautiful-dnd` over to using hooks https://github.com/atlassian/react-beautiful-dnd/issues/871. I have the whole thing working and tested \ud83d\udc4d     It leans quite heavily on `useMemo` and `useCallback` right now. If the memoization cache for is cleared for a dragging item, the result will be a cancelled drag. This is not good.     My understanding is that `useMemo` and `useCallback` are currently *not* subject to cache purging based on this language:    > In the **future**, React may choose to \u201cforget\u201d    **Request 1**: Is it possible to opt-out of this cache purging? Perhaps a third `options` argument to `useMemo` and `useCallback`:        (Naming up for grabs, but this is just the big idea)    A work around is to use a custom memoization toolset such as a `useMemoOne` which reimplements `useMemo` and `useCallback` just using `ref`s [see example](https://twitter.com/alexandereardon/status/1108488559881641986)    I am keen to avoid the work around if possible.    **Request 2**: While *request 1* is favourable, it would be good to know the exact conditions in which the memoization caches are purged",
        "human_words_regrex": "According to the `React` docs, `useMemo` and `useCallback` are subject to cache purging: > You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \u201cforget\u201d some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo \u2014 and then add it to optimize performance.  I am working on moving `react-beautiful-dnd` over to using hooks  I have the whole thing working and tested \ud83d\udc4d It leans quite heavily on `useMemo` and `useCallback` right now. If the memoization cache for is cleared for a dragging item, the result will be a cancelled drag. This is not good. My understanding is that `useMemo` and `useCallback` are currently *not* subject to cache purging based on this language: > In the **future**, React may choose to \u201cforget\u201d **Request 1**: Is it possible to opt-out of this cache purging? Perhaps a third `options` argument to `useMemo` and `useCallback`: (Naming up for grabs, but this is just the big idea) A work around is to use a custom memoization toolset such as a `useMemoOne` which reimplements `useMemo` and `useCallback` just using `ref`s  I am keen to avoid the work around if possible. **Request 2**: While *request 1* is favourable, it would be good to know the exact conditions in which the memoization caches are purged",
        "human_words_stopwords_removal_lemmatization": "according ` react ` doc , ` usememo ` ` usecallback ` subject cache purging : > may rely usememo performance optimization , semantic guarantee . future , react may choose \u201c forget \u201d previously memoized value recalculate next render , e.g . free memory offscreen component . write code still work without usememo \u2014 add optimize performance . working moving ` react-beautiful-dnd ` using hook whole thing working tested \ud83d\udc4d lean quite heavily ` usememo ` ` usecallback ` right . memoization cache cleared dragging item , result cancelled drag . good . understanding ` usememo ` ` usecallback ` currently * * subject cache purging based language : > * * future * * , react may choose \u201c forget \u201d * * request 1 * * : possible opt-out cache purging ? perhaps third ` option ` argument ` usememo ` ` usecallback ` : ( naming grab , big idea ) work around use custom memoization toolset ` usememoone ` reimplements ` usememo ` ` usecallback ` using ` ref ` keen avoid work around possible . * * request 2 * * : * request 1 * favourable , would good know exact condition memoization cache purged",
        "title_stopwords_removal_lemmatization": "usememo / usecallback cache busting opt"
    },
    {
        "issue_id": 426597099,
        "title": "Dancing between state and effects - a real-world use case",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-28T16:41:29Z",
        "status": "open",
        "description": "I started this as a gist but Dan mentioned that this would be a good discussion issue so here goes. I've been writing with and refactoring code into hooks for a while now. For 95% of code, they are great and very straight-forward once you get the basic idea. There are still a few more complex cases where I struggle with the right answer though. This is an attempt to explain them.\r\n\r\n## The use case\r\n\r\nThis is a real-world use case from an app I'm building: interacting with a list items. I've simplified the examples into codesandboxes though to illustrate the basic idea.\r\n\r\nHere's the first one: https://codesandbox.io/s/lx55q0v3qz. It renders a list of items, and if you click on any of them, an editable input will appear to edit it (it doesn't save yet). The colored box on the right will change whenever an item rerenders.\r\n\r\nIf you click around in the items, you can see that when changing the edited item, all items rerender. But the `Row` component is wrapped with `React.memo`! They all rerender because the `onEdit` is new each time the app renders, causing all items to rerender.\r\n\r\n## Maintaining callback identity\r\n\r\nWe want `onEdit` to be same function for all future renders. In this case, it's easy because it doesn't depend on anything. We can simply wrap it in `useCallback` with an empty dependencies array:\r\n\r\n```js\r\n  let onEdit = useCallback(id => {\r\n    setEditingId(id);\r\n  }, []);\r\n```\r\n\r\nNow, you can see clicking around only rerenders the necessary items (only those colors change): https://codesandbox.io/s/k33klz68yr\r\n\r\n## Implementing saving\r\n\r\nWe're missing a crucial feature: after editing an item, on blur it should save the value. In my app the way the \"save\" event gets triggered is different, but doing it on blur is fine here.\r\n\r\nTo do this, we create an `onSave` callback in the app and pass it down to each item, which calls it on blur with the new value. `onSave` takes a new item and updates the items array with the new item and sets the `items` state.\r\n\r\nHere is it running: https://codesandbox.io/s/yvl79qj5vj\r\n\r\nYou'll notice that all items are rerendering again when saving. The list rerenders twice when you click another item: first when you click down and the input loses focus, and then again to edit a different item. So all the colors change once, and then only the editing rows color changes again.\r\n\r\nThe reason all of them are rerendering is because `onSave` is now a new callback every render. But we can't fix it with the same technique as `onEdit` because it depends on `items` - so we *have* to create a new callback which closes over `items` otherwise you'd lose previous edits. This is the \"callbacks are recreated too many times\" problem with hooks.\r\n\r\nOne solution is to switch to `useReducer`. Here's that implementation:\r\nhttps://codesandbox.io/s/nrq5y77kj0\r\n\r\nNote that I still wrap up the reducer into `onEdit` and `onSave` callbacks that are passed down to the row. I find passing callbacks to be clearer in most cases, and works with any components in the ecosystem that already expect callbacks. We can simply use `useCallback` with no dependencies though since `dispatch` is always the same.\r\n\r\nNote how that even when saving an item, only the necessary rows rerender.\r\n\r\n## The difference between event handlers and dispatch\r\n\r\nThere's a problem though. This works with a simple demo, but in my real app `onSave` *both* optimistically updates local state and saves it off to the server. It does a side effect.\r\n\r\nIt's something like this:\r\n\r\n```js\r\nasync function onSave(transaction) {\r\n  let { changes, newTransactions } = updateTransaction(transactions, transaction);\r\n  // optimistic update\r\n  setTransactions(newTransactions)\r\n  // save to server\r\n  await postToServer('apply-changes', { changes })\r\n}\r\n```\r\n\r\nThere's a big difference between the phase when an event handler and dispatch is run. Event handlers are run whenever they are triggered (naturally) but the dispatching the action (running `reducer`) happens when rendering. The reducer must be pure because of this.\r\n\r\nHere's the reducer from https://codesandbox.io/s/nrq5y77kj0:\r\n\r\n```js\r\n  function reducer(state, action) {\r\n    switch (action.type) {\r\n      case \"save-item\": {\r\n        let { item } = action;\r\n        return {\r\n          ...state,\r\n          items: items.map(it => (it.id === item.id ? item : it))\r\n        };\r\n      }\r\n      case \"edit-item\": {\r\n        return { ...state, editingId: action.id };\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\nHow is `save-item` also supposed to trigger a side effect? First, item's important to understand these 3 phases:\r\n\r\n```\r\nEvent handler -> render -> commit\r\n```\r\n\r\nEvents are run in the first phase, which causes a render (when dispatches happen), and when everything is finally ready to be flushed to the DOM it does it in a \"commit\" phase, which is when all effects are run (more or less).\r\n\r\nWe need our side effect to run in the commit phase.\r\n\r\n### Option 1\r\n\r\nOne option is to use a ref to \"mark\" the saving effect to be run. Here's the code: https://codesandbox.io/s/m5xrrm4ym8\r\n\r\nBasically you create a flag as a ref:\r\n\r\n```js\r\nlet shouldSave = useRef(false);\r\n```\r\n\r\nLuckily, we've already wrapped the save dispatch into an event handler. Inside `onSave` we mark this flag as true. We can't do it inside of the reducer because it must be pure:\r\n\r\n```js\r\n  let onSave = useCallback(item => {\r\n    shouldSave.current = true;\r\n    dispatch({ type: \"save-item\", item });\r\n  }, []);\r\n```\r\n\r\nFinally, we define an effect that always runs after rendering and checks the flag and resets it:\r\n\r\n```js\r\n  useEffect(() => {\r\n    if (shouldSave.current) {\r\n      // save... all the items to the server?\r\n      post(items)\r\n      shouldSave.current = false;\r\n    }\r\n  });\r\n```\r\n\r\nI thought this option was going to work, but just ran into this issue. We don't know *what* to save anymore. We certainly don't want to send the entire items array to the server! I suppose we could store the item in the ref, but what happens if multiple events are fired before the effect runs? I suppose you could store an array, but... do we really need that?\r\n\r\n### Option 2\r\n\r\n**Note**: I just noticed this option is documented in [How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback), but I disagree with the tone used. I think this is a fine pattern an better in many cases than `dispatch`, even if it's not quite as robust. Especially since it's not as powerful as callbacks. (see end of this section)\r\n\r\nKeeping around all of the data we need to do the effect might work in some cases, but it feels a little clunky. If we could \"queue up\" effect from the reducer, that would work, but we can't do that. Instead, another option is to embrace callbacks.\r\n\r\nGoing back to the version which used a naive `onSave` which forced all items to rerender (https://codesandbox.io/s/yvl79qj5vj), `onSave` looks like this:\r\n\r\n```js\r\n  let onSave = useCallback(\r\n    item => {\r\n      setItems(items.map(it => (it.id === item.id ? item : it)));\r\n    },\r\n    [items]\r\n  );\r\n```\r\n\r\nThe core problem is that it depends on items. We need to recreate `onSave` because it closes over `items`. But what if it didn't close over it? Instead, let's create a ref:\r\n\r\n```js\r\nlet latestItems = useRef(items);\r\n```\r\n\r\nAnd an effect which keeps it up-to-date with items:\r\n\r\n```js\r\nuseEffect(() => {\r\n  latestItems.current = items\r\n});\r\n```\r\n\r\nNow, the `onSave` callback can reference the ref to always get the up-to-date items. Which means we can memoize it with `useCallback`:\r\n\r\n\r\n```js\r\nlet onSave = useCallback(item => {\r\n  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));\r\n}, []);\r\n```\r\n\r\nWe are **intentionally** opting to always referencing the latest item. The biggest change with hooks in my opinion is that they are safe by default: an async function will always reference the exact same state that existed at the time they were called. Classes operate the other way: you access state from this.state which can be mutated between async work. Sometimes you want that though so you can maintain callback identity.\r\n\r\nHere is the running sandbox for it: https://codesandbox.io/s/0129jop840. Notice how you can edit items and only the necessary rows rerender, even though it updates `items`. Now, we can do anything we want in our callback, like posting to a server:\r\n\r\n```js\r\nlet onSave = useCallback(item => {\r\n  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));\r\n  // save to server\r\n  post('/save-item', { item })\r\n}, []);\r\n```\r\n\r\nBasically, if all you need is the latest data since last commit, **callbacks can be memoized as well as reducers**. The drawback is that you need to put each piece of data you need in a ref. If you have lots of pieces of data and only a few simple effects, reducers would be better, but in my case (and I suspect in many others) it's easier to use callbacks with refs.\r\n\r\nIt's nice too because in my real app the save process is more complicated. It needs to get changes back from the server and apply them locally as well, so it looks more like this:\r\n\r\n```js\r\nlet onSave = useCallback(item => {\r\n  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));\r\n  // save to server\r\n  let changes = await post('/save-item', { item })\r\n  applyChanges(latestItems.current, changes)\r\n}, []);\r\n```\r\n\r\nMaintainability-wise, it's *really* nice to see this whole flow here in one place. Breakin this up to try to manually queue up effects and do a dance with `useReducer` feels much more convoluted.\r\n\r\n### Option 3\r\n\r\nI suppose another option would be to try to \"mark\" the effect to be run in state itself. That way you could do it in `useReducer` as well, and it would look something like this:\r\n\r\n```js\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case \"save-item\": {\r\n      let { item } = action;\r\n      return {\r\n        ...state,\r\n        items: state.items.map(it => (it.id === item.id ? item : it)),\r\n        itemsToSave: itemsToSave.concat([item])\r\n      };\r\n    }\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nAnd an effect would check the `itemsToSave` state and save them off. The problem is resetting that state - the effect would have to change state, causing a useless rerender, and it's not determistic to make sure that the effect does not run multiple times before `itemsToSave` gets reset.\r\n\r\nIn my experience mixing effects into state, causing renders, make things a lot more difficult to maintain and debug.\r\n\r\n### What's the difference between Option 1 and 2?\r\n\r\nIs there a crucial difference between 1 and 2? Yes, but I'd argue it's not a big deal if you can accept it. Remember these three phases:\r\n\r\n```\r\nEvent handler -> render -> commit\r\n```\r\n\r\nThe big difference is option 1 is doing the side effect in the commit phase, and option 2 is doing it in the event handler phase. Why does this matter?\r\n\r\nIf, for some reason, an item called `onSave` multiple times before the next commit phase happened, option 1 is more robust. A reducer will \"queue up\" the actions and run them in order, updating state in between them, so if you did:\r\n\r\n```js\r\nonSave({ id: 1, name: \"Foo\" })\r\nonSave({ id: 2, name: \"Bar\" })\r\n```\r\n\r\nwhich runs the callback twice immediately, the reducer will process the first save and update the items, and process the second save **passing in the already updated state**.\r\n\r\nHowever, with option 2, when processing the second save **the commit phase hasn't been run yet** so the `latestItems` ref hasn't been updated yet. **The first save will be lost**.\r\n\r\nHowever, the ergonomics of option 2 is much better for many use cases, and I think it's fine to weight these benefits and never need the ability to handle such quick updates. Although concurrent mode might introduce some interesting arguments against that.\r\n\r\n## Another small use case for triggering effects\r\n\r\nIn case this wasn't already long enough, there's a similar use case I'll describe quickly. You can also add new items to the list by editing data in an empty row, and the state of this \"new item\" is tracked separately. \"Saving\" this item doesn't touch the backend, but simply updates the local state, and separate explicit \"add\" action is needed to add it to the list.\r\n\r\nThe hard part is that there is a keybinding for adding the item to the list while editing - something like alt+enter. The problem is I want to coordinate with the state change, so first I want to save the existing field and *then* add to the list. The saving process is complicated so it need to run through that first (I can't just duplicate it all in `onAdd`).\r\n\r\nThis isn't a problem specific to hooks, it's just about coordinating with state changes. When I was working with reducers, I had though that something like this would be neat. Basically when the new items detect that you want to save + add it first an action like `{ type: 'save-item', fields: { name: 'Foo' }, shouldAdd: true }`\r\n\r\n\r\n```js\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case \"save-item\": {\r\n      let { fields } = action;\r\n      let newItem = { ...state.newItem, ...fields };\r\n\r\n      if(action.shouldAdd) {\r\n        shouldAdd.current = true\r\n      }\r\n\r\n      return { ...state, newItem };\r\n    }\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nwhere `shouldAdd` is a ref that is checked on commit phase and saves the item off to the server. This isn't possible though.\r\n\r\nAnother option would be for the item to call `onAdd` instead of `onSave` when saving + adding, and you could manually call the reducer yourself to process the changes:\r\n\r\n```js\r\nasync function onAdd(fields) {\r\n  let action = { type: 'save-item', fields }\r\n  dispatch(action)\r\n  \r\n  let newItem = reducer(state, action)\r\n  post('/add-item', { newItem });\r\n\r\n}\r\n```\r\n\r\nThis is kind of a neat trick: you are manually running the reducer to get the updated state, and React will run the reducer again whenever it wants.\r\n\r\nSince I ended up liking callbacks for my original problems, I ended up going with a similar approach where I have a ref flag that I just set in `onSave`:\r\n\r\n```js\r\nlet [newItem, setNewItem] = useState({})\r\nlet latestNewItem = useRef(newItem);\r\nlet shouldAdd = useRef(false);\r\n\r\nuseEffect(() => {\r\n  latestNewItem.current = newItem;\r\n})\r\n\r\nuseEffect(() => {\r\n  if(shouldAdd.current) {\r\n    setNewItem({})\r\n    post('/add-item', { newItem })\r\n    shouldAdd.current = false;\r\n  }\r\n})\r\n\r\nlet onSave = useCallback((fields, { add }) => {\r\n  // In my real app, applying the changes to the current item is a bit more complicated than this,\r\n  // so it's not an option to separate on an `onAdd` function that duplicates this logic\r\n  setNewItem({ ...latestNewItem.current, ...fields });\r\n\r\n  // This action also should add, mark the effect to be run\r\n  if(add) {\r\n    shouldAdd.current = true;\r\n  }\r\n}, [])\r\n```\r\n\r\n## Conclusions\r\n\r\nSorry for the length of this. I figure I'd be over-detailed rather than under-detailed, and I've been brewing these thoughts since hooks came out. I'll try to conclude my thoughts here:\r\n\r\n* Effects are **very nice**. It feels like we have easy access to the \"commit\" phase of React, whereas previously it was all in `componentDidUpdate` and not composable at all. Now it's super easy to throw on code to the commit phase which makes coordinating stuff with state easier.\r\n\r\n* Reducers have interesting properties, and I can see how they are fully robust in a concurrent world, but for many cases they are too limited. The ergonomics of implementing many effect-ful workflows with them requires an awkward dance, kind of like when you try to track effect states in local state and split up workflows. Keeping a linear workflow in a callback is not only nice, but necessary in many cases for maintainability.\r\n\r\n* Callbacks can be made memoizable without much work. In many cases I think it's easier to use the ref trick than reducers, but the question is: just *how* dangerous is it? Right now it's not that dangerous, but maybe concurrent mode really is going to break it.\r\n\r\n* If that's the case, we should figure out a better way to weave together effects and state changes.\r\n\r\nI hope all of this made sense. Let me know if something is unclear and I'll try to fix it.",
        "remove_template_description": "I started this as a gist but Dan mentioned that this would be a good discussion issue so here goes. I've been writing with and refactoring code into hooks for a while now. For 95% of code, they are great and very straight-forward once you get the basic idea. There are still a few more complex cases where I struggle with the right answer though. This is an attempt to explain them.    ## The use case    This is a real-world use case from an app I'm building: interacting with a list items. I've simplified the examples into codesandboxes though to illustrate the basic idea.    Here's the first one: https://codesandbox.io/s/lx55q0v3qz. It renders a list of items, and if you click on any of them, an editable input will appear to edit it (it doesn't save yet). The colored box on the right will change whenever an item rerenders.    If you click around in the items, you can see that when changing the edited item, all items rerender. But the `Row` component is wrapped with `React.memo`! They all rerender because the `onEdit` is new each time the app renders, causing all items to rerender.    ## Maintaining callback identity    We want `onEdit` to be same function for all future renders. In this case, it's easy because it doesn't depend on anything. We can simply wrap it in `useCallback` with an empty dependencies array:    ```js    let onEdit = useCallback(id => {      setEditingId(id);    }, []);  ```    Now, you can see clicking around only rerenders the necessary items (only those colors change): https://codesandbox.io/s/k33klz68yr    ## Implementing saving    We're missing a crucial feature: after editing an item, on blur it should save the value. In my app the way the \"save\" event gets triggered is different, but doing it on blur is fine here.    To do this, we create an `onSave` callback in the app and pass it down to each item, which calls it on blur with the new value. `onSave` takes a new item and updates the items array with the new item and sets the `items` state.    Here is it running: https://codesandbox.io/s/yvl79qj5vj    You'll notice that all items are rerendering again when saving. The list rerenders twice when you click another item: first when you click down and the input loses focus, and then again to edit a different item. So all the colors change once, and then only the editing rows color changes again.    The reason all of them are rerendering is because `onSave` is now a new callback every render. But we can't fix it with the same technique as `onEdit` because it depends on `items` - so we *have* to create a new callback which closes over `items` otherwise you'd lose previous edits. This is the \"callbacks are recreated too many times\" problem with hooks.    One solution is to switch to `useReducer`. Here's that implementation:  https://codesandbox.io/s/nrq5y77kj0    Note that I still wrap up the reducer into `onEdit` and `onSave` callbacks that are passed down to the row. I find passing callbacks to be clearer in most cases, and works with any components in the ecosystem that already expect callbacks. We can simply use `useCallback` with no dependencies though since `dispatch` is always the same.    Note how that even when saving an item, only the necessary rows rerender.    ## The difference between event handlers and dispatch    There's a problem though. This works with a simple demo, but in my real app `onSave` *both* optimistically updates local state and saves it off to the server. It does a side effect.    It's something like this:    ```js  async function onSave(transaction) {    let { changes, newTransactions } = updateTransaction(transactions, transaction);    // optimistic update    setTransactions(newTransactions)    // save to server    await postToServer('apply-changes', { changes })  }  ```    There's a big difference between the phase when an event handler and dispatch is run. Event handlers are run whenever they are triggered (naturally) but the dispatching the action (running `reducer`) happens when rendering. The reducer must be pure because of this.    Here's the reducer from https://codesandbox.io/s/nrq5y77kj0:    ```js    function reducer(state, action) {      switch (action.type) {        case \"save-item\": {          let { item } = action;          return {            ...state,            items: items.map(it => (it.id === item.id ? item : it))          };        }        case \"edit-item\": {          return { ...state, editingId: action.id };        }      }    }  ```    How is `save-item` also supposed to trigger a side effect? First, item's important to understand these 3 phases:    ```  Event handler -> render -> commit  ```    Events are run in the first phase, which causes a render (when dispatches happen), and when everything is finally ready to be flushed to the DOM it does it in a \"commit\" phase, which is when all effects are run (more or less).    We need our side effect to run in the commit phase.    ### Option 1    One option is to use a ref to \"mark\" the saving effect to be run. Here's the code: https://codesandbox.io/s/m5xrrm4ym8    Basically you create a flag as a ref:    ```js  let shouldSave = useRef(false);  ```    Luckily, we've already wrapped the save dispatch into an event handler. Inside `onSave` we mark this flag as true. We can't do it inside of the reducer because it must be pure:    ```js    let onSave = useCallback(item => {      shouldSave.current = true;      dispatch({ type: \"save-item\", item });    }, []);  ```    Finally, we define an effect that always runs after rendering and checks the flag and resets it:    ```js    useEffect(() => {      if (shouldSave.current) {        // save... all the items to the server?        post(items)        shouldSave.current = false;      }    });  ```    I thought this option was going to work, but just ran into this issue. We don't know *what* to save anymore. We certainly don't want to send the entire items array to the server! I suppose we could store the item in the ref, but what happens if multiple events are fired before the effect runs? I suppose you could store an array, but... do we really need that?    ### Option 2    **Note**: I just noticed this option is documented in [How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback), but I disagree with the tone used. I think this is a fine pattern an better in many cases than `dispatch`, even if it's not quite as robust. Especially since it's not as powerful as callbacks. (see end of this section)    Keeping around all of the data we need to do the effect might work in some cases, but it feels a little clunky. If we could \"queue up\" effect from the reducer, that would work, but we can't do that. Instead, another option is to embrace callbacks.    Going back to the version which used a naive `onSave` which forced all items to rerender (https://codesandbox.io/s/yvl79qj5vj), `onSave` looks like this:    ```js    let onSave = useCallback(      item => {        setItems(items.map(it => (it.id === item.id ? item : it)));      },      [items]    );  ```    The core problem is that it depends on items. We need to recreate `onSave` because it closes over `items`. But what if it didn't close over it? Instead, let's create a ref:    ```js  let latestItems = useRef(items);  ```    And an effect which keeps it up-to-date with items:    ```js  useEffect(() => {    latestItems.current = items  });  ```    Now, the `onSave` callback can reference the ref to always get the up-to-date items. Which means we can memoize it with `useCallback`:      ```js  let onSave = useCallback(item => {    setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));  }, []);  ```    We are **intentionally** opting to always referencing the latest item. The biggest change with hooks in my opinion is that they are safe by default: an async function will always reference the exact same state that existed at the time they were called. Classes operate the other way: you access state from this.state which can be mutated between async work. Sometimes you want that though so you can maintain callback identity.    Here is the running sandbox for it: https://codesandbox.io/s/0129jop840. Notice how you can edit items and only the necessary rows rerender, even though it updates `items`. Now, we can do anything we want in our callback, like posting to a server:    ```js  let onSave = useCallback(item => {    setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));    // save to server    post('/save-item', { item })  }, []);  ```    Basically, if all you need is the latest data since last commit, **callbacks can be memoized as well as reducers**. The drawback is that you need to put each piece of data you need in a ref. If you have lots of pieces of data and only a few simple effects, reducers would be better, but in my case (and I suspect in many others) it's easier to use callbacks with refs.    It's nice too because in my real app the save process is more complicated. It needs to get changes back from the server and apply them locally as well, so it looks more like this:    ```js  let onSave = useCallback(item => {    setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));    // save to server    let changes = await post('/save-item', { item })    applyChanges(latestItems.current, changes)  }, []);  ```    Maintainability-wise, it's *really* nice to see this whole flow here in one place. Breakin this up to try to manually queue up effects and do a dance with `useReducer` feels much more convoluted.    ### Option 3    I suppose another option would be to try to \"mark\" the effect to be run in state itself. That way you could do it in `useReducer` as well, and it would look something like this:    ```js  function reducer(state, action) {    switch (action.type) {      case \"save-item\": {        let { item } = action;        return {          ...state,          items: state.items.map(it => (it.id === item.id ? item : it)),          itemsToSave: itemsToSave.concat([item])        };      }      // ...    }  }  ```    And an effect would check the `itemsToSave` state and save them off. The problem is resetting that state - the effect would have to change state, causing a useless rerender, and it's not determistic to make sure that the effect does not run multiple times before `itemsToSave` gets reset.    In my experience mixing effects into state, causing renders, make things a lot more difficult to maintain and debug.    ### What's the difference between Option 1 and 2?    Is there a crucial difference between 1 and 2? Yes, but I'd argue it's not a big deal if you can accept it. Remember these three phases:    ```  Event handler -> render -> commit  ```    The big difference is option 1 is doing the side effect in the commit phase, and option 2 is doing it in the event handler phase. Why does this matter?    If, for some reason, an item called `onSave` multiple times before the next commit phase happened, option 1 is more robust. A reducer will \"queue up\" the actions and run them in order, updating state in between them, so if you did:    ```js  onSave({ id: 1, name: \"Foo\" })  onSave({ id: 2, name: \"Bar\" })  ```    which runs the callback twice immediately, the reducer will process the first save and update the items, and process the second save **passing in the already updated state**.    However, with option 2, when processing the second save **the commit phase hasn't been run yet** so the `latestItems` ref hasn't been updated yet. **The first save will be lost**.    However, the ergonomics of option 2 is much better for many use cases, and I think it's fine to weight these benefits and never need the ability to handle such quick updates. Although concurrent mode might introduce some interesting arguments against that.    ## Another small use case for triggering effects    In case this wasn't already long enough, there's a similar use case I'll describe quickly. You can also add new items to the list by editing data in an empty row, and the state of this \"new item\" is tracked separately. \"Saving\" this item doesn't touch the backend, but simply updates the local state, and separate explicit \"add\" action is needed to add it to the list.    The hard part is that there is a keybinding for adding the item to the list while editing - something like alt+enter. The problem is I want to coordinate with the state change, so first I want to save the existing field and *then* add to the list. The saving process is complicated so it need to run through that first (I can't just duplicate it all in `onAdd`).    This isn't a problem specific to hooks, it's just about coordinating with state changes. When I was working with reducers, I had though that something like this would be neat. Basically when the new items detect that you want to save + add it first an action like `{ type: 'save-item', fields: { name: 'Foo' }, shouldAdd: true }`      ```js  function reducer(state, action) {    switch (action.type) {      case \"save-item\": {        let { fields } = action;        let newItem = { ...state.newItem, ...fields };          if(action.shouldAdd) {          shouldAdd.current = true        }          return { ...state, newItem };      }      // ...    }  }  ```    where `shouldAdd` is a ref that is checked on commit phase and saves the item off to the server. This isn't possible though.    Another option would be for the item to call `onAdd` instead of `onSave` when saving + adding, and you could manually call the reducer yourself to process the changes:    ```js  async function onAdd(fields) {    let action = { type: 'save-item', fields }    dispatch(action)        let newItem = reducer(state, action)    post('/add-item', { newItem });    }  ```    This is kind of a neat trick: you are manually running the reducer to get the updated state, and React will run the reducer again whenever it wants.    Since I ended up liking callbacks for my original problems, I ended up going with a similar approach where I have a ref flag that I just set in `onSave`:    ```js  let [newItem, setNewItem] = useState({})  let latestNewItem = useRef(newItem);  let shouldAdd = useRef(false);    useEffect(() => {    latestNewItem.current = newItem;  })    useEffect(() => {    if(shouldAdd.current) {      setNewItem({})      post('/add-item', { newItem })      shouldAdd.current = false;    }  })    let onSave = useCallback((fields, { add }) => {    // In my real app, applying the changes to the current item is a bit more complicated than this,    // so it's not an option to separate on an `onAdd` function that duplicates this logic    setNewItem({ ...latestNewItem.current, ...fields });      // This action also should add, mark the effect to be run    if(add) {      shouldAdd.current = true;    }  }, [])  ```    ## Conclusions    Sorry for the length of this. I figure I'd be over-detailed rather than under-detailed, and I've been brewing these thoughts since hooks came out. I'll try to conclude my thoughts here:    * Effects are **very nice**. It feels like we have easy access to the \"commit\" phase of React, whereas previously it was all in `componentDidUpdate` and not composable at all. Now it's super easy to throw on code to the commit phase which makes coordinating stuff with state easier.    * Reducers have interesting properties, and I can see how they are fully robust in a concurrent world, but for many cases they are too limited. The ergonomics of implementing many effect-ful workflows with them requires an awkward dance, kind of like when you try to track effect states in local state and split up workflows. Keeping a linear workflow in a callback is not only nice, but necessary in many cases for maintainability.    * Callbacks can be made memoizable without much work. In many cases I think it's easier to use the ref trick than reducers, but the question is: just *how* dangerous is it? Right now it's not that dangerous, but maybe concurrent mode really is going to break it.    * If that's the case, we should figure out a better way to weave together effects and state changes.    I hope all of this made sense. Let me know if something is unclear and I'll try to fix it.",
        "human_words": "I started this as a gist but Dan mentioned that this would be a good discussion issue so here goes. I've been writing with and refactoring code into hooks for a while now. For 95% of code, they are great and very straight-forward once you get the basic idea. There are still a few more complex cases where I struggle with the right answer though. This is an attempt to explain them.    ## The use case    This is a real-world use case from an app I'm building: interacting with a list items. I've simplified the examples into codesandboxes though to illustrate the basic idea.    Here's the first one: https://codesandbox.io/s/lx55q0v3qz. It renders a list of items, and if you click on any of them, an editable input will appear to edit it (it doesn't save yet). The colored box on the right will change whenever an item rerenders.    If you click around in the items, you can see that when changing the edited item, all items rerender. But the `Row` component is wrapped with `React.memo`! They all rerender because the `onEdit` is new each time the app renders, causing all items to rerender.    ## Maintaining callback identity    We want `onEdit` to be same function for all future renders. In this case, it's easy because it doesn't depend on anything. We can simply wrap it in `useCallback` with an empty dependencies array:        Now, you can see clicking around only rerenders the necessary items (only those colors change): https://codesandbox.io/s/k33klz68yr    ## Implementing saving    We're missing a crucial feature: after editing an item, on blur it should save the value. In my app the way the \"save\" event gets triggered is different, but doing it on blur is fine here.    To do this, we create an `onSave` callback in the app and pass it down to each item, which calls it on blur with the new value. `onSave` takes a new item and updates the items array with the new item and sets the `items` state.    Here is it running: https://codesandbox.io/s/yvl79qj5vj    You'll notice that all items are rerendering again when saving. The list rerenders twice when you click another item: first when you click down and the input loses focus, and then again to edit a different item. So all the colors change once, and then only the editing rows color changes again.    The reason all of them are rerendering is because `onSave` is now a new callback every render. But we can't fix it with the same technique as `onEdit` because it depends on `items` - so we *have* to create a new callback which closes over `items` otherwise you'd lose previous edits. This is the \"callbacks are recreated too many times\" problem with hooks.    One solution is to switch to `useReducer`. Here's that implementation:  https://codesandbox.io/s/nrq5y77kj0    Note that I still wrap up the reducer into `onEdit` and `onSave` callbacks that are passed down to the row. I find passing callbacks to be clearer in most cases, and works with any components in the ecosystem that already expect callbacks. We can simply use `useCallback` with no dependencies though since `dispatch` is always the same.    Note how that even when saving an item, only the necessary rows rerender.    ## The difference between event handlers and dispatch    There's a problem though. This works with a simple demo, but in my real app `onSave` *both* optimistically updates local state and saves it off to the server. It does a side effect.    It's something like this:        There's a big difference between the phase when an event handler and dispatch is run. Event handlers are run whenever they are triggered (naturally) but the dispatching the action (running `reducer`) happens when rendering. The reducer must be pure because of this.    Here's the reducer from https://codesandbox.io/s/nrq5y77kj0:        How is `save-item` also supposed to trigger a side effect? First, item's important to understand these 3 phases:        Events are run in the first phase, which causes a render (when dispatches happen), and when everything is finally ready to be flushed to the DOM it does it in a \"commit\" phase, which is when all effects are run (more or less).    We need our side effect to run in the commit phase.    ### Option 1    One option is to use a ref to \"mark\" the saving effect to be run. Here's the code: https://codesandbox.io/s/m5xrrm4ym8    Basically you create a flag as a ref:        Luckily, we've already wrapped the save dispatch into an event handler. Inside `onSave` we mark this flag as true. We can't do it inside of the reducer because it must be pure:        Finally, we define an effect that always runs after rendering and checks the flag and resets it:        I thought this option was going to work, but just ran into this issue. We don't know *what* to save anymore. We certainly don't want to send the entire items array to the server! I suppose we could store the item in the ref, but what happens if multiple events are fired before the effect runs? I suppose you could store an array, but... do we really need that?    ### Option 2    **Note**: I just noticed this option is documented in [How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback), but I disagree with the tone used. I think this is a fine pattern an better in many cases than `dispatch`, even if it's not quite as robust. Especially since it's not as powerful as callbacks. (see end of this section)    Keeping around all of the data we need to do the effect might work in some cases, but it feels a little clunky. If we could \"queue up\" effect from the reducer, that would work, but we can't do that. Instead, another option is to embrace callbacks.    Going back to the version which used a naive `onSave` which forced all items to rerender (https://codesandbox.io/s/yvl79qj5vj), `onSave` looks like this:        The core problem is that it depends on items. We need to recreate `onSave` because it closes over `items`. But what if it didn't close over it? Instead, let's create a ref:        And an effect which keeps it up-to-date with items:        Now, the `onSave` callback can reference the ref to always get the up-to-date items. Which means we can memoize it with `useCallback`:          We are **intentionally** opting to always referencing the latest item. The biggest change with hooks in my opinion is that they are safe by default: an async function will always reference the exact same state that existed at the time they were called. Classes operate the other way: you access state from this.state which can be mutated between async work. Sometimes you want that though so you can maintain callback identity.    Here is the running sandbox for it: https://codesandbox.io/s/0129jop840. Notice how you can edit items and only the necessary rows rerender, even though it updates `items`. Now, we can do anything we want in our callback, like posting to a server:        Basically, if all you need is the latest data since last commit, **callbacks can be memoized as well as reducers**. The drawback is that you need to put each piece of data you need in a ref. If you have lots of pieces of data and only a few simple effects, reducers would be better, but in my case (and I suspect in many others) it's easier to use callbacks with refs.    It's nice too because in my real app the save process is more complicated. It needs to get changes back from the server and apply them locally as well, so it looks more like this:        Maintainability-wise, it's *really* nice to see this whole flow here in one place. Breakin this up to try to manually queue up effects and do a dance with `useReducer` feels much more convoluted.    ### Option 3    I suppose another option would be to try to \"mark\" the effect to be run in state itself. That way you could do it in `useReducer` as well, and it would look something like this:        And an effect would check the `itemsToSave` state and save them off. The problem is resetting that state - the effect would have to change state, causing a useless rerender, and it's not determistic to make sure that the effect does not run multiple times before `itemsToSave` gets reset.    In my experience mixing effects into state, causing renders, make things a lot more difficult to maintain and debug.    ### What's the difference between Option 1 and 2?    Is there a crucial difference between 1 and 2? Yes, but I'd argue it's not a big deal if you can accept it. Remember these three phases:        The big difference is option 1 is doing the side effect in the commit phase, and option 2 is doing it in the event handler phase. Why does this matter?    If, for some reason, an item called `onSave` multiple times before the next commit phase happened, option 1 is more robust. A reducer will \"queue up\" the actions and run them in order, updating state in between them, so if you did:        which runs the callback twice immediately, the reducer will process the first save and update the items, and process the second save **passing in the already updated state**.    However, with option 2, when processing the second save **the commit phase hasn't been run yet** so the `latestItems` ref hasn't been updated yet. **The first save will be lost**.    However, the ergonomics of option 2 is much better for many use cases, and I think it's fine to weight these benefits and never need the ability to handle such quick updates. Although concurrent mode might introduce some interesting arguments against that.    ## Another small use case for triggering effects    In case this wasn't already long enough, there's a similar use case I'll describe quickly. You can also add new items to the list by editing data in an empty row, and the state of this \"new item\" is tracked separately. \"Saving\" this item doesn't touch the backend, but simply updates the local state, and separate explicit \"add\" action is needed to add it to the list.    The hard part is that there is a keybinding for adding the item to the list while editing - something like alt+enter. The problem is I want to coordinate with the state change, so first I want to save the existing field and *then* add to the list. The saving process is complicated so it need to run through that first (I can't just duplicate it all in `onAdd`).    This isn't a problem specific to hooks, it's just about coordinating with state changes. When I was working with reducers, I had though that something like this would be neat. Basically when the new items detect that you want to save + add it first an action like `{ type: 'save-item', fields: { name: 'Foo' }, shouldAdd: true }`          where `shouldAdd` is a ref that is checked on commit phase and saves the item off to the server. This isn't possible though.    Another option would be for the item to call `onAdd` instead of `onSave` when saving + adding, and you could manually call the reducer yourself to process the changes:        This is kind of a neat trick: you are manually running the reducer to get the updated state, and React will run the reducer again whenever it wants.    Since I ended up liking callbacks for my original problems, I ended up going with a similar approach where I have a ref flag that I just set in `onSave`:        ## Conclusions    Sorry for the length of this. I figure I'd be over-detailed rather than under-detailed, and I've been brewing these thoughts since hooks came out. I'll try to conclude my thoughts here:    * Effects are **very nice**. It feels like we have easy access to the \"commit\" phase of React, whereas previously it was all in `componentDidUpdate` and not composable at all. Now it's super easy to throw on code to the commit phase which makes coordinating stuff with state easier.    * Reducers have interesting properties, and I can see how they are fully robust in a concurrent world, but for many cases they are too limited. The ergonomics of implementing many effect-ful workflows with them requires an awkward dance, kind of like when you try to track effect states in local state and split up workflows. Keeping a linear workflow in a callback is not only nice, but necessary in many cases for maintainability.    * Callbacks can be made memoizable without much work. In many cases I think it's easier to use the ref trick than reducers, but the question is: just *how* dangerous is it? Right now it's not that dangerous, but maybe concurrent mode really is going to break it.    * If that's the case, we should figure out a better way to weave together effects and state changes.    I hope all of this made sense. Let me know if something is unclear and I'll try to fix it.",
        "human_words_regrex": "I started this as a gist but Dan mentioned that this would be a good discussion issue so here goes. I've been writing with and refactoring code into hooks for a while now. For 95% of code, they are great and very straight-forward once you get the basic idea. There are still a few more complex cases where I struggle with the right answer though. This is an attempt to explain them. ## The use case This is a real-world use case from an app I'm building: interacting with a list items. I've simplified the examples into codesandboxes though to illustrate the basic idea. Here's the first one:  It renders a list of items, and if you click on any of them, an editable input will appear to edit it (it doesn't save yet). The colored box on the right will change whenever an item rerenders. If you click around in the items, you can see that when changing the edited item, all items rerender. But the `Row` component is wrapped with `React.memo`! They all rerender because the `onEdit` is new each time the app renders, causing all items to rerender. ## Maintaining callback identity We want `onEdit` to be same function for all future renders. In this case, it's easy because it doesn't depend on anything. We can simply wrap it in `useCallback` with an empty dependencies array: Now, you can see clicking around only rerenders the necessary items (only those colors change):  ## Implementing saving We're missing a crucial feature: after editing an item, on blur it should save the value. In my app the way the \"save\" event gets triggered is different, but doing it on blur is fine here. To do this, we create an `onSave` callback in the app and pass it down to each item, which calls it on blur with the new value. `onSave` takes a new item and updates the items array with the new item and sets the `items` state. Here is it running:  You'll notice that all items are rerendering again when saving. The list rerenders twice when you click another item: first when you click down and the input loses focus, and then again to edit a different item. So all the colors change once, and then only the editing rows color changes again. The reason all of them are rerendering is because `onSave` is now a new callback every render. But we can't fix it with the same technique as `onEdit` because it depends on `items` - so we *have* to create a new callback which closes over `items` otherwise you'd lose previous edits. This is the \"callbacks are recreated too many times\" problem with hooks. One solution is to switch to `useReducer`. Here's that implementation:  Note that I still wrap up the reducer into `onEdit` and `onSave` callbacks that are passed down to the row. I find passing callbacks to be clearer in most cases, and works with any components in the ecosystem that already expect callbacks. We can simply use `useCallback` with no dependencies though since `dispatch` is always the same. Note how that even when saving an item, only the necessary rows rerender. ## The difference between event handlers and dispatch There's a problem though. This works with a simple demo, but in my real app `onSave` *both* optimistically updates local state and saves it off to the server. It does a side effect. It's something like this: There's a big difference between the phase when an event handler and dispatch is run. Event handlers are run whenever they are triggered (naturally) but the dispatching the action (running `reducer`) happens when rendering. The reducer must be pure because of this. Here's the reducer from  How is `save-item` also supposed to trigger a side effect? First, item's important to understand these 3 phases: Events are run in the first phase, which causes a render (when dispatches happen), and when everything is finally ready to be flushed to the DOM it does it in a \"commit\" phase, which is when all effects are run (more or less). We need our side effect to run in the commit phase. ### Option 1 One option is to use a ref to \"mark\" the saving effect to be run. Here's the code:  Basically you create a flag as a ref: Luckily, we've already wrapped the save dispatch into an event handler. Inside `onSave` we mark this flag as true. We can't do it inside of the reducer because it must be pure: Finally, we define an effect that always runs after rendering and checks the flag and resets it: I thought this option was going to work, but just ran into this issue. We don't know *what* to save anymore. We certainly don't want to send the entire items array to the server! I suppose we could store the item in the ref, but what happens if multiple events are fired before the effect runs? I suppose you could store an array, but... do we really need that? ### Option 2 **Note**: I just noticed this option is documented in , but I disagree with the tone used. I think this is a fine pattern an better in many cases than `dispatch`, even if it's not quite as robust. Especially since it's not as powerful as callbacks. (see end of this section) Keeping around all of the data we need to do the effect might work in some cases, but it feels a little clunky. If we could \"queue up\" effect from the reducer, that would work, but we can't do that. Instead, another option is to embrace callbacks. Going back to the version which used a naive `onSave` which forced all items to rerender ( `onSave` looks like this: The core problem is that it depends on items. We need to recreate `onSave` because it closes over `items`. But what if it didn't close over it? Instead, let's create a ref: And an effect which keeps it up-to-date with items: Now, the `onSave` callback can reference the ref to always get the up-to-date items. Which means we can memoize it with `useCallback`: We are **intentionally** opting to always referencing the latest item. The biggest change with hooks in my opinion is that they are safe by default: an async function will always reference the exact same state that existed at the time they were called. Classes operate the other way: you access state from this.state which can be mutated between async work. Sometimes you want that though so you can maintain callback identity. Here is the running sandbox for it:  Notice how you can edit items and only the necessary rows rerender, even though it updates `items`. Now, we can do anything we want in our callback, like posting to a server: Basically, if all you need is the latest data since last commit, **callbacks can be memoized as well as reducers**. The drawback is that you need to put each piece of data you need in a ref. If you have lots of pieces of data and only a few simple effects, reducers would be better, but in my case (and I suspect in many others) it's easier to use callbacks with refs. It's nice too because in my real app the save process is more complicated. It needs to get changes back from the server and apply them locally as well, so it looks more like this: Maintainability-wise, it's *really* nice to see this whole flow here in one place. Breakin this up to try to manually queue up effects and do a dance with `useReducer` feels much more convoluted. ### Option 3 I suppose another option would be to try to \"mark\" the effect to be run in state itself. That way you could do it in `useReducer` as well, and it would look something like this: And an effect would check the `itemsToSave` state and save them off. The problem is resetting that state - the effect would have to change state, causing a useless rerender, and it's not determistic to make sure that the effect does not run multiple times before `itemsToSave` gets reset. In my experience mixing effects into state, causing renders, make things a lot more difficult to maintain and debug. ### What's the difference between Option 1 and 2? Is there a crucial difference between 1 and 2? Yes, but I'd argue it's not a big deal if you can accept it. Remember these three phases: The big difference is option 1 is doing the side effect in the commit phase, and option 2 is doing it in the event handler phase. Why does this matter? If, for some reason, an item called `onSave` multiple times before the next commit phase happened, option 1 is more robust. A reducer will \"queue up\" the actions and run them in order, updating state in between them, so if you did: which runs the callback twice immediately, the reducer will process the first save and update the items, and process the second save **passing in the already updated state**. However, with option 2, when processing the second save **the commit phase hasn't been run yet** so the `latestItems` ref hasn't been updated yet. **The first save will be lost**. However, the ergonomics of option 2 is much better for many use cases, and I think it's fine to weight these benefits and never need the ability to handle such quick updates. Although concurrent mode might introduce some interesting arguments against that. ## Another small use case for triggering effects In case this wasn't already long enough, there's a similar use case I'll describe quickly. You can also add new items to the list by editing data in an empty row, and the state of this \"new item\" is tracked separately. \"Saving\" this item doesn't touch the backend, but simply updates the local state, and separate explicit \"add\" action is needed to add it to the list. The hard part is that there is a keybinding for adding the item to the list while editing - something like alt+enter. The problem is I want to coordinate with the state change, so first I want to save the existing field and *then* add to the list. The saving process is complicated so it need to run through that first (I can't just duplicate it all in `onAdd`). This isn't a problem specific to hooks, it's just about coordinating with state changes. When I was working with reducers, I had though that something like this would be neat. Basically when the new items detect that you want to save + add it first an action like `{ type: 'save-item', fields: { name: 'Foo' }, shouldAdd: true }` where `shouldAdd` is a ref that is checked on commit phase and saves the item off to the server. This isn't possible though. Another option would be for the item to call `onAdd` instead of `onSave` when saving + adding, and you could manually call the reducer yourself to process the changes: This is kind of a neat trick: you are manually running the reducer to get the updated state, and React will run the reducer again whenever it wants. Since I ended up liking callbacks for my original problems, I ended up going with a similar approach where I have a ref flag that I just set in `onSave`: ## Conclusions Sorry for the length of this. I figure I'd be over-detailed rather than under-detailed, and I've been brewing these thoughts since hooks came out. I'll try to conclude my thoughts here: * Effects are **very nice**. It feels like we have easy access to the \"commit\" phase of React, whereas previously it was all in `componentDidUpdate` and not composable at all. Now it's super easy to throw on code to the commit phase which makes coordinating stuff with state easier. * Reducers have interesting properties, and I can see how they are fully robust in a concurrent world, but for many cases they are too limited. The ergonomics of implementing many effect-ful workflows with them requires an awkward dance, kind of like when you try to track effect states in local state and split up workflows. Keeping a linear workflow in a callback is not only nice, but necessary in many cases for maintainability. * Callbacks can be made memoizable without much work. In many cases I think it's easier to use the ref trick than reducers, but the question is: just *how* dangerous is it? Right now it's not that dangerous, but maybe concurrent mode really is going to break it. * If that's the case, we should figure out a better way to weave together effects and state changes. I hope all of this made sense. Let me know if something is unclear and I'll try to fix it.",
        "human_words_stopwords_removal_lemmatization": "started gist dan mentioned would good discussion issue go . 've writing refactoring code hook . 95 % code , great straight-forward get basic idea . still complex case struggle right answer though . attempt explain . # # use case real-world use case app 'm building : interacting list item . 've simplified example codesandboxes though illustrate basic idea . 's first one : render list item , click , editable input appear edit ( n't save yet ) . colored box right change whenever item rerenders . click around item , see changing edited item , item rerender . ` row ` component wrapped ` react.memo ` ! rerender ` onedit ` new time app render , causing item rerender . # # maintaining callback identity want ` onedit ` function future render . case , 's easy n't depend anything . simply wrap ` usecallback ` empty dependency array : , see clicking around rerenders necessary item ( color change ) : # # implementing saving 're missing crucial feature : editing item , blur save value . app way `` save '' event get triggered different , blur fine . , create ` onsave ` callback app pas item , call blur new value . ` onsave ` take new item update item array new item set ` item ` state . running : 'll notice item rerendering saving . list rerenders twice click another item : first click input loses focus , edit different item . color change , editing row color change . reason rerendering ` onsave ` new callback every render . ca n't fix technique ` onedit ` depends ` item ` - * * create new callback close ` item ` otherwise 'd lose previous edits . `` callback recreated many time '' problem hook . one solution switch ` usereducer ` . 's implementation : note still wrap reducer ` onedit ` ` onsave ` callback passed row . find passing callback clearer case , work component ecosystem already expect callback . simply use ` usecallback ` dependency though since ` dispatch ` always . note even saving item , necessary row rerender . # # difference event handler dispatch 's problem though . work simple demo , real app ` onsave ` * * optimistically update local state save server . side effect . 's something like : 's big difference phase event handler dispatch run . event handler run whenever triggered ( naturally ) dispatching action ( running ` reducer ` ) happens rendering . reducer must pure . 's reducer ` save-item ` also supposed trigger side effect ? first , item 's important understand 3 phase : event run first phase , cause render ( dispatch happen ) , everything finally ready flushed dom `` commit '' phase , effect run ( le ) . need side effect run commit phase . # # # option 1 one option use ref `` mark '' saving effect run . 's code : basically create flag ref : luckily , 've already wrapped save dispatch event handler . inside ` onsave ` mark flag true . ca n't inside reducer must pure : finally , define effect always run rendering check flag reset : thought option going work , ran issue . n't know * * save anymore . certainly n't want send entire item array server ! suppose could store item ref , happens multiple event fired effect run ? suppose could store array , ... really need ? # # # option 2 * * note * * : noticed option documented , disagree tone used . think fine pattern better many case ` dispatch ` , even 's quite robust . especially since 's powerful callback . ( see end section ) keeping around data need effect might work case , feel little clunky . could `` queue '' effect reducer , would work , ca n't . instead , another option embrace callback . going back version used naive ` onsave ` forced item rerender ( ` onsave ` look like : core problem depends item . need recreate ` onsave ` close ` item ` . n't close ? instead , let 's create ref : effect keep up-to-date item : , ` onsave ` callback reference ref always get up-to-date item . mean memoize ` usecallback ` : * * intentionally * * opting always referencing latest item . biggest change hook opinion safe default : async function always reference exact state existed time called . class operate way : access state this.state mutated async work . sometimes want though maintain callback identity . running sandbox : notice edit item necessary row rerender , even though update ` item ` . , anything want callback , like posting server : basically , need latest data since last commit , * * callback memoized well reducer * * . drawback need put piece data need ref . lot piece data simple effect , reducer would better , case ( suspect many others ) 's easier use callback ref . 's nice real app save process complicated . need get change back server apply locally well , look like : maintainability-wise , 's * really * nice see whole flow one place . breakin try manually queue effect dance ` usereducer ` feel much convoluted . # # # option 3 suppose another option would try `` mark '' effect run state . way could ` usereducer ` well , would look something like : effect would check ` itemstosave ` state save . problem resetting state - effect would change state , causing useless rerender , 's determistic make sure effect run multiple time ` itemstosave ` get reset . experience mixing effect state , causing render , make thing lot difficult maintain debug . # # # 's difference option 1 2 ? crucial difference 1 2 ? yes , 'd argue 's big deal accept . remember three phase : big difference option 1 side effect commit phase , option 2 event handler phase . matter ? , reason , item called ` onsave ` multiple time next commit phase happened , option 1 robust . reducer `` queue '' action run order , updating state , : run callback twice immediately , reducer process first save update item , process second save * * passing already updated state * * . however , option 2 , processing second save * * commit phase n't run yet * * ` latestitems ` ref n't updated yet . * * first save lost * * . however , ergonomics option 2 much better many use case , think 's fine weight benefit never need ability handle quick update . although concurrent mode might introduce interesting argument . # # another small use case triggering effect case n't already long enough , 's similar use case 'll describe quickly . also add new item list editing data empty row , state `` new item '' tracked separately . `` saving '' item n't touch backend , simply update local state , separate explicit `` add '' action needed add list . hard part keybinding adding item list editing - something like alt+enter . problem want coordinate state change , first want save existing field * * add list . saving process complicated need run first ( ca n't duplicate ` onadd ` ) . n't problem specific hook , 's coordinating state change . working reducer , though something like would neat . basically new item detect want save + add first action like ` { type : 'save-item ' , field : { name : 'foo ' } , shouldadd : true } ` ` shouldadd ` ref checked commit phase save item server . n't possible though . another option would item call ` onadd ` instead ` onsave ` saving + adding , could manually call reducer process change : kind neat trick : manually running reducer get updated state , react run reducer whenever want . since ended liking callback original problem , ended going similar approach ref flag set ` onsave ` : # # conclusion sorry length . figure 'd over-detailed rather under-detailed , 've brewing thought since hook came . 'll try conclude thought : * effect * * nice * * . feel like easy access `` commit '' phase react , whereas previously ` componentdidupdate ` composable . 's super easy throw code commit phase make coordinating stuff state easier . * reducer interesting property , see fully robust concurrent world , many case limited . ergonomics implementing many effect-ful workflow requires awkward dance , kind like try track effect state local state split workflow . keeping linear workflow callback nice , necessary many case maintainability . * callback made memoizable without much work . many case think 's easier use ref trick reducer , question : * * dangerous ? right 's dangerous , maybe concurrent mode really going break . * 's case , figure better way weave together effect state change . hope made sense . let know something unclear 'll try fix .",
        "title_stopwords_removal_lemmatization": "dancing state effect - real-world use case"
    },
    {
        "issue_id": 426573772,
        "title": "Noscript tags no longer rendering components in 16.5.0",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-28T15:56:11Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nStarting in version 16.4.3, the following code:\r\n\r\n```\r\n<noscript>\r\n  <a href=\"/cat\">Cat</a>\r\n  <a href=\"/dog\">Dog</a>\r\n</noscript>\r\n```\r\n\r\nis being rendered in the browser as:\r\n\r\n```\r\n<noscript></noscript>\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**\r\n\r\nPrior to 16.4.3: https://codesandbox.io/embed/5mww4nzpwp\r\n\r\nAfter 16.4.3: https://codesandbox.io/embed/6v8m4yo303\r\n\r\n(The changes are not visible, but if you `inspect element` you can see that, in the first example, the links are being rendered, and in the second example they're not being rendered.)\r\n\r\n**What is the expected behavior?**\r\n\r\nIt should render in the browser the same as in the code:\r\n\r\n```\r\n<noscript>\r\n  <a href=\"/cat\">Cat</a>\r\n  <a href=\"/dog\">Dog</a>\r\n</noscript>\r\n```\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nSee above, it was working in versions prior to 16.4.3. (I couldn't find a previous issue mentioning this bug. I think it could have been introduced in the fix for https://github.com/facebook/react/issues/11423)\r\n\r\n**Why is this a problem?**\r\n\r\nI use a snapshot tool with React to generate a set of static pages from a React project. These pages have less functionality than the full application, but they allow webcrawlers and users who have disabled JavaScript to use the site at a basic level. For example, the code might look like this:\r\n\r\n```\r\n<FancyInteractiveButton linksTo=\"page\">link</FancyInteractiveButton>\r\n<noscript>\r\n  <a href=\"page\">link</a>\r\n</noscript>\r\n```\r\n\r\nPreventing components in `<noscript>` tags from rendering breaks this functionality for users with JavaScript disabled. The generated snapshots no longer contain the links. It also makes the site harder to navigate by webcrawlers, even if they have JavaScript enabled, because they have to be smart enough to use the fancy button instead of following the link.",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    Starting in version 16.4.3, the following code:    ```  <noscript>    <a href=\"/cat\">Cat</a>    <a href=\"/dog\">Dog</a>  </noscript>  ```    is being rendered in the browser as:    ```  <noscript></noscript>  ```    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    Prior to 16.4.3: https://codesandbox.io/embed/5mww4nzpwp    After 16.4.3: https://codesandbox.io/embed/6v8m4yo303    (The changes are not visible, but if you `inspect element` you can see that, in the first example, the links are being rendered, and in the second example they're not being rendered.)    **What is the expected behavior?**    It should render in the browser the same as in the code:    ```  <noscript>    <a href=\"/cat\">Cat</a>    <a href=\"/dog\">Dog</a>  </noscript>  ```    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    See above, it was working in versions prior to 16.4.3. (I couldn't find a previous issue mentioning this bug. I think it could have been introduced in the fix for https://github.com/facebook/react/issues/11423)    **Why is this a problem?**    I use a snapshot tool with React to generate a set of static pages from a React project. These pages have less functionality than the full application, but they allow webcrawlers and users who have disabled JavaScript to use the site at a basic level. For example, the code might look like this:    ```  <FancyInteractiveButton linksTo=\"page\">link</FancyInteractiveButton>  <noscript>    <a href=\"page\">link</a>  </noscript>  ```    Preventing components in `<noscript>` tags from rendering breaks this functionality for users with JavaScript disabled. The generated snapshots no longer contain the links. It also makes the site harder to navigate by webcrawlers, even if they have JavaScript enabled, because they have to be smart enough to use the fancy button instead of following the link.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    Starting in version 16.4.3, the following code:        is being rendered in the browser as:        **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    Prior to 16.4.3: https://codesandbox.io/embed/5mww4nzpwp    After 16.4.3: https://codesandbox.io/embed/6v8m4yo303    (The changes are not visible, but if you `inspect element` you can see that, in the first example, the links are being rendered, and in the second example they're not being rendered.)    **What is the expected behavior?**    It should render in the browser the same as in the code:        **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    See above, it was working in versions prior to 16.4.3. (I couldn't find a previous issue mentioning this bug. I think it could have been introduced in the fix for https://github.com/facebook/react/issues/11423)    **Why is this a problem?**    I use a snapshot tool with React to generate a set of static pages from a React project. These pages have less functionality than the full application, but they allow webcrawlers and users who have disabled JavaScript to use the site at a basic level. For example, the code might look like this:        Preventing components in `<noscript>` tags from rendering breaks this functionality for users with JavaScript disabled. The generated snapshots no longer contain the links. It also makes the site harder to navigate by webcrawlers, even if they have JavaScript enabled, because they have to be smart enough to use the fancy button instead of following the link.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** Starting in version 16.4.3, the following code: is being rendered in the browser as: **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.** Prior to 16.4.3:  After 16.4.3:  (The changes are not visible, but if you `inspect element` you can see that, in the first example, the links are being rendered, and in the second example they're not being rendered.) **What is the expected behavior?** It should render in the browser the same as in the code: **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** See above, it was working in versions prior to 16.4.3. (I couldn't find a previous issue mentioning this bug. I think it could have been introduced in the fix for  **Why is this a problem?** I use a snapshot tool with React to generate a set of static pages from a React project. These pages have less functionality than the full application, but they allow webcrawlers and users who have disabled JavaScript to use the site at a basic level. For example, the code might look like this: Preventing components in `` tags from rendering breaks this functionality for users with JavaScript disabled. The generated snapshots no longer contain the links. It also makes the site harder to navigate by webcrawlers, even if they have JavaScript enabled, because they have to be smart enough to use the fancy button instead of following the link.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * starting version 16.4.3 , following code : rendered browser : * * current behavior bug , please provide step reproduce possible minimal demo problem . * * prior 16.4.3 : 16.4.3 : ( change visible , ` inspect element ` see , first example , link rendered , second example 're rendered . ) * * expected behavior ? * * render browser code : * * version react , browser / o affected issue ? work previous version react ? * * see , working version prior 16.4.3 . ( could n't find previous issue mentioning bug . think could introduced fix * * problem ? * * use snapshot tool react generate set static page react project . page le functionality full application , allow webcrawlers user disabled javascript use site basic level . example , code might look like : preventing component `` tag rendering break functionality user javascript disabled . generated snapshot longer contain link . also make site harder navigate webcrawlers , even javascript enabled , smart enough use fancy button instead following link .",
        "title_stopwords_removal_lemmatization": "noscript tag longer rendering component 16.5.0"
    },
    {
        "issue_id": 424679429,
        "title": "[react-hooks/exhaustive-deps] eslint --fix breaks the code",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-25T00:20:38Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nI want to report a bug\r\n\r\n**What is the current behavior?**\r\n\r\neslint --fix trying to break my hook)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nI have a very simple hook:\r\n```jsx\r\nimport { useEffect, useState } from 'react'\r\n\r\nexport function useSwitchTab(trigger, tabsAmount, initialState = 0) {\r\n  const [currentTab, setTab] = useState(initialState - 1)\r\n\r\n  useEffect(() => {\r\n    setTab(currentTab + 1 >= tabsAmount ? 0 : currentTab + 1)\r\n  }, [tabsAmount, trigger])\r\n\r\n  return [currentTab, setTab]\r\n}\r\n```\r\nIf props `tabsAmount` or `trigger` will change, I need to increase `currentTab` value by 1. It works fine and looks ok for me, but in `eslint-plugin-react-hook` rule `react-hooks/exhaustive-deps` will warn here:\r\n\r\n> React Hook useEffect has a missing dependency: 'currentTab'. Either include it or remove the dependency array. You can also do a functional update 'setTab(c => ...)' if you only need 'c\r\n> urrentTab' in the 'setTab' call  react-hooks/exhaustive-deps\r\n\r\nAnd eslint --fix will break my code like this:\r\n\r\n```jsx\r\nimport { useEffect, useState } from 'react'\r\n\r\nexport function useSwitchTab(trigger, tabsAmount, initialState = 0) {\r\n  const [currentTab, setTab] = useState(initialState - 1)\r\n\r\n  useEffect(() => {\r\n    setTab(currentTab + 1 >= tabsAmount ? 0 : currentTab + 1)\r\n  }, [currentTab, tabsAmount, trigger])\r\n\r\n  return [currentTab, setTab]\r\n}\r\n```\r\nIt will add `currentTab` in deps for useEffect and this will create **endless loop**. \r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nEslint shouldn't fix this warning with --fix option, It may break the code.\r\n\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nreact: 16.8.5\r\neslint-plugin-react-hooks: 1.6.0",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    I want to report a bug    **What is the current behavior?**    eslint --fix trying to break my hook)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    I have a very simple hook:  ```jsx  import { useEffect, useState } from 'react'    export function useSwitchTab(trigger, tabsAmount, initialState = 0) {    const [currentTab, setTab] = useState(initialState - 1)      useEffect(() => {      setTab(currentTab + 1 >= tabsAmount ? 0 : currentTab + 1)    }, [tabsAmount, trigger])      return [currentTab, setTab]  }  ```  If props `tabsAmount` or `trigger` will change, I need to increase `currentTab` value by 1. It works fine and looks ok for me, but in `eslint-plugin-react-hook` rule `react-hooks/exhaustive-deps` will warn here:    > React Hook useEffect has a missing dependency: 'currentTab'. Either include it or remove the dependency array. You can also do a functional update 'setTab(c => ...)' if you only need 'c  > urrentTab' in the 'setTab' call  react-hooks/exhaustive-deps    And eslint --fix will break my code like this:    ```jsx  import { useEffect, useState } from 'react'    export function useSwitchTab(trigger, tabsAmount, initialState = 0) {    const [currentTab, setTab] = useState(initialState - 1)      useEffect(() => {      setTab(currentTab + 1 >= tabsAmount ? 0 : currentTab + 1)    }, [currentTab, tabsAmount, trigger])      return [currentTab, setTab]  }  ```  It will add `currentTab` in deps for useEffect and this will create **endless loop**.       **What is the expected behavior?**    Eslint shouldn't fix this warning with --fix option, It may break the code.      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react: 16.8.5  eslint-plugin-react-hooks: 1.6.0",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    I want to report a bug    **What is the current behavior?**    eslint --fix trying to break my hook)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    I have a very simple hook:    If props `tabsAmount` or `trigger` will change, I need to increase `currentTab` value by 1. It works fine and looks ok for me, but in `eslint-plugin-react-hook` rule `react-hooks/exhaustive-deps` will warn here:    > React Hook useEffect has a missing dependency: 'currentTab'. Either include it or remove the dependency array. You can also do a functional update 'setTab(c => ...)' if you only need 'c  > urrentTab' in the 'setTab' call  react-hooks/exhaustive-deps    And eslint --fix will break my code like this:      It will add `currentTab` in deps for useEffect and this will create **endless loop**.       **What is the expected behavior?**    Eslint shouldn't fix this warning with --fix option, It may break the code.      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react: 16.8.5  eslint-plugin-react-hooks: 1.6.0",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** I want to report a bug **What is the current behavior?** eslint --fix trying to break my hook) **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** I have a very simple hook: If props `tabsAmount` or `trigger` will change, I need to increase `currentTab` value by 1. It works fine and looks ok for me, but in `eslint-plugin-react-hook` rule `react-hooks/exhaustive-deps` will warn here: > React Hook useEffect has a missing dependency: 'currentTab'. Either include it or remove the dependency array. You can also do a functional update 'setTab(c => ...)' if you only need 'c > urrentTab' in the 'setTab' call react-hooks/exhaustive-deps And eslint --fix will break my code like this: It will add `currentTab` in deps for useEffect and this will create **endless loop**. **What is the expected behavior?** Eslint shouldn't fix this warning with --fix option, It may break the code. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** react: 16.8.5 eslint-plugin-react-hooks: 1.6.0",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * want report bug * * current behavior ? * * eslint -- fix trying break hook ) * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * simple hook : prop ` tabsamount ` ` trigger ` change , need increase ` currenttab ` value 1. work fine look ok , ` eslint-plugin-react-hook ` rule ` react-hooks/exhaustive-deps ` warn : > react hook useeffect missing dependency : 'currenttab ' . either include remove dependency array . also functional update 'settab ( c = > ... ) ' need ' c > urrenttab ' 'settab ' call react-hooks/exhaustive-deps eslint -- fix break code like : add ` currenttab ` deps useeffect create * * endless loop * * . * * expected behavior ? * * eslint n't fix warning -- fix option , may break code . * * version react , browser / o affected issue ? work previous version react ? * * react : 16.8.5 eslint-plugin-react-hooks : 1.6.0",
        "title_stopwords_removal_lemmatization": "[ react-hooks/exhaustive-deps ] eslint -- fix break code"
    },
    {
        "issue_id": 424082507,
        "title": "useEffect can very quickly consume free quotas or cost money when used with 3rd party services",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-22T07:40:58Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nFeature / Documentation-Request\r\n\r\n**What is the current behavior?**\r\nWhen I developed my app last week with useEffect and firebase firestore, it happened to me that my effect used up the 20k-write limit within about 20 seconds. Of course this was a bug introduced by myself, but if I had been in a pay-as-you-go plan it could have cost me some money. I now use a custom hook as useEffect, which counts in development whether a hook is executed too often in 500ms and if so, it throws an error.\r\n\r\n**What is the expected behavior?**\r\nI'm not sure how you could solve this on your side. Of course you could do the check in development-mode, but that would probably trigger existing projects too much. However, a small hint in the documentation would be good that you should take care during development that useEffect can quickly lead to this behavior and that you should be careful when using other 3rd-party services that have a quota or have to be paid.\r\n\r\nI just wanted to share my experiences while developing a \"real\" app. If you can't or won't do anything here, you are welcome to close the issue.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Feature / Documentation-Request    **What is the current behavior?**  When I developed my app last week with useEffect and firebase firestore, it happened to me that my effect used up the 20k-write limit within about 20 seconds. Of course this was a bug introduced by myself, but if I had been in a pay-as-you-go plan it could have cost me some money. I now use a custom hook as useEffect, which counts in development whether a hook is executed too often in 500ms and if so, it throws an error.    **What is the expected behavior?**  I'm not sure how you could solve this on your side. Of course you could do the check in development-mode, but that would probably trigger existing projects too much. However, a small hint in the documentation would be good that you should take care during development that useEffect can quickly lead to this behavior and that you should be careful when using other 3rd-party services that have a quota or have to be paid.    I just wanted to share my experiences while developing a \"real\" app. If you can't or won't do anything here, you are welcome to close the issue.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Feature / Documentation-Request    **What is the current behavior?**  When I developed my app last week with useEffect and firebase firestore, it happened to me that my effect used up the 20k-write limit within about 20 seconds. Of course this was a bug introduced by myself, but if I had been in a pay-as-you-go plan it could have cost me some money. I now use a custom hook as useEffect, which counts in development whether a hook is executed too often in 500ms and if so, it throws an error.    **What is the expected behavior?**  I'm not sure how you could solve this on your side. Of course you could do the check in development-mode, but that would probably trigger existing projects too much. However, a small hint in the documentation would be good that you should take care during development that useEffect can quickly lead to this behavior and that you should be careful when using other 3rd-party services that have a quota or have to be paid.    I just wanted to share my experiences while developing a \"real\" app. If you can't or won't do anything here, you are welcome to close the issue.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Feature / Documentation-Request **What is the current behavior?** When I developed my app last week with useEffect and firebase firestore, it happened to me that my effect used up the 20k-write limit within about 20 seconds. Of course this was a bug introduced by myself, but if I had been in a pay-as-you-go plan it could have cost me some money. I now use a custom hook as useEffect, which counts in development whether a hook is executed too often in 500ms and if so, it throws an error. **What is the expected behavior?** I'm not sure how you could solve this on your side. Of course you could do the check in development-mode, but that would probably trigger existing projects too much. However, a small hint in the documentation would be good that you should take care during development that useEffect can quickly lead to this behavior and that you should be careful when using other 3rd-party services that have a quota or have to be paid. I just wanted to share my experiences while developing a \"real\" app. If you can't or won't do anything here, you are welcome to close the issue.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature / documentation-request * * current behavior ? * * developed app last week useeffect firebase firestore , happened effect used 20k-write limit within 20 second . course bug introduced , pay-as-you-go plan could cost money . use custom hook useeffect , count development whether hook executed often 500ms , throw error . * * expected behavior ? * * 'm sure could solve side . course could check development-mode , would probably trigger existing project much . however , small hint documentation would good take care development useeffect quickly lead behavior careful using 3rd-party service quota paid . wanted share experience developing `` real '' app . ca n't wo n't anything , welcome close issue .",
        "title_stopwords_removal_lemmatization": "useeffect quickly consume free quota cost money used 3rd party service"
    },
    {
        "issue_id": 423641735,
        "title": "React callback ref cleanup function",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-21T09:44:36Z",
        "status": "open",
        "description": "At the time React added callback refs the main use case for them was to replace string refs. A lot of the callback refs looked like this:\r\n\r\n```jsx\r\n<div ref={node => this.node = node} />\r\n```\r\n\r\nWith the introduction of `createRef` and `useRef` this use case is pretty much replaced by these alternatives so the use case of callback refs will shift to advanced use cases like [measuring DOM nodes](https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node).\r\n\r\nIt would be nice if you could return a cleanup function from the callback ref which is called instead of the callback with null. This way it will behave more like the `useEffect` API.\r\n\r\n```jsx\r\n<div ref={node => {\r\n  // Normal ref callback\r\n\r\n  return () => {\r\n    // Cleanup function which is called when the ref is removed\r\n  }\r\n}} />\r\n```\r\n\r\nThis will be super helpful when you need to set up a Resize-, Intersection- or  MutationObserver.\r\n\r\n```jsx\r\nfunction useDimensions() {\r\n  const [entry, setEntry] = useState()\r\n  \r\n  const targetRef = useCallback((node) => {\r\n    const observer = new ResizeObserver(([entry]) => {\r\n      setEntry(entry)\r\n    })\r\n\r\n    observer.observe(node)\r\n\r\n    return () => {\r\n      observer.disconnect()\r\n    }\r\n  }, [])\r\n\r\n  return [entry, targetRef]\r\n}\r\n\r\nfunction Comp() {\r\n  const [dimensions, targetRef] = useDimensions()\r\n\r\n  return (\r\n    <pre ref={targetRef}>\r\n      {JSON.stringify(dimensions, null, 2)}\r\n    </pre>\r\n  )\r\n}\r\n```\r\n\r\nCurrently, if you want to implement something like this you need to save the observer into a ref and then if the callback ref is called with null you have to clean up the observer from the ref.\r\n\r\nTo be 99% backward compatible we could call both the callback ref with null and the cleanup function. The only case where it isn't backward compatible is if currently someone is returning a function and doesn't expect the function to be called.\r\n\r\n```jsx\r\nfunction ref(node) {\r\n  if (node === null) {\r\n    return\r\n  }\r\n\r\n  // Do something\r\n\r\n  return () => {\r\n    // Cleanup something\r\n  }\r\n}\r\n```",
        "remove_template_description": "At the time React added callback refs the main use case for them was to replace string refs. A lot of the callback refs looked like this:    ```jsx  <div ref={node => this.node = node} />  ```    With the introduction of `createRef` and `useRef` this use case is pretty much replaced by these alternatives so the use case of callback refs will shift to advanced use cases like [measuring DOM nodes](https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node).    It would be nice if you could return a cleanup function from the callback ref which is called instead of the callback with null. This way it will behave more like the `useEffect` API.    ```jsx  <div ref={node => {    // Normal ref callback      return () => {      // Cleanup function which is called when the ref is removed    }  }} />  ```    This will be super helpful when you need to set up a Resize-, Intersection- or  MutationObserver.    ```jsx  function useDimensions() {    const [entry, setEntry] = useState()        const targetRef = useCallback((node) => {      const observer = new ResizeObserver(([entry]) => {        setEntry(entry)      })        observer.observe(node)        return () => {        observer.disconnect()      }    }, [])      return [entry, targetRef]  }    function Comp() {    const [dimensions, targetRef] = useDimensions()      return (      <pre ref={targetRef}>        {JSON.stringify(dimensions, null, 2)}      </pre>    )  }  ```    Currently, if you want to implement something like this you need to save the observer into a ref and then if the callback ref is called with null you have to clean up the observer from the ref.    To be 99% backward compatible we could call both the callback ref with null and the cleanup function. The only case where it isn't backward compatible is if currently someone is returning a function and doesn't expect the function to be called.    ```jsx  function ref(node) {    if (node === null) {      return    }      // Do something      return () => {      // Cleanup something    }  }  ```",
        "human_words": "At the time React added callback refs the main use case for them was to replace string refs. A lot of the callback refs looked like this:        With the introduction of `createRef` and `useRef` this use case is pretty much replaced by these alternatives so the use case of callback refs will shift to advanced use cases like [measuring DOM nodes](https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node).    It would be nice if you could return a cleanup function from the callback ref which is called instead of the callback with null. This way it will behave more like the `useEffect` API.        This will be super helpful when you need to set up a Resize-, Intersection- or  MutationObserver.        Currently, if you want to implement something like this you need to save the observer into a ref and then if the callback ref is called with null you have to clean up the observer from the ref.    To be 99% backward compatible we could call both the callback ref with null and the cleanup function. The only case where it isn't backward compatible is if currently someone is returning a function and doesn't expect the function to be called.    ",
        "human_words_regrex": "At the time React added callback refs the main use case for them was to replace string refs. A lot of the callback refs looked like this: With the introduction of `createRef` and `useRef` this use case is pretty much replaced by these alternatives so the use case of callback refs will shift to advanced use cases like . It would be nice if you could return a cleanup function from the callback ref which is called instead of the callback with null. This way it will behave more like the `useEffect` API. This will be super helpful when you need to set up a Resize-, Intersection- or MutationObserver. Currently, if you want to implement something like this you need to save the observer into a ref and then if the callback ref is called with null you have to clean up the observer from the ref. To be 99% backward compatible we could call both the callback ref with null and the cleanup function. The only case where it isn't backward compatible is if currently someone is returning a function and doesn't expect the function to be called. ",
        "human_words_stopwords_removal_lemmatization": "time react added callback ref main use case replace string ref . lot callback ref looked like : introduction ` createref ` ` useref ` use case pretty much replaced alternative use case callback ref shift advanced use case like . would nice could return cleanup function callback ref called instead callback null . way behave like ` useeffect ` api . super helpful need set resize- , intersection- mutationobserver . currently , want implement something like need save observer ref callback ref called null clean observer ref . 99 % backward compatible could call callback ref null cleanup function . case n't backward compatible currently someone returning function n't expect function called .",
        "title_stopwords_removal_lemmatization": "react callback ref cleanup function"
    },
    {
        "issue_id": 423386505,
        "title": "Should useLayoutEffect fire for sub component updates?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-20T17:39:43Z",
        "status": "closed",
        "description": "To my current understanding, `useLayoutEffect` is used to interact with the browser layout, and to allow you to update a component accordingly.\r\n\r\nIf a sub-component updates, it is possible that the layout of the parent component changes.\r\n\r\nIn the current version of React, the `useLayoutEffect` would not be called on the parent, so the parent is unable to react to layout changes. This makes this API unsuitable for a lot of layout-based use-cases, despite this being its primary use-case.\r\n\r\nIs this something that should be revisited?",
        "remove_template_description": "To my current understanding, `useLayoutEffect` is used to interact with the browser layout, and to allow you to update a component accordingly.    If a sub-component updates, it is possible that the layout of the parent component changes.    In the current version of React, the `useLayoutEffect` would not be called on the parent, so the parent is unable to react to layout changes. This makes this API unsuitable for a lot of layout-based use-cases, despite this being its primary use-case.    Is this something that should be revisited?",
        "human_words": "To my current understanding, `useLayoutEffect` is used to interact with the browser layout, and to allow you to update a component accordingly.    If a sub-component updates, it is possible that the layout of the parent component changes.    In the current version of React, the `useLayoutEffect` would not be called on the parent, so the parent is unable to react to layout changes. This makes this API unsuitable for a lot of layout-based use-cases, despite this being its primary use-case.    Is this something that should be revisited?",
        "human_words_regrex": "To my current understanding, `useLayoutEffect` is used to interact with the browser layout, and to allow you to update a component accordingly. If a sub-component updates, it is possible that the layout of the parent component changes. In the current version of React, the `useLayoutEffect` would not be called on the parent, so the parent is unable to react to layout changes. This makes this API unsuitable for a lot of layout-based use-cases, despite this being its primary use-case. Is this something that should be revisited?",
        "human_words_stopwords_removal_lemmatization": "current understanding , ` uselayouteffect ` used interact browser layout , allow update component accordingly . sub-component update , possible layout parent component change . current version react , ` uselayouteffect ` would called parent , parent unable react layout change . make api unsuitable lot layout-based use-cases , despite primary use-case . something revisited ?",
        "title_stopwords_removal_lemmatization": "uselayouteffect fire sub component update ?"
    },
    {
        "issue_id": 422874408,
        "title": "Effect memoization and immutable data structures",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-19T17:58:05Z",
        "status": "open",
        "description": "Current design of `useEffect` requires dependencies to be either primitive values or references to the same object, because shallow equality check relies on `Object.is` which is an identity check for objects.\r\n\r\nThe above means that there's no way to perform structural comparison, which is needed for immutable data structures when identity check fails.\r\n\r\nTo maintain backwards compatibility a comparator function could be provided as the third argument to `useEffect`:\r\n```js\r\nuseEffect(fn, deps, depsComparator);\r\n```\r\n\r\nThe goal here is to preserve an ease of use of the API with immutable data structures in order to provide an idiomatic usage of `useEffect` in ClojureScript and other environments that rely on immutability e.g. Immutable.js\r\n\r\ncc @mhuebert @Lokeh @orestis",
        "remove_template_description": "Current design of `useEffect` requires dependencies to be either primitive values or references to the same object, because shallow equality check relies on `Object.is` which is an identity check for objects.    The above means that there's no way to perform structural comparison, which is needed for immutable data structures when identity check fails.    To maintain backwards compatibility a comparator function could be provided as the third argument to `useEffect`:  ```js  useEffect(fn, deps, depsComparator);  ```    The goal here is to preserve an ease of use of the API with immutable data structures in order to provide an idiomatic usage of `useEffect` in ClojureScript and other environments that rely on immutability e.g. Immutable.js    cc @mhuebert @Lokeh @orestis",
        "human_words": "Current design of `useEffect` requires dependencies to be either primitive values or references to the same object, because shallow equality check relies on `Object.is` which is an identity check for objects.    The above means that there's no way to perform structural comparison, which is needed for immutable data structures when identity check fails.    To maintain backwards compatibility a comparator function could be provided as the third argument to `useEffect`:      The goal here is to preserve an ease of use of the API with immutable data structures in order to provide an idiomatic usage of `useEffect` in ClojureScript and other environments that rely on immutability e.g. Immutable.js    cc @mhuebert @Lokeh @orestis",
        "human_words_regrex": "Current design of `useEffect` requires dependencies to be either primitive values or references to the same object, because shallow equality check relies on `Object.is` which is an identity check for objects. The above means that there's no way to perform structural comparison, which is needed for immutable data structures when identity check fails. To maintain backwards compatibility a comparator function could be provided as the third argument to `useEffect`: The goal here is to preserve an ease of use of the API with immutable data structures in order to provide an idiomatic usage of `useEffect` in ClojureScript and other environments that rely on immutability e.g. Immutable.js cc @mhuebert @Lokeh @orestis",
        "human_words_stopwords_removal_lemmatization": "current design ` useeffect ` requires dependency either primitive value reference object , shallow equality check relies ` object.is ` identity check object . mean 's way perform structural comparison , needed immutable data structure identity check fails . maintain backwards compatibility comparator function could provided third argument ` useeffect ` : goal preserve ease use api immutable data structure order provide idiomatic usage ` useeffect ` clojurescript environment rely immutability e.g . immutable.js cc @ mhuebert @ lokeh @ orestis",
        "title_stopwords_removal_lemmatization": "effect memoization immutable data structure"
    },
    {
        "issue_id": 422872651,
        "title": "eslint-plugin-react-hooks - autofix useCallback/useMemo behaviour",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2019-03-19T17:54:16Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nDiscussion for new feature\r\n\r\n**What is the current behavior?**\r\n\r\nuseCallback/useMemo hook's do nothing when there is no second argument provided for deps. The eslint plugin reports this but does not autofix\r\n\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n16.8.4\r\n\r\n**PR to implement:** \r\n\r\nhttps://github.com/facebook/react/pull/15146\r\n\r\n&nbsp;\r\n\r\nCurrently, the eslint plugin does not autofix useCallback/useMemo to infer deps if there isn't a second argument provided to the hook. We can autofix it to infer deps if needed, or autofix to remove the hook altogether if there no deps needed (according to https://reactjs.org/docs/hooks-reference.html#usememo, if no second argument is provided it behaves as if the hook doesn't exist anyways).\r\n\r\nWhat would be the best way to implement this autofix? In my opinion, linting shouldn't be breaking functionality on an autofix, so autofixing to remove the hook is the safest to implement. Autofixing to infer deps will change behavior in code so I was thinking of having a config option the dev needs to specify so that linting changes that is affecting behavior is explicit.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Discussion for new feature    **What is the current behavior?**    useCallback/useMemo hook's do nothing when there is no second argument provided for deps. The eslint plugin reports this but does not autofix      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.8.4    **PR to implement:**     https://github.com/facebook/react/pull/15146    &nbsp;    Currently, the eslint plugin does not autofix useCallback/useMemo to infer deps if there isn't a second argument provided to the hook. We can autofix it to infer deps if needed, or autofix to remove the hook altogether if there no deps needed (according to https://reactjs.org/docs/hooks-reference.html#usememo, if no second argument is provided it behaves as if the hook doesn't exist anyways).    What would be the best way to implement this autofix? In my opinion, linting shouldn't be breaking functionality on an autofix, so autofixing to remove the hook is the safest to implement. Autofixing to infer deps will change behavior in code so I was thinking of having a config option the dev needs to specify so that linting changes that is affecting behavior is explicit.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Discussion for new feature    **What is the current behavior?**    useCallback/useMemo hook's do nothing when there is no second argument provided for deps. The eslint plugin reports this but does not autofix      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.8.4    **PR to implement:**     https://github.com/facebook/react/pull/15146    &nbsp;    Currently, the eslint plugin does not autofix useCallback/useMemo to infer deps if there isn't a second argument provided to the hook. We can autofix it to infer deps if needed, or autofix to remove the hook altogether if there no deps needed (according to https://reactjs.org/docs/hooks-reference.html#usememo, if no second argument is provided it behaves as if the hook doesn't exist anyways).    What would be the best way to implement this autofix? In my opinion, linting shouldn't be breaking functionality on an autofix, so autofixing to remove the hook is the safest to implement. Autofixing to infer deps will change behavior in code so I was thinking of having a config option the dev needs to specify so that linting changes that is affecting behavior is explicit.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Discussion for new feature **What is the current behavior?** useCallback/useMemo hook's do nothing when there is no second argument provided for deps. The eslint plugin reports this but does not autofix **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.8.4 **PR to implement:**  &nbsp; Currently, the eslint plugin does not autofix useCallback/useMemo to infer deps if there isn't a second argument provided to the hook. We can autofix it to infer deps if needed, or autofix to remove the hook altogether if there no deps needed (according to  if no second argument is provided it behaves as if the hook doesn't exist anyways). What would be the best way to implement this autofix? In my opinion, linting shouldn't be breaking functionality on an autofix, so autofixing to remove the hook is the safest to implement. Autofixing to infer deps will change behavior in code so I was thinking of having a config option the dev needs to specify so that linting changes that is affecting behavior is explicit.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * discussion new feature * * current behavior ? * * usecallback/usememo hook 's nothing second argument provided deps . eslint plugin report autofix * * version react , browser / o affected issue ? work previous version react ? * * 16.8.4 * * pr implement : * * & nbsp ; currently , eslint plugin autofix usecallback/usememo infer deps n't second argument provided hook . autofix infer deps needed , autofix remove hook altogether deps needed ( according second argument provided behaves hook n't exist anyways ) . would best way implement autofix ? opinion , linting n't breaking functionality autofix , autofixing remove hook safest implement . autofixing infer deps change behavior code thinking config option dev need specify linting change affecting behavior explicit .",
        "title_stopwords_removal_lemmatization": "eslint-plugin-react-hooks - autofix usecallback/usememo behaviour"
    },
    {
        "issue_id": 421845605,
        "title": "Hooks - unmount and didUpdate",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-16T19:50:01Z",
        "status": "open",
        "description": "I'm opening this up at Dan's request from a twitter discussion:\r\nhttps://twitter.com/lichstam/status/1106995545938247682\r\n\r\nFrom Twitter:\r\n\r\nI can fill in on this. The first example I would like to point to is a debouncing hook I've created that looks something like this:\r\n  \r\n```javascript\r\nuseEffect(() => {\r\n  const debounced = setTimeout(() => setDebounced(steps), 500);\r\n  return () => clearTimeout(debounced);\r\n}, [steps])\r\n```\r\n\r\nand then I have another one, that actually performs the request:\r\n\r\n```javascript\r\nuseEffect(request, [debounced])\r\n```\r\n\r\nAnd it all works fine, apart from when the component is mounted and unmounted.\r\nIn the class model I was able to make sure it never runs the first time and on unmounting I could clear the timeout and, if the state value differs from prop (yes I know, you shouldn't mirror your props but I have to debounce somewhere), I could just perform a last request before I unmount. \r\nFurthermore, `componentDidUpdate` really made it easy preventing this from running the first time. I'm not quite sure how to approach this with hooks.\r\nPerhaps I'm doing it all wrong but to Patrick's point, the class way was more straight forward.\r\n\r\nAnother example: I code in RN and use the Animated API a lot. I have cases that translates into something like this:\r\n\r\n```javascript\r\nuseEffect(() => {\r\n  if (inAddStage) moveAndShowStep(); // Animate with Animated API\r\n}, [inAddStage]);\r\n```\r\n\r\nThis works well but it does perform an unnecessary initial run which makes me wonder if I've missed the point with hooks (again, to Patrick's point, it seems a bit more complex sometimes). Why isn't there a hook that **doesn't** run the first time btw? Again, with the old lifecycles it was much clearer how to prevent this from happening (using `componentDidUpdate`).\r\n\r\nOn a last note, I just want to say that I'm very fond of the idea and wholeheartedly support the functional approach and I really like the concept of hooks being \"state observers\", that react only when the specified attributes change - which basically makes the whole code more declarative.\r\nI've just started using them so I'll probably figure things out along the way but I thought I could give you something since you didn't get any answer :)",
        "remove_template_description": "I'm opening this up at Dan's request from a twitter discussion:  https://twitter.com/lichstam/status/1106995545938247682    From Twitter:    I can fill in on this. The first example I would like to point to is a debouncing hook I've created that looks something like this:      ```javascript  useEffect(() => {    const debounced = setTimeout(() => setDebounced(steps), 500);    return () => clearTimeout(debounced);  }, [steps])  ```    and then I have another one, that actually performs the request:    ```javascript  useEffect(request, [debounced])  ```    And it all works fine, apart from when the component is mounted and unmounted.  In the class model I was able to make sure it never runs the first time and on unmounting I could clear the timeout and, if the state value differs from prop (yes I know, you shouldn't mirror your props but I have to debounce somewhere), I could just perform a last request before I unmount.   Furthermore, `componentDidUpdate` really made it easy preventing this from running the first time. I'm not quite sure how to approach this with hooks.  Perhaps I'm doing it all wrong but to Patrick's point, the class way was more straight forward.    Another example: I code in RN and use the Animated API a lot. I have cases that translates into something like this:    ```javascript  useEffect(() => {    if (inAddStage) moveAndShowStep(); // Animate with Animated API  }, [inAddStage]);  ```    This works well but it does perform an unnecessary initial run which makes me wonder if I've missed the point with hooks (again, to Patrick's point, it seems a bit more complex sometimes). Why isn't there a hook that **doesn't** run the first time btw? Again, with the old lifecycles it was much clearer how to prevent this from happening (using `componentDidUpdate`).    On a last note, I just want to say that I'm very fond of the idea and wholeheartedly support the functional approach and I really like the concept of hooks being \"state observers\", that react only when the specified attributes change - which basically makes the whole code more declarative.  I've just started using them so I'll probably figure things out along the way but I thought I could give you something since you didn't get any answer :)",
        "human_words": "I'm opening this up at Dan's request from a twitter discussion:  https://twitter.com/lichstam/status/1106995545938247682    From Twitter:    I can fill in on this. The first example I would like to point to is a debouncing hook I've created that looks something like this:          and then I have another one, that actually performs the request:        And it all works fine, apart from when the component is mounted and unmounted.  In the class model I was able to make sure it never runs the first time and on unmounting I could clear the timeout and, if the state value differs from prop (yes I know, you shouldn't mirror your props but I have to debounce somewhere), I could just perform a last request before I unmount.   Furthermore, `componentDidUpdate` really made it easy preventing this from running the first time. I'm not quite sure how to approach this with hooks.  Perhaps I'm doing it all wrong but to Patrick's point, the class way was more straight forward.    Another example: I code in RN and use the Animated API a lot. I have cases that translates into something like this:        This works well but it does perform an unnecessary initial run which makes me wonder if I've missed the point with hooks (again, to Patrick's point, it seems a bit more complex sometimes). Why isn't there a hook that **doesn't** run the first time btw? Again, with the old lifecycles it was much clearer how to prevent this from happening (using `componentDidUpdate`).    On a last note, I just want to say that I'm very fond of the idea and wholeheartedly support the functional approach and I really like the concept of hooks being \"state observers\", that react only when the specified attributes change - which basically makes the whole code more declarative.  I've just started using them so I'll probably figure things out along the way but I thought I could give you something since you didn't get any answer :)",
        "human_words_regrex": "I'm opening this up at Dan's request from a twitter discussion:  From Twitter: I can fill in on this. The first example I would like to point to is a debouncing hook I've created that looks something like this: and then I have another one, that actually performs the request: And it all works fine, apart from when the component is mounted and unmounted. In the class model I was able to make sure it never runs the first time and on unmounting I could clear the timeout and, if the state value differs from prop (yes I know, you shouldn't mirror your props but I have to debounce somewhere), I could just perform a last request before I unmount. Furthermore, `componentDidUpdate` really made it easy preventing this from running the first time. I'm not quite sure how to approach this with hooks. Perhaps I'm doing it all wrong but to Patrick's point, the class way was more straight forward. Another example: I code in RN and use the Animated API a lot. I have cases that translates into something like this: This works well but it does perform an unnecessary initial run which makes me wonder if I've missed the point with hooks (again, to Patrick's point, it seems a bit more complex sometimes). Why isn't there a hook that **doesn't** run the first time btw? Again, with the old lifecycles it was much clearer how to prevent this from happening (using `componentDidUpdate`). On a last note, I just want to say that I'm very fond of the idea and wholeheartedly support the functional approach and I really like the concept of hooks being \"state observers\", that react only when the specified attributes change - which basically makes the whole code more declarative. I've just started using them so I'll probably figure things out along the way but I thought I could give you something since you didn't get any answer :)",
        "human_words_stopwords_removal_lemmatization": "'m opening dan 's request twitter discussion : twitter : fill . first example would like point debouncing hook 've created look something like : another one , actually performs request : work fine , apart component mounted unmounted . class model able make sure never run first time unmounting could clear timeout , state value differs prop ( yes know , n't mirror prop debounce somewhere ) , could perform last request unmount . furthermore , ` componentdidupdate ` really made easy preventing running first time . 'm quite sure approach hook . perhaps 'm wrong patrick 's point , class way straight forward . another example : code rn use animated api lot . case translates something like : work well perform unnecessary initial run make wonder 've missed point hook ( , patrick 's point , seems bit complex sometimes ) . n't hook * * n't * * run first time btw ? , old lifecycles much clearer prevent happening ( using ` componentdidupdate ` ) . last note , want say 'm fond idea wholeheartedly support functional approach really like concept hook `` state observer '' , react specified attribute change - basically make whole code declarative . 've started using 'll probably figure thing along way thought could give something since n't get answer : )",
        "title_stopwords_removal_lemmatization": "hook - unmount didupdate"
    },
    {
        "issue_id": 419606173,
        "title": "eslint-plugin-react-hooks useEffect autofix of adding function names causes a lot of infinite loops",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-11T17:56:48Z",
        "status": "closed",
        "description": "I've read \"My function value is constant\" from https://github.com/facebook/react/issues/14920#issuecomment-471070149.\r\n\r\n> There is a problem on the opposite spectrum of this, which is where you get infinite loops (a function value always changes). We catch that in the lint rule now when possible (in the same component) and suggest a fix. But it's tricky if you pass something several levels down.\r\n\r\nIf you autofix the `useEffect`, would it also be possible to autofix any functions added by wrapping them in a `useCallback` at the same time?\r\n\r\nThis would greatly improve the user experience.\r\n\r\n\r\n",
        "remove_template_description": "I've read \"My function value is constant\" from https://github.com/facebook/react/issues/14920#issuecomment-471070149.    > There is a problem on the opposite spectrum of this, which is where you get infinite loops (a function value always changes). We catch that in the lint rule now when possible (in the same component) and suggest a fix. But it's tricky if you pass something several levels down.    If you autofix the `useEffect`, would it also be possible to autofix any functions added by wrapping them in a `useCallback` at the same time?    This would greatly improve the user experience.",
        "human_words": "I've read \"My function value is constant\" from https://github.com/facebook/react/issues/14920#issuecomment-471070149.    > There is a problem on the opposite spectrum of this, which is where you get infinite loops (a function value always changes). We catch that in the lint rule now when possible (in the same component) and suggest a fix. But it's tricky if you pass something several levels down.    If you autofix the `useEffect`, would it also be possible to autofix any functions added by wrapping them in a `useCallback` at the same time?    This would greatly improve the user experience.",
        "human_words_regrex": "I've read \"My function value is constant\" from  > There is a problem on the opposite spectrum of this, which is where you get infinite loops (a function value always changes). We catch that in the lint rule now when possible (in the same component) and suggest a fix. But it's tricky if you pass something several levels down. If you autofix the `useEffect`, would it also be possible to autofix any functions added by wrapping them in a `useCallback` at the same time? This would greatly improve the user experience.",
        "human_words_stopwords_removal_lemmatization": "'ve read `` function value constant '' > problem opposite spectrum , get infinite loop ( function value always change ) . catch lint rule possible ( component ) suggest fix . 's tricky pas something several level . autofix ` useeffect ` , would also possible autofix function added wrapping ` usecallback ` time ? would greatly improve user experience .",
        "title_stopwords_removal_lemmatization": "eslint-plugin-react-hooks useeffect autofix adding function name cause lot infinite loop"
    },
    {
        "issue_id": 419249211,
        "title": "Consider exporting `batchedUpdates` from React",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-10T23:51:41Z",
        "status": "closed",
        "description": "ReactDOM and React Native both currently export an `unstable_batchedUpdates` API.  Because batching is a renderer/reconciliation-level concern, this API is exported by the renderer packages, not the core `react` package.\r\n\r\nThe React team has recently encouraged the Redux team to make use of `unstable_batchedUpdates` in React-Redux.  However, this becomes complicated due to how that API is being exported.\r\n\r\nIt's possible to deal with this at the bundler level.  Some experimentation shows that creating an alternate file with a `.native.js` extension will cause that to be picked up by the RN bundler, as in this example:\r\n\r\n```js\r\n// batch.js\r\nimport {unstable_batchedUpdates} from \"./react-dom\";\r\n\r\n// ./react-dom.js\r\nexport {unstable_batchedUpdates} from \"react-dom\"\r\n\r\n// ./react-dom.native.js\r\nexport {unstable_batchedUpdates} from \"react-native\"\r\n```\r\n\r\nHowever, this does not handle the case where an alternative React renderer is being used.  The [list of other React renderers is continuing to grow](https://github.com/chentsulin/awesome-react-renderer), which means that a React library that needs batching would have to deal with that situation in some way.  This becomes extremely complicated when you start considering variations on bundlers, module formats, and build environments.\r\n\r\nIt would be extremely beneficial if the React core itself exported a `batchedUpdates` API.  That could default to being a noop wrapper like `(callback) => callback()` if no suitable implementation was available.\r\n\r\nI know that `unstable_batchedUpdates()` is, uh... \"unstable\".  However, the React team has stated that \"it's the most stable of the unstable APIs\", and \"half of Facebook depends on this\".\r\n\r\nI think it would really help the ecosystem if some form of this API was solidified and exported from the core React package itself.",
        "remove_template_description": "ReactDOM and React Native both currently export an `unstable_batchedUpdates` API.  Because batching is a renderer/reconciliation-level concern, this API is exported by the renderer packages, not the core `react` package.    The React team has recently encouraged the Redux team to make use of `unstable_batchedUpdates` in React-Redux.  However, this becomes complicated due to how that API is being exported.    It's possible to deal with this at the bundler level.  Some experimentation shows that creating an alternate file with a `.native.js` extension will cause that to be picked up by the RN bundler, as in this example:    ```js  // batch.js  import {unstable_batchedUpdates} from \"./react-dom\";    // ./react-dom.js  export {unstable_batchedUpdates} from \"react-dom\"    // ./react-dom.native.js  export {unstable_batchedUpdates} from \"react-native\"  ```    However, this does not handle the case where an alternative React renderer is being used.  The [list of other React renderers is continuing to grow](https://github.com/chentsulin/awesome-react-renderer), which means that a React library that needs batching would have to deal with that situation in some way.  This becomes extremely complicated when you start considering variations on bundlers, module formats, and build environments.    It would be extremely beneficial if the React core itself exported a `batchedUpdates` API.  That could default to being a noop wrapper like `(callback) => callback()` if no suitable implementation was available.    I know that `unstable_batchedUpdates()` is, uh... \"unstable\".  However, the React team has stated that \"it's the most stable of the unstable APIs\", and \"half of Facebook depends on this\".    I think it would really help the ecosystem if some form of this API was solidified and exported from the core React package itself.",
        "human_words": "ReactDOM and React Native both currently export an `unstable_batchedUpdates` API.  Because batching is a renderer/reconciliation-level concern, this API is exported by the renderer packages, not the core `react` package.    The React team has recently encouraged the Redux team to make use of `unstable_batchedUpdates` in React-Redux.  However, this becomes complicated due to how that API is being exported.    It's possible to deal with this at the bundler level.  Some experimentation shows that creating an alternate file with a `.native.js` extension will cause that to be picked up by the RN bundler, as in this example:        However, this does not handle the case where an alternative React renderer is being used.  The [list of other React renderers is continuing to grow](https://github.com/chentsulin/awesome-react-renderer), which means that a React library that needs batching would have to deal with that situation in some way.  This becomes extremely complicated when you start considering variations on bundlers, module formats, and build environments.    It would be extremely beneficial if the React core itself exported a `batchedUpdates` API.  That could default to being a noop wrapper like `(callback) => callback()` if no suitable implementation was available.    I know that `unstable_batchedUpdates()` is, uh... \"unstable\".  However, the React team has stated that \"it's the most stable of the unstable APIs\", and \"half of Facebook depends on this\".    I think it would really help the ecosystem if some form of this API was solidified and exported from the core React package itself.",
        "human_words_regrex": "ReactDOM and React Native both currently export an `unstable_batchedUpdates` API. Because batching is a renderer/reconciliation-level concern, this API is exported by the renderer packages, not the core `react` package. The React team has recently encouraged the Redux team to make use of `unstable_batchedUpdates` in React-Redux. However, this becomes complicated due to how that API is being exported. It's possible to deal with this at the bundler level. Some experimentation shows that creating an alternate file with a `.native.js` extension will cause that to be picked up by the RN bundler, as in this example: However, this does not handle the case where an alternative React renderer is being used. The , which means that a React library that needs batching would have to deal with that situation in some way. This becomes extremely complicated when you start considering variations on bundlers, module formats, and build environments. It would be extremely beneficial if the React core itself exported a `batchedUpdates` API. That could default to being a noop wrapper like `(callback) => callback()` if no suitable implementation was available. I know that `unstable_batchedUpdates()` is, uh... \"unstable\". However, the React team has stated that \"it's the most stable of the unstable APIs\", and \"half of Facebook depends on this\". I think it would really help the ecosystem if some form of this API was solidified and exported from the core React package itself.",
        "human_words_stopwords_removal_lemmatization": "reactdom react native currently export ` unstable_batchedupdates ` api . batching renderer/reconciliation-level concern , api exported renderer package , core ` react ` package . react team recently encouraged redux team make use ` unstable_batchedupdates ` react-redux . however , becomes complicated due api exported . 's possible deal bundler level . experimentation show creating alternate file ` .native.js ` extension cause picked rn bundler , example : however , handle case alternative react renderer used . , mean react library need batching would deal situation way . becomes extremely complicated start considering variation bundlers , module format , build environment . would extremely beneficial react core exported ` batchedupdates ` api . could default noop wrapper like ` ( callback ) = > callback ( ) ` suitable implementation available . know ` unstable_batchedupdates ( ) ` , uh ... `` unstable '' . however , react team stated `` 's stable unstable apis '' , `` half facebook depends '' . think would really help ecosystem form api solidified exported core react package .",
        "title_stopwords_removal_lemmatization": "consider exporting ` batchedupdates ` react"
    },
    {
        "issue_id": 418804183,
        "title": "Double-invoking the render function in StrictMode is somewhat too deterministic",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-08T14:15:26Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nfeature in the development mode\r\n\r\n**What is the current behavior?**\r\n\r\nInside `<StrictMode>`, the render function is invoked twice, but always the second one is committed.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nhttps://codesandbox.io/s/k938koy8mv\r\nI made a tiny change in @gaearon 's code.\r\n```\r\n  // This may not work in concurrent mode.\r\n  savedCallback.current = callback;\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nDevelopers can notice the wrong code (unintentionally mutating refs in the render function).\r\n\r\nOne idea is to occasionally (ex. `Math.random() < 0.25`) commit the first result from double-invoked render function.\r\nThe other could be to introduce `<StrictStrictMode>` which is to triple-invoke the render function and commit the second one.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReact 16.8",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    feature in the development mode    **What is the current behavior?**    Inside `<StrictMode>`, the render function is invoked twice, but always the second one is committed.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/k938koy8mv  I made a tiny change in @gaearon 's code.  ```    // This may not work in concurrent mode.    savedCallback.current = callback;  ```    **What is the expected behavior?**    Developers can notice the wrong code (unintentionally mutating refs in the render function).    One idea is to occasionally (ex. `Math.random() < 0.25`) commit the first result from double-invoked render function.  The other could be to introduce `<StrictStrictMode>` which is to triple-invoke the render function and commit the second one.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.8",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    feature in the development mode    **What is the current behavior?**    Inside `<StrictMode>`, the render function is invoked twice, but always the second one is committed.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/k938koy8mv  I made a tiny change in @gaearon 's code.      **What is the expected behavior?**    Developers can notice the wrong code (unintentionally mutating refs in the render function).    One idea is to occasionally (ex. `Math.random() < 0.25`) commit the first result from double-invoked render function.  The other could be to introduce `<StrictStrictMode>` which is to triple-invoke the render function and commit the second one.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.8",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** feature in the development mode **What is the current behavior?** Inside ``, the render function is invoked twice, but always the second one is committed. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:**  I made a tiny change in @gaearon 's code. **What is the expected behavior?** Developers can notice the wrong code (unintentionally mutating refs in the render function). One idea is to occasionally (ex. `Math.random() ` which is to triple-invoke the render function and commit the second one. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.8",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature development mode * * current behavior ? * * inside `` , render function invoked twice , always second one committed . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * made tiny change @ gaearon 's code . * * expected behavior ? * * developer notice wrong code ( unintentionally mutating ref render function ) . one idea occasionally ( ex . ` math.random ( ) ` triple-invoke render function commit second one . * * version react , browser / o affected issue ? work previous version react ? * * react 16.8",
        "title_stopwords_removal_lemmatization": "double-invoking render function strictmode somewhat deterministic"
    },
    {
        "issue_id": 418738932,
        "title": "eslint-plugin-react-hooks on vscode with formatOnSave enabled strange insertion on useEffect skipping array",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-08T10:59:39Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nOn VSCode with formatOnSave enabled, the eslint-plugin-react-hooks appends inside useEffect's skipping array the function I'm invoking in useEffect.\r\n\r\nInitial\r\n1. useEffect(() => { fetchData() }, [aProp])\r\n2. const fetchData = async () => { ... }\r\n\r\nAfter saving\r\n\r\nuseEffect(() => { fetchData() }, [aProp, fetchData])\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n**What is the expected behavior?**\r\n\r\nIt shouldn't append the function inside the skipping array of useEffect.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    On VSCode with formatOnSave enabled, the eslint-plugin-react-hooks appends inside useEffect's skipping array the function I'm invoking in useEffect.    Initial  1. useEffect(() => { fetchData() }, [aProp])  2. const fetchData = async () => { ... }    After saving    useEffect(() => { fetchData() }, [aProp, fetchData])    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    It shouldn't append the function inside the skipping array of useEffect.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    On VSCode with formatOnSave enabled, the eslint-plugin-react-hooks appends inside useEffect's skipping array the function I'm invoking in useEffect.    Initial  1. useEffect(() => { fetchData() }, [aProp])  2. const fetchData = async () => { ... }    After saving    useEffect(() => { fetchData() }, [aProp, fetchData])    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    It shouldn't append the function inside the skipping array of useEffect.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** On VSCode with formatOnSave enabled, the eslint-plugin-react-hooks appends inside useEffect's skipping array the function I'm invoking in useEffect. Initial 1. useEffect(() => { fetchData() }, [aProp]) 2. const fetchData = async () => { ... } After saving useEffect(() => { fetchData() }, [aProp, fetchData]) **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** It shouldn't append the function inside the skipping array of useEffect. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * vscode formatonsave enabled , eslint-plugin-react-hooks appends inside useeffect 's skipping array function 'm invoking useeffect . initial 1. useeffect ( ( ) = > { fetchdata ( ) } , [ aprop ] ) 2. const fetchdata = async ( ) = > { ... } saving useeffect ( ( ) = > { fetchdata ( ) } , [ aprop , fetchdata ] ) * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * n't append function inside skipping array useeffect . * * version react , browser / o affected issue ? work previous version react ? * *",
        "title_stopwords_removal_lemmatization": "eslint-plugin-react-hooks vscode formatonsave enabled strange insertion useeffect skipping array"
    },
    {
        "issue_id": 417108407,
        "title": "DOM tree normalization causes React to enter an irrecoverable error state",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-05T04:13:53Z",
        "status": "closed",
        "description": "Reproduction:\r\n1) Open any React site that has a variable adjacent to other text\r\n2) Type document.body.normalize() into javascript console\r\n3) React enters an irrecoverable error state",
        "remove_template_description": "Reproduction:  1) Open any React site that has a variable adjacent to other text  2) Type document.body.normalize() into javascript console  3) React enters an irrecoverable error state",
        "human_words": "Reproduction:  1) Open any React site that has a variable adjacent to other text  2) Type document.body.normalize() into javascript console  3) React enters an irrecoverable error state",
        "human_words_regrex": "Reproduction: 1) Open any React site that has a variable adjacent to other text 2) Type document.body.normalize() into javascript console 3) React enters an irrecoverable error state",
        "human_words_stopwords_removal_lemmatization": "reproduction : 1 ) open react site variable adjacent text 2 ) type document.body.normalize ( ) javascript console 3 ) react enters irrecoverable error state",
        "title_stopwords_removal_lemmatization": "dom tree normalization cause react enter irrecoverable error state"
    },
    {
        "issue_id": 416406852,
        "title": "Keys for hooks",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-02T15:17:13Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nHooks must always be called in the same order.\r\n\r\n**What is the desired behavior?**\r\n\r\nIt would be useful to be able to use hooks in loops and conditions, as this would allow hooks to be lifted out of child components that are rendered by loops and conditions.\r\n\r\nFor example, consider this hook that stores the state for a contact form:\r\n\r\n```js\r\nfunction useContactModel({ defaultValue }) {\r\n  let [name, setName] = useState(defaultValue.name || '')\r\n  let [email, setEmail] = useState(defaultValue.email || '')\r\n\r\n  return {\r\n    error: name === '' ? 'Please enter a name' : undefined,\r\n    name: {\r\n      value: name,\r\n      onChange: e => setName(e.target.value),\r\n    },\r\n    email: {\r\n      value: email,\r\n      onChange: e => setEmail(e.target.value),\r\n    },\r\n  }\r\n}\r\n```\r\n\r\nThis hook works fine when it is used inside a form component -- let's call it `<ContactForm>`. But say that your requirements change and you now need to be able to embed an arbitrary number of contacts in the form, and thus want to lift the state up into a `<ContactList>` component so that you can access all the contact state at once (see [demo](https://frontarm.com/demoboard/?id=e1a331f5-3468-488c-ab53-9eb455730af5)) -- there's no way to reuse the `useContactModel()` hook within `<ContactList>`, because it would need to be called within a loop.\r\n\r\n```jsx\r\nfunction ContactList() {\r\n  let contactIds = ['a', 'b', 'c']\r\n  let contactModels = contactIds.map(useContactModel)\r\n\r\n  return contactIds.map((id, i) =>\r\n        <Contact\r\n          key={id}\r\n          model={contactModels[i]}\r\n        />\r\n  )\r\n}\r\n```\r\n\r\nThe contact form example feels a little contrived, but this scenario of wanting to store some \"model\" an arbitrary number of times comes up relatively often when building forms. \r\n\r\n**Proposed solution**\r\n\r\nI've taken a cursory look at the source but I really don't understand it enough to know if this could even work, but with that said...\r\n\r\nWould it be possible to somehow assign keys to hooks, just as you can with components, and use that extra information to reconcile hooks called in conditionals/loops? For example, a hypothetical `withKey` function could accept a key and a callback, and allow for hooks to be called within the callback as if they were being called in a child component -- but returning the result of the callback instead of rendering elements.\r\n\r\n```js\r\nlet contactIds = ['a', 'b', 'c']\r\nlet contactModels = contactIds.map(id => \r\n  withKey(id, () => useContactModel())\r\n)\r\n```\r\n\r\nNot sure if this is possible or even particularly desirable given the potential performance problems of the enormous hooks it would enable. It'd certainly make it easier to lift state up the tree, though.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    Hooks must always be called in the same order.    **What is the desired behavior?**    It would be useful to be able to use hooks in loops and conditions, as this would allow hooks to be lifted out of child components that are rendered by loops and conditions.    For example, consider this hook that stores the state for a contact form:    ```js  function useContactModel({ defaultValue }) {    let [name, setName] = useState(defaultValue.name || '')    let [email, setEmail] = useState(defaultValue.email || '')      return {      error: name === '' ? 'Please enter a name' : undefined,      name: {        value: name,        onChange: e => setName(e.target.value),      },      email: {        value: email,        onChange: e => setEmail(e.target.value),      },    }  }  ```    This hook works fine when it is used inside a form component -- let's call it `<ContactForm>`. But say that your requirements change and you now need to be able to embed an arbitrary number of contacts in the form, and thus want to lift the state up into a `<ContactList>` component so that you can access all the contact state at once (see [demo](https://frontarm.com/demoboard/?id=e1a331f5-3468-488c-ab53-9eb455730af5)) -- there's no way to reuse the `useContactModel()` hook within `<ContactList>`, because it would need to be called within a loop.    ```jsx  function ContactList() {    let contactIds = ['a', 'b', 'c']    let contactModels = contactIds.map(useContactModel)      return contactIds.map((id, i) =>          <Contact            key={id}            model={contactModels[i]}          />    )  }  ```    The contact form example feels a little contrived, but this scenario of wanting to store some \"model\" an arbitrary number of times comes up relatively often when building forms.     **Proposed solution**    I've taken a cursory look at the source but I really don't understand it enough to know if this could even work, but with that said...    Would it be possible to somehow assign keys to hooks, just as you can with components, and use that extra information to reconcile hooks called in conditionals/loops? For example, a hypothetical `withKey` function could accept a key and a callback, and allow for hooks to be called within the callback as if they were being called in a child component -- but returning the result of the callback instead of rendering elements.    ```js  let contactIds = ['a', 'b', 'c']  let contactModels = contactIds.map(id =>     withKey(id, () => useContactModel())  )  ```    Not sure if this is possible or even particularly desirable given the potential performance problems of the enormous hooks it would enable. It'd certainly make it easier to lift state up the tree, though.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    Hooks must always be called in the same order.    **What is the desired behavior?**    It would be useful to be able to use hooks in loops and conditions, as this would allow hooks to be lifted out of child components that are rendered by loops and conditions.    For example, consider this hook that stores the state for a contact form:        This hook works fine when it is used inside a form component -- let's call it `<ContactForm>`. But say that your requirements change and you now need to be able to embed an arbitrary number of contacts in the form, and thus want to lift the state up into a `<ContactList>` component so that you can access all the contact state at once (see [demo](https://frontarm.com/demoboard/?id=e1a331f5-3468-488c-ab53-9eb455730af5)) -- there's no way to reuse the `useContactModel()` hook within `<ContactList>`, because it would need to be called within a loop.        The contact form example feels a little contrived, but this scenario of wanting to store some \"model\" an arbitrary number of times comes up relatively often when building forms.     **Proposed solution**    I've taken a cursory look at the source but I really don't understand it enough to know if this could even work, but with that said...    Would it be possible to somehow assign keys to hooks, just as you can with components, and use that extra information to reconcile hooks called in conditionals/loops? For example, a hypothetical `withKey` function could accept a key and a callback, and allow for hooks to be called within the callback as if they were being called in a child component -- but returning the result of the callback instead of rendering elements.        Not sure if this is possible or even particularly desirable given the potential performance problems of the enormous hooks it would enable. It'd certainly make it easier to lift state up the tree, though.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** Hooks must always be called in the same order. **What is the desired behavior?** It would be useful to be able to use hooks in loops and conditions, as this would allow hooks to be lifted out of child components that are rendered by loops and conditions. For example, consider this hook that stores the state for a contact form: This hook works fine when it is used inside a form component -- let's call it ``. But say that your requirements change and you now need to be able to embed an arbitrary number of contacts in the form, and thus want to lift the state up into a `` component so that you can access all the contact state at once (see ) -- there's no way to reuse the `useContactModel()` hook within ``, because it would need to be called within a loop. The contact form example feels a little contrived, but this scenario of wanting to store some \"model\" an arbitrary number of times comes up relatively often when building forms. **Proposed solution** I've taken a cursory look at the source but I really don't understand it enough to know if this could even work, but with that said... Would it be possible to somehow assign keys to hooks, just as you can with components, and use that extra information to reconcile hooks called in conditionals/loops? For example, a hypothetical `withKey` function could accept a key and a callback, and allow for hooks to be called within the callback as if they were being called in a child component -- but returning the result of the callback instead of rendering elements. Not sure if this is possible or even particularly desirable given the potential performance problems of the enormous hooks it would enable. It'd certainly make it easier to lift state up the tree, though.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * hook must always called order . * * desired behavior ? * * would useful able use hook loop condition , would allow hook lifted child component rendered loop condition . example , consider hook store state contact form : hook work fine used inside form component -- let 's call `` . say requirement change need able embed arbitrary number contact form , thus want lift state `` component access contact state ( see ) -- 's way reuse ` usecontactmodel ( ) ` hook within `` , would need called within loop . contact form example feel little contrived , scenario wanting store `` model '' arbitrary number time come relatively often building form . * * proposed solution * * 've taken cursory look source really n't understand enough know could even work , said ... would possible somehow assign key hook , component , use extra information reconcile hook called conditionals/loops ? example , hypothetical ` withkey ` function could accept key callback , allow hook called within callback called child component -- returning result callback instead rendering element . sure possible even particularly desirable given potential performance problem enormous hook would enable . 'd certainly make easier lift state tree , though .",
        "title_stopwords_removal_lemmatization": "key hook"
    },
    {
        "issue_id": 416269626,
        "title": "Unexpected \"Hooks can only be called inside the body of a function component.\"",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-03-01T20:36:37Z",
        "status": "closed",
        "description": "I already know why this problem occurs.\r\n\r\nBut I'm needing for one solution to my case.\r\n\r\nI have three packages: a `Lib A`, and the `Project A` and `Project B`.\r\n\r\nThe projects use `Lib A`\r\n\r\nIf I generate a `Lib A` bundle and run the `Project A` or the `Project B` with this bundle, I receive this message: `Unexpected \"Hooks can only be called inside the body of a function component.\"`\r\n\r\nActually I can solve this with this command:\r\n\r\n`npm link ../project-a/node_modules/react` (In `Lib A` package)\r\n\r\nNow, when I run the `Project A`, the error message isn't appear.\r\n\r\nBut the problem isn't solved in the `Project B`.\r\n\r\nTo solve this in the `Project B` i need execute the same steps, and... It is a sucks :'(\r\n\r\nIs it possible solve this?\r\n\r\nI know that the error is because the two instances of React, but... How can I solve the problem?",
        "remove_template_description": "I already know why this problem occurs.    But I'm needing for one solution to my case.    I have three packages: a `Lib A`, and the `Project A` and `Project B`.    The projects use `Lib A`    If I generate a `Lib A` bundle and run the `Project A` or the `Project B` with this bundle, I receive this message: `Unexpected \"Hooks can only be called inside the body of a function component.\"`    Actually I can solve this with this command:    `npm link ../project-a/node_modules/react` (In `Lib A` package)    Now, when I run the `Project A`, the error message isn't appear.    But the problem isn't solved in the `Project B`.    To solve this in the `Project B` i need execute the same steps, and... It is a sucks :'(    Is it possible solve this?    I know that the error is because the two instances of React, but... How can I solve the problem?",
        "human_words": "I already know why this problem occurs.    But I'm needing for one solution to my case.    I have three packages: a `Lib A`, and the `Project A` and `Project B`.    The projects use `Lib A`    If I generate a `Lib A` bundle and run the `Project A` or the `Project B` with this bundle, I receive this message: `Unexpected \"Hooks can only be called inside the body of a function component.\"`    Actually I can solve this with this command:    `npm link ../project-a/node_modules/react` (In `Lib A` package)    Now, when I run the `Project A`, the error message isn't appear.    But the problem isn't solved in the `Project B`.    To solve this in the `Project B` i need execute the same steps, and... It is a sucks :'(    Is it possible solve this?    I know that the error is because the two instances of React, but... How can I solve the problem?",
        "human_words_regrex": "I already know why this problem occurs. But I'm needing for one solution to my case. I have three packages: a `Lib A`, and the `Project A` and `Project B`. The projects use `Lib A` If I generate a `Lib A` bundle and run the `Project A` or the `Project B` with this bundle, I receive this message: `Unexpected \"Hooks can only be called inside the body of a function component.\"` Actually I can solve this with this command: `npm link ../project-a/node_modules/react` (In `Lib A` package) Now, when I run the `Project A`, the error message isn't appear. But the problem isn't solved in the `Project B`. To solve this in the `Project B` i need execute the same steps, and... It is a sucks :'( Is it possible solve this? I know that the error is because the two instances of React, but... How can I solve the problem?",
        "human_words_stopwords_removal_lemmatization": "already know problem occurs . 'm needing one solution case . three package : ` lib ` , ` project ` ` project b ` . project use ` lib ` generate ` lib ` bundle run ` project ` ` project b ` bundle , receive message : ` unexpected `` hook called inside body function component . `` ` actually solve command : ` npm link .. /project-a/node_modules/react ` ( ` lib ` package ) , run ` project ` , error message n't appear . problem n't solved ` project b ` . solve ` project b ` need execute step , ... suck : ' ( possible solve ? know error two instance react , ... solve problem ?",
        "title_stopwords_removal_lemmatization": "unexpected `` hook called inside body function component . ''"
    },
    {
        "issue_id": 416238549,
        "title": "useState not bailing out when state does not change",
        "label": [
            "Type: Discussion",
            "Type: Needs Investigation"
        ],
        "date": "2019-03-01T19:05:10Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nAs demonstrated in [this](https://codesandbox.io/s/1r539z96r3) codesandbox, trying to implement a pattern similar to the one discussed in https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops results in an infinite loop, even if the value of the state does not change. This seems like a bug, because, as documented [here](https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update), `If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects.`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n**What is the expected behavior?**\r\n\r\nSince the state does not change, bail out on the re-render.\r\nThis can be worked around by adding a check before `setState` to check if the state has changed before calling the function.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    As demonstrated in [this](https://codesandbox.io/s/1r539z96r3) codesandbox, trying to implement a pattern similar to the one discussed in https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops results in an infinite loop, even if the value of the state does not change. This seems like a bug, because, as documented [here](https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update), `If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects.`    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    Since the state does not change, bail out on the re-render.  This can be worked around by adding a check before `setState` to check if the state has changed before calling the function.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    As demonstrated in [this](https://codesandbox.io/s/1r539z96r3) codesandbox, trying to implement a pattern similar to the one discussed in https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops results in an infinite loop, even if the value of the state does not change. This seems like a bug, because, as documented [here](https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update), `If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects.`    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    Since the state does not change, bail out on the re-render.  This can be worked around by adding a check before `setState` to check if the state has changed before calling the function.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** As demonstrated in  codesandbox, trying to implement a pattern similar to the one discussed in  results in an infinite loop, even if the value of the state does not change. This seems like a bug, because, as documented , `If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects.` **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** Since the state does not change, bail out on the re-render. This can be worked around by adding a check before `setState` to check if the state has changed before calling the function. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * demonstrated codesandbox , trying implement pattern similar one discussed result infinite loop , even value state change . seems like bug , , documented , ` update state hook value current state , react bail without rendering child firing effects. ` * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * since state change , bail re-render . worked around adding check ` setstate ` check state changed calling function . * * version react , browser / o affected issue ? work previous version react ? * *",
        "title_stopwords_removal_lemmatization": "usestate bailing state change"
    },
    {
        "issue_id": 416027015,
        "title": "Subscription to event listener in useEffect can miss an update",
        "label": [
            "Type: Discussion",
            "Component: Hooks",
            "Component: Concurrent Features"
        ],
        "date": "2019-03-01T10:01:51Z",
        "status": "closed",
        "description": "**Steps to reproduce:**\r\nRun the following app that uses an event-emitting counter and maintains a subscription to render updates:\r\n```js\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nfunction createCounter() {\r\n  let value = 0;\r\n  const listeners = new Set();\r\n\r\n  return {\r\n    get() { return value; },\r\n    on(listener) { listeners.add(listener); },\r\n    off(listener) { listeners.delete(listener); },\r\n    increment() { value++; listeners.forEach(listener => listener()); }\r\n  };\r\n}\r\n\r\nconst Counter = createCounter();\r\n\r\nfunction CounterWithHook() {\r\n  const [counter, setCounter] = React.useState(Counter.get);\r\n\r\n  React.useEffect(() => {\r\n    const onChange = () => setCounter(Counter.get());\r\n    Counter.on(onChange);\r\n    return () => Counter.off(onChange);\r\n  }, []);\r\n\r\n  return <div>counter: {counter}</div>;\r\n}\r\n\r\nReactDOM.render(\r\n  <>\r\n    <CounterWithHook />\r\n    <button onClick={Counter.increment}>increment</button>\r\n  </>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\nrequestAnimationFrame(Counter.increment);\r\n```\r\n\r\nThe `requestAnimationFrame` at the end will increment the counter in a slightly insidious way.\r\n\r\n**Expected result:**\r\nAfter loading the app, I see `counter: 1` and clicking the `increment` button updates the UI to `counter: 2`.\r\n\r\n**Actual result:**\r\nAfter loading the app, I see `counter: 0` and clicking the button updates the UI to `counter: 2`.\r\n\r\nThe timing of the `Counter.increment` is such that it happens after the initial render, but before the listener is attached.\r\n\r\nImplementing the same thing with lifecycle methods behaves differently: `componentDidMount` runs soon enough to catch the update.\r\n\r\nIs that expected and a part of the `useEffect` contract? Is there a better way to maintain subscriptions? Note that the missed update came from an independent source, completely outside React.",
        "remove_template_description": "**Steps to reproduce:**  Run the following app that uses an event-emitting counter and maintains a subscription to render updates:  ```js  import React from \"react\";  import ReactDOM from \"react-dom\";    function createCounter() {    let value = 0;    const listeners = new Set();      return {      get() { return value; },      on(listener) { listeners.add(listener); },      off(listener) { listeners.delete(listener); },      increment() { value++; listeners.forEach(listener => listener()); }    };  }    const Counter = createCounter();    function CounterWithHook() {    const [counter, setCounter] = React.useState(Counter.get);      React.useEffect(() => {      const onChange = () => setCounter(Counter.get());      Counter.on(onChange);      return () => Counter.off(onChange);    }, []);      return <div>counter: {counter}</div>;  }    ReactDOM.render(    <>      <CounterWithHook />      <button onClick={Counter.increment}>increment</button>    </>,    document.getElementById(\"root\")  );    requestAnimationFrame(Counter.increment);  ```    The `requestAnimationFrame` at the end will increment the counter in a slightly insidious way.    **Expected result:**  After loading the app, I see `counter: 1` and clicking the `increment` button updates the UI to `counter: 2`.    **Actual result:**  After loading the app, I see `counter: 0` and clicking the button updates the UI to `counter: 2`.    The timing of the `Counter.increment` is such that it happens after the initial render, but before the listener is attached.    Implementing the same thing with lifecycle methods behaves differently: `componentDidMount` runs soon enough to catch the update.    Is that expected and a part of the `useEffect` contract? Is there a better way to maintain subscriptions? Note that the missed update came from an independent source, completely outside React.",
        "human_words": "**Steps to reproduce:**  Run the following app that uses an event-emitting counter and maintains a subscription to render updates:      The `requestAnimationFrame` at the end will increment the counter in a slightly insidious way.    **Expected result:**  After loading the app, I see `counter: 1` and clicking the `increment` button updates the UI to `counter: 2`.    **Actual result:**  After loading the app, I see `counter: 0` and clicking the button updates the UI to `counter: 2`.    The timing of the `Counter.increment` is such that it happens after the initial render, but before the listener is attached.    Implementing the same thing with lifecycle methods behaves differently: `componentDidMount` runs soon enough to catch the update.    Is that expected and a part of the `useEffect` contract? Is there a better way to maintain subscriptions? Note that the missed update came from an independent source, completely outside React.",
        "human_words_regrex": "**Steps to reproduce:** Run the following app that uses an event-emitting counter and maintains a subscription to render updates: The `requestAnimationFrame` at the end will increment the counter in a slightly insidious way. **Expected result:** After loading the app, I see `counter: 1` and clicking the `increment` button updates the UI to `counter: 2`. **Actual result:** After loading the app, I see `counter: 0` and clicking the button updates the UI to `counter: 2`. The timing of the `Counter.increment` is such that it happens after the initial render, but before the listener is attached. Implementing the same thing with lifecycle methods behaves differently: `componentDidMount` runs soon enough to catch the update. Is that expected and a part of the `useEffect` contract? Is there a better way to maintain subscriptions? Note that the missed update came from an independent source, completely outside React.",
        "human_words_stopwords_removal_lemmatization": "* * step reproduce : * * run following app us event-emitting counter maintains subscription render update : ` requestanimationframe ` end increment counter slightly insidious way . * * expected result : * * loading app , see ` counter : 1 ` clicking ` increment ` button update ui ` counter : 2 ` . * * actual result : * * loading app , see ` counter : 0 ` clicking button update ui ` counter : 2 ` . timing ` counter.increment ` happens initial render , listener attached . implementing thing lifecycle method behaves differently : ` componentdidmount ` run soon enough catch update . expected part ` useeffect ` contract ? better way maintain subscription ? note missed update came independent source , completely outside react .",
        "title_stopwords_removal_lemmatization": "subscription event listener useeffect miss update"
    },
    {
        "issue_id": 413077280,
        "title": "[ESLint] Feedback for 'exhaustive-deps' lint rule",
        "label": [
            "Type: Discussion",
            "Component: ESLint Rules"
        ],
        "date": "2019-02-21T19:03:49Z",
        "status": "closed",
        "description": "## Common Answers\r\n\r\n\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\r\n\r\n**We analyzed the comments on this post to provide some guidance: https://github.com/facebook/react/issues/14920#issuecomment-471070149.**\r\n\r\n\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\r\n\r\n----\r\n\r\n## What is this\r\n\r\nThis is a new ESLint rule that verifies the list of dependencies for Hooks like `useEffect` and similar, protecting against the stale closure pitfalls. For most cases it has an autofix. We'll add more documentation over the next weeks.\r\n\r\n![autofix demo](https://user-images.githubusercontent.com/810438/54288712-d3615a00-459f-11e9-82a6-904442995d2f.gif)\r\n\r\n\r\n## Installation\r\n\r\n```\r\nyarn add eslint-plugin-react-hooks@next\r\n# or\r\nnpm install eslint-plugin-react-hooks@next\r\n```\r\n\r\nESLint config:\r\n\r\n```js\r\n{\r\n  \"plugins\": [\"react-hooks\"],\r\n  // ...\r\n  \"rules\": {\r\n    \"react-hooks/rules-of-hooks\": 'error',\r\n    \"react-hooks/exhaustive-deps\": 'warn' // <--- THIS IS THE NEW RULE\r\n  }\r\n}\r\n```\r\n\r\nSimple test case to verify the rule works:\r\n\r\n```js\r\nfunction Foo(props) {\r\n  useEffect(() => {\r\n    console.log(props.name);\r\n  }, []); // <-- should error and offer autofix to [props.name]\r\n}\r\n``` \r\n## The lint rule complains but my code is fine!\r\n\r\n**If this new `react-hooks/exhaustive-deps` lint rule fires for you but you think your code is correct**, please post in this issue.\r\n\r\n----\r\n\r\n\r\n\r\n# BEFORE YOU POST A COMMENT\r\n\r\n**Please** include these three things:\r\n\r\n1. A CodeSandbox demonstrating a **minimal code example** that still expresses your intent (not \"foo bar\" but **actual UI pattern** you're implementing).\r\n2. An explanation of the **steps** a user does and what you expect to see on the screen.\r\n3. An explanation of the **intended API** of your Hook/component.\r\n\r\n![please](https://media1.giphy.com/media/14cNSEhRyTX8Ag/giphy.gif?cid=3640f6095c700c9b774a644a51e2089e)\r\n\r\n## But my case is simple, I don't want to include those things!\r\n\r\nIt might be simple to you \u2014 but it\u2019s not at all simple to us. **If your comment doesn't include either of them (e.g. no CodeSandbox link), we will hide your comment** because it\u2019s very hard to track the discussion otherwise. Thank you for respecting everyone\u2019s time by including them.\r\n\r\nThe end goal of this thread is to find common scenarios and transform them into better docs and warnings. This can only happen when enough details are available. Drive-by comments with incomplete code snippets significantly drive down the quality of the discussion \u2014 to the point that it's not worth it.",
        "remove_template_description": "## Common Answers    \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1    **We analyzed the comments on this post to provide some guidance: https://github.com/facebook/react/issues/14920#issuecomment-471070149.**    \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1    ----    ## What is this    This is a new ESLint rule that verifies the list of dependencies for Hooks like `useEffect` and similar, protecting against the stale closure pitfalls. For most cases it has an autofix. We'll add more documentation over the next weeks.    ![autofix demo](https://user-images.githubusercontent.com/810438/54288712-d3615a00-459f-11e9-82a6-904442995d2f.gif)      ## Installation    ```  yarn add eslint-plugin-react-hooks@next  # or  npm install eslint-plugin-react-hooks@next  ```    ESLint config:    ```js  {    \"plugins\": [\"react-hooks\"],    // ...    \"rules\": {      \"react-hooks/rules-of-hooks\": 'error',      \"react-hooks/exhaustive-deps\": 'warn' // <--- THIS IS THE NEW RULE    }  }  ```    Simple test case to verify the rule works:    ```js  function Foo(props) {    useEffect(() => {      console.log(props.name);    }, []); // <-- should error and offer autofix to [props.name]  }  ```   ## The lint rule complains but my code is fine!    **If this new `react-hooks/exhaustive-deps` lint rule fires for you but you think your code is correct**, please post in this issue.    ----        # BEFORE YOU POST A COMMENT    **Please** include these three things:    1. A CodeSandbox demonstrating a **minimal code example** that still expresses your intent (not \"foo bar\" but **actual UI pattern** you're implementing).  2. An explanation of the **steps** a user does and what you expect to see on the screen.  3. An explanation of the **intended API** of your Hook/component.    ![please](https://media1.giphy.com/media/14cNSEhRyTX8Ag/giphy.gif?cid=3640f6095c700c9b774a644a51e2089e)    ## But my case is simple, I don't want to include those things!    It might be simple to you \u2014 but it\u2019s not at all simple to us. **If your comment doesn't include either of them (e.g. no CodeSandbox link), we will hide your comment** because it\u2019s very hard to track the discussion otherwise. Thank you for respecting everyone\u2019s time by including them.    The end goal of this thread is to find common scenarios and transform them into better docs and warnings. This can only happen when enough details are available. Drive-by comments with incomplete code snippets significantly drive down the quality of the discussion \u2014 to the point that it's not worth it.",
        "human_words": "## Common Answers    \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1    **We analyzed the comments on this post to provide some guidance: https://github.com/facebook/react/issues/14920#issuecomment-471070149.**    \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1    ----    ## What is this    This is a new ESLint rule that verifies the list of dependencies for Hooks like `useEffect` and similar, protecting against the stale closure pitfalls. For most cases it has an autofix. We'll add more documentation over the next weeks.    ![autofix demo](https://user-images.githubusercontent.com/810438/54288712-d3615a00-459f-11e9-82a6-904442995d2f.gif)      ## Installation        ESLint config:        Simple test case to verify the rule works:       ## The lint rule complains but my code is fine!    **If this new `react-hooks/exhaustive-deps` lint rule fires for you but you think your code is correct**, please post in this issue.    ----        # BEFORE YOU POST A COMMENT    **Please** include these three things:    1. A CodeSandbox demonstrating a **minimal code example** that still expresses your intent (not \"foo bar\" but **actual UI pattern** you're implementing).  2. An explanation of the **steps** a user does and what you expect to see on the screen.  3. An explanation of the **intended API** of your Hook/component.    ![please](https://media1.giphy.com/media/14cNSEhRyTX8Ag/giphy.gif?cid=3640f6095c700c9b774a644a51e2089e)    ## But my case is simple, I don't want to include those things!    It might be simple to you \u2014 but it\u2019s not at all simple to us. **If your comment doesn't include either of them (e.g. no CodeSandbox link), we will hide your comment** because it\u2019s very hard to track the discussion otherwise. Thank you for respecting everyone\u2019s time by including them.    The end goal of this thread is to find common scenarios and transform them into better docs and warnings. This can only happen when enough details are available. Drive-by comments with incomplete code snippets significantly drive down the quality of the discussion \u2014 to the point that it's not worth it.",
        "human_words_regrex": "## Common Answers \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1 **We analyzed the comments on this post to provide some guidance:  \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1 ---- ## What is this This is a new ESLint rule that verifies the list of dependencies for Hooks like `useEffect` and similar, protecting against the stale closure pitfalls. For most cases it has an autofix. We'll add more documentation over the next weeks. ! ## Installation ESLint config: Simple test case to verify the rule works: ## The lint rule complains but my code is fine! **If this new `react-hooks/exhaustive-deps` lint rule fires for you but you think your code is correct**, please post in this issue. ---- # BEFORE YOU POST A COMMENT **Please** include these three things: 1. A CodeSandbox demonstrating a **minimal code example** that still expresses your intent (not \"foo bar\" but **actual UI pattern** you're implementing). 2. An explanation of the **steps** a user does and what you expect to see on the screen. 3. An explanation of the **intended API** of your Hook/component. ! ## But my case is simple, I don't want to include those things! It might be simple to you \u2014 but it\u2019s not at all simple to us. **If your comment doesn't include either of them (e.g. no CodeSandbox link), we will hide your comment** because it\u2019s very hard to track the discussion otherwise. Thank you for respecting everyone\u2019s time by including them. The end goal of this thread is to find common scenarios and transform them into better docs and warnings. This can only happen when enough details are available. Drive-by comments with incomplete code snippets significantly drive down the quality of the discussion \u2014 to the point that it's not worth it.",
        "human_words_stopwords_removal_lemmatization": "# # common answer \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1 * * analyzed comment post provide guidance : \ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1\ud83d\udca1 -- -- # # new eslint rule verifies list dependency hook like ` useeffect ` similar , protecting stale closure pitfall . case autofix . 'll add documentation next week . ! # # installation eslint config : simple test case verify rule work : # # lint rule complains code fine ! * * new ` react-hooks/exhaustive-deps ` lint rule fire think code correct * * , please post issue . -- -- # post comment * * please * * include three thing : 1. codesandbox demonstrating * * minimal code example * * still express intent ( `` foo bar '' * * actual ui pattern * * 're implementing ) . 2. explanation * * step * * user expect see screen . 3. explanation * * intended api * * hook/component . ! # # case simple , n't want include thing ! might simple \u2014 \u2019 simple u . * * comment n't include either ( e.g . codesandbox link ) , hide comment * * \u2019 hard track discussion otherwise . thank respecting everyone \u2019 time including . end goal thread find common scenario transform better doc warning . happen enough detail available . drive-by comment incomplete code snippet significantly drive quality discussion \u2014 point 's worth .",
        "title_stopwords_removal_lemmatization": "[ eslint ] feedback 'exhaustive-deps ' lint rule"
    },
    {
        "issue_id": 410478306,
        "title": "Chrome 73 breaks wheel events",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-02-14T20:28:58Z",
        "status": "closed",
        "description": "Similar to #8968, but for the `wheel` and `mousewheel` events. They are now passive by default for root elements in Chrome 73 (currently beta) which means React apps that have custom scrolling/zooming behaviors will run into issues.\r\n\r\nThe quick fix may be to manually add event listeners with `{passive: false}` but has the React team considered if this should be configurable for the React event handler?\r\n\r\nBlog post from the Chrome team here: https://developers.google.com/web/updates/2019/02/scrolling-intervention",
        "remove_template_description": "Similar to #8968, but for the `wheel` and `mousewheel` events. They are now passive by default for root elements in Chrome 73 (currently beta) which means React apps that have custom scrolling/zooming behaviors will run into issues.    The quick fix may be to manually add event listeners with `{passive: false}` but has the React team considered if this should be configurable for the React event handler?    Blog post from the Chrome team here: https://developers.google.com/web/updates/2019/02/scrolling-intervention",
        "human_words": "Similar to #8968, but for the `wheel` and `mousewheel` events. They are now passive by default for root elements in Chrome 73 (currently beta) which means React apps that have custom scrolling/zooming behaviors will run into issues.    The quick fix may be to manually add event listeners with `{passive: false}` but has the React team considered if this should be configurable for the React event handler?    Blog post from the Chrome team here: https://developers.google.com/web/updates/2019/02/scrolling-intervention",
        "human_words_regrex": "Similar to #8968, but for the `wheel` and `mousewheel` events. They are now passive by default for root elements in Chrome 73 (currently beta) which means React apps that have custom scrolling/zooming behaviors will run into issues. The quick fix may be to manually add event listeners with `{passive: false}` but has the React team considered if this should be configurable for the React event handler? Blog post from the Chrome team here: ",
        "human_words_stopwords_removal_lemmatization": "similar # 8968 , ` wheel ` ` mousewheel ` event . passive default root element chrome 73 ( currently beta ) mean react apps custom scrolling/zooming behavior run issue . quick fix may manually add event listener ` { passive : false } ` react team considered configurable react event handler ? blog post chrome team :",
        "title_stopwords_removal_lemmatization": "chrome 73 break wheel event"
    },
    {
        "issue_id": 407597506,
        "title": "defaultValue does not work with input when type is set to submit",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-02-07T09:01:40Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen you use uncontrolled `<input type=\"submit\" />` and set `defaultValue` attribute, it would be ignored in versions 1.5.0 or higher (there would be no `value` attribute in the HTML result). It was working correctly in older versions. Looks like only `type=\"submit\"` is affected, for other input types `defaultValue` behaves correctly.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nCorrect behaviour with react 16.4.2: https://codepen.io/anon/pen/zePmrZ\r\nIncorrect behaviour with react 16.8.1: https://codepen.io/anon/pen/PVOyqV\r\n\r\n**What is the expected behavior?**\r\n\r\nWhen `defaultValue=\"foo\"` is set on `<input type=\"submit\"/>` it should result in `<input type=\"submit\" value=\"foo\" />` in the HTML result.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nAll versions starting from 16.5.0\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    When you use uncontrolled `<input type=\"submit\" />` and set `defaultValue` attribute, it would be ignored in versions 1.5.0 or higher (there would be no `value` attribute in the HTML result). It was working correctly in older versions. Looks like only `type=\"submit\"` is affected, for other input types `defaultValue` behaves correctly.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    Correct behaviour with react 16.4.2: https://codepen.io/anon/pen/zePmrZ  Incorrect behaviour with react 16.8.1: https://codepen.io/anon/pen/PVOyqV    **What is the expected behavior?**    When `defaultValue=\"foo\"` is set on `<input type=\"submit\"/>` it should result in `<input type=\"submit\" value=\"foo\" />` in the HTML result.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All versions starting from 16.5.0",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug    **What is the current behavior?**    When you use uncontrolled `<input type=\"submit\" />` and set `defaultValue` attribute, it would be ignored in versions 1.5.0 or higher (there would be no `value` attribute in the HTML result). It was working correctly in older versions. Looks like only `type=\"submit\"` is affected, for other input types `defaultValue` behaves correctly.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    Correct behaviour with react 16.4.2: https://codepen.io/anon/pen/zePmrZ  Incorrect behaviour with react 16.8.1: https://codepen.io/anon/pen/PVOyqV    **What is the expected behavior?**    When `defaultValue=\"foo\"` is set on `<input type=\"submit\"/>` it should result in `<input type=\"submit\" value=\"foo\" />` in the HTML result.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All versions starting from 16.5.0",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** When you use uncontrolled `` and set `defaultValue` attribute, it would be ignored in versions 1.5.0 or higher (there would be no `value` attribute in the HTML result). It was working correctly in older versions. Looks like only `type=\"submit\"` is affected, for other input types `defaultValue` behaves correctly. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** Correct behaviour with react 16.4.2:  Incorrect behaviour with react 16.8.1:  **What is the expected behavior?** When `defaultValue=\"foo\"` is set on `` it should result in `` in the HTML result. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** All versions starting from 16.5.0",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * use uncontrolled `` set ` defaultvalue ` attribute , would ignored version 1.5.0 higher ( would ` value ` attribute html result ) . working correctly older version . look like ` type= '' submit '' ` affected , input type ` defaultvalue ` behaves correctly . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * correct behaviour react 16.4.2 : incorrect behaviour react 16.8.1 : * * expected behavior ? * * ` defaultvalue= '' foo '' ` set `` result `` html result . * * version react , browser / o affected issue ? work previous version react ? * * version starting 16.5.0",
        "title_stopwords_removal_lemmatization": "defaultvalue work input type set submit"
    },
    {
        "issue_id": 405247974,
        "title": "Dependency-based reinitialization of useState",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-01-31T13:34:17Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nConsider I want to have a dynamically calculated list of options, and a piece of state that represents the currently selected option. I can achieve this using hooks as follows:\r\n\r\n```js\r\nconst options = useMemo(() => {\r\n  // Calculate the options\r\n}, [dep1, dep2]);\r\n\r\nconst [choice, setChoice] = useState(options[0]);\r\n\r\nconst result = useMemo(() => {\r\n  // Calculate the displayed result\r\n}, [choice]);\r\n```\r\n\r\nHowever, a problem occurs if either `dep1` or `dep2` changes. The list of options changes, which means `choice` may no longer be valid. To fix this, I must split `choice` into a selected value and a memoized value that checks for validity:\r\n\r\n```js\r\nconst [selectedChoice, setSelectedChoice] = useState(options[0]);\r\n\r\nconst choice = useMemo(() => {\r\n  if (options.includes(selectedChoice) {\r\n    return selectedChoice;\r\n  } else {\r\n    setSelectedChoice(options[0]);\r\n    return options[0];\r\n  }\r\n}, [options, selectedChoice]);\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nIt would useful if we could declare dependencies for `useState`, in the same way that we can for `useMemo`, and have the state reset back to the initial state if they change:\r\n\r\n```js\r\nconst [choice, setChoice] = useState(options[0], [options]);\r\n```\r\n\r\nIn order to allow preserving the current value if its valid, React could supply `prevState` to the initial state factory function, if any exists, e.g.\r\n\r\n```js\r\nconst [choice, setChoice] = useState(prevState => {\r\n  if (prevState && options.includes(prevState) {\r\n    return prevState;\r\n else {\r\n    return options[0];\r\n }\r\n}, [options]);\r\n```\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n16.8.0-alpha.1\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    Consider I want to have a dynamically calculated list of options, and a piece of state that represents the currently selected option. I can achieve this using hooks as follows:    ```js  const options = useMemo(() => {    // Calculate the options  }, [dep1, dep2]);    const [choice, setChoice] = useState(options[0]);    const result = useMemo(() => {    // Calculate the displayed result  }, [choice]);  ```    However, a problem occurs if either `dep1` or `dep2` changes. The list of options changes, which means `choice` may no longer be valid. To fix this, I must split `choice` into a selected value and a memoized value that checks for validity:    ```js  const [selectedChoice, setSelectedChoice] = useState(options[0]);    const choice = useMemo(() => {    if (options.includes(selectedChoice) {      return selectedChoice;    } else {      setSelectedChoice(options[0]);      return options[0];    }  }, [options, selectedChoice]);  ```    **What is the expected behavior?**    It would useful if we could declare dependencies for `useState`, in the same way that we can for `useMemo`, and have the state reset back to the initial state if they change:    ```js  const [choice, setChoice] = useState(options[0], [options]);  ```    In order to allow preserving the current value if its valid, React could supply `prevState` to the initial state factory function, if any exists, e.g.    ```js  const [choice, setChoice] = useState(prevState => {    if (prevState && options.includes(prevState) {      return prevState;   else {      return options[0];   }  }, [options]);  ```    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.8.0-alpha.1",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    Consider I want to have a dynamically calculated list of options, and a piece of state that represents the currently selected option. I can achieve this using hooks as follows:        However, a problem occurs if either `dep1` or `dep2` changes. The list of options changes, which means `choice` may no longer be valid. To fix this, I must split `choice` into a selected value and a memoized value that checks for validity:        **What is the expected behavior?**    It would useful if we could declare dependencies for `useState`, in the same way that we can for `useMemo`, and have the state reset back to the initial state if they change:        In order to allow preserving the current value if its valid, React could supply `prevState` to the initial state factory function, if any exists, e.g.        **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.8.0-alpha.1",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** Consider I want to have a dynamically calculated list of options, and a piece of state that represents the currently selected option. I can achieve this using hooks as follows: However, a problem occurs if either `dep1` or `dep2` changes. The list of options changes, which means `choice` may no longer be valid. To fix this, I must split `choice` into a selected value and a memoized value that checks for validity: **What is the expected behavior?** It would useful if we could declare dependencies for `useState`, in the same way that we can for `useMemo`, and have the state reset back to the initial state if they change: In order to allow preserving the current value if its valid, React could supply `prevState` to the initial state factory function, if any exists, e.g. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.8.0-alpha.1",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * consider want dynamically calculated list option , piece state represents currently selected option . achieve using hook follows : however , problem occurs either ` dep1 ` ` dep2 ` change . list option change , mean ` choice ` may longer valid . fix , must split ` choice ` selected value memoized value check validity : * * expected behavior ? * * would useful could declare dependency ` usestate ` , way ` usememo ` , state reset back initial state change : order allow preserving current value valid , react could supply ` prevstate ` initial state factory function , exists , e.g . * * version react , browser / o affected issue ? work previous version react ? * * 16.8.0-alpha.1",
        "title_stopwords_removal_lemmatization": "dependency-based reinitialization usestate"
    },
    {
        "issue_id": 401823391,
        "title": "`useCallback()` & `useMemo()` automatically with a Babel Plug-in",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-01-22T15:38:42Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature request.\r\n\r\n**What is the current behavior?**\r\n\r\nWe need to `useCallback()` and `useMemo()` which seems redundant and can cost us in performance if not used right, which is likely to happen.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n```js\r\nexport default ({ data, sortComparator, filterPredicate, history }) => {\r\n  const transformedData = data.filter(filterPredicate).sort(sortComparator)\r\n\r\n  return (\r\n    <div>\r\n      <button className=\"back-btn\" onClick={() => history.pop()} />\r\n      <ul className=\"data-list\">\r\n        {transformedData.map(({ id, value }) => (\r\n          <li className=\"data-item\" key={id} onClick={() => history.push(`data/${id}`)}>{value}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nJust like the [docs](https://reactjs.org/docs/hooks-reference.html#usecallback) suggest:\r\n\r\n```\r\nIn the future, a sufficiently advanced compiler could create this array automatically.\r\n```\r\n\r\nAccordingly, I have implemented a Babel-plug-in that does exactly that; see [babel-plugin-react-persist](https://github.com/DAB0mB/babel-plugin-react-persist). Given the code snippet above, the plug-in should generate the following output:\r\n\r\n```js\r\nlet _anonymousFnComponent, _anonymousFnComponent2\r\n\r\nexport default ({ data, sortComparator, filterPredicate, history }) => {\r\n  const transformedData = React.useMemo(() =>\r\n    data.filter(filterPredicate).sort(sortComparator)\r\n  , [data, data.filter, filterPredicate, sortComparator])\r\n\r\n  return React.createElement(_anonymousFnComponent2 = _anonymousFnComponent2 || (() => {\r\n    const _onClick2 = React.useCallback(() => history.pop(), [history, history.pop])\r\n\r\n    return (\r\n      <div>\r\n        <button className=\"back-btn\" onClick={_onClick2} />\r\n        <ul className=\"data-list\">\r\n          {transformedData.map(({ id, value }) =>\r\n            React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() => {\r\n              const _onClick = React.useCallback(() =>\r\n                history.push(`data/${id}`)\r\n              , [history, history.push, id])\r\n\r\n              return (\r\n                <li className=\"data-item\" key={id} onClick={_onClick}>\r\n                  {value}\r\n                </li>\r\n              )\r\n            }), { key: id })\r\n          )}\r\n        </ul>\r\n      </div>\r\n    )\r\n  }), null)\r\n}\r\n```\r\n\r\nThe plug-in will:\r\n\r\n- `useCallback()` automatically when a function is created.\r\n- `useMemo()` automatically when a value is assigned.\r\n- Will memoize inline callbacks.\r\n\r\nI don't see however how can `useEffect()` be inferred automatically and if it's a good idea. The plug-in is not a feature request directly for React, but since it's stated in the docs I thought maybe it can be useful somehow. Maybe it can potentially be included as part of `create-react-app`? Would like to hear your thoughts about it. An alternative solution is suggested at #14406, but I don't see why do this at runtime when everything can be done ahead of time and save processing power.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReact 16.8-alpha (hooks)\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Feature request.    **What is the current behavior?**    We need to `useCallback()` and `useMemo()` which seems redundant and can cost us in performance if not used right, which is likely to happen.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    ```js  export default ({ data, sortComparator, filterPredicate, history }) => {    const transformedData = data.filter(filterPredicate).sort(sortComparator)      return (      <div>        <button className=\"back-btn\" onClick={() => history.pop()} />        <ul className=\"data-list\">          {transformedData.map(({ id, value }) => (            <li className=\"data-item\" key={id} onClick={() => history.push(`data/${id}`)}>{value}</li>          ))}        </ul>      </div>    )  }  ```    **What is the expected behavior?**    Just like the [docs](https://reactjs.org/docs/hooks-reference.html#usecallback) suggest:    ```  In the future, a sufficiently advanced compiler could create this array automatically.  ```    Accordingly, I have implemented a Babel-plug-in that does exactly that; see [babel-plugin-react-persist](https://github.com/DAB0mB/babel-plugin-react-persist). Given the code snippet above, the plug-in should generate the following output:    ```js  let _anonymousFnComponent, _anonymousFnComponent2    export default ({ data, sortComparator, filterPredicate, history }) => {    const transformedData = React.useMemo(() =>      data.filter(filterPredicate).sort(sortComparator)    , [data, data.filter, filterPredicate, sortComparator])      return React.createElement(_anonymousFnComponent2 = _anonymousFnComponent2 || (() => {      const _onClick2 = React.useCallback(() => history.pop(), [history, history.pop])        return (        <div>          <button className=\"back-btn\" onClick={_onClick2} />          <ul className=\"data-list\">            {transformedData.map(({ id, value }) =>              React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() => {                const _onClick = React.useCallback(() =>                  history.push(`data/${id}`)                , [history, history.push, id])                  return (                  <li className=\"data-item\" key={id} onClick={_onClick}>                    {value}                  </li>                )              }), { key: id })            )}          </ul>        </div>      )    }), null)  }  ```    The plug-in will:    - `useCallback()` automatically when a function is created.  - `useMemo()` automatically when a value is assigned.  - Will memoize inline callbacks.    I don't see however how can `useEffect()` be inferred automatically and if it's a good idea. The plug-in is not a feature request directly for React, but since it's stated in the docs I thought maybe it can be useful somehow. Maybe it can potentially be included as part of `create-react-app`? Would like to hear your thoughts about it. An alternative solution is suggested at #14406, but I don't see why do this at runtime when everything can be done ahead of time and save processing power.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.8-alpha (hooks)",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Feature request.    **What is the current behavior?**    We need to `useCallback()` and `useMemo()` which seems redundant and can cost us in performance if not used right, which is likely to happen.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**        **What is the expected behavior?**    Just like the [docs](https://reactjs.org/docs/hooks-reference.html#usecallback) suggest:        Accordingly, I have implemented a Babel-plug-in that does exactly that; see [babel-plugin-react-persist](https://github.com/DAB0mB/babel-plugin-react-persist). Given the code snippet above, the plug-in should generate the following output:        The plug-in will:    - `useCallback()` automatically when a function is created.  - `useMemo()` automatically when a value is assigned.  - Will memoize inline callbacks.    I don't see however how can `useEffect()` be inferred automatically and if it's a good idea. The plug-in is not a feature request directly for React, but since it's stated in the docs I thought maybe it can be useful somehow. Maybe it can potentially be included as part of `create-react-app`? Would like to hear your thoughts about it. An alternative solution is suggested at #14406, but I don't see why do this at runtime when everything can be done ahead of time and save processing power.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.8-alpha (hooks)",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature request. **What is the current behavior?** We need to `useCallback()` and `useMemo()` which seems redundant and can cost us in performance if not used right, which is likely to happen. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** Just like the  suggest: Accordingly, I have implemented a Babel-plug-in that does exactly that; see . Given the code snippet above, the plug-in should generate the following output: The plug-in will: - `useCallback()` automatically when a function is created. - `useMemo()` automatically when a value is assigned. - Will memoize inline callbacks. I don't see however how can `useEffect()` be inferred automatically and if it's a good idea. The plug-in is not a feature request directly for React, but since it's stated in the docs I thought maybe it can be useful somehow. Maybe it can potentially be included as part of `create-react-app`? Would like to hear your thoughts about it. An alternative solution is suggested at #14406, but I don't see why do this at runtime when everything can be done ahead of time and save processing power. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.8-alpha (hooks)",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature request . * * current behavior ? * * need ` usecallback ( ) ` ` usememo ( ) ` seems redundant cost u performance used right , likely happen . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * like suggest : accordingly , implemented babel-plug-in exactly ; see . given code snippet , plug-in generate following output : plug-in : - ` usecallback ( ) ` automatically function created . - ` usememo ( ) ` automatically value assigned . - memoize inline callback . n't see however ` useeffect ( ) ` inferred automatically 's good idea . plug-in feature request directly react , since 's stated doc thought maybe useful somehow . maybe potentially included part ` create-react-app ` ? would like hear thought . alternative solution suggested # 14406 , n't see runtime everything done ahead time save processing power . * * version react , browser / o affected issue ? work previous version react ? * * react 16.8-alpha ( hook )",
        "title_stopwords_removal_lemmatization": "` usecallback ( ) ` & ` usememo ( ) ` automatically babel plug-in"
    },
    {
        "issue_id": 398512867,
        "title": "Question: How to know if the loading status of Suspense resolved",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-01-12T02:40:45Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nQuestion\r\n\r\n**What is the current behavior?**\r\n\r\nI'm trying to implement supports of `React.lazy` and `React.Suspense` in enzyme (airbnb/enzyme#1975). I'd like to have something like `waitUntilLazyLoaded` so we can write such test:\r\n\r\n```js\r\n// in DynamicComponent.js\r\n\r\nclass DynamicComponent extends React.Component {\r\n  render() {\r\n    // render something\r\n  }\r\n}\r\n\r\n// in test.js\r\n\r\nconst LazyComponent = lazy(() => import('./DynamicComponent'));\r\nconst Fallback = () => <div />;\r\nconst SuspenseComponent = () => (\r\n  <Suspense fallback={<Fallback />}>\r\n    <LazyComponent />\r\n  </Suspense>\r\n);\r\n\r\n// mount the react element\r\nconst wrapper = mount(<SuspenseComponent />)\r\n\r\n// On starter this should render Fallback\r\nexpect(wrapper.find('Fallback')).to.have.lengthOf(1)\r\nexpect(wrapper.find('DynamicComponent')).to.have.lenghtOf(0)\r\n\r\n// wait for LazyComponent loading DynamicComponent and update of rendering\r\nawait wrapper.waitUntilLazyLoaded()\r\n\r\n// render loaded component now\r\nexpect(wrapper.find('Fallback')).to.have.lengthOf(0)\r\nexpect(wrapper.find('DynamicComponent')).to.have.lengthOf(1)\r\n\r\n```\r\n\r\nInside the `mount` implementation we call the `ReactDOM.render` to render it and get the root fiber node. Now my problem is: Given a Fiber node of `Suspense`, how could we know the loading status of `Suspense` so I can make sure whether (1) the module is loaded successfully loaded (or failed) and (2) React has rendered (or not rendered) the new component tree?\r\n\r\nI'm not familiar with the implementation detail of Fiber and I'm still trying to investigate into this. That would be great if someone familiar with this could answer. Thanks!\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n^16.6\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Question    **What is the current behavior?**    I'm trying to implement supports of `React.lazy` and `React.Suspense` in enzyme (airbnb/enzyme#1975). I'd like to have something like `waitUntilLazyLoaded` so we can write such test:    ```js  // in DynamicComponent.js    class DynamicComponent extends React.Component {    render() {      // render something    }  }    // in test.js    const LazyComponent = lazy(() => import('./DynamicComponent'));  const Fallback = () => <div />;  const SuspenseComponent = () => (    <Suspense fallback={<Fallback />}>      <LazyComponent />    </Suspense>  );    // mount the react element  const wrapper = mount(<SuspenseComponent />)    // On starter this should render Fallback  expect(wrapper.find('Fallback')).to.have.lengthOf(1)  expect(wrapper.find('DynamicComponent')).to.have.lenghtOf(0)    // wait for LazyComponent loading DynamicComponent and update of rendering  await wrapper.waitUntilLazyLoaded()    // render loaded component now  expect(wrapper.find('Fallback')).to.have.lengthOf(0)  expect(wrapper.find('DynamicComponent')).to.have.lengthOf(1)    ```    Inside the `mount` implementation we call the `ReactDOM.render` to render it and get the root fiber node. Now my problem is: Given a Fiber node of `Suspense`, how could we know the loading status of `Suspense` so I can make sure whether (1) the module is loaded successfully loaded (or failed) and (2) React has rendered (or not rendered) the new component tree?    I'm not familiar with the implementation detail of Fiber and I'm still trying to investigate into this. That would be great if someone familiar with this could answer. Thanks!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    ^16.6",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Question    **What is the current behavior?**    I'm trying to implement supports of `React.lazy` and `React.Suspense` in enzyme (airbnb/enzyme#1975). I'd like to have something like `waitUntilLazyLoaded` so we can write such test:        Inside the `mount` implementation we call the `ReactDOM.render` to render it and get the root fiber node. Now my problem is: Given a Fiber node of `Suspense`, how could we know the loading status of `Suspense` so I can make sure whether (1) the module is loaded successfully loaded (or failed) and (2) React has rendered (or not rendered) the new component tree?    I'm not familiar with the implementation detail of Fiber and I'm still trying to investigate into this. That would be great if someone familiar with this could answer. Thanks!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    ^16.6",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Question **What is the current behavior?** I'm trying to implement supports of `React.lazy` and `React.Suspense` in enzyme (airbnb/enzyme#1975). I'd like to have something like `waitUntilLazyLoaded` so we can write such test: Inside the `mount` implementation we call the `ReactDOM.render` to render it and get the root fiber node. Now my problem is: Given a Fiber node of `Suspense`, how could we know the loading status of `Suspense` so I can make sure whether (1) the module is loaded successfully loaded (or failed) and (2) React has rendered (or not rendered) the new component tree? I'm not familiar with the implementation detail of Fiber and I'm still trying to investigate into this. That would be great if someone familiar with this could answer. Thanks! **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** ^16.6",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * question * * current behavior ? * * 'm trying implement support ` react.lazy ` ` react.suspense ` enzyme ( airbnb/enzyme # 1975 ) . 'd like something like ` waituntillazyloaded ` write test : inside ` mount ` implementation call ` reactdom.render ` render get root fiber node . problem : given fiber node ` suspense ` , could know loading status ` suspense ` make sure whether ( 1 ) module loaded successfully loaded ( failed ) ( 2 ) react rendered ( rendered ) new component tree ? 'm familiar implementation detail fiber 'm still trying investigate . would great someone familiar could answer . thanks ! * * version react , browser / o affected issue ? work previous version react ? * * ^16.6",
        "title_stopwords_removal_lemmatization": "question : know loading status suspense resolved"
    },
    {
        "issue_id": 397811559,
        "title": "React.Children.count returns invalid number of children",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-01-10T12:37:06Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBUG\r\n\r\n**What is the current behavior?**\r\n\r\n>nextProps.children\r\n> false\r\n\r\n>React.Children.count(nextProps.children)\r\n>1\r\n\r\n>React.Children.toArray(nextProps.children).length\r\n>0\r\n\r\n>React.version\r\n>\"16.4.2\"\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n**What is the expected behavior?**\r\n\r\nThat `React.Children.count(false)` behaviour is somehow aligned with `React.Children.toArray(false)`\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    BUG    **What is the current behavior?**    >nextProps.children  > false    >React.Children.count(nextProps.children)  >1    >React.Children.toArray(nextProps.children).length  >0    >React.version  >\"16.4.2\"    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    That `React.Children.count(false)` behaviour is somehow aligned with `React.Children.toArray(false)`    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    BUG    **What is the current behavior?**    >nextProps.children  > false    >React.Children.count(nextProps.children)  >1    >React.Children.toArray(nextProps.children).length  >0    >React.version  >\"16.4.2\"    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    That `React.Children.count(false)` behaviour is somehow aligned with `React.Children.toArray(false)`    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** BUG **What is the current behavior?** >nextProps.children > false >React.Children.count(nextProps.children) >1 >React.Children.toArray(nextProps.children).length >0 >React.version >\"16.4.2\" **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** That `React.Children.count(false)` behaviour is somehow aligned with `React.Children.toArray(false)` **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * > nextprops.children > false > react.children.count ( nextprops.children ) > 1 > react.children.toarray ( nextprops.children ) .length > 0 > react.version > '' 16.4.2 '' * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * ` react.children.count ( false ) ` behaviour somehow aligned ` react.children.toarray ( false ) ` * * version react , browser / o affected issue ? work previous version react ? * *",
        "title_stopwords_removal_lemmatization": "react.children.count return invalid number child"
    },
    {
        "issue_id": 396786559,
        "title": "Add `get` function to `useState`",
        "label": [
            "Type: Discussion"
        ],
        "date": "2019-01-08T07:51:31Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n- feature\r\n\r\n**What is the current behavior?**\r\nCode from [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html):\r\n```javascript\r\nimport { useState } from 'react';\r\n\r\nfunction Example() {\r\n  // Declare a new state variable, which we'll call \"count\"\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n```javascript\r\n// each time \"count\" changed, this arrow function will be created again.\r\n// so that it can access the latest \"count\"\r\nonClick={() => setCount(count + 1)}\r\n```\r\nI don't think it is good to create a fixed function many times, so I try to modify the code:\r\n(Update on Jul 2022: No matter using the inline anonymous function or wrapping with `useCallback`, the function will always be created. The difference is that, in `useCallback` approach, the function reference will not be changed, which could be helpful if we use `memo` to wrap the component who receives the function as a property)\r\n```javascript\r\nconst [count, setCount] = useState(0);\r\nconst handleClick = useCallback(() => setCount(count + 1), []);\r\n```\r\nBut obviously the callback in `useCallback` couldn't get the latest `count` because I pass in an empty inputs array to avoid this callback been generated again and again.\r\n\r\nSo, in fact, the inputs array decide two things:\r\n1. when to recreate the callback\r\n2. which state can be accessed in the callback\r\n\r\nIn most situation, the two things are one thing, but here they conflict. \r\n\r\nSo I think maybe it's good to add a `get` function to `useState` like this:\r\n```javascript\r\nimport { useState, useCallback } from 'react';\r\n\r\nfunction Example() {\r\n  // Declare a new state variable, which we'll call \"count\"\r\n  const [count, setCount, getCount] = useState(0);\r\n\r\n  const handleClick = useCallback(() => setCount(getCount() + 1), []);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={handleClick}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n```\r\nMaybe it's confusing because `getCount` can totally replace `count`, but it brings the possible to avoid creating callbacks again and again.\r\n\r\n### Edited\r\nhttps://github.com/facebook/react/issues/14543#issuecomment-452237355 exactly resolves the case above. But there\u2018re many other scenarios can't use `updater` to resolve. Here are some more code snippets:\r\n#### 1. Access states in a timer.\r\n```javascript\r\nuseEffect(() => {\r\n  // or setInterval\r\n  const id = setTimeout(() => {\r\n    // access states\r\n  }, period);\r\n  return () => clearTimeout(id);\r\n}, inputs);\r\n```\r\n#### 2. Access states in WebSocket callbacks\r\n```javascript\r\nuseEffect(() => {\r\n  // create a WebSocket client named \"ws\"\r\n  ws.onopen = () => {\r\n    // access states\r\n  };\r\n  ws.onmessage = () => {\r\n    // access states\r\n  };\r\n  return () => ws.close();\r\n}, inputs);\r\n```\r\n#### 3. Access states in Promise\r\n```javascript\r\nuseEffect(() => {\r\n  create_a_promise().then(() => {\r\n    // access states\r\n  });\r\n}, inputs);\r\n```\r\n#### 4. Access states in event callbacks\r\n```javascript\r\nuseEffect(() => {\r\n  function handleThatEvent() {\r\n    // access states\r\n  }\r\n  instance.addEventListener('eventName', handleThatEvent);\r\n  return instance.removeEventListener('eventName', handleThatEvent);\r\n}, inputs);\r\n```\r\n\r\nWe had to use some workaround patterns to resolve those cases, like\r\nhttps://github.com/facebook/react/issues/14543#issuecomment-452676760\r\nhttps://github.com/facebook/react/issues/14543#issuecomment-453058025\r\nhttps://github.com/facebook/react/issues/14543#issuecomment-453079958\r\nOr a funny way:\r\n```javascript\r\nconst [state, setState] = useState();\r\nuseEffect(() => {\r\n  // or setInterval\r\n  const id = setTimeout(() => {\r\n    // access states\r\n    setState((prevState) => {\r\n      // Now I can do anything with state...\ud83e\udd2e\r\n      ...\r\n      return prevState;\r\n    });\r\n  }, period);\r\n  return () => clearTimeout(id);\r\n}, inputs);\r\n```\r\n\r\nSo let's discuss and wait...\r\nhttps://github.com/facebook/react/issues/14543#issuecomment-452713416\r\n\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n**What is the expected behavior?**\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n- React 16.7.0-alpha.2\r\n\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  - feature    **What is the current behavior?**  Code from [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html):  ```javascript  import { useState } from 'react';    function Example() {    // Declare a new state variable, which we'll call \"count\"    const [count, setCount] = useState(0);      return (      <div>        <p>You clicked {count} times</p>        <button onClick={() => setCount(count + 1)}>          Click me        </button>      </div>    );  }  ```  ```javascript  // each time \"count\" changed, this arrow function will be created again.  // so that it can access the latest \"count\"  onClick={() => setCount(count + 1)}  ```  I don't think it is good to create a fixed function many times, so I try to modify the code:  (Update on Jul 2022: No matter using the inline anonymous function or wrapping with `useCallback`, the function will always be created. The difference is that, in `useCallback` approach, the function reference will not be changed, which could be helpful if we use `memo` to wrap the component who receives the function as a property)  ```javascript  const [count, setCount] = useState(0);  const handleClick = useCallback(() => setCount(count + 1), []);  ```  But obviously the callback in `useCallback` couldn't get the latest `count` because I pass in an empty inputs array to avoid this callback been generated again and again.    So, in fact, the inputs array decide two things:  1. when to recreate the callback  2. which state can be accessed in the callback    In most situation, the two things are one thing, but here they conflict.     So I think maybe it's good to add a `get` function to `useState` like this:  ```javascript  import { useState, useCallback } from 'react';    function Example() {    // Declare a new state variable, which we'll call \"count\"    const [count, setCount, getCount] = useState(0);      const handleClick = useCallback(() => setCount(getCount() + 1), []);      return (      <div>        <p>You clicked {count} times</p>        <button onClick={handleClick}>          Click me        </button>      </div>    );  }  ```  Maybe it's confusing because `getCount` can totally replace `count`, but it brings the possible to avoid creating callbacks again and again.    ### Edited  https://github.com/facebook/react/issues/14543#issuecomment-452237355 exactly resolves the case above. But there\u2018re many other scenarios can't use `updater` to resolve. Here are some more code snippets:  #### 1. Access states in a timer.  ```javascript  useEffect(() => {    // or setInterval    const id = setTimeout(() => {      // access states    }, period);    return () => clearTimeout(id);  }, inputs);  ```  #### 2. Access states in WebSocket callbacks  ```javascript  useEffect(() => {    // create a WebSocket client named \"ws\"    ws.onopen = () => {      // access states    };    ws.onmessage = () => {      // access states    };    return () => ws.close();  }, inputs);  ```  #### 3. Access states in Promise  ```javascript  useEffect(() => {    create_a_promise().then(() => {      // access states    });  }, inputs);  ```  #### 4. Access states in event callbacks  ```javascript  useEffect(() => {    function handleThatEvent() {      // access states    }    instance.addEventListener('eventName', handleThatEvent);    return instance.removeEventListener('eventName', handleThatEvent);  }, inputs);  ```    We had to use some workaround patterns to resolve those cases, like  https://github.com/facebook/react/issues/14543#issuecomment-452676760  https://github.com/facebook/react/issues/14543#issuecomment-453058025  https://github.com/facebook/react/issues/14543#issuecomment-453079958  Or a funny way:  ```javascript  const [state, setState] = useState();  useEffect(() => {    // or setInterval    const id = setTimeout(() => {      // access states      setState((prevState) => {        // Now I can do anything with state...\ud83e\udd2e        ...        return prevState;      });    }, period);    return () => clearTimeout(id);  }, inputs);  ```    So let's discuss and wait...  https://github.com/facebook/react/issues/14543#issuecomment-452713416        **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  - React 16.7.0-alpha.2",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  - feature    **What is the current behavior?**  Code from [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html):      I don't think it is good to create a fixed function many times, so I try to modify the code:  (Update on Jul 2022: No matter using the inline anonymous function or wrapping with `useCallback`, the function will always be created. The difference is that, in `useCallback` approach, the function reference will not be changed, which could be helpful if we use `memo` to wrap the component who receives the function as a property)    But obviously the callback in `useCallback` couldn't get the latest `count` because I pass in an empty inputs array to avoid this callback been generated again and again.    So, in fact, the inputs array decide two things:  1. when to recreate the callback  2. which state can be accessed in the callback    In most situation, the two things are one thing, but here they conflict.     So I think maybe it's good to add a `get` function to `useState` like this:    Maybe it's confusing because `getCount` can totally replace `count`, but it brings the possible to avoid creating callbacks again and again.    ### Edited  https://github.com/facebook/react/issues/14543#issuecomment-452237355 exactly resolves the case above. But there\u2018re many other scenarios can't use `updater` to resolve. Here are some more code snippets:  #### 1. Access states in a timer.    #### 2. Access states in WebSocket callbacks    #### 3. Access states in Promise    #### 4. Access states in event callbacks      We had to use some workaround patterns to resolve those cases, like  https://github.com/facebook/react/issues/14543#issuecomment-452676760  https://github.com/facebook/react/issues/14543#issuecomment-453058025  https://github.com/facebook/react/issues/14543#issuecomment-453079958  Or a funny way:      So let's discuss and wait...  https://github.com/facebook/react/issues/14543#issuecomment-452713416        **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  - React 16.7.0-alpha.2",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** - feature **What is the current behavior?** Code from : I don't think it is good to create a fixed function many times, so I try to modify the code: (Update on Jul 2022: No matter using the inline anonymous function or wrapping with `useCallback`, the function will always be created. The difference is that, in `useCallback` approach, the function reference will not be changed, which could be helpful if we use `memo` to wrap the component who receives the function as a property) But obviously the callback in `useCallback` couldn't get the latest `count` because I pass in an empty inputs array to avoid this callback been generated again and again. So, in fact, the inputs array decide two things: 1. when to recreate the callback 2. which state can be accessed in the callback In most situation, the two things are one thing, but here they conflict. So I think maybe it's good to add a `get` function to `useState` like this: Maybe it's confusing because `getCount` can totally replace `count`, but it brings the possible to avoid creating callbacks again and again. ### Edited  exactly resolves the case above. But there\u2018re many other scenarios can't use `updater` to resolve. Here are some more code snippets: #### 1. Access states in a timer. #### 2. Access states in WebSocket callbacks #### 3. Access states in Promise #### 4. Access states in event callbacks We had to use some workaround patterns to resolve those cases, like    Or a funny way: So let's discuss and wait...  **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** - React 16.7.0-alpha.2",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * - feature * * current behavior ? * * code : n't think good create fixed function many time , try modify code : ( update jul 2022 : matter using inline anonymous function wrapping ` usecallback ` , function always created . difference , ` usecallback ` approach , function reference changed , could helpful use ` memo ` wrap component receives function property ) obviously callback ` usecallback ` could n't get latest ` count ` pas empty input array avoid callback generated . , fact , input array decide two thing : 1. recreate callback 2. state accessed callback situation , two thing one thing , conflict . think maybe 's good add ` get ` function ` usestate ` like : maybe 's confusing ` getcount ` totally replace ` count ` , brings possible avoid creating callback . # # # edited exactly resolve case . \u2018 many scenario ca n't use ` updater ` resolve . code snippet : # # # # 1. access state timer . # # # # 2. access state websocket callback # # # # 3. access state promise # # # # 4. access state event callback use workaround pattern resolve case , like funny way : let 's discus wait ... * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * * * version react , browser / o affected issue ? work previous version react ? * * - react 16.7.0-alpha.2",
        "title_stopwords_removal_lemmatization": "add ` get ` function ` usestate `"
    },
    {
        "issue_id": 391218542,
        "title": "Warning should appear when versions of react and react-dom do not match",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-12-14T18:28:45Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nRequest a feature\r\n\r\n**What is the current behavior?**\r\n\r\nIf the version of react and react-dom do not match, some features fail silently.  See this issue for example: https://github.com/reduxjs/react-redux/issues/1125\r\n\r\nIn this issue, the new Context API wasn't working as intended, but no errors or warnings were visible.  Components simply did not update.  It turns out that this issue was because I updated react to version 16.6.3, but still had react-dom at version 16.5.\r\n\r\n**What is the expected behavior?**\r\n\r\nI would like to see some sort of warning message in the console in development mode when the versions of react and react-dom do not match.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Request a feature    **What is the current behavior?**    If the version of react and react-dom do not match, some features fail silently.  See this issue for example: https://github.com/reduxjs/react-redux/issues/1125    In this issue, the new Context API wasn't working as intended, but no errors or warnings were visible.  Components simply did not update.  It turns out that this issue was because I updated react to version 16.6.3, but still had react-dom at version 16.5.    **What is the expected behavior?**    I would like to see some sort of warning message in the console in development mode when the versions of react and react-dom do not match.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Request a feature    **What is the current behavior?**    If the version of react and react-dom do not match, some features fail silently.  See this issue for example: https://github.com/reduxjs/react-redux/issues/1125    In this issue, the new Context API wasn't working as intended, but no errors or warnings were visible.  Components simply did not update.  It turns out that this issue was because I updated react to version 16.6.3, but still had react-dom at version 16.5.    **What is the expected behavior?**    I would like to see some sort of warning message in the console in development mode when the versions of react and react-dom do not match.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Request a feature **What is the current behavior?** If the version of react and react-dom do not match, some features fail silently. See this issue for example:  In this issue, the new Context API wasn't working as intended, but no errors or warnings were visible. Components simply did not update. It turns out that this issue was because I updated react to version 16.6.3, but still had react-dom at version 16.5. **What is the expected behavior?** I would like to see some sort of warning message in the console in development mode when the versions of react and react-dom do not match.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * request feature * * current behavior ? * * version react react-dom match , feature fail silently . see issue example : issue , new context api n't working intended , error warning visible . component simply update . turn issue updated react version 16.6.3 , still react-dom version 16.5 . * * expected behavior ? * * would like see sort warning message console development mode version react react-dom match .",
        "title_stopwords_removal_lemmatization": "warning appear version react react-dom match"
    },
    {
        "issue_id": 387086723,
        "title": "useEffect(effect, [ref.current]) is prematurely re-running",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2018-12-04T02:05:07Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIt seems `useEffect(effect, [ref.current])` is re-running under certain circumstances without the current ref identity changing.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React:**\r\nhttps://codesandbox.io/s/qkzl9xjj44\r\n\r\n**What is the expected behavior?**\r\nIn this example, the effect should only be run once, not re-run (and thus cleaned up) upon clicking the button for the first time. The `isActive` state should be returned to false on mouseup. `CLEAN UP!` should not be logged to the console since the ref hasn't been reassigned.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n16.7.0-alpha.2 (affects all environments)",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  It seems `useEffect(effect, [ref.current])` is re-running under certain circumstances without the current ref identity changing.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React:**  https://codesandbox.io/s/qkzl9xjj44    **What is the expected behavior?**  In this example, the effect should only be run once, not re-run (and thus cleaned up) upon clicking the button for the first time. The `isActive` state should be returned to false on mouseup. `CLEAN UP!` should not be logged to the console since the ref hasn't been reassigned.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  16.7.0-alpha.2 (affects all environments)",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  It seems `useEffect(effect, [ref.current])` is re-running under certain circumstances without the current ref identity changing.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React:**  https://codesandbox.io/s/qkzl9xjj44    **What is the expected behavior?**  In this example, the effect should only be run once, not re-run (and thus cleaned up) upon clicking the button for the first time. The `isActive` state should be returned to false on mouseup. `CLEAN UP!` should not be logged to the console since the ref hasn't been reassigned.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  16.7.0-alpha.2 (affects all environments)",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** It seems `useEffect(effect, [ref.current])` is re-running under certain circumstances without the current ref identity changing. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React:**  **What is the expected behavior?** In this example, the effect should only be run once, not re-run (and thus cleaned up) upon clicking the button for the first time. The `isActive` state should be returned to false on mouseup. `CLEAN UP!` should not be logged to the console since the ref hasn't been reassigned. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.7.0-alpha.2 (affects all environments)",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * seems ` useeffect ( effect , [ ref.current ] ) ` re-running certain circumstance without current ref identity changing . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react : * * * * expected behavior ? * * example , effect run , re-run ( thus cleaned ) upon clicking button first time . ` isactive ` state returned false mouseup . ` clean ! ` logged console since ref n't reassigned . * * version react , browser / o affected issue ? work previous version react ? * * 16.7.0-alpha.2 ( affect environment )",
        "title_stopwords_removal_lemmatization": "useeffect ( effect , [ ref.current ] ) prematurely re-running"
    },
    {
        "issue_id": 386211194,
        "title": "remove useLayoutEffect server warning ",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-11-30T14:33:00Z",
        "status": "closed",
        "description": "`useLayourEffect` if used on a server generates following warning [useLayoutEffect does nothing on the server, because it...](https://github.com/facebook/react/blob/c2a2d8a539bf02e40c43d36adc2826e228f30955/packages/react-dom/src/server/ReactPartialRendererHooks.js#L280)\r\n\r\n`useEffect` is just noop without warning\r\n\r\nThere are other lifecyles methods available in React which are not worked on the server and as developers we know about.\r\n\r\nWould you mind to remove it and change on `noop` as like as `useEffect` or there some deep reason to have it.",
        "remove_template_description": "`useLayourEffect` if used on a server generates following warning [useLayoutEffect does nothing on the server, because it...](https://github.com/facebook/react/blob/c2a2d8a539bf02e40c43d36adc2826e228f30955/packages/react-dom/src/server/ReactPartialRendererHooks.js#L280)    `useEffect` is just noop without warning    There are other lifecyles methods available in React which are not worked on the server and as developers we know about.    Would you mind to remove it and change on `noop` as like as `useEffect` or there some deep reason to have it.",
        "human_words": "`useLayourEffect` if used on a server generates following warning [useLayoutEffect does nothing on the server, because it...](https://github.com/facebook/react/blob/c2a2d8a539bf02e40c43d36adc2826e228f30955/packages/react-dom/src/server/ReactPartialRendererHooks.js#L280)    `useEffect` is just noop without warning    There are other lifecyles methods available in React which are not worked on the server and as developers we know about.    Would you mind to remove it and change on `noop` as like as `useEffect` or there some deep reason to have it.",
        "human_words_regrex": "`useLayourEffect` if used on a server generates following warning  `useEffect` is just noop without warning There are other lifecyles methods available in React which are not worked on the server and as developers we know about. Would you mind to remove it and change on `noop` as like as `useEffect` or there some deep reason to have it.",
        "human_words_stopwords_removal_lemmatization": "` uselayoureffect ` used server generates following warning ` useeffect ` noop without warning lifecyles method available react worked server developer know . would mind remove change ` noop ` like ` useeffect ` deep reason .",
        "title_stopwords_removal_lemmatization": "remove uselayouteffect server warning"
    },
    {
        "issue_id": 382486022,
        "title": "Warn when calling dispatch() from useEffect() cleanup function on unmounting",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2018-11-20T03:34:44Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug\r\n\r\n**What is the current behavior?**\r\n\r\naction dispatched in return callback of `useEffect` seem to not work\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nhttps://codesandbox.io/s/5yqmo128v4\r\n\r\nonly foo -> baz is logged\r\n\r\n```javascript\r\nimport React, { useState, useEffect, useReducer } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"./styles.css\";\r\n\r\nfunction reducer(state, action) {\r\n  console.log(\"bar\", action); // not logged\r\n  // debugger\r\n  return state;\r\n}\r\n\r\nfunction Foo({ value }) {\r\n  const [state, dispatch] = useReducer(reducer, {});\r\n\r\n  useEffect(\r\n    () => {\r\n      return () => {\r\n        console.log(\"foo\");\r\n        // debugger\r\n        dispatch({ type: \"foo\" });\r\n        // debugger\r\n        console.log(\"baz\");\r\n      };\r\n    },\r\n    [state, value]\r\n  );\r\n\r\n  return <p>{value}</p>;\r\n}\r\n\r\nfunction App() {\r\n  const [value, set] = useState(0);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <button onClick={() => set(value + 1)}>INC</button>\r\n      {value % 2 ? <Foo value={value} /> : null}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<App />, rootElement);\r\n```\r\n\r\n**What is the expected behavior?**\r\nbar is logged in console\r\n(foo -> baz -> bar`action`)\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nreact: \"16.7.0-alpha.2\",\r\nreact-dom: \"16.7.0-alpha.2\"\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    bug    **What is the current behavior?**    action dispatched in return callback of `useEffect` seem to not work    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/5yqmo128v4    only foo -> baz is logged    ```javascript  import React, { useState, useEffect, useReducer } from \"react\";  import ReactDOM from \"react-dom\";    import \"./styles.css\";    function reducer(state, action) {    console.log(\"bar\", action); // not logged    // debugger    return state;  }    function Foo({ value }) {    const [state, dispatch] = useReducer(reducer, {});      useEffect(      () => {        return () => {          console.log(\"foo\");          // debugger          dispatch({ type: \"foo\" });          // debugger          console.log(\"baz\");        };      },      [state, value]    );      return <p>{value}</p>;  }    function App() {    const [value, set] = useState(0);      return (      <div className=\"App\">        <button onClick={() => set(value + 1)}>INC</button>        {value % 2 ? <Foo value={value} /> : null}      </div>    );  }    const rootElement = document.getElementById(\"root\");  ReactDOM.render(<App />, rootElement);  ```    **What is the expected behavior?**  bar is logged in console  (foo -> baz -> bar`action`)    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react: \"16.7.0-alpha.2\",  react-dom: \"16.7.0-alpha.2\"",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    bug    **What is the current behavior?**    action dispatched in return callback of `useEffect` seem to not work    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    https://codesandbox.io/s/5yqmo128v4    only foo -> baz is logged        **What is the expected behavior?**  bar is logged in console  (foo -> baz -> bar`action`)    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react: \"16.7.0-alpha.2\",  react-dom: \"16.7.0-alpha.2\"",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** bug **What is the current behavior?** action dispatched in return callback of `useEffect` seem to not work **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:**  only foo -> baz is logged **What is the expected behavior?** bar is logged in console (foo -> baz -> bar`action`) **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** react: \"16.7.0-alpha.2\", react-dom: \"16.7.0-alpha.2\"",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * action dispatched return callback ` useeffect ` seem work * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * foo - > baz logged * * expected behavior ? * * bar logged console ( foo - > baz - > bar ` action ` ) * * version react , browser / o affected issue ? work previous version react ? * * react : `` 16.7.0-alpha.2 '' , react-dom : `` 16.7.0-alpha.2 ''",
        "title_stopwords_removal_lemmatization": "warn calling dispatch ( ) useeffect ( ) cleanup function unmounting"
    },
    {
        "issue_id": 377446594,
        "title": "Simple React app (using hooks) starts using 100% of CPU",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2018-11-05T15:20:40Z",
        "status": "closed",
        "description": "As far as I can understand, this is a bug.\r\n \r\n**What is the current behavior?**\r\n\r\nI have a simple app created with the CLI. I replaced the `App.js` file by the following:\r\n\r\n```javascript\r\nimport React, { useEffect, useState } from \"react\";\r\nimport \"./App.css\";\r\n\r\nconst App = () => {\r\n  const [value1, setValue1] = useState(\"default value1\");\r\n  const [value2, setValue2] = useState(\"default value2\");\r\n\r\n  useEffect(() => {\r\n    setTimeout(() => {\r\n      setValue1(\"done waiting for value1\");\r\n    }, 1000);\r\n  });\r\n\r\n  useEffect(() => {\r\n    setTimeout(() => {\r\n      setValue2(\"done waiting for value2\");\r\n    }, 2000);\r\n  });\r\n\r\n/* // this infinitely tries to load /test hence CPU usage too\r\n  useEffect(() => {\r\n    fetch(\"/test\").then(() => setValue1(\"done waiting for value1\"));\r\n  });\r\n\r\n  useEffect(() => {\r\n    fetch(\"/test\").then(() => setValue2(\"done waiting for value2\"));\r\n  });\r\n*/\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <p>value 1: {value1}</p>\r\n      <p>value 2: {value2}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\nUpgrade to `@next` both react and react-dom. Then run this with `npm start`.\r\n\r\nOn both my linux machines I see:\r\n![image](https://user-images.githubusercontent.com/232478/48005568-0be5b880-e114-11e8-8aa8-99185ff10942.png)\r\n\r\nFirefox starts eating 100% of CPU after a small amount of time. Chromium does the same.\r\n\r\n**What is the expected behavior?**\r\n\r\nI expect that my CPU usage stays low.\r\n\r\nObviously I could test the value of my `value1`and `value2` to not perform the operation if different than the default value but that might be complicated in some cases.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n    \"react\": \"16.7.0-alpha.0\",\r\n    \"react-dom\": \"16.7.0-alpha.0\",\r\n\r\nfirefox 63.0\r\nChromium 70.0.3538.77\r\nUbuntu 18.04",
        "remove_template_description": "As far as I can understand, this is a bug.     **What is the current behavior?**    I have a simple app created with the CLI. I replaced the `App.js` file by the following:    ```javascript  import React, { useEffect, useState } from \"react\";  import \"./App.css\";    const App = () => {    const [value1, setValue1] = useState(\"default value1\");    const [value2, setValue2] = useState(\"default value2\");      useEffect(() => {      setTimeout(() => {        setValue1(\"done waiting for value1\");      }, 1000);    });      useEffect(() => {      setTimeout(() => {        setValue2(\"done waiting for value2\");      }, 2000);    });    /* // this infinitely tries to load /test hence CPU usage too    useEffect(() => {      fetch(\"/test\").then(() => setValue1(\"done waiting for value1\"));    });      useEffect(() => {      fetch(\"/test\").then(() => setValue2(\"done waiting for value2\"));    });  */      return (      <div className=\"App\">        <p>value 1: {value1}</p>        <p>value 2: {value2}</p>      </div>    );  };    export default App;  ```  Upgrade to `@next` both react and react-dom. Then run this with `npm start`.    On both my linux machines I see:  ![image](https://user-images.githubusercontent.com/232478/48005568-0be5b880-e114-11e8-8aa8-99185ff10942.png)    Firefox starts eating 100% of CPU after a small amount of time. Chromium does the same.    **What is the expected behavior?**    I expect that my CPU usage stays low.    Obviously I could test the value of my `value1`and `value2` to not perform the operation if different than the default value but that might be complicated in some cases.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**        \"react\": \"16.7.0-alpha.0\",      \"react-dom\": \"16.7.0-alpha.0\",    firefox 63.0  Chromium 70.0.3538.77  Ubuntu 18.04",
        "human_words": "As far as I can understand, this is a bug.     **What is the current behavior?**    I have a simple app created with the CLI. I replaced the `App.js` file by the following:      Upgrade to `@next` both react and react-dom. Then run this with `npm start`.    On both my linux machines I see:  ![image](https://user-images.githubusercontent.com/232478/48005568-0be5b880-e114-11e8-8aa8-99185ff10942.png)    Firefox starts eating 100% of CPU after a small amount of time. Chromium does the same.    **What is the expected behavior?**    I expect that my CPU usage stays low.    Obviously I could test the value of my `value1`and `value2` to not perform the operation if different than the default value but that might be complicated in some cases.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**        \"react\": \"16.7.0-alpha.0\",      \"react-dom\": \"16.7.0-alpha.0\",    firefox 63.0  Chromium 70.0.3538.77  Ubuntu 18.04",
        "human_words_regrex": "As far as I can understand, this is a bug. **What is the current behavior?** I have a simple app created with the CLI. I replaced the `App.js` file by the following: Upgrade to `@next` both react and react-dom. Then run this with `npm start`. On both my linux machines I see: ! Firefox starts eating 100% of CPU after a small amount of time. Chromium does the same. **What is the expected behavior?** I expect that my CPU usage stays low. Obviously I could test the value of my `value1`and `value2` to not perform the operation if different than the default value but that might be complicated in some cases. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** \"react\": \"16.7.0-alpha.0\", \"react-dom\": \"16.7.0-alpha.0\", firefox 63.0 Chromium 70.0.3538.77 Ubuntu 18.04",
        "human_words_stopwords_removal_lemmatization": "far understand , bug . * * current behavior ? * * simple app created cli . replaced ` app.js ` file following : upgrade ` @ next ` react react-dom . run ` npm start ` . linux machine see : ! firefox start eating 100 % cpu small amount time . chromium . * * expected behavior ? * * expect cpu usage stay low . obviously could test value ` value1 ` ` value2 ` perform operation different default value might complicated case . * * version react , browser / o affected issue ? work previous version react ? * * `` react '' : `` 16.7.0-alpha.0 '' , `` react-dom '' : `` 16.7.0-alpha.0 '' , firefox 63.0 chromium 70.0.3538.77 ubuntu 18.04",
        "title_stopwords_removal_lemmatization": "simple react app ( using hook ) start using 100 % cpu"
    },
    {
        "issue_id": 376767583,
        "title": "Hooks, useImperativeMethods and multiple refs",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-11-02T11:11:35Z",
        "status": "closed",
        "description": "I am not sure where to post this question, feel free to delete it if it doesn't belong here. \r\n\r\nHere is a small Accordion with AccordionPanels. It uses hooks to manage state and when some panel is opened we need to scroll to it, so we need a ref. \r\n\r\nMy question is: Is this how hooks are supposed to be used? Do you see some problems with this approach?\r\n\r\n**App.js**\r\n```js\r\nfunction App() {\r\n    const panels = [\r\n        'Panel 1',\r\n        'Panel 2',\r\n        'Panel 3'\r\n    ];\r\n\r\n    const [currentIndex, onClick, refs] = useAccordion(panels.length);\r\n\r\n    return <Accordion>\r\n        {panels.map((panel, index) => (\r\n            <AccordionPanel\r\n                ref={refs[index]}\r\n                key={index}\r\n                label={panel}\r\n                isOpen={currentIndex === index}\r\n                onClick={() => onClick(index)}\r\n            />\r\n        ))}\r\n    </Accordion>;\r\n}\r\n```\r\n\r\n**Accordion.js**\r\n```js\r\nfunction useAccordion(panelsCount) {\r\n    const [currentIndex, setCurrentIndex] = useState(undefined);\r\n    let refs = {};\r\n\r\n    for (let i = 0; i <= panelsCount; i++) {\r\n        refs[i] = createRef();\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (currentIndex !== undefined) {\r\n            refs[currentIndex].current.scrollTo();\r\n        }\r\n    }, [currentIndex]);\r\n\r\n    function onClick(newIndex) {\r\n        setCurrentIndex(currentIndex === newIndex ? undefined : newIndex);\r\n    }\r\n\r\n    return [currentIndex, onClick, refs];\r\n}\r\n\r\nconst AccordionPanel = React.forwardRef((props, ref) => {\r\n    const containerRef = useRef();\r\n\r\n    useImperativeMethods(ref, () => ({\r\n        scrollTo: () => console.info('do scrolling')\r\n    }));\r\n\r\n    return <div onClick={props.onClick} ref={containerRef}>\r\n        {props.label}, {props.isOpen && 'open'}\r\n    </div>;\r\n});\r\n\r\nfunction Accordion(props) {\r\n    return <div>{props.children}</div>;\r\n}\r\n```",
        "remove_template_description": "I am not sure where to post this question, feel free to delete it if it doesn't belong here.     Here is a small Accordion with AccordionPanels. It uses hooks to manage state and when some panel is opened we need to scroll to it, so we need a ref.     My question is: Is this how hooks are supposed to be used? Do you see some problems with this approach?    **App.js**  ```js  function App() {      const panels = [          'Panel 1',          'Panel 2',          'Panel 3'      ];        const [currentIndex, onClick, refs] = useAccordion(panels.length);        return <Accordion>          {panels.map((panel, index) => (              <AccordionPanel                  ref={refs[index]}                  key={index}                  label={panel}                  isOpen={currentIndex === index}                  onClick={() => onClick(index)}              />          ))}      </Accordion>;  }  ```    **Accordion.js**  ```js  function useAccordion(panelsCount) {      const [currentIndex, setCurrentIndex] = useState(undefined);      let refs = {};        for (let i = 0; i <= panelsCount; i++) {          refs[i] = createRef();      }        useEffect(() => {          if (currentIndex !== undefined) {              refs[currentIndex].current.scrollTo();          }      }, [currentIndex]);        function onClick(newIndex) {          setCurrentIndex(currentIndex === newIndex ? undefined : newIndex);      }        return [currentIndex, onClick, refs];  }    const AccordionPanel = React.forwardRef((props, ref) => {      const containerRef = useRef();        useImperativeMethods(ref, () => ({          scrollTo: () => console.info('do scrolling')      }));        return <div onClick={props.onClick} ref={containerRef}>          {props.label}, {props.isOpen && 'open'}      </div>;  });    function Accordion(props) {      return <div>{props.children}</div>;  }  ```",
        "human_words": "I am not sure where to post this question, feel free to delete it if it doesn't belong here.     Here is a small Accordion with AccordionPanels. It uses hooks to manage state and when some panel is opened we need to scroll to it, so we need a ref.     My question is: Is this how hooks are supposed to be used? Do you see some problems with this approach?    **App.js**      **Accordion.js**  ",
        "human_words_regrex": "I am not sure where to post this question, feel free to delete it if it doesn't belong here. Here is a small Accordion with AccordionPanels. It uses hooks to manage state and when some panel is opened we need to scroll to it, so we need a ref. My question is: Is this how hooks are supposed to be used? Do you see some problems with this approach? **App.js** **Accordion.js** ",
        "human_words_stopwords_removal_lemmatization": "sure post question , feel free delete n't belong . small accordion accordionpanels . us hook manage state panel opened need scroll , need ref . question : hook supposed used ? see problem approach ? * * app.js * * * * accordion.js * *",
        "title_stopwords_removal_lemmatization": "hook , useimperativemethods multiple ref"
    },
    {
        "issue_id": 376140752,
        "title": "Using both getDerivedStateFromError and getDerivedStateFromProps can be a foot gun",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-10-31T20:10:47Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nIf `componentDidCatch` and/or `getDerivedStateFromError` put the component in a state that avoids the cause of the error, and `getDerivedStateFromProps` reverts that state change, the error boundary will (obviously) fail to avert disaster.\r\n\r\nhttps://codesandbox.io/s/pj0lwxk15j\r\n\r\nIt sounds very obvious when simplified like this, but when my team updated to React 16.5.x (and 16.6.0), suddenly this started happening for us. So something changed internally, but it's hard to pinpoint what. Unfortunately I haven't been able to create a small repro for that specific case that works in 16.4.2 but not 16.5.0 \u2013 so I'm making this issue about avoiding the cause in the first place.\r\n\r\n**What is the expected behavior?**\r\n\r\nNaively, my thinking is that because errors are more exceptional, let the state from error handlers take precedence. Probably there's a reason why this can't happen so a warning of some kind when this can happen would be nice. Two ways to do this comes to mind:\r\n\r\n1. Cross-check that keys in state from `getDerivedStateFromProps` or `setState` in `componentDidCatch` don't collide with `getDerivedStateFromError` (sounds a bit far fetched?)\r\n2. Be more explicit in documentation for error boundaries about how `getDerivedStateFromProps` will run last so that a developer can consider this case\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n16.5.0 and up (16.4.2 behaves a bit differently \u2013\u00a0see above), all platforms/browsers.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    If `componentDidCatch` and/or `getDerivedStateFromError` put the component in a state that avoids the cause of the error, and `getDerivedStateFromProps` reverts that state change, the error boundary will (obviously) fail to avert disaster.    https://codesandbox.io/s/pj0lwxk15j    It sounds very obvious when simplified like this, but when my team updated to React 16.5.x (and 16.6.0), suddenly this started happening for us. So something changed internally, but it's hard to pinpoint what. Unfortunately I haven't been able to create a small repro for that specific case that works in 16.4.2 but not 16.5.0 \u2013 so I'm making this issue about avoiding the cause in the first place.    **What is the expected behavior?**    Naively, my thinking is that because errors are more exceptional, let the state from error handlers take precedence. Probably there's a reason why this can't happen so a warning of some kind when this can happen would be nice. Two ways to do this comes to mind:    1. Cross-check that keys in state from `getDerivedStateFromProps` or `setState` in `componentDidCatch` don't collide with `getDerivedStateFromError` (sounds a bit far fetched?)  2. Be more explicit in documentation for error boundaries about how `getDerivedStateFromProps` will run last so that a developer can consider this case    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.5.0 and up (16.4.2 behaves a bit differently \u2013\u00a0see above), all platforms/browsers.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    If `componentDidCatch` and/or `getDerivedStateFromError` put the component in a state that avoids the cause of the error, and `getDerivedStateFromProps` reverts that state change, the error boundary will (obviously) fail to avert disaster.    https://codesandbox.io/s/pj0lwxk15j    It sounds very obvious when simplified like this, but when my team updated to React 16.5.x (and 16.6.0), suddenly this started happening for us. So something changed internally, but it's hard to pinpoint what. Unfortunately I haven't been able to create a small repro for that specific case that works in 16.4.2 but not 16.5.0 \u2013 so I'm making this issue about avoiding the cause in the first place.    **What is the expected behavior?**    Naively, my thinking is that because errors are more exceptional, let the state from error handlers take precedence. Probably there's a reason why this can't happen so a warning of some kind when this can happen would be nice. Two ways to do this comes to mind:    1. Cross-check that keys in state from `getDerivedStateFromProps` or `setState` in `componentDidCatch` don't collide with `getDerivedStateFromError` (sounds a bit far fetched?)  2. Be more explicit in documentation for error boundaries about how `getDerivedStateFromProps` will run last so that a developer can consider this case    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.5.0 and up (16.4.2 behaves a bit differently \u2013\u00a0see above), all platforms/browsers.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** If `componentDidCatch` and/or `getDerivedStateFromError` put the component in a state that avoids the cause of the error, and `getDerivedStateFromProps` reverts that state change, the error boundary will (obviously) fail to avert disaster.  It sounds very obvious when simplified like this, but when my team updated to React 16.5.x (and 16.6.0), suddenly this started happening for us. So something changed internally, but it's hard to pinpoint what. Unfortunately I haven't been able to create a small repro for that specific case that works in 16.4.2 but not 16.5.0 \u2013 so I'm making this issue about avoiding the cause in the first place. **What is the expected behavior?** Naively, my thinking is that because errors are more exceptional, let the state from error handlers take precedence. Probably there's a reason why this can't happen so a warning of some kind when this can happen would be nice. Two ways to do this comes to mind: 1. Cross-check that keys in state from `getDerivedStateFromProps` or `setState` in `componentDidCatch` don't collide with `getDerivedStateFromError` (sounds a bit far fetched?) 2. Be more explicit in documentation for error boundaries about how `getDerivedStateFromProps` will run last so that a developer can consider this case **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.5.0 and up (16.4.2 behaves a bit differently \u2013 see above), all platforms/browsers.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * ` componentdidcatch ` and/or ` getderivedstatefromerror ` put component state avoids cause error , ` getderivedstatefromprops ` reverts state change , error boundary ( obviously ) fail avert disaster . sound obvious simplified like , team updated react 16.5.x ( 16.6.0 ) , suddenly started happening u . something changed internally , 's hard pinpoint . unfortunately n't able create small repro specific case work 16.4.2 16.5.0 \u2013 'm making issue avoiding cause first place . * * expected behavior ? * * naively , thinking error exceptional , let state error handler take precedence . probably 's reason ca n't happen warning kind happen would nice . two way come mind : 1. cross-check key state ` getderivedstatefromprops ` ` setstate ` ` componentdidcatch ` n't collide ` getderivedstatefromerror ` ( sound bit far fetched ? ) 2. explicit documentation error boundary ` getderivedstatefromprops ` run last developer consider case * * version react , browser / o affected issue ? work previous version react ? * * 16.5.0 ( 16.4.2 behaves bit differently \u2013 see ) , platforms/browsers .",
        "title_stopwords_removal_lemmatization": "using getderivedstatefromerror getderivedstatefromprops foot gun"
    },
    {
        "issue_id": 374954758,
        "title": "iOS 12.0 and above causes strange click/touch-behavior",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-10-29T10:43:20Z",
        "status": "closed",
        "description": "Bug in iOS 12.0 and above, both simulator and device.\r\n\r\nIm not sure exactly what's causing the problem, but click/touch events gets triggered outside the buttons (red squares) and they trigger the buttons inside the yellow squares, almost like the buttons in the yellow squares are flowing over.\r\n\r\n\"react\": \"^16.6.0-alpha.8af6728\",\r\n\"react-native\": \"^0.57.4\",\r\n\"react-navigation\": \"^2.18.2\",\r\n\r\n\r\n![simulator-screen-shot---iphone-8---2018-10-29-at-11 38 16](https://user-images.githubusercontent.com/16066712/47644904-b89dc400-db6f-11e8-9910-3840e02e93af.jpg)\r\n\r\n",
        "remove_template_description": "Bug in iOS 12.0 and above, both simulator and device.    Im not sure exactly what's causing the problem, but click/touch events gets triggered outside the buttons (red squares) and they trigger the buttons inside the yellow squares, almost like the buttons in the yellow squares are flowing over.    \"react\": \"^16.6.0-alpha.8af6728\",  \"react-native\": \"^0.57.4\",  \"react-navigation\": \"^2.18.2\",      ![simulator-screen-shot---iphone-8---2018-10-29-at-11 38 16](https://user-images.githubusercontent.com/16066712/47644904-b89dc400-db6f-11e8-9910-3840e02e93af.jpg)",
        "human_words": "Bug in iOS 12.0 and above, both simulator and device.    Im not sure exactly what's causing the problem, but click/touch events gets triggered outside the buttons (red squares) and they trigger the buttons inside the yellow squares, almost like the buttons in the yellow squares are flowing over.    \"react\": \"^16.6.0-alpha.8af6728\",  \"react-native\": \"^0.57.4\",  \"react-navigation\": \"^2.18.2\",      ![simulator-screen-shot---iphone-8---2018-10-29-at-11 38 16](https://user-images.githubusercontent.com/16066712/47644904-b89dc400-db6f-11e8-9910-3840e02e93af.jpg)",
        "human_words_regrex": "Bug in iOS 12.0 and above, both simulator and device. Im not sure exactly what's causing the problem, but click/touch events gets triggered outside the buttons (red squares) and they trigger the buttons inside the yellow squares, almost like the buttons in the yellow squares are flowing over. \"react\": \"^16.6.0-alpha.8af6728\", \"react-native\": \"^0.57.4\", \"react-navigation\": \"^2.18.2\", !",
        "human_words_stopwords_removal_lemmatization": "bug io 12.0 , simulator device . im sure exactly 's causing problem , click/touch event get triggered outside button ( red square ) trigger button inside yellow square , almost like button yellow square flowing . `` react '' : `` ^16.6.0-alpha.8af6728 '' , `` react-native '' : `` ^0.57.4 '' , `` react-navigation '' : `` ^2.18.2 '' , !",
        "title_stopwords_removal_lemmatization": "io 12.0 cause strange click/touch-behavior"
    },
    {
        "issue_id": 374733347,
        "title": "React Hooks with Typescript via with Babel 7",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-10-28T09:14:46Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nQuestion/Bug\r\n\r\n**What is the current behavior?**\r\n\r\nI'm trying to use hooks with a typescript project which uses babel 7 but I'm getting the error **Uncaught Error: Hooks can only be called inside the body of a function component.**\r\n\r\nI guess I'm missing something trivial here but I couldn't figure out what it is. A minimal reproduction of the issue is available at https://github.com/Raathigesh/react-hooks-typescript-with-babel-issue\r\n\r\n```javascript\r\nimport React, { useState } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nfunction Hello() {\r\n  const [isDrawerOpen, setDrawerOpen] = useState(false);\r\n  return <div>Hello</div>;\r\n}\r\n\r\nReactDOM.render(<Hello />, document.getElementById(\"root\"));\r\n```\r\n\r\nAny pointers would be helpful.\r\n\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Question/Bug    **What is the current behavior?**    I'm trying to use hooks with a typescript project which uses babel 7 but I'm getting the error **Uncaught Error: Hooks can only be called inside the body of a function component.**    I guess I'm missing something trivial here but I couldn't figure out what it is. A minimal reproduction of the issue is available at https://github.com/Raathigesh/react-hooks-typescript-with-babel-issue    ```javascript  import React, { useState } from \"react\";  import ReactDOM from \"react-dom\";    function Hello() {    const [isDrawerOpen, setDrawerOpen] = useState(false);    return <div>Hello</div>;  }    ReactDOM.render(<Hello />, document.getElementById(\"root\"));  ```    Any pointers would be helpful.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Question/Bug    **What is the current behavior?**    I'm trying to use hooks with a typescript project which uses babel 7 but I'm getting the error **Uncaught Error: Hooks can only be called inside the body of a function component.**    I guess I'm missing something trivial here but I couldn't figure out what it is. A minimal reproduction of the issue is available at https://github.com/Raathigesh/react-hooks-typescript-with-babel-issue        Any pointers would be helpful.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Question/Bug **What is the current behavior?** I'm trying to use hooks with a typescript project which uses babel 7 but I'm getting the error **Uncaught Error: Hooks can only be called inside the body of a function component.** I guess I'm missing something trivial here but I couldn't figure out what it is. A minimal reproduction of the issue is available at  Any pointers would be helpful.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * question/bug * * current behavior ? * * 'm trying use hook typescript project us babel 7 'm getting error * * uncaught error : hook called inside body function component . * * guess 'm missing something trivial could n't figure . minimal reproduction issue available pointer would helpful .",
        "title_stopwords_removal_lemmatization": "react hook typescript via babel 7"
    },
    {
        "issue_id": 374587589,
        "title": "Hooks + multiple instances of React",
        "label": [
            "Type: Discussion",
            "Component: Hooks"
        ],
        "date": "2018-10-27T00:34:08Z",
        "status": "open",
        "description": "# To people coming from search: please [read this page first](https://reactjs.org/warnings/invalid-hook-call-warning.html). It contains most common possible fixes!\r\n\r\n\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nEnhancement\r\n\r\n**What is the current behavior?**\r\n\r\nI had multiple instances of React by mistake.\r\n\r\nWhen trying to use hooks, got this error:\r\n`hooks can only be called inside the body of a function component`\r\n\r\nWhich is not correct since I was using function components. Took me a while to find the real cause of the issue.\r\n\r\n**What is the expected behavior?**\r\n\r\nShow the correct error message. Maybe detect that the app has multiple instances of React and say that it may be the reason of bugs. ",
        "remove_template_description": "# To people coming from search: please [read this page first](https://reactjs.org/warnings/invalid-hook-call-warning.html). It contains most common possible fixes!        **Do you want to request a *feature* or report a *bug*?**    Enhancement    **What is the current behavior?**    I had multiple instances of React by mistake.    When trying to use hooks, got this error:  `hooks can only be called inside the body of a function component`    Which is not correct since I was using function components. Took me a while to find the real cause of the issue.    **What is the expected behavior?**    Show the correct error message. Maybe detect that the app has multiple instances of React and say that it may be the reason of bugs.",
        "human_words": "# To people coming from search: please [read this page first](https://reactjs.org/warnings/invalid-hook-call-warning.html). It contains most common possible fixes!        **Do you want to request a *feature* or report a *bug*?**    Enhancement    **What is the current behavior?**    I had multiple instances of React by mistake.    When trying to use hooks, got this error:  `hooks can only be called inside the body of a function component`    Which is not correct since I was using function components. Took me a while to find the real cause of the issue.    **What is the expected behavior?**    Show the correct error message. Maybe detect that the app has multiple instances of React and say that it may be the reason of bugs.",
        "human_words_regrex": "# To people coming from search: please . It contains most common possible fixes! **Do you want to request a *feature* or report a *bug*?** Enhancement **What is the current behavior?** I had multiple instances of React by mistake. When trying to use hooks, got this error: `hooks can only be called inside the body of a function component` Which is not correct since I was using function components. Took me a while to find the real cause of the issue. **What is the expected behavior?** Show the correct error message. Maybe detect that the app has multiple instances of React and say that it may be the reason of bugs.",
        "human_words_stopwords_removal_lemmatization": "# people coming search : please . contains common possible fix ! * * want request * feature * report * bug * ? * * enhancement * * current behavior ? * * multiple instance react mistake . trying use hook , got error : ` hook called inside body function component ` correct since using function component . took find real cause issue . * * expected behavior ? * * show correct error message . maybe detect app multiple instance react say may reason bug .",
        "title_stopwords_removal_lemmatization": "hook + multiple instance react"
    },
    {
        "issue_id": 362967976,
        "title": "DOM Event Mount Target Considerations",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2018-09-23T19:00:28Z",
        "status": "closed",
        "description": "Given that we\u2019re considering a [rewrite of the event system](https://github.com/facebook/react/pull/13613#issuecomment-420286431) and are thinking about [attaching events to the React root](https://github.com/facebook/react/issues/13525), I thought it would be fitting to explore all our options on where to mount the event listeners a little and combine all the knowledge that is scattered across the repo.\r\n\r\nIn general, there are three candidates for attaching event listeners:\r\n\r\n1. Document  Listeners\r\n2. React Root Listeners\r\n3. Element Listeners\r\n\r\nEvery option comes with shortcomings and I want to summarize what we\u2019ve learned over the years.\r\n\r\n## Document Listeners\r\n\r\nHistorically, React always listened at the document level and implemented a synthetic event system to simulate capture and bubble phases inside the React tree. Most event listeners are listening at the bubble phase which means that users can still add capture-level document listeners and see them fire before React will process the event.\r\n\r\nAdditionally, not all events bubble in the DOM. To support bubbling for all events, React sometimes eagerly adds event listeners (media events, for example) or listens to the capture phase instead.\r\n\r\nWhile it usually works to leave the React event system and attach native listeners when needed, there are certain caveats that come with that. One example is that calling `.stopPropagation()` on a capture document-level listener has no effect (#12518, https://github.com/facebook/react/issues/285#issuecomment-253502585/). Another implication of this is that interoperability between other React roots or third-party frameworks will behave unexpectedly (#8117, #8693).\r\n\r\nSome browsers have certain optimizations in place that make handling of document listeners complicated (Safari is not properly bubbling when document listeners are used #12717, #12989 and Chrome doesn\u2019t respect preventDefault() on touch start at the document level https://github.com/facebook/react/issues/11530#issuecomment-413704069).\r\n\r\nWe\u2019re also never cleaning up document-level listeners (#7128).\r\n\r\nThere are certain benefits of this solution as well. Our current event system can use the same \"event bus\" to implement polyfills that require document based listeners. Implementation of portal-bubbling is easier because we only need to ensure that we\u2019re already listening at the document of the portal target (more on that later).\r\n\r\n## React Root Listeners (#2043)\r\n\r\nOne solution to the issues outlined above is the use of React roots as the mount target for events. This would still rely on event delegation and would require a synthetic event system.\r\n\r\nRoot level listeners would certainly help make bubbling more robust when using multiple React instances since we no longer add all listeners at the same level. This will, however, only work for bubbling. Some events use capturing (`scroll`, `focus`, `blur`, `cancel`, and `close`) and would fire in an inverse bubble order (https://github.com/facebook/react/pull/8117#issuecomment-257024618, https://github.com/facebook/react/pull/12919#issuecomment-392556395). Capture handlers between multiple roots will also always fire in the wrong order.\r\n\r\nPortal bubbling will also become more complicated since we have to find out if the portal root is inside the react-root to see if we need to attach listeners to the portal root as well. Consider the following example, where we need to add listeners to the `#react-root` as well as the `#portal-root`:\r\n\r\n```html\r\n<body>\r\n  <div id=\"react-root\"></div>\r\n  <div id=\"portal-root\"></div>\r\n</body>\r\n```\r\n\r\nAnd compare it with this example, where we don\u2019t need that:\r\n\r\n```html\r\n<body>\r\n  <div id=\"react-root\">\r\n    <div id=\"portal-root\"></div>\r\n  </div>\r\n</body>\r\n```\r\n\r\nI\u2019ve compiled a list of previous implementation attempts and the issues that were pointed out as well:\r\n\r\n| Date          | PR                                          | Issues                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| ------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Oct&nbsp;2016 | https://github.com/facebook/react/pull/8117 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/8117#issuecomment-256498143)</li><li>Issues when using the same instance of React (https://github.com/facebook/react/pull/8117#issuecomment-256503428)</li><li>Captured events (like focus in Firefox) will fire in reverse order (https://github.com/facebook/react/pull/8117#issuecomment-257024618)</li><li>iOS Tap Highlight (https://github.com/facebook/react/pull/8117#issuecomment-257105712, https://github.com/facebook/react/issues/12989#issuecomment-414266839)</li><li>Select Shims (https://github.com/facebook/react/pull/8117#issuecomment-270206114)</li></ul> |\r\n| Jun&nbsp;2016 | https://github.com/facebook/react/pull/7088 | <ul><li>Firefox v8.01 mousemove events (https://github.com/facebook/react/pull/7088#issuecomment-227191272)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| Aug&nbsp;2014 | https://github.com/facebook/react/pull/2050 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/2050#issue-19863619)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n\r\nIt\u2019s probably possible to work around some/all of the issues. The invalid capturing order can be worked around by adding both a bubble and a capture listener for regular events and then only trigger the appropriate phase. The shims can probably be rewritten and if they need the document, additional listeners could be added. iOS tap highlight could be disabled via CSS. To get rid of some of the edge cases around events that don\u2019t bubble in the browser, we should consider deprecating support for this all together.\r\n\r\n### New Features\r\n\r\nSince we\u2019re taking the time to rethink the event system, I also want us to think about: **Passive Event Listeners (#6436)** and **Web Components (#7901, #9242)**.\r\n\r\nI think we _can_ (albeit with an additional implementation effort) support passive event systems while keep using event delegation: We\u2019d add two different listeners (one for capturing and one for bubbling) and handle them as completely different events. \r\n\r\nSupport for shadow roots is a bit more complex as event delegation doesn\u2019t really make sense there. We can\u2019t easily consider the shadow root the same as a React root or a portal root since we can\u2019t rely on adding listeners to the `#react-root` if it\u2019s the parent of a shadow root. Consider the following case:\r\n\r\n```html\r\n<div id=\"react-root\">\r\n  <!-- Listening on #react-root will catch events inside the #portal-root -->\r\n  <div id=\"portal-root\"></div> \r\n  <!-- Listening on #react-root will NOT catch events inside the #shadow-root -->\r\n  <my-component id=\"shadow-root\"></my-component>\r\n</div>\r\n```\r\n\r\nThere\u2019s a handy comparison of Custom Elements support of different JavaScript framework and [React can definitely do better](https://custom-elements-everywhere.com/#react). With the planned changes to the event system, we should work on that.\r\n\r\n## Element Listeners (sort of #4751)\r\n\r\nThere\u2019s a more radical approach to changing the event system and that is to get rid of event delegation altogether. This is what happens in [Preact](https://github.com/developit/preact/wiki/Differences-to-React#whats-missing), [react-dom-lite](https://github.com/jquense/react-dom-lite/blob/master/src/events/index.js#L35-L36), [Vue.js](https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/test/unit/modules/vdom/modules/events.spec.js#L5-L14), and probably other frameworks as well (We should research Ember and Angular at this point).\r\n\r\nIn this case, it\u2019s trivial to add support for passive event listeners and bubble/capture will behave as expected. It also allows us to completely remove the need of the synthetic event system as we could rely on the browser for this. We also know that some browsers can better optimize certain events if they are attached directly to the element (#1254, #1964).\r\n\r\nI can think of at least two major roadblocks for this, though:\r\n\r\n1. **Performance** \r\n   Event delegation avoids the need to `addEventListener()` for every element with an event handler. We should figure out how significant this overhead really is - especially while considering the possible bundle size improvement that should make initial-render faster again. This needs to be compared at a real-world application. \r\n\r\n   While doing some [very rough benchmarking](https://github.com/philipp-spiess/react-event-benchmark/tree/755b0e208e6ae920f5b44573f09ffb519eed47ba) (It\u2019s a microbenchmark so the outcomes are not representative for real apps) of an event-system less React, I noticed that there\u2019s another feature of event delegation that is often overlooked: setState batching. Right now, React knows when all event listeners are called and can batch setState calls until this is the case. I looked a bit into a [potential callback mechanism](https://github.com/philipp-spiess/request-post-events-callback) that would fire when all events are processed and before the next frame is drawn but I don\u2019t think this is possible in all browsers. We have to evaluate the performance implications on a real-world application to see how bad this is and how often setState batching is occurring (we could still batch inside the same event listener).\r\n\r\n2. **Portal Bubbling**\r\n   The big issue I see with portal bubbling is that we still need to use event delegation on the portal roots to catch events that are only listened to in parents. In the write-up about React Fire (#13525), @gaearon\u00a0mentioned that we could use re-dispatching of native events but that would still require us to set up the listeners first.\r\n\r\n## Further Considerations\r\n\r\n- The whole synthetic event system currently accounts for **~20%** of the React DOM bundle size. [Back in July](https://github.com/philipp-spiess/react/commit/b4fda332b2be55e1b12021bd60209c6b442c3cda) I worked on an example that removed everything event related and added a tiny Preact-like system to find out how much we can save. I didn\u2019t look into edge cases too much but I already got most of the tests to pass.\r\n- In general we might also consider adding an API for installing global DOM event handlers (#285) since the upcoming concurrent mode will make it more complicated to listen to arbitrary non React-controlled events (because of them possibly being fired during render time slices). This discussion is out of scope for this write-up though but maybe good to keep in mind.\r\n\r\nThat\u2019s all I have for now. I\u2019m especially curious for ways how we could implement portal bubbling when using element listeners - I\u2019d say this is the biggest uncertainty I have right now. \ud83d\ude42 \r\n",
        "remove_template_description": "Given that we\u2019re considering a [rewrite of the event system](https://github.com/facebook/react/pull/13613#issuecomment-420286431) and are thinking about [attaching events to the React root](https://github.com/facebook/react/issues/13525), I thought it would be fitting to explore all our options on where to mount the event listeners a little and combine all the knowledge that is scattered across the repo.    In general, there are three candidates for attaching event listeners:    1. Document  Listeners  2. React Root Listeners  3. Element Listeners    Every option comes with shortcomings and I want to summarize what we\u2019ve learned over the years.    ## Document Listeners    Historically, React always listened at the document level and implemented a synthetic event system to simulate capture and bubble phases inside the React tree. Most event listeners are listening at the bubble phase which means that users can still add capture-level document listeners and see them fire before React will process the event.    Additionally, not all events bubble in the DOM. To support bubbling for all events, React sometimes eagerly adds event listeners (media events, for example) or listens to the capture phase instead.    While it usually works to leave the React event system and attach native listeners when needed, there are certain caveats that come with that. One example is that calling `.stopPropagation()` on a capture document-level listener has no effect (#12518, https://github.com/facebook/react/issues/285#issuecomment-253502585/). Another implication of this is that interoperability between other React roots or third-party frameworks will behave unexpectedly (#8117, #8693).    Some browsers have certain optimizations in place that make handling of document listeners complicated (Safari is not properly bubbling when document listeners are used #12717, #12989 and Chrome doesn\u2019t respect preventDefault() on touch start at the document level https://github.com/facebook/react/issues/11530#issuecomment-413704069).    We\u2019re also never cleaning up document-level listeners (#7128).    There are certain benefits of this solution as well. Our current event system can use the same \"event bus\" to implement polyfills that require document based listeners. Implementation of portal-bubbling is easier because we only need to ensure that we\u2019re already listening at the document of the portal target (more on that later).    ## React Root Listeners (#2043)    One solution to the issues outlined above is the use of React roots as the mount target for events. This would still rely on event delegation and would require a synthetic event system.    Root level listeners would certainly help make bubbling more robust when using multiple React instances since we no longer add all listeners at the same level. This will, however, only work for bubbling. Some events use capturing (`scroll`, `focus`, `blur`, `cancel`, and `close`) and would fire in an inverse bubble order (https://github.com/facebook/react/pull/8117#issuecomment-257024618, https://github.com/facebook/react/pull/12919#issuecomment-392556395). Capture handlers between multiple roots will also always fire in the wrong order.    Portal bubbling will also become more complicated since we have to find out if the portal root is inside the react-root to see if we need to attach listeners to the portal root as well. Consider the following example, where we need to add listeners to the `#react-root` as well as the `#portal-root`:    ```html  <body>    <div id=\"react-root\"></div>    <div id=\"portal-root\"></div>  </body>  ```    And compare it with this example, where we don\u2019t need that:    ```html  <body>    <div id=\"react-root\">      <div id=\"portal-root\"></div>    </div>  </body>  ```    I\u2019ve compiled a list of previous implementation attempts and the issues that were pointed out as well:    | Date          | PR                                          | Issues                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |  | ------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  | Oct&nbsp;2016 | https://github.com/facebook/react/pull/8117 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/8117#issuecomment-256498143)</li><li>Issues when using the same instance of React (https://github.com/facebook/react/pull/8117#issuecomment-256503428)</li><li>Captured events (like focus in Firefox) will fire in reverse order (https://github.com/facebook/react/pull/8117#issuecomment-257024618)</li><li>iOS Tap Highlight (https://github.com/facebook/react/pull/8117#issuecomment-257105712, https://github.com/facebook/react/issues/12989#issuecomment-414266839)</li><li>Select Shims (https://github.com/facebook/react/pull/8117#issuecomment-270206114)</li></ul> |  | Jun&nbsp;2016 | https://github.com/facebook/react/pull/7088 | <ul><li>Firefox v8.01 mousemove events (https://github.com/facebook/react/pull/7088#issuecomment-227191272)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |  | Aug&nbsp;2014 | https://github.com/facebook/react/pull/2050 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/2050#issue-19863619)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |    It\u2019s probably possible to work around some/all of the issues. The invalid capturing order can be worked around by adding both a bubble and a capture listener for regular events and then only trigger the appropriate phase. The shims can probably be rewritten and if they need the document, additional listeners could be added. iOS tap highlight could be disabled via CSS. To get rid of some of the edge cases around events that don\u2019t bubble in the browser, we should consider deprecating support for this all together.    ### New Features    Since we\u2019re taking the time to rethink the event system, I also want us to think about: **Passive Event Listeners (#6436)** and **Web Components (#7901, #9242)**.    I think we _can_ (albeit with an additional implementation effort) support passive event systems while keep using event delegation: We\u2019d add two different listeners (one for capturing and one for bubbling) and handle them as completely different events.     Support for shadow roots is a bit more complex as event delegation doesn\u2019t really make sense there. We can\u2019t easily consider the shadow root the same as a React root or a portal root since we can\u2019t rely on adding listeners to the `#react-root` if it\u2019s the parent of a shadow root. Consider the following case:    ```html  <div id=\"react-root\">    <!-- Listening on #react-root will catch events inside the #portal-root -->    <div id=\"portal-root\"></div>     <!-- Listening on #react-root will NOT catch events inside the #shadow-root -->    <my-component id=\"shadow-root\"></my-component>  </div>  ```    There\u2019s a handy comparison of Custom Elements support of different JavaScript framework and [React can definitely do better](https://custom-elements-everywhere.com/#react). With the planned changes to the event system, we should work on that.    ## Element Listeners (sort of #4751)    There\u2019s a more radical approach to changing the event system and that is to get rid of event delegation altogether. This is what happens in [Preact](https://github.com/developit/preact/wiki/Differences-to-React#whats-missing), [react-dom-lite](https://github.com/jquense/react-dom-lite/blob/master/src/events/index.js#L35-L36), [Vue.js](https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/test/unit/modules/vdom/modules/events.spec.js#L5-L14), and probably other frameworks as well (We should research Ember and Angular at this point).    In this case, it\u2019s trivial to add support for passive event listeners and bubble/capture will behave as expected. It also allows us to completely remove the need of the synthetic event system as we could rely on the browser for this. We also know that some browsers can better optimize certain events if they are attached directly to the element (#1254, #1964).    I can think of at least two major roadblocks for this, though:    1. **Performance**      Event delegation avoids the need to `addEventListener()` for every element with an event handler. We should figure out how significant this overhead really is - especially while considering the possible bundle size improvement that should make initial-render faster again. This needs to be compared at a real-world application.        While doing some [very rough benchmarking](https://github.com/philipp-spiess/react-event-benchmark/tree/755b0e208e6ae920f5b44573f09ffb519eed47ba) (It\u2019s a microbenchmark so the outcomes are not representative for real apps) of an event-system less React, I noticed that there\u2019s another feature of event delegation that is often overlooked: setState batching. Right now, React knows when all event listeners are called and can batch setState calls until this is the case. I looked a bit into a [potential callback mechanism](https://github.com/philipp-spiess/request-post-events-callback) that would fire when all events are processed and before the next frame is drawn but I don\u2019t think this is possible in all browsers. We have to evaluate the performance implications on a real-world application to see how bad this is and how often setState batching is occurring (we could still batch inside the same event listener).    2. **Portal Bubbling**     The big issue I see with portal bubbling is that we still need to use event delegation on the portal roots to catch events that are only listened to in parents. In the write-up about React Fire (#13525), @gaearon\u00a0mentioned that we could use re-dispatching of native events but that would still require us to set up the listeners first.    ## Further Considerations    - The whole synthetic event system currently accounts for **~20%** of the React DOM bundle size. [Back in July](https://github.com/philipp-spiess/react/commit/b4fda332b2be55e1b12021bd60209c6b442c3cda) I worked on an example that removed everything event related and added a tiny Preact-like system to find out how much we can save. I didn\u2019t look into edge cases too much but I already got most of the tests to pass.  - In general we might also consider adding an API for installing global DOM event handlers (#285) since the upcoming concurrent mode will make it more complicated to listen to arbitrary non React-controlled events (because of them possibly being fired during render time slices). This discussion is out of scope for this write-up though but maybe good to keep in mind.    That\u2019s all I have for now. I\u2019m especially curious for ways how we could implement portal bubbling when using element listeners - I\u2019d say this is the biggest uncertainty I have right now. \ud83d\ude42",
        "human_words": "Given that we\u2019re considering a [rewrite of the event system](https://github.com/facebook/react/pull/13613#issuecomment-420286431) and are thinking about [attaching events to the React root](https://github.com/facebook/react/issues/13525), I thought it would be fitting to explore all our options on where to mount the event listeners a little and combine all the knowledge that is scattered across the repo.    In general, there are three candidates for attaching event listeners:    1. Document  Listeners  2. React Root Listeners  3. Element Listeners    Every option comes with shortcomings and I want to summarize what we\u2019ve learned over the years.    ## Document Listeners    Historically, React always listened at the document level and implemented a synthetic event system to simulate capture and bubble phases inside the React tree. Most event listeners are listening at the bubble phase which means that users can still add capture-level document listeners and see them fire before React will process the event.    Additionally, not all events bubble in the DOM. To support bubbling for all events, React sometimes eagerly adds event listeners (media events, for example) or listens to the capture phase instead.    While it usually works to leave the React event system and attach native listeners when needed, there are certain caveats that come with that. One example is that calling `.stopPropagation()` on a capture document-level listener has no effect (#12518, https://github.com/facebook/react/issues/285#issuecomment-253502585/). Another implication of this is that interoperability between other React roots or third-party frameworks will behave unexpectedly (#8117, #8693).    Some browsers have certain optimizations in place that make handling of document listeners complicated (Safari is not properly bubbling when document listeners are used #12717, #12989 and Chrome doesn\u2019t respect preventDefault() on touch start at the document level https://github.com/facebook/react/issues/11530#issuecomment-413704069).    We\u2019re also never cleaning up document-level listeners (#7128).    There are certain benefits of this solution as well. Our current event system can use the same \"event bus\" to implement polyfills that require document based listeners. Implementation of portal-bubbling is easier because we only need to ensure that we\u2019re already listening at the document of the portal target (more on that later).    ## React Root Listeners (#2043)    One solution to the issues outlined above is the use of React roots as the mount target for events. This would still rely on event delegation and would require a synthetic event system.    Root level listeners would certainly help make bubbling more robust when using multiple React instances since we no longer add all listeners at the same level. This will, however, only work for bubbling. Some events use capturing (`scroll`, `focus`, `blur`, `cancel`, and `close`) and would fire in an inverse bubble order (https://github.com/facebook/react/pull/8117#issuecomment-257024618, https://github.com/facebook/react/pull/12919#issuecomment-392556395). Capture handlers between multiple roots will also always fire in the wrong order.    Portal bubbling will also become more complicated since we have to find out if the portal root is inside the react-root to see if we need to attach listeners to the portal root as well. Consider the following example, where we need to add listeners to the `#react-root` as well as the `#portal-root`:        And compare it with this example, where we don\u2019t need that:        I\u2019ve compiled a list of previous implementation attempts and the issues that were pointed out as well:    | Date          | PR                                          | Issues                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |  | ------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  | Oct&nbsp;2016 | https://github.com/facebook/react/pull/8117 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/8117#issuecomment-256498143)</li><li>Issues when using the same instance of React (https://github.com/facebook/react/pull/8117#issuecomment-256503428)</li><li>Captured events (like focus in Firefox) will fire in reverse order (https://github.com/facebook/react/pull/8117#issuecomment-257024618)</li><li>iOS Tap Highlight (https://github.com/facebook/react/pull/8117#issuecomment-257105712, https://github.com/facebook/react/issues/12989#issuecomment-414266839)</li><li>Select Shims (https://github.com/facebook/react/pull/8117#issuecomment-270206114)</li></ul> |  | Jun&nbsp;2016 | https://github.com/facebook/react/pull/7088 | <ul><li>Firefox v8.01 mousemove events (https://github.com/facebook/react/pull/7088#issuecomment-227191272)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |  | Aug&nbsp;2014 | https://github.com/facebook/react/pull/2050 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/2050#issue-19863619)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |    It\u2019s probably possible to work around some/all of the issues. The invalid capturing order can be worked around by adding both a bubble and a capture listener for regular events and then only trigger the appropriate phase. The shims can probably be rewritten and if they need the document, additional listeners could be added. iOS tap highlight could be disabled via CSS. To get rid of some of the edge cases around events that don\u2019t bubble in the browser, we should consider deprecating support for this all together.    ### New Features    Since we\u2019re taking the time to rethink the event system, I also want us to think about: **Passive Event Listeners (#6436)** and **Web Components (#7901, #9242)**.    I think we _can_ (albeit with an additional implementation effort) support passive event systems while keep using event delegation: We\u2019d add two different listeners (one for capturing and one for bubbling) and handle them as completely different events.     Support for shadow roots is a bit more complex as event delegation doesn\u2019t really make sense there. We can\u2019t easily consider the shadow root the same as a React root or a portal root since we can\u2019t rely on adding listeners to the `#react-root` if it\u2019s the parent of a shadow root. Consider the following case:        There\u2019s a handy comparison of Custom Elements support of different JavaScript framework and [React can definitely do better](https://custom-elements-everywhere.com/#react). With the planned changes to the event system, we should work on that.    ## Element Listeners (sort of #4751)    There\u2019s a more radical approach to changing the event system and that is to get rid of event delegation altogether. This is what happens in [Preact](https://github.com/developit/preact/wiki/Differences-to-React#whats-missing), [react-dom-lite](https://github.com/jquense/react-dom-lite/blob/master/src/events/index.js#L35-L36), [Vue.js](https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/test/unit/modules/vdom/modules/events.spec.js#L5-L14), and probably other frameworks as well (We should research Ember and Angular at this point).    In this case, it\u2019s trivial to add support for passive event listeners and bubble/capture will behave as expected. It also allows us to completely remove the need of the synthetic event system as we could rely on the browser for this. We also know that some browsers can better optimize certain events if they are attached directly to the element (#1254, #1964).    I can think of at least two major roadblocks for this, though:    1. **Performance**      Event delegation avoids the need to `addEventListener()` for every element with an event handler. We should figure out how significant this overhead really is - especially while considering the possible bundle size improvement that should make initial-render faster again. This needs to be compared at a real-world application.        While doing some [very rough benchmarking](https://github.com/philipp-spiess/react-event-benchmark/tree/755b0e208e6ae920f5b44573f09ffb519eed47ba) (It\u2019s a microbenchmark so the outcomes are not representative for real apps) of an event-system less React, I noticed that there\u2019s another feature of event delegation that is often overlooked: setState batching. Right now, React knows when all event listeners are called and can batch setState calls until this is the case. I looked a bit into a [potential callback mechanism](https://github.com/philipp-spiess/request-post-events-callback) that would fire when all events are processed and before the next frame is drawn but I don\u2019t think this is possible in all browsers. We have to evaluate the performance implications on a real-world application to see how bad this is and how often setState batching is occurring (we could still batch inside the same event listener).    2. **Portal Bubbling**     The big issue I see with portal bubbling is that we still need to use event delegation on the portal roots to catch events that are only listened to in parents. In the write-up about React Fire (#13525), @gaearon\u00a0mentioned that we could use re-dispatching of native events but that would still require us to set up the listeners first.    ## Further Considerations    - The whole synthetic event system currently accounts for **~20%** of the React DOM bundle size. [Back in July](https://github.com/philipp-spiess/react/commit/b4fda332b2be55e1b12021bd60209c6b442c3cda) I worked on an example that removed everything event related and added a tiny Preact-like system to find out how much we can save. I didn\u2019t look into edge cases too much but I already got most of the tests to pass.  - In general we might also consider adding an API for installing global DOM event handlers (#285) since the upcoming concurrent mode will make it more complicated to listen to arbitrary non React-controlled events (because of them possibly being fired during render time slices). This discussion is out of scope for this write-up though but maybe good to keep in mind.    That\u2019s all I have for now. I\u2019m especially curious for ways how we could implement portal bubbling when using element listeners - I\u2019d say this is the biggest uncertainty I have right now. \ud83d\ude42",
        "human_words_regrex": "Given that we\u2019re considering a  and are thinking about , I thought it would be fitting to explore all our options on where to mount the event listeners a little and combine all the knowledge that is scattered across the repo. In general, there are three candidates for attaching event listeners: 1. Document Listeners 2. React Root Listeners 3. Element Listeners Every option comes with shortcomings and I want to summarize what we\u2019ve learned over the years. ## Document Listeners Historically, React always listened at the document level and implemented a synthetic event system to simulate capture and bubble phases inside the React tree. Most event listeners are listening at the bubble phase which means that users can still add capture-level document listeners and see them fire before React will process the event. Additionally, not all events bubble in the DOM. To support bubbling for all events, React sometimes eagerly adds event listeners (media events, for example) or listens to the capture phase instead. While it usually works to leave the React event system and attach native listeners when needed, there are certain caveats that come with that. One example is that calling `.stopPropagation()` on a capture document-level listener has no effect (#12518,  Another implication of this is that interoperability between other React roots or third-party frameworks will behave unexpectedly (#8117, #8693). Some browsers have certain optimizations in place that make handling of document listeners complicated (Safari is not properly bubbling when document listeners are used #12717, #12989 and Chrome doesn\u2019t respect preventDefault() on touch start at the document level  We\u2019re also never cleaning up document-level listeners (#7128). There are certain benefits of this solution as well. Our current event system can use the same \"event bus\" to implement polyfills that require document based listeners. Implementation of portal-bubbling is easier because we only need to ensure that we\u2019re already listening at the document of the portal target (more on that later). ## React Root Listeners (#2043) One solution to the issues outlined above is the use of React roots as the mount target for events. This would still rely on event delegation and would require a synthetic event system. Root level listeners would certainly help make bubbling more robust when using multiple React instances since we no longer add all listeners at the same level. This will, however, only work for bubbling. Some events use capturing (`scroll`, `focus`, `blur`, `cancel`, and `close`) and would fire in an inverse bubble order (  Capture handlers between multiple roots will also always fire in the wrong order. Portal bubbling will also become more complicated since we have to find out if the portal root is inside the react-root to see if we need to attach listeners to the portal root as well. Consider the following example, where we need to add listeners to the `#react-root` as well as the `#portal-root`: And compare it with this example, where we don\u2019t need that: I\u2019ve compiled a list of previous implementation attempts and the issues that were pointed out as well: | Date | PR | Issues | | ------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | Oct&nbsp;2016 |  | Enter/Leave Shims ( when using the same instance of React ( events (like focus in Firefox) will fire in reverse order ( Tap Highlight (  Shims ( | | Jun&nbsp;2016 |  | Firefox v8.01 mousemove events ( | | Aug&nbsp;2014 |  | Enter/Leave Shims ( | It\u2019s probably possible to work around some/all of the issues. The invalid capturing order can be worked around by adding both a bubble and a capture listener for regular events and then only trigger the appropriate phase. The shims can probably be rewritten and if they need the document, additional listeners could be added. iOS tap highlight could be disabled via CSS. To get rid of some of the edge cases around events that don\u2019t bubble in the browser, we should consider deprecating support for this all together. ### New Features Since we\u2019re taking the time to rethink the event system, I also want us to think about: **Passive Event Listeners (#6436)** and **Web Components (#7901, #9242)**. I think we _can_ (albeit with an additional implementation effort) support passive event systems while keep using event delegation: We\u2019d add two different listeners (one for capturing and one for bubbling) and handle them as completely different events. Support for shadow roots is a bit more complex as event delegation doesn\u2019t really make sense there. We can\u2019t easily consider the shadow root the same as a React root or a portal root since we can\u2019t rely on adding listeners to the `#react-root` if it\u2019s the parent of a shadow root. Consider the following case: There\u2019s a handy comparison of Custom Elements support of different JavaScript framework and . With the planned changes to the event system, we should work on that. ## Element Listeners (sort of #4751) There\u2019s a more radical approach to changing the event system and that is to get rid of event delegation altogether. This is what happens in , , , and probably other frameworks as well (We should research Ember and Angular at this point). In this case, it\u2019s trivial to add support for passive event listeners and bubble/capture will behave as expected. It also allows us to completely remove the need of the synthetic event system as we could rely on the browser for this. We also know that some browsers can better optimize certain events if they are attached directly to the element (#1254, #1964). I can think of at least two major roadblocks for this, though: 1. **Performance** Event delegation avoids the need to `addEventListener()` for every element with an event handler. We should figure out how significant this overhead really is - especially while considering the possible bundle size improvement that should make initial-render faster again. This needs to be compared at a real-world application. While doing some  (It\u2019s a microbenchmark so the outcomes are not representative for real apps) of an event-system less React, I noticed that there\u2019s another feature of event delegation that is often overlooked: setState batching. Right now, React knows when all event listeners are called and can batch setState calls until this is the case. I looked a bit into a  that would fire when all events are processed and before the next frame is drawn but I don\u2019t think this is possible in all browsers. We have to evaluate the performance implications on a real-world application to see how bad this is and how often setState batching is occurring (we could still batch inside the same event listener). 2. **Portal Bubbling** The big issue I see with portal bubbling is that we still need to use event delegation on the portal roots to catch events that are only listened to in parents. In the write-up about React Fire (#13525), @gaearon mentioned that we could use re-dispatching of native events but that would still require us to set up the listeners first. ## Further Considerations - The whole synthetic event system currently accounts for **~20%** of the React DOM bundle size.  I worked on an example that removed everything event related and added a tiny Preact-like system to find out how much we can save. I didn\u2019t look into edge cases too much but I already got most of the tests to pass. - In general we might also consider adding an API for installing global DOM event handlers (#285) since the upcoming concurrent mode will make it more complicated to listen to arbitrary non React-controlled events (because of them possibly being fired during render time slices). This discussion is out of scope for this write-up though but maybe good to keep in mind. That\u2019s all I have for now. I\u2019m especially curious for ways how we could implement portal bubbling when using element listeners - I\u2019d say this is the biggest uncertainty I have right now. \ud83d\ude42",
        "human_words_stopwords_removal_lemmatization": "given \u2019 considering thinking , thought would fitting explore option mount event listener little combine knowledge scattered across repo . general , three candidate attaching event listener : 1. document listener 2. react root listener 3. element listener every option come shortcoming want summarize \u2019 learned year . # # document listener historically , react always listened document level implemented synthetic event system simulate capture bubble phase inside react tree . event listener listening bubble phase mean user still add capture-level document listener see fire react process event . additionally , event bubble dom . support bubbling event , react sometimes eagerly add event listener ( medium event , example ) listens capture phase instead . usually work leave react event system attach native listener needed , certain caveat come . one example calling ` .stoppropagation ( ) ` capture document-level listener effect ( # 12518 , another implication interoperability react root third-party framework behave unexpectedly ( # 8117 , # 8693 ) . browser certain optimization place make handling document listener complicated ( safari properly bubbling document listener used # 12717 , # 12989 chrome \u2019 respect preventdefault ( ) touch start document level \u2019 also never cleaning document-level listener ( # 7128 ) . certain benefit solution well . current event system use `` event bus '' implement polyfills require document based listener . implementation portal-bubbling easier need ensure \u2019 already listening document portal target ( later ) . # # react root listener ( # 2043 ) one solution issue outlined use react root mount target event . would still rely event delegation would require synthetic event system . root level listener would certainly help make bubbling robust using multiple react instance since longer add listener level . , however , work bubbling . event use capturing ( ` scroll ` , ` focus ` , ` blur ` , ` cancel ` , ` close ` ) would fire inverse bubble order ( capture handler multiple root also always fire wrong order . portal bubbling also become complicated since find portal root inside react-root see need attach listener portal root well . consider following example , need add listener ` # react-root ` well ` # portal-root ` : compare example , \u2019 need : \u2019 compiled list previous implementation attempt issue pointed well : | date | pr | issue | | -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | | oct & nbsp ; 2016 | | enter/leave shim ( using instance react ( event ( like focus firefox ) fire reverse order ( tap highlight ( shim ( | | jun & nbsp ; 2016 | | firefox v8.01 mousemove event ( | | aug & nbsp ; 2014 | | enter/leave shim ( | \u2019 probably possible work around some/all issue . invalid capturing order worked around adding bubble capture listener regular event trigger appropriate phase . shim probably rewritten need document , additional listener could added . io tap highlight could disabled via cs . get rid edge case around event \u2019 bubble browser , consider deprecating support together . # # # new feature since \u2019 taking time rethink event system , also want u think : * * passive event listener ( # 6436 ) * * * * web component ( # 7901 , # 9242 ) * * . think _can_ ( albeit additional implementation effort ) support passive event system keep using event delegation : \u2019 add two different listener ( one capturing one bubbling ) handle completely different event . support shadow root bit complex event delegation \u2019 really make sense . \u2019 easily consider shadow root react root portal root since \u2019 rely adding listener ` # react-root ` \u2019 parent shadow root . consider following case : \u2019 handy comparison custom element support different javascript framework . planned change event system , work . # # element listener ( sort # 4751 ) \u2019 radical approach changing event system get rid event delegation altogether . happens , , , probably framework well ( research ember angular point ) . case , \u2019 trivial add support passive event listener bubble/capture behave expected . also allows u completely remove need synthetic event system could rely browser . also know browser better optimize certain event attached directly element ( # 1254 , # 1964 ) . think least two major roadblock , though : 1 . * * performance * * event delegation avoids need ` addeventlistener ( ) ` every element event handler . figure significant overhead really - especially considering possible bundle size improvement make initial-render faster . need compared real-world application . ( \u2019 microbenchmark outcome representative real apps ) event-system le react , noticed \u2019 another feature event delegation often overlooked : setstate batching . right , react know event listener called batch setstate call case . looked bit would fire event processed next frame drawn \u2019 think possible browser . evaluate performance implication real-world application see bad often setstate batching occurring ( could still batch inside event listener ) . 2 . * * portal bubbling * * big issue see portal bubbling still need use event delegation portal root catch event listened parent . write-up react fire ( # 13525 ) , @ gaearon mentioned could use re-dispatching native event would still require u set listener first . # # consideration - whole synthetic event system currently account * * ~20 % * * react dom bundle size . worked example removed everything event related added tiny preact-like system find much save . \u2019 look edge case much already got test pas . - general might also consider adding api installing global dom event handler ( # 285 ) since upcoming concurrent mode make complicated listen arbitrary non react-controlled event ( possibly fired render time slice ) . discussion scope write-up though maybe good keep mind . \u2019 . \u2019 especially curious way could implement portal bubbling using element listener - \u2019 say biggest uncertainty right . \ud83d\ude42",
        "title_stopwords_removal_lemmatization": "dom event mount target consideration"
    },
    {
        "issue_id": 361413793,
        "title": "How to prevent ReactDOM.render errors from bubbling when otherwise explicitly handled",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-09-18T17:48:47Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nThis is a bug. Ordinarily, this would probably be considered a feature request. However, the stated purpose of the feature referenced below is being violated in certain environments.\r\n\r\n**What is the current behavior?** \r\n\r\nReact 16+ surfaces an uncaught error during render, even when using `componentDidCatch` as designed or using try/catch around the render. As described in the comment [above the related code](https://github.com/facebook/react/blob/master/packages/shared/invokeGuardedCallbackImpl.js#L32:L49), this is a convenience provided for developers using DevTools for debugging purposes. However, the convenience provided for development debugging is changing behavior in specs, causing failures for otherwise protected code paths, which goes against this statement from the comment description for the code:\r\n\r\n> But because the error happens in a different event loop context, it does not interrupt the normal program flow.\r\n\r\nWhen the error occurs, a spec runner such as Mocha will fail the test with the uncaught error, then continue with the next test. After advancing, the second render of the component will complete and call the ReactDOM.render callback, which continues code from the already-failed test while a subsequent test is in progress. This pollutes the spec suite and leads to other issues that are not produced when using the Production version of React.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nAll relevant code and content has been included in [this CodeSandbox](https://codesandbox.io/s/vvmv7q7o7y). Due to the use of karma/mocha, tests must be run locally. Inline comments add detail to behavior and expectations.\r\n\r\nTo see the tests pass, switch \"test\" to \"production\" in the `karma.js` file.\r\n\r\n**What is the expected behavior?**\r\n\r\nTypically, DevTools are used in a different context from running specs\u2014automation vs investigation, for lack of more precise terms. It should be an option rather than the default when using React in a non-production environment. At least in an environment of `test`, where spec runners are conditionally sensitive to global errors, developers must have the option to disable or disallow this behavior as it is implemented at this time.\r\n\r\nFor a second, perhaps more intuitive option, refer to this portion of the mentioned comment, talking about \"pause on caught exceptions\":\r\n\r\n> This is untintuitive, though, because even though React has caught the error, from the developer's perspective, the error is uncaught.\r\n\r\nWhen an exception during render is captured using `componentDidCatch` or try/catch as mentioned above, the exception should be considered \"caught,\" as the developer has explicitly created an error boundary around this render. In this case, expected behavior would be for the error to not be surfaced globally and for the developer to debug any exceptions within the error boundary they defined.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nThis is present only in the non-production version of React 16+. The `development` or `test` environments of React 16+ feature this behavior. React 15.* and below do not have this issue. Prior to React 16, explicit try/catch handlers were solely responsible for being an error boundary during render.",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    This is a bug. Ordinarily, this would probably be considered a feature request. However, the stated purpose of the feature referenced below is being violated in certain environments.    **What is the current behavior?**     React 16+ surfaces an uncaught error during render, even when using `componentDidCatch` as designed or using try/catch around the render. As described in the comment [above the related code](https://github.com/facebook/react/blob/master/packages/shared/invokeGuardedCallbackImpl.js#L32:L49), this is a convenience provided for developers using DevTools for debugging purposes. However, the convenience provided for development debugging is changing behavior in specs, causing failures for otherwise protected code paths, which goes against this statement from the comment description for the code:    > But because the error happens in a different event loop context, it does not interrupt the normal program flow.    When the error occurs, a spec runner such as Mocha will fail the test with the uncaught error, then continue with the next test. After advancing, the second render of the component will complete and call the ReactDOM.render callback, which continues code from the already-failed test while a subsequent test is in progress. This pollutes the spec suite and leads to other issues that are not produced when using the Production version of React.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    All relevant code and content has been included in [this CodeSandbox](https://codesandbox.io/s/vvmv7q7o7y). Due to the use of karma/mocha, tests must be run locally. Inline comments add detail to behavior and expectations.    To see the tests pass, switch \"test\" to \"production\" in the `karma.js` file.    **What is the expected behavior?**    Typically, DevTools are used in a different context from running specs\u2014automation vs investigation, for lack of more precise terms. It should be an option rather than the default when using React in a non-production environment. At least in an environment of `test`, where spec runners are conditionally sensitive to global errors, developers must have the option to disable or disallow this behavior as it is implemented at this time.    For a second, perhaps more intuitive option, refer to this portion of the mentioned comment, talking about \"pause on caught exceptions\":    > This is untintuitive, though, because even though React has caught the error, from the developer's perspective, the error is uncaught.    When an exception during render is captured using `componentDidCatch` or try/catch as mentioned above, the exception should be considered \"caught,\" as the developer has explicitly created an error boundary around this render. In this case, expected behavior would be for the error to not be surfaced globally and for the developer to debug any exceptions within the error boundary they defined.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This is present only in the non-production version of React 16+. The `development` or `test` environments of React 16+ feature this behavior. React 15.* and below do not have this issue. Prior to React 16, explicit try/catch handlers were solely responsible for being an error boundary during render.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    This is a bug. Ordinarily, this would probably be considered a feature request. However, the stated purpose of the feature referenced below is being violated in certain environments.    **What is the current behavior?**     React 16+ surfaces an uncaught error during render, even when using `componentDidCatch` as designed or using try/catch around the render. As described in the comment [above the related code](https://github.com/facebook/react/blob/master/packages/shared/invokeGuardedCallbackImpl.js#L32:L49), this is a convenience provided for developers using DevTools for debugging purposes. However, the convenience provided for development debugging is changing behavior in specs, causing failures for otherwise protected code paths, which goes against this statement from the comment description for the code:    > But because the error happens in a different event loop context, it does not interrupt the normal program flow.    When the error occurs, a spec runner such as Mocha will fail the test with the uncaught error, then continue with the next test. After advancing, the second render of the component will complete and call the ReactDOM.render callback, which continues code from the already-failed test while a subsequent test is in progress. This pollutes the spec suite and leads to other issues that are not produced when using the Production version of React.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    All relevant code and content has been included in [this CodeSandbox](https://codesandbox.io/s/vvmv7q7o7y). Due to the use of karma/mocha, tests must be run locally. Inline comments add detail to behavior and expectations.    To see the tests pass, switch \"test\" to \"production\" in the `karma.js` file.    **What is the expected behavior?**    Typically, DevTools are used in a different context from running specs\u2014automation vs investigation, for lack of more precise terms. It should be an option rather than the default when using React in a non-production environment. At least in an environment of `test`, where spec runners are conditionally sensitive to global errors, developers must have the option to disable or disallow this behavior as it is implemented at this time.    For a second, perhaps more intuitive option, refer to this portion of the mentioned comment, talking about \"pause on caught exceptions\":    > This is untintuitive, though, because even though React has caught the error, from the developer's perspective, the error is uncaught.    When an exception during render is captured using `componentDidCatch` or try/catch as mentioned above, the exception should be considered \"caught,\" as the developer has explicitly created an error boundary around this render. In this case, expected behavior would be for the error to not be surfaced globally and for the developer to debug any exceptions within the error boundary they defined.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This is present only in the non-production version of React 16+. The `development` or `test` environments of React 16+ feature this behavior. React 15.* and below do not have this issue. Prior to React 16, explicit try/catch handlers were solely responsible for being an error boundary during render.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** This is a bug. Ordinarily, this would probably be considered a feature request. However, the stated purpose of the feature referenced below is being violated in certain environments. **What is the current behavior?** React 16+ surfaces an uncaught error during render, even when using `componentDidCatch` as designed or using try/catch around the render. As described in the comment , this is a convenience provided for developers using DevTools for debugging purposes. However, the convenience provided for development debugging is changing behavior in specs, causing failures for otherwise protected code paths, which goes against this statement from the comment description for the code: > But because the error happens in a different event loop context, it does not interrupt the normal program flow. When the error occurs, a spec runner such as Mocha will fail the test with the uncaught error, then continue with the next test. After advancing, the second render of the component will complete and call the ReactDOM.render callback, which continues code from the already-failed test while a subsequent test is in progress. This pollutes the spec suite and leads to other issues that are not produced when using the Production version of React. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** All relevant code and content has been included in . Due to the use of karma/mocha, tests must be run locally. Inline comments add detail to behavior and expectations. To see the tests pass, switch \"test\" to \"production\" in the `karma.js` file. **What is the expected behavior?** Typically, DevTools are used in a different context from running specs\u2014automation vs investigation, for lack of more precise terms. It should be an option rather than the default when using React in a non-production environment. At least in an environment of `test`, where spec runners are conditionally sensitive to global errors, developers must have the option to disable or disallow this behavior as it is implemented at this time. For a second, perhaps more intuitive option, refer to this portion of the mentioned comment, talking about \"pause on caught exceptions\": > This is untintuitive, though, because even though React has caught the error, from the developer's perspective, the error is uncaught. When an exception during render is captured using `componentDidCatch` or try/catch as mentioned above, the exception should be considered \"caught,\" as the developer has explicitly created an error boundary around this render. In this case, expected behavior would be for the error to not be surfaced globally and for the developer to debug any exceptions within the error boundary they defined. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** This is present only in the non-production version of React 16+. The `development` or `test` environments of React 16+ feature this behavior. React 15.* and below do not have this issue. Prior to React 16, explicit try/catch handlers were solely responsible for being an error boundary during render.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug . ordinarily , would probably considered feature request . however , stated purpose feature referenced violated certain environment . * * current behavior ? * * react 16+ surface uncaught error render , even using ` componentdidcatch ` designed using try/catch around render . described comment , convenience provided developer using devtools debugging purpose . however , convenience provided development debugging changing behavior spec , causing failure otherwise protected code path , go statement comment description code : > error happens different event loop context , interrupt normal program flow . error occurs , spec runner mocha fail test uncaught error , continue next test . advancing , second render component complete call reactdom.render callback , continues code already-failed test subsequent test progress . pollutes spec suite lead issue produced using production version react . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * relevant code content included . due use karma/mocha , test must run locally . inline comment add detail behavior expectation . see test pas , switch `` test '' `` production '' ` karma.js ` file . * * expected behavior ? * * typically , devtools used different context running specs\u2014automation v investigation , lack precise term . option rather default using react non-production environment . least environment ` test ` , spec runner conditionally sensitive global error , developer must option disable disallow behavior implemented time . second , perhaps intuitive option , refer portion mentioned comment , talking `` pause caught exception '' : > untintuitive , though , even though react caught error , developer 's perspective , error uncaught . exception render captured using ` componentdidcatch ` try/catch mentioned , exception considered `` caught , '' developer explicitly created error boundary around render . case , expected behavior would error surfaced globally developer debug exception within error boundary defined . * * version react , browser / o affected issue ? work previous version react ? * * present non-production version react 16+ . ` development ` ` test ` environment react 16+ feature behavior . react 15 . * issue . prior react 16 , explicit try/catch handler solely responsible error boundary render .",
        "title_stopwords_removal_lemmatization": "prevent reactdom.render error bubbling otherwise explicitly handled"
    },
    {
        "issue_id": 360472610,
        "title": "\"Cannot update during an existing state transition\" exception is not caught by componentDidCatch",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-09-14T22:24:28Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug\r\n\r\n**What is the current behavior?**\r\n\r\nI'm working with `react-apollo` right now and there was a mistake in my code which could re-render the inner query at the same time with the outer query (this was an integration test). I can see this React error in the console (which perfectly makes sense), but the problem is that I expect it to be caught by top-level boundary component with componentDidCatch() but it didn't get executed in this case. As a result, `jest` hangs up and bitbucket pipelines stop the build for the PR after 2 hours of inactivity.\r\n\r\n**What is the expected behavior?**\r\n\r\nI guess componentDidCatch() could've caught this exception.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nWe're using React@16.4.1",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    bug    **What is the current behavior?**    I'm working with `react-apollo` right now and there was a mistake in my code which could re-render the inner query at the same time with the outer query (this was an integration test). I can see this React error in the console (which perfectly makes sense), but the problem is that I expect it to be caught by top-level boundary component with componentDidCatch() but it didn't get executed in this case. As a result, `jest` hangs up and bitbucket pipelines stop the build for the PR after 2 hours of inactivity.    **What is the expected behavior?**    I guess componentDidCatch() could've caught this exception.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    We're using React@16.4.1",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    bug    **What is the current behavior?**    I'm working with `react-apollo` right now and there was a mistake in my code which could re-render the inner query at the same time with the outer query (this was an integration test). I can see this React error in the console (which perfectly makes sense), but the problem is that I expect it to be caught by top-level boundary component with componentDidCatch() but it didn't get executed in this case. As a result, `jest` hangs up and bitbucket pipelines stop the build for the PR after 2 hours of inactivity.    **What is the expected behavior?**    I guess componentDidCatch() could've caught this exception.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    We're using React@16.4.1",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** bug **What is the current behavior?** I'm working with `react-apollo` right now and there was a mistake in my code which could re-render the inner query at the same time with the outer query (this was an integration test). I can see this React error in the console (which perfectly makes sense), but the problem is that I expect it to be caught by top-level boundary component with componentDidCatch() but it didn't get executed in this case. As a result, `jest` hangs up and bitbucket pipelines stop the build for the PR after 2 hours of inactivity. **What is the expected behavior?** I guess componentDidCatch() could've caught this exception. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** We're using React@16.4.1",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * 'm working ` react-apollo ` right mistake code could re-render inner query time outer query ( integration test ) . see react error console ( perfectly make sense ) , problem expect caught top-level boundary component componentdidcatch ( ) n't get executed case . result , ` jest ` hang bitbucket pipeline stop build pr 2 hour inactivity . * * expected behavior ? * * guess componentdidcatch ( ) could 've caught exception . * * version react , browser / o affected issue ? work previous version react ? * * 're using react @ 16.4.1",
        "title_stopwords_removal_lemmatization": "`` update existing state transition '' exception caught componentdidcatch"
    },
    {
        "issue_id": 360431676,
        "title": "Root element noop blocking GSAP Draggable",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-09-14T19:46:30Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nHonestly I don't know\r\n\r\n**What is the current behavior?**\r\nI'm a moderator in the GreenSock forums and the most recent update (16.5.X) is causing some issues with the Draggable tool. By default the Draggable tool ignores clicks on specific elements so by default those are not draggable elements, unless you specify that the element should be draggable. Starting on version 16.5.0 a `noop` function is passed on the `onclick` event of the root element of a react app, which is preventing a simple `<div>` tag from being used by the Draggable tool.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React.\r\nhttps://codesandbox.io/s/jrkbkxeqy\r\nThe blue square is not draggabl(should rotate). If you either uncomment line 24 or change the React and ReactDOM versions to 16.4.2, \r\n\r\n**What is the expected behavior?**\r\nIt shouldn't be necessary to add the indication to make the element Draggable, it should work by default just in any regular application or web page.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nReact: 16.5.0 - 16.5.1\r\nChrome 69 - Firefox 62 - IE11 - Edge 17\r\nWindows 7 64\r\nAlso other users have tested in Chrome and Firefox in OSX (don't know specific versions)",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Honestly I don't know    **What is the current behavior?**  I'm a moderator in the GreenSock forums and the most recent update (16.5.X) is causing some issues with the Draggable tool. By default the Draggable tool ignores clicks on specific elements so by default those are not draggable elements, unless you specify that the element should be draggable. Starting on version 16.5.0 a `noop` function is passed on the `onclick` event of the root element of a react app, which is preventing a simple `<div>` tag from being used by the Draggable tool.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React.  https://codesandbox.io/s/jrkbkxeqy  The blue square is not draggabl(should rotate). If you either uncomment line 24 or change the React and ReactDOM versions to 16.4.2,     **What is the expected behavior?**  It shouldn't be necessary to add the indication to make the element Draggable, it should work by default just in any regular application or web page.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React: 16.5.0 - 16.5.1  Chrome 69 - Firefox 62 - IE11 - Edge 17  Windows 7 64  Also other users have tested in Chrome and Firefox in OSX (don't know specific versions)",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Honestly I don't know    **What is the current behavior?**  I'm a moderator in the GreenSock forums and the most recent update (16.5.X) is causing some issues with the Draggable tool. By default the Draggable tool ignores clicks on specific elements so by default those are not draggable elements, unless you specify that the element should be draggable. Starting on version 16.5.0 a `noop` function is passed on the `onclick` event of the root element of a react app, which is preventing a simple `<div>` tag from being used by the Draggable tool.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React.  https://codesandbox.io/s/jrkbkxeqy  The blue square is not draggabl(should rotate). If you either uncomment line 24 or change the React and ReactDOM versions to 16.4.2,     **What is the expected behavior?**  It shouldn't be necessary to add the indication to make the element Draggable, it should work by default just in any regular application or web page.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React: 16.5.0 - 16.5.1  Chrome 69 - Firefox 62 - IE11 - Edge 17  Windows 7 64  Also other users have tested in Chrome and Firefox in OSX (don't know specific versions)",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Honestly I don't know **What is the current behavior?** I'm a moderator in the GreenSock forums and the most recent update (16.5.X) is causing some issues with the Draggable tool. By default the Draggable tool ignores clicks on specific elements so by default those are not draggable elements, unless you specify that the element should be draggable. Starting on version 16.5.0 a `noop` function is passed on the `onclick` event of the root element of a react app, which is preventing a simple `` tag from being used by the Draggable tool. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React.  The blue square is not draggabl(should rotate). If you either uncomment line 24 or change the React and ReactDOM versions to 16.4.2, **What is the expected behavior?** It shouldn't be necessary to add the indication to make the element Draggable, it should work by default just in any regular application or web page. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React: 16.5.0 - 16.5.1 Chrome 69 - Firefox 62 - IE11 - Edge 17 Windows 7 64 Also other users have tested in Chrome and Firefox in OSX (don't know specific versions)",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * honestly n't know * * current behavior ? * * 'm moderator greensock forum recent update ( 16.5.x ) causing issue draggable tool . default draggable tool ignores click specific element default draggable element , unless specify element draggable . starting version 16.5.0 ` noop ` function passed ` onclick ` event root element react app , preventing simple `` tag used draggable tool . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . blue square draggabl ( rotate ) . either uncomment line 24 change react reactdom version 16.4.2 , * * expected behavior ? * * n't necessary add indication make element draggable , work default regular application web page . * * version react , browser / o affected issue ? work previous version react ? * * react : 16.5.0 - 16.5.1 chrome 69 - firefox 62 - ie11 - edge 17 window 7 64 also user tested chrome firefox osx ( n't know specific version )",
        "title_stopwords_removal_lemmatization": "root element noop blocking gsap draggable"
    },
    {
        "issue_id": 358078653,
        "title": "[bug][16.5.0] option returns [object Object] instead of string",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-09-07T13:59:49Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**What is the current behavior?**\r\n`<option>` returns [object Object] instead string\r\n\r\n**Demo:** https://codesandbox.io/s/ww5mv2w957\r\n\r\n**What is the expected behavior?**\r\nExpected string\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **What is the current behavior?**  `<option>` returns [object Object] instead string    **Demo:** https://codesandbox.io/s/ww5mv2w957    **What is the expected behavior?**  Expected string    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **What is the current behavior?**  `<option>` returns [object Object] instead string    **Demo:** https://codesandbox.io/s/ww5mv2w957    **What is the expected behavior?**  Expected string    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_regrex": " **What is the current behavior?** `` returns [object Object] instead string **Demo:**  **What is the expected behavior?** Expected string **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**",
        "human_words_stopwords_removal_lemmatization": "* * current behavior ? * * `` return [ object object ] instead string * * demo : * * * * expected behavior ? * * expected string * * version react , browser / o affected issue ? work previous version react ? * *",
        "title_stopwords_removal_lemmatization": "[ bug ] [ 16.5.0 ] option return [ object object ] instead string"
    },
    {
        "issue_id": 357300893,
        "title": "Consider stopping auto-adding `px` to number style values (except for a small whitelist)",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2018-09-05T16:08:37Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA removal of a feature, in a sense.\r\n\r\n**What is the current behavior?**\r\n\r\nReact automatically adds the `px` suffix for numerical values passed to the `style` prop. As some CSS properties accept unitless values, React maintains a blacklist of properties that shouldn't get `px` auto-appended.\r\n\r\nThe problem is that this solution doesn't scale. It requires us to add more & more properties to the list as CSS specs expand and recently the list grows faster; Flexbox & Grid added quite a few of them. What's more confusing, some of those props would work both with & without the `px` suffix and that changes the meaning (`lineHeight` is suffering from that).\r\n\r\nAlthough I'm a React newbie I'm quite familiar with this issue due to being a member of the jQuery Core team. jQuery has the same logic as React here and we keep having to add to the list. We've actually exposed the list at [jQuery.cssNumber](https://api.jquery.com/jQuery.cssNumber/) so that people don't always have to wait for us to add support for a property and do a release.\r\n\r\nThat's why we decided that in jQuery 4 we'll drop the auto-prefixing blacklist and turn to a whitelist that lists only a few most common properties to which we want to auto-append `px` (mostly because they're extremely common and we don't want to break the world too much); we plan to _not_ expand that list unless we missed something really common. You can see the current plan in my PR: https://github.com/jquery/jquery/pull/4055. In particular, see the proposed whitelist in a (visualized) regexp in:\r\nhttps://github.com/jquery/jquery/blob/03e9dba3882868e1ee79f1fb0504326da925644f/src/css/isAutoPx.js.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n**What is the expected behavior?**\r\n\r\nI propose that React could do the same thing jQuery is planning to and switch the ever-expanding blacklist of CSS props that shouldn't have the `px` suffix applied to a small whitelist that should have the suffix applied.\r\n\r\nThis topic has been initially described in #13550.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nAll browses & OSs. I don't know how old this logic is in React.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A removal of a feature, in a sense.    **What is the current behavior?**    React automatically adds the `px` suffix for numerical values passed to the `style` prop. As some CSS properties accept unitless values, React maintains a blacklist of properties that shouldn't get `px` auto-appended.    The problem is that this solution doesn't scale. It requires us to add more & more properties to the list as CSS specs expand and recently the list grows faster; Flexbox & Grid added quite a few of them. What's more confusing, some of those props would work both with & without the `px` suffix and that changes the meaning (`lineHeight` is suffering from that).    Although I'm a React newbie I'm quite familiar with this issue due to being a member of the jQuery Core team. jQuery has the same logic as React here and we keep having to add to the list. We've actually exposed the list at [jQuery.cssNumber](https://api.jquery.com/jQuery.cssNumber/) so that people don't always have to wait for us to add support for a property and do a release.    That's why we decided that in jQuery 4 we'll drop the auto-prefixing blacklist and turn to a whitelist that lists only a few most common properties to which we want to auto-append `px` (mostly because they're extremely common and we don't want to break the world too much); we plan to _not_ expand that list unless we missed something really common. You can see the current plan in my PR: https://github.com/jquery/jquery/pull/4055. In particular, see the proposed whitelist in a (visualized) regexp in:  https://github.com/jquery/jquery/blob/03e9dba3882868e1ee79f1fb0504326da925644f/src/css/isAutoPx.js.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    I propose that React could do the same thing jQuery is planning to and switch the ever-expanding blacklist of CSS props that shouldn't have the `px` suffix applied to a small whitelist that should have the suffix applied.    This topic has been initially described in #13550.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All browses & OSs. I don't know how old this logic is in React.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A removal of a feature, in a sense.    **What is the current behavior?**    React automatically adds the `px` suffix for numerical values passed to the `style` prop. As some CSS properties accept unitless values, React maintains a blacklist of properties that shouldn't get `px` auto-appended.    The problem is that this solution doesn't scale. It requires us to add more & more properties to the list as CSS specs expand and recently the list grows faster; Flexbox & Grid added quite a few of them. What's more confusing, some of those props would work both with & without the `px` suffix and that changes the meaning (`lineHeight` is suffering from that).    Although I'm a React newbie I'm quite familiar with this issue due to being a member of the jQuery Core team. jQuery has the same logic as React here and we keep having to add to the list. We've actually exposed the list at [jQuery.cssNumber](https://api.jquery.com/jQuery.cssNumber/) so that people don't always have to wait for us to add support for a property and do a release.    That's why we decided that in jQuery 4 we'll drop the auto-prefixing blacklist and turn to a whitelist that lists only a few most common properties to which we want to auto-append `px` (mostly because they're extremely common and we don't want to break the world too much); we plan to _not_ expand that list unless we missed something really common. You can see the current plan in my PR: https://github.com/jquery/jquery/pull/4055. In particular, see the proposed whitelist in a (visualized) regexp in:  https://github.com/jquery/jquery/blob/03e9dba3882868e1ee79f1fb0504326da925644f/src/css/isAutoPx.js.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    **What is the expected behavior?**    I propose that React could do the same thing jQuery is planning to and switch the ever-expanding blacklist of CSS props that shouldn't have the `px` suffix applied to a small whitelist that should have the suffix applied.    This topic has been initially described in #13550.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All browses & OSs. I don't know how old this logic is in React.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** A removal of a feature, in a sense. **What is the current behavior?** React automatically adds the `px` suffix for numerical values passed to the `style` prop. As some CSS properties accept unitless values, React maintains a blacklist of properties that shouldn't get `px` auto-appended. The problem is that this solution doesn't scale. It requires us to add more & more properties to the list as CSS specs expand and recently the list grows faster; Flexbox & Grid added quite a few of them. What's more confusing, some of those props would work both with & without the `px` suffix and that changes the meaning (`lineHeight` is suffering from that). Although I'm a React newbie I'm quite familiar with this issue due to being a member of the jQuery Core team. jQuery has the same logic as React here and we keep having to add to the list. We've actually exposed the list at  so that people don't always have to wait for us to add support for a property and do a release. That's why we decided that in jQuery 4 we'll drop the auto-prefixing blacklist and turn to a whitelist that lists only a few most common properties to which we want to auto-append `px` (mostly because they're extremely common and we don't want to break the world too much); we plan to _not_ expand that list unless we missed something really common. You can see the current plan in my PR:  In particular, see the proposed whitelist in a (visualized) regexp in:  **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** **What is the expected behavior?** I propose that React could do the same thing jQuery is planning to and switch the ever-expanding blacklist of CSS props that shouldn't have the `px` suffix applied to a small whitelist that should have the suffix applied. This topic has been initially described in #13550. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** All browses & OSs. I don't know how old this logic is in React.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * removal feature , sense . * * current behavior ? * * react automatically add ` px ` suffix numerical value passed ` style ` prop . cs property accept unitless value , react maintains blacklist property n't get ` px ` auto-appended . problem solution n't scale . requires u add & property list cs spec expand recently list grows faster ; flexbox & grid added quite . 's confusing , prop would work & without ` px ` suffix change meaning ( ` lineheight ` suffering ) . although 'm react newbie 'm quite familiar issue due member jquery core team . jquery logic react keep add list . 've actually exposed list people n't always wait u add support property release . 's decided jquery 4 'll drop auto-prefixing blacklist turn whitelist list common property want auto-append ` px ` ( mostly 're extremely common n't want break world much ) ; plan _not_ expand list unless missed something really common . see current plan pr : particular , see proposed whitelist ( visualized ) regexp : * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * expected behavior ? * * propose react could thing jquery planning switch ever-expanding blacklist cs prop n't ` px ` suffix applied small whitelist suffix applied . topic initially described # 13550 . * * version react , browser / o affected issue ? work previous version react ? * * browse & os . n't know old logic react .",
        "title_stopwords_removal_lemmatization": "consider stopping auto-adding ` px ` number style value ( except small whitelist )"
    },
    {
        "issue_id": 352431414,
        "title": "UMD builds are not enabled on UNPKG",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-08-21T08:14:19Z",
        "status": "open",
        "description": "Visiting https://unpkg.com/react displays the CJS build (https://unpkg.com/react@16.4.2/index.js) when the UMD build (https://unpkg.com/react@16.4.2/umd/react.development.js) should be displayed instead. I also noticed this issue with react-dom, so I assume all packages need to be fixed.\r\n\r\nPlease refer to the usage instructions at the bottom of https://unpkg.com/.",
        "remove_template_description": "Visiting https://unpkg.com/react displays the CJS build (https://unpkg.com/react@16.4.2/index.js) when the UMD build (https://unpkg.com/react@16.4.2/umd/react.development.js) should be displayed instead. I also noticed this issue with react-dom, so I assume all packages need to be fixed.    Please refer to the usage instructions at the bottom of https://unpkg.com/.",
        "human_words": "Visiting https://unpkg.com/react displays the CJS build (https://unpkg.com/react@16.4.2/index.js) when the UMD build (https://unpkg.com/react@16.4.2/umd/react.development.js) should be displayed instead. I also noticed this issue with react-dom, so I assume all packages need to be fixed.    Please refer to the usage instructions at the bottom of https://unpkg.com/.",
        "human_words_regrex": "Visiting  displays the CJS build ( when the UMD build ( should be displayed instead. I also noticed this issue with react-dom, so I assume all packages need to be fixed. Please refer to the usage instructions at the bottom of ",
        "human_words_stopwords_removal_lemmatization": "visiting display cjs build ( umd build ( displayed instead . also noticed issue react-dom , assume package need fixed . please refer usage instruction bottom",
        "title_stopwords_removal_lemmatization": "umd build enabled unpkg"
    },
    {
        "issue_id": 350627761,
        "title": "Boolean DOM properties coerce empty string to false, contrary to HTML standard",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-08-14T23:04:45Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\nThis is in kind of the same space as https://github.com/facebook/react/pull/13372 and is an offshoot of my attempt to better [model React DOM props in Flow](https://github.com/facebook/flow/pull/6727).\r\n\r\n**tl;dr:** Should React warn when the value `\"\"` is passed into a known boolean DOM prop?\r\n\r\n---\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nDepends on interpretation \ud83d\ude05  This is possibly a bug, definitely an inconsistency worth mitigating IMHO.\r\n\r\n**What is the current behavior?**\r\n\r\nReact normalises values supplied to [known DOM boolean props](https://github.com/facebook/react/blob/69e2a0d732e1ca74f6dc5df9d0ddd0bf24373965/packages/react-dom/src/shared/DOMProperty.js#L278-L331) (e.g. `readOnly`) such that passing the empty string `\"\"` (being falsy in JavaScript) results in the corresponding attribute being omitted from the HTML output. However, in [HTML](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attribute), the empty string is a truthy value in this context; it's one of the values that the standard specifically allows in boolean attributes.\r\n\r\nThe above is a potential source of confusion in itself, but React 16's handling of unknown attributes gives rise to the following hypothetical scenario: a new DOM boolean attribute `foobar` is introduced, some people write JSX code that uses it as `foobar=\"\"` (passed through to HTML, truthy), and later React adds `foobar` to its internal whitelist in a minor/patch version and starts processing it as a boolean (JS falsy, omitted from HTML); this would _technically_ be a breaking change for those people.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**\r\n\r\nhttps://codesandbox.io/s/y0pmz9149x\r\n\r\n**What is the expected behavior?**\r\n\r\nThere is definitely a clash of expectations here at the interface of JS and HTML.\r\n\r\n1. Coming from JS, `\"\"` is falsy and treating it as such in a \"boolean\" prop is fine; from this perspective, the current behaviour is justifiable.\r\n2. Coming from HTML, it might not be obvious that React is doing this \"extra\" processing and deviating from what's clearly stated in the HTML spec; from this perspective, the current behaviour is surprising.\r\n\r\nThere probably isn't justification for changing React's actual handling of `\"\"` (not least for fear of breaking code that relies on this long-standing behaviour, see version information below), but perhaps a warning about the ambiguity is warranted, a la #13372?\r\n\r\nNote that a warning won't fully mitigate the worst-case scenario I mentioned above (since we can't warn about a prop that we don't _know_ is a DOM boolean), but at least it would give some signal _after_ the React version update that the code might not be doing the expected thing anymore.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nVersions of React as far back as 0.14 (and probably way older) process whitelisted boolean DOM props the same way.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    This is in kind of the same space as https://github.com/facebook/react/pull/13372 and is an offshoot of my attempt to better [model React DOM props in Flow](https://github.com/facebook/flow/pull/6727).    **tl;dr:** Should React warn when the value `\"\"` is passed into a known boolean DOM prop?    ---    **Do you want to request a *feature* or report a *bug*?**    Depends on interpretation \ud83d\ude05  This is possibly a bug, definitely an inconsistency worth mitigating IMHO.    **What is the current behavior?**    React normalises values supplied to [known DOM boolean props](https://github.com/facebook/react/blob/69e2a0d732e1ca74f6dc5df9d0ddd0bf24373965/packages/react-dom/src/shared/DOMProperty.js#L278-L331) (e.g. `readOnly`) such that passing the empty string `\"\"` (being falsy in JavaScript) results in the corresponding attribute being omitted from the HTML output. However, in [HTML](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attribute), the empty string is a truthy value in this context; it's one of the values that the standard specifically allows in boolean attributes.    The above is a potential source of confusion in itself, but React 16's handling of unknown attributes gives rise to the following hypothetical scenario: a new DOM boolean attribute `foobar` is introduced, some people write JSX code that uses it as `foobar=\"\"` (passed through to HTML, truthy), and later React adds `foobar` to its internal whitelist in a minor/patch version and starts processing it as a boolean (JS falsy, omitted from HTML); this would _technically_ be a breaking change for those people.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    https://codesandbox.io/s/y0pmz9149x    **What is the expected behavior?**    There is definitely a clash of expectations here at the interface of JS and HTML.    1. Coming from JS, `\"\"` is falsy and treating it as such in a \"boolean\" prop is fine; from this perspective, the current behaviour is justifiable.  2. Coming from HTML, it might not be obvious that React is doing this \"extra\" processing and deviating from what's clearly stated in the HTML spec; from this perspective, the current behaviour is surprising.    There probably isn't justification for changing React's actual handling of `\"\"` (not least for fear of breaking code that relies on this long-standing behaviour, see version information below), but perhaps a warning about the ambiguity is warranted, a la #13372?    Note that a warning won't fully mitigate the worst-case scenario I mentioned above (since we can't warn about a prop that we don't _know_ is a DOM boolean), but at least it would give some signal _after_ the React version update that the code might not be doing the expected thing anymore.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Versions of React as far back as 0.14 (and probably way older) process whitelisted boolean DOM props the same way.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    This is in kind of the same space as https://github.com/facebook/react/pull/13372 and is an offshoot of my attempt to better [model React DOM props in Flow](https://github.com/facebook/flow/pull/6727).    **tl;dr:** Should React warn when the value `\"\"` is passed into a known boolean DOM prop?    ---    **Do you want to request a *feature* or report a *bug*?**    Depends on interpretation \ud83d\ude05  This is possibly a bug, definitely an inconsistency worth mitigating IMHO.    **What is the current behavior?**    React normalises values supplied to [known DOM boolean props](https://github.com/facebook/react/blob/69e2a0d732e1ca74f6dc5df9d0ddd0bf24373965/packages/react-dom/src/shared/DOMProperty.js#L278-L331) (e.g. `readOnly`) such that passing the empty string `\"\"` (being falsy in JavaScript) results in the corresponding attribute being omitted from the HTML output. However, in [HTML](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attribute), the empty string is a truthy value in this context; it's one of the values that the standard specifically allows in boolean attributes.    The above is a potential source of confusion in itself, but React 16's handling of unknown attributes gives rise to the following hypothetical scenario: a new DOM boolean attribute `foobar` is introduced, some people write JSX code that uses it as `foobar=\"\"` (passed through to HTML, truthy), and later React adds `foobar` to its internal whitelist in a minor/patch version and starts processing it as a boolean (JS falsy, omitted from HTML); this would _technically_ be a breaking change for those people.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    https://codesandbox.io/s/y0pmz9149x    **What is the expected behavior?**    There is definitely a clash of expectations here at the interface of JS and HTML.    1. Coming from JS, `\"\"` is falsy and treating it as such in a \"boolean\" prop is fine; from this perspective, the current behaviour is justifiable.  2. Coming from HTML, it might not be obvious that React is doing this \"extra\" processing and deviating from what's clearly stated in the HTML spec; from this perspective, the current behaviour is surprising.    There probably isn't justification for changing React's actual handling of `\"\"` (not least for fear of breaking code that relies on this long-standing behaviour, see version information below), but perhaps a warning about the ambiguity is warranted, a la #13372?    Note that a warning won't fully mitigate the worst-case scenario I mentioned above (since we can't warn about a prop that we don't _know_ is a DOM boolean), but at least it would give some signal _after_ the React version update that the code might not be doing the expected thing anymore.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Versions of React as far back as 0.14 (and probably way older) process whitelisted boolean DOM props the same way.",
        "human_words_regrex": " This is in kind of the same space as  and is an offshoot of my attempt to better . **tl;dr:** Should React warn when the value `\"\"` is passed into a known boolean DOM prop? --- **Do you want to request a *feature* or report a *bug*?** Depends on interpretation \ud83d\ude05 This is possibly a bug, definitely an inconsistency worth mitigating IMHO. **What is the current behavior?** React normalises values supplied to  (e.g. `readOnly`) such that passing the empty string `\"\"` (being falsy in JavaScript) results in the corresponding attribute being omitted from the HTML output. However, in , the empty string is a truthy value in this context; it's one of the values that the standard specifically allows in boolean attributes. The above is a potential source of confusion in itself, but React 16's handling of unknown attributes gives rise to the following hypothetical scenario: a new DOM boolean attribute `foobar` is introduced, some people write JSX code that uses it as `foobar=\"\"` (passed through to HTML, truthy), and later React adds `foobar` to its internal whitelist in a minor/patch version and starts processing it as a boolean (JS falsy, omitted from HTML); this would _technically_ be a breaking change for those people. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**  **What is the expected behavior?** There is definitely a clash of expectations here at the interface of JS and HTML. 1. Coming from JS, `\"\"` is falsy and treating it as such in a \"boolean\" prop is fine; from this perspective, the current behaviour is justifiable. 2. Coming from HTML, it might not be obvious that React is doing this \"extra\" processing and deviating from what's clearly stated in the HTML spec; from this perspective, the current behaviour is surprising. There probably isn't justification for changing React's actual handling of `\"\"` (not least for fear of breaking code that relies on this long-standing behaviour, see version information below), but perhaps a warning about the ambiguity is warranted, a la #13372? Note that a warning won't fully mitigate the worst-case scenario I mentioned above (since we can't warn about a prop that we don't _know_ is a DOM boolean), but at least it would give some signal _after_ the React version update that the code might not be doing the expected thing anymore. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** Versions of React as far back as 0.14 (and probably way older) process whitelisted boolean DOM props the same way.",
        "human_words_stopwords_removal_lemmatization": "kind space offshoot attempt better . * * tl ; dr : * * react warn value ` `` '' ` passed known boolean dom prop ? -- - * * want request * feature * report * bug * ? * * depends interpretation \ud83d\ude05 possibly bug , definitely inconsistency worth mitigating imho . * * current behavior ? * * react normalises value supplied ( e.g . ` readonly ` ) passing empty string ` `` '' ` ( falsy javascript ) result corresponding attribute omitted html output . however , , empty string truthy value context ; 's one value standard specifically allows boolean attribute . potential source confusion , react 16 's handling unknown attribute give rise following hypothetical scenario : new dom boolean attribute ` foobar ` introduced , people write jsx code us ` foobar= '' '' ` ( passed html , truthy ) , later react add ` foobar ` internal whitelist minor/patch version start processing boolean ( j falsy , omitted html ) ; would _technically_ breaking change people . * * current behavior bug , please provide step reproduce possible minimal demo problem . * * * * expected behavior ? * * definitely clash expectation interface j html . 1. coming j , ` `` '' ` falsy treating `` boolean '' prop fine ; perspective , current behaviour justifiable . 2. coming html , might obvious react `` extra '' processing deviating 's clearly stated html spec ; perspective , current behaviour surprising . probably n't justification changing react 's actual handling ` `` '' ` ( least fear breaking code relies long-standing behaviour , see version information ) , perhaps warning ambiguity warranted , la # 13372 ? note warning wo n't fully mitigate worst-case scenario mentioned ( since ca n't warn prop n't _know_ dom boolean ) , least would give signal _after_ react version update code might expected thing anymore . * * version react , browser / o affected issue ? work previous version react ? * * version react far back 0.14 ( probably way older ) process whitelisted boolean dom prop way .",
        "title_stopwords_removal_lemmatization": "boolean dom property coerce empty string false , contrary html standard"
    },
    {
        "issue_id": 348420896,
        "title": "RFC: Omit end tags when possible in ReactDOMServerRenderer",
        "label": [
            "Component: Server Rendering",
            "Type: Discussion"
        ],
        "date": "2018-08-07T17:41:53Z",
        "status": "closed",
        "description": "# Background\r\n\r\nThere are a lot of instances defined in the HTML spec where end tags can be omitted while still maintaining valid markup.\r\n\r\nSome examples:\r\n\r\n> An li element\u2019s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\r\n\r\n> A p element\u2019s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.\r\n\r\nYou can see all of them over at https://www.w3.org/TR/html5/syntax.html#optional-tags\r\n\r\nUtilizing these rules, I think it may be possible to reduce the amount of html needed to be initially downloaded by the user for serverside rendering.\r\n\r\nDepending on what's being rendered, there could be a significant decrease in html size. Here's an example I pulled from the W3C of a table element utilizing these rules. The difference is 464 bytes compared to 629 \u2013 about a **26% decrease** in size.\r\n\r\n```html\r\n<table>\r\n<caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)\r\n<colgroup><col><col><col>\r\n<thead>\r\n<tr>\r\n  <th>Function\r\n  <th>Control Unit\r\n  <th>Central Station\r\n<tbody>\r\n<tr>\r\n  <td>Headlights\r\n  <td>\u2714\r\n  <td>\u2714\r\n<tr>\r\n  <td>Interior Lights\r\n  <td>\u2714\r\n  <td>\u2714\r\n<tr>\r\n  <td>Electric locomotive operating sounds\r\n  <td>\u2714\r\n  <td>\u2714\r\n<tr>\r\n  <td>Engineer\u2019s cab lighting\r\n  <td>\r\n  <td>\u2714\r\n<tr>\r\n  <td>Station Announcements - Swiss\r\n  <td>\r\n  <td>\u2714\r\n</table>\r\n```\r\n\r\n# Caveats\r\n\r\n- Even though these rules are in the spec, they still feel like quirks to me. There probably are some browser-to-browser differences in how these are handled.\r\n- Should this even be handled by React? I could see a babel plugin or something like that being a good fit for an optimization like this too.\r\n\r\n# Possible roadmap\r\n\r\n- Research what end tags would be stable to omit (https://www.w3.org/TR/html5/syntax.html#optional-tags)\r\n- Roll out this optimization for a subset of tags\r\n- Gauge real-world load time improvements and continue adding omission cases if everything is looking good",
        "remove_template_description": "# Background    There are a lot of instances defined in the HTML spec where end tags can be omitted while still maintaining valid markup.    Some examples:    > An li element\u2019s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.    > A p element\u2019s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.    You can see all of them over at https://www.w3.org/TR/html5/syntax.html#optional-tags    Utilizing these rules, I think it may be possible to reduce the amount of html needed to be initially downloaded by the user for serverside rendering.    Depending on what's being rendered, there could be a significant decrease in html size. Here's an example I pulled from the W3C of a table element utilizing these rules. The difference is 464 bytes compared to 629 \u2013 about a **26% decrease** in size.    ```html  <table>  <caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)  <colgroup><col><col><col>  <thead>  <tr>    <th>Function    <th>Control Unit    <th>Central Station  <tbody>  <tr>    <td>Headlights    <td>\u2714    <td>\u2714  <tr>    <td>Interior Lights    <td>\u2714    <td>\u2714  <tr>    <td>Electric locomotive operating sounds    <td>\u2714    <td>\u2714  <tr>    <td>Engineer\u2019s cab lighting    <td>    <td>\u2714  <tr>    <td>Station Announcements - Swiss    <td>    <td>\u2714  </table>  ```    # Caveats    - Even though these rules are in the spec, they still feel like quirks to me. There probably are some browser-to-browser differences in how these are handled.  - Should this even be handled by React? I could see a babel plugin or something like that being a good fit for an optimization like this too.    # Possible roadmap    - Research what end tags would be stable to omit (https://www.w3.org/TR/html5/syntax.html#optional-tags)  - Roll out this optimization for a subset of tags  - Gauge real-world load time improvements and continue adding omission cases if everything is looking good",
        "human_words": "# Background    There are a lot of instances defined in the HTML spec where end tags can be omitted while still maintaining valid markup.    Some examples:    > An li element\u2019s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.    > A p element\u2019s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.    You can see all of them over at https://www.w3.org/TR/html5/syntax.html#optional-tags    Utilizing these rules, I think it may be possible to reduce the amount of html needed to be initially downloaded by the user for serverside rendering.    Depending on what's being rendered, there could be a significant decrease in html size. Here's an example I pulled from the W3C of a table element utilizing these rules. The difference is 464 bytes compared to 629 \u2013 about a **26% decrease** in size.        # Caveats    - Even though these rules are in the spec, they still feel like quirks to me. There probably are some browser-to-browser differences in how these are handled.  - Should this even be handled by React? I could see a babel plugin or something like that being a good fit for an optimization like this too.    # Possible roadmap    - Research what end tags would be stable to omit (https://www.w3.org/TR/html5/syntax.html#optional-tags)  - Roll out this optimization for a subset of tags  - Gauge real-world load time improvements and continue adding omission cases if everything is looking good",
        "human_words_regrex": "# Background There are a lot of instances defined in the HTML spec where end tags can be omitted while still maintaining valid markup. Some examples: > An li element\u2019s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element. > A p element\u2019s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element. You can see all of them over at  Utilizing these rules, I think it may be possible to reduce the amount of html needed to be initially downloaded by the user for serverside rendering. Depending on what's being rendered, there could be a significant decrease in html size. Here's an example I pulled from the W3C of a table element utilizing these rules. The difference is 464 bytes compared to 629 \u2013 about a **26% decrease** in size. # Caveats - Even though these rules are in the spec, they still feel like quirks to me. There probably are some browser-to-browser differences in how these are handled. - Should this even be handled by React? I could see a babel plugin or something like that being a good fit for an optimization like this too. # Possible roadmap - Research what end tags would be stable to omit ( - Roll out this optimization for a subset of tags - Gauge real-world load time improvements and continue adding omission cases if everything is looking good",
        "human_words_stopwords_removal_lemmatization": "# background lot instance defined html spec end tag omitted still maintaining valid markup . example : > li element \u2019 end tag may omitted li element immediately followed another li element content parent element . > p element \u2019 end tag may omitted p element immediately followed address , article , aside , blockquote , detail , div , dl , fieldset , figcaption , figure , footer , form , h1 , h2 , h3 , h4 , h5 , h6 , header , hr , main , nav , ol , p , pre , section , table , ul element , content parent element parent element html element , audio , del , in , map , noscript , video element , autonomous custom element . see utilizing rule , think may possible reduce amount html needed initially downloaded user serverside rendering . depending 's rendered , could significant decrease html size . 's example pulled w3c table element utilizing rule . difference 464 byte compared 629 \u2013 * * 26 % decrease * * size . # caveat - even though rule spec , still feel like quirk . probably browser-to-browser difference handled . - even handled react ? could see babel plugin something like good fit optimization like . # possible roadmap - research end tag would stable omit ( - roll optimization subset tag - gauge real-world load time improvement continue adding omission case everything looking good",
        "title_stopwords_removal_lemmatization": "rfc : omit end tag possible reactdomserverrenderer"
    },
    {
        "issue_id": 348134323,
        "title": "Imperative wrappers can't access current context value in commit phase",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2018-08-07T01:30:41Z",
        "status": "closed",
        "description": "Sometimes we have an imperative wrapper like this:\r\n\r\n```js\r\ncomponentDidMount() {\r\n  renderSomethingImperatively(this.props)\r\n}\r\n\r\ncomponentDidUpdate() {\r\n  renderSomethingImperatively(this.props)\r\n}\r\n\r\nrender() {\r\n  return null\r\n}\r\n```\r\n\r\nPortals eliminated the need for this for regular DOM jumps. But we still need this for embedding renderers (e.g. `react-art` [does this](https://github.com/facebook/react/blob/3b3b7fcbbdc734d7f2a2e509a0b07c0eb053f779/packages/react-art/src/ReactART.js#L59-L84)) and use cases like \"Vue inside React\".\r\n\r\nFor cross-renderer embedding, maybe we could extend portals to do that (https://github.com/facebook/react/issues/13332). There are still imperative use cases for cross-library rendering though.\r\n\r\nOne thing that becomes annoying is that new context won't propagate down through this imperative boundary. This is because we don't maintain a stack in the commit phase. We're traversing a flat linked list of effects. So we don't actually know what context value is current by the time `componentDidMount` or `componentDidUpdate` fires.\r\n\r\nFor `react-art` and friends, this means context from a host app is not accessible. This is quite annoying. You could hack around it with something like\r\n\r\n```js\r\n<MyConsumer>\r\n  {value =>\r\n    <ReactART.Surface>\r\n      <MyContext.Provider value={value}>\r\n        <Stuff />\r\n      </MyContext.Provider>\r\n    </ReactART.Surface>\r\n  }\r\n</MyConsumer>\r\n```\r\n\r\nBut this is neither obvious nor convenient. You have to anticipate all contexts that can get used below.\r\n\r\nThis seems even less convenient for imperative cases like \"Vue inside React\". \r\n\r\n```js\r\ncomponentDidMount() {\r\n  renderSomethingImperatively(this.props) // ???\r\n}\r\n\r\ncomponentDidUpdate() {\r\n  renderSomethingImperatively(this.props) // ???\r\n}\r\n\r\nrender() {\r\n  // <MyConsumer>{value => ???}</MyConsumer>\r\n  return <div />\r\n}\r\n```\r\n\r\nSeems like you could use `unstable_read()` in `getDerivedStateFromProps` and that would put it into state so you can use it in lifecycles. So maybe that's sufficient. It still means you need to be explicit about which contexts you want to remember though.\r\n\r\nI wonder if we can find a better solution to these use cases.",
        "remove_template_description": "Sometimes we have an imperative wrapper like this:    ```js  componentDidMount() {    renderSomethingImperatively(this.props)  }    componentDidUpdate() {    renderSomethingImperatively(this.props)  }    render() {    return null  }  ```    Portals eliminated the need for this for regular DOM jumps. But we still need this for embedding renderers (e.g. `react-art` [does this](https://github.com/facebook/react/blob/3b3b7fcbbdc734d7f2a2e509a0b07c0eb053f779/packages/react-art/src/ReactART.js#L59-L84)) and use cases like \"Vue inside React\".    For cross-renderer embedding, maybe we could extend portals to do that (https://github.com/facebook/react/issues/13332). There are still imperative use cases for cross-library rendering though.    One thing that becomes annoying is that new context won't propagate down through this imperative boundary. This is because we don't maintain a stack in the commit phase. We're traversing a flat linked list of effects. So we don't actually know what context value is current by the time `componentDidMount` or `componentDidUpdate` fires.    For `react-art` and friends, this means context from a host app is not accessible. This is quite annoying. You could hack around it with something like    ```js  <MyConsumer>    {value =>      <ReactART.Surface>        <MyContext.Provider value={value}>          <Stuff />        </MyContext.Provider>      </ReactART.Surface>    }  </MyConsumer>  ```    But this is neither obvious nor convenient. You have to anticipate all contexts that can get used below.    This seems even less convenient for imperative cases like \"Vue inside React\".     ```js  componentDidMount() {    renderSomethingImperatively(this.props) // ???  }    componentDidUpdate() {    renderSomethingImperatively(this.props) // ???  }    render() {    // <MyConsumer>{value => ???}</MyConsumer>    return <div />  }  ```    Seems like you could use `unstable_read()` in `getDerivedStateFromProps` and that would put it into state so you can use it in lifecycles. So maybe that's sufficient. It still means you need to be explicit about which contexts you want to remember though.    I wonder if we can find a better solution to these use cases.",
        "human_words": "Sometimes we have an imperative wrapper like this:        Portals eliminated the need for this for regular DOM jumps. But we still need this for embedding renderers (e.g. `react-art` [does this](https://github.com/facebook/react/blob/3b3b7fcbbdc734d7f2a2e509a0b07c0eb053f779/packages/react-art/src/ReactART.js#L59-L84)) and use cases like \"Vue inside React\".    For cross-renderer embedding, maybe we could extend portals to do that (https://github.com/facebook/react/issues/13332). There are still imperative use cases for cross-library rendering though.    One thing that becomes annoying is that new context won't propagate down through this imperative boundary. This is because we don't maintain a stack in the commit phase. We're traversing a flat linked list of effects. So we don't actually know what context value is current by the time `componentDidMount` or `componentDidUpdate` fires.    For `react-art` and friends, this means context from a host app is not accessible. This is quite annoying. You could hack around it with something like        But this is neither obvious nor convenient. You have to anticipate all contexts that can get used below.    This seems even less convenient for imperative cases like \"Vue inside React\".         Seems like you could use `unstable_read()` in `getDerivedStateFromProps` and that would put it into state so you can use it in lifecycles. So maybe that's sufficient. It still means you need to be explicit about which contexts you want to remember though.    I wonder if we can find a better solution to these use cases.",
        "human_words_regrex": "Sometimes we have an imperative wrapper like this: Portals eliminated the need for this for regular DOM jumps. But we still need this for embedding renderers (e.g. `react-art` ) and use cases like \"Vue inside React\". For cross-renderer embedding, maybe we could extend portals to do that ( There are still imperative use cases for cross-library rendering though. One thing that becomes annoying is that new context won't propagate down through this imperative boundary. This is because we don't maintain a stack in the commit phase. We're traversing a flat linked list of effects. So we don't actually know what context value is current by the time `componentDidMount` or `componentDidUpdate` fires. For `react-art` and friends, this means context from a host app is not accessible. This is quite annoying. You could hack around it with something like But this is neither obvious nor convenient. You have to anticipate all contexts that can get used below. This seems even less convenient for imperative cases like \"Vue inside React\". Seems like you could use `unstable_read()` in `getDerivedStateFromProps` and that would put it into state so you can use it in lifecycles. So maybe that's sufficient. It still means you need to be explicit about which contexts you want to remember though. I wonder if we can find a better solution to these use cases.",
        "human_words_stopwords_removal_lemmatization": "sometimes imperative wrapper like : portal eliminated need regular dom jump . still need embedding renderers ( e.g . ` react-art ` ) use case like `` vue inside react '' . cross-renderer embedding , maybe could extend portal ( still imperative use case cross-library rendering though . one thing becomes annoying new context wo n't propagate imperative boundary . n't maintain stack commit phase . 're traversing flat linked list effect . n't actually know context value current time ` componentdidmount ` ` componentdidupdate ` fire . ` react-art ` friend , mean context host app accessible . quite annoying . could hack around something like neither obvious convenient . anticipate context get used . seems even le convenient imperative case like `` vue inside react '' . seems like could use ` unstable_read ( ) ` ` getderivedstatefromprops ` would put state use lifecycles . maybe 's sufficient . still mean need explicit context want remember though . wonder find better solution use case .",
        "title_stopwords_removal_lemmatization": "imperative wrapper ca n't access current context value commit phase"
    },
    {
        "issue_id": 341038585,
        "title": "Longterm support for Internet Explorer",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-07-13T14:23:24Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**feature**\r\n\r\nI'd like to know how the current roadmap for support of the Internet Explorer (namely the IE11) is. Is there a time frame for which react guarantees IE support and if yes for how long?\r\n\r\nBest regards and thanks for any answer! ",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **feature**    I'd like to know how the current roadmap for support of the Internet Explorer (namely the IE11) is. Is there a time frame for which react guarantees IE support and if yes for how long?    Best regards and thanks for any answer!",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **feature**    I'd like to know how the current roadmap for support of the Internet Explorer (namely the IE11) is. Is there a time frame for which react guarantees IE support and if yes for how long?    Best regards and thanks for any answer!",
        "human_words_regrex": " **feature** I'd like to know how the current roadmap for support of the Internet Explorer (namely the IE11) is. Is there a time frame for which react guarantees IE support and if yes for how long? Best regards and thanks for any answer!",
        "human_words_stopwords_removal_lemmatization": "* * feature * * 'd like know current roadmap support internet explorer ( namely ie11 ) . time frame react guarantee ie support yes long ? best regard thanks answer !",
        "title_stopwords_removal_lemmatization": "longterm support internet explorer"
    },
    {
        "issue_id": 336031026,
        "title": "Moving to React Portal after touchstart swallows future touch events",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2018-06-26T23:55:39Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug \ud83d\udc1e\r\n\r\n**What is the current behavior?**\r\n\r\nWhen you move a component into a React Portal in response to a `touchstart` the `touchmove` and `touchend` events are swallowed for the rest of the interaction\r\n\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nExample: https://codesandbox.io/s/nr75vkklnm\r\n\r\n> You will either need to be on touch device, or enable touch sensors in your browser to see this\r\n\r\nSteps:\r\n\r\n1. add a `onTouchStart` listener to a component\r\n2. in response to `onTouchStart` move the component into a Portal\r\n3. touchmove events and the touchend events are then blocked for the rest of the touch interaction\r\n\r\nIf the component is already in a component before the touchstart event then the events are emitted correctly: https://codesandbox.io/s/v54x54vp5\r\n\r\nI have also created a vanilla js example that has a portal implementation. It moves the element into a portal after touch start. It is correctly allowing touch touchmove and touchend events: https://codesandbox.io/s/r4mn0yj6po\r\n\r\n**What is the expected behavior?**\r\n\r\nThat the touchmove and touchend events are published\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReproduced bug in Firefox and Chrome\r\n\r\nReact version: tested on 16.1, 16.3 and 16.4.1",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug \ud83d\udc1e    **What is the current behavior?**    When you move a component into a React Portal in response to a `touchstart` the `touchmove` and `touchend` events are swallowed for the rest of the interaction        **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    Example: https://codesandbox.io/s/nr75vkklnm    > You will either need to be on touch device, or enable touch sensors in your browser to see this    Steps:    1. add a `onTouchStart` listener to a component  2. in response to `onTouchStart` move the component into a Portal  3. touchmove events and the touchend events are then blocked for the rest of the touch interaction    If the component is already in a component before the touchstart event then the events are emitted correctly: https://codesandbox.io/s/v54x54vp5    I have also created a vanilla js example that has a portal implementation. It moves the element into a portal after touch start. It is correctly allowing touch touchmove and touchend events: https://codesandbox.io/s/r4mn0yj6po    **What is the expected behavior?**    That the touchmove and touchend events are published    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Reproduced bug in Firefox and Chrome    React version: tested on 16.1, 16.3 and 16.4.1",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Bug \ud83d\udc1e    **What is the current behavior?**    When you move a component into a React Portal in response to a `touchstart` the `touchmove` and `touchend` events are swallowed for the rest of the interaction        **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    Example: https://codesandbox.io/s/nr75vkklnm    > You will either need to be on touch device, or enable touch sensors in your browser to see this    Steps:    1. add a `onTouchStart` listener to a component  2. in response to `onTouchStart` move the component into a Portal  3. touchmove events and the touchend events are then blocked for the rest of the touch interaction    If the component is already in a component before the touchstart event then the events are emitted correctly: https://codesandbox.io/s/v54x54vp5    I have also created a vanilla js example that has a portal implementation. It moves the element into a portal after touch start. It is correctly allowing touch touchmove and touchend events: https://codesandbox.io/s/r4mn0yj6po    **What is the expected behavior?**    That the touchmove and touchend events are published    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    Reproduced bug in Firefox and Chrome    React version: tested on 16.1, 16.3 and 16.4.1",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Bug \ud83d\udc1e **What is the current behavior?** When you move a component into a React Portal in response to a `touchstart` the `touchmove` and `touchend` events are swallowed for the rest of the interaction **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** Example:  > You will either need to be on touch device, or enable touch sensors in your browser to see this Steps: 1. add a `onTouchStart` listener to a component 2. in response to `onTouchStart` move the component into a Portal 3. touchmove events and the touchend events are then blocked for the rest of the touch interaction If the component is already in a component before the touchstart event then the events are emitted correctly:  I have also created a vanilla js example that has a portal implementation. It moves the element into a portal after touch start. It is correctly allowing touch touchmove and touchend events:  **What is the expected behavior?** That the touchmove and touchend events are published **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** Reproduced bug in Firefox and Chrome React version: tested on 16.1, 16.3 and 16.4.1",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug \ud83d\udc1e * * current behavior ? * * move component react portal response ` touchstart ` ` touchmove ` ` touchend ` event swallowed rest interaction * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * example : > either need touch device , enable touch sensor browser see step : 1. add ` ontouchstart ` listener component 2. response ` ontouchstart ` move component portal 3. touchmove event touchend event blocked rest touch interaction component already component touchstart event event emitted correctly : also created vanilla j example portal implementation . move element portal touch start . correctly allowing touch touchmove touchend event : * * expected behavior ? * * touchmove touchend event published * * version react , browser / o affected issue ? work previous version react ? * * reproduced bug firefox chrome react version : tested 16.1 , 16.3 16.4.1",
        "title_stopwords_removal_lemmatization": "moving react portal touchstart swallow future touch event"
    },
    {
        "issue_id": 330904209,
        "title": "Exposing prevProps in getDerivedStateFromProps for persistent view animations",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-06-09T17:15:17Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nRequest a feature\r\n\r\n**What is the current behavior?**\r\n`getDerivedStateFromProps` does not expose `prevProps`\r\n\r\n**What is the expected behavior?**\r\n`getDerivedStateFromProps` should expose `prevProps` for cleaner implementation of use case mentioned below.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nreact: 16.4+\r\n\r\nI know there was a similar discussion in the issues here before regarding exposing previous props in `getDerivedStateFromProps`, but I believe I came across a use case where this can be useful, its very specific, yet it required me to replicate a lot of previous props in the state.\r\n\r\nBelow is a component I use in react-native to add an animation where screens crossfade and don't just unmount instantly, it also checks if next route is an overlay and preserves screen behind it. As you can see I had to create `prevPathname` `prevData` and `prevChildren` for this to work, which I think is not too terrible, yet results in a lot of repetition.\r\n\r\nPerhaps my implementation is missing something to remove the repetition or maybe I am not understanding why we are not exposing prevProps?\r\n\r\n```js\r\n// @flow\r\nimport React, { Component } from 'react'\r\nimport { Animated } from 'react-native'\r\nimport { durationNormal, easeInQuad, easeOutQuad } from '../services/Animation'\r\nimport type { Node } from 'react'\r\n\r\ntype Props = {\r\n  pathname: string,\r\n  data: ?{ overlay: boolean },\r\n  children: Node,\r\n  authenticated: boolean\r\n}\r\n\r\ntype State = {\r\n  prevPathname: ?string,\r\n  prevChildren: Node,\r\n  prevData: ?{ overlay: boolean },\r\n  animation: Animated.Value,\r\n  activeChildren: Node,\r\n  pointerEvents: boolean,\r\n  authAnimation: boolean\r\n}\r\n\r\nclass RouteFadeAnimation extends Component<Props, State> {\r\n  state = {\r\n    prevPathname: null,\r\n    prevChildren: null,\r\n    prevData: null,\r\n    animation: new Animated.Value(0),\r\n    activeChildren: null,\r\n    pointerEvents: true,\r\n    authAnimation: true\r\n  }\r\n\r\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\r\n    const { pathname, data, children } = nextProps\r\n    const { prevPathname, prevData, prevChildren } = prevState\r\n    // This will be returned always to store \"previous\" props in state, so we can compare against them in\r\n    // future getDerivedStateFromProps, this is where I'd like to use prevProps\r\n    const prevPropsState = {\r\n      prevChildren: children,\r\n      prevPathname: pathname,\r\n      prevData: data\r\n    }\r\n    // Check if pathname changed, i.e we are going to another view\r\n    if (pathname !== prevPathname) {\r\n      // Check if current visible view is a modal, if it is, we go to default return\r\n      if (!prevData || !prevData.overlay) {\r\n        // Check if future view is not a modal\r\n        if (!data || !data.overlay) {\r\n          // Preserve current view while we are animationg out (even though pathname changed)\r\n          return {\r\n            activeChildren: prevChildren,\r\n            pointerEvents: false,\r\n            ...prevPropsState\r\n          }\r\n        // If future view is a modal, preserve current view, so it is visible behind it\r\n        } else if (data.overlay) {\r\n          return {\r\n            activeChildren: prevChildren,\r\n            ...prevPropsState\r\n          }\r\n        }\r\n      }\r\n      // If previous view was a modal (only normal view can follow after modal) reset our view persistance\r\n      // and use children as opposed to activeChildren\r\n      return {\r\n        activeChildren: null,\r\n        ...prevPropsState\r\n      }\r\n    }\r\n    // Persist prevProps in state\r\n    return {\r\n      ...prevPropsState\r\n    }\r\n  }\r\n\r\n  // This just handles animation based on cases above\r\n  componentDidUpdate(prevProps: Props) {\r\n    const { pathname, data, authenticated } = this.props\r\n    const { authAnimation } = this.state\r\n    if (authenticated && authAnimation) this.animate(1)\r\n    else if (pathname !== prevProps.pathname) {\r\n      if (!prevProps.data || !prevProps.data.overlay) {\r\n        if (!data || !data.overlay) this.animate(0)\r\n      }\r\n    }\r\n  }\r\n\r\n  animate = (value: 0 | 1) => {\r\n    let delay = value === 1 ? 60 : 0\r\n    const { authAnimation } = this.state\r\n    if (authAnimation) delay = 2000\r\n    Animated.timing(this.state.animation, {\r\n      toValue: value,\r\n      duration: durationNormal,\r\n      delay,\r\n      easing: value === 0 ? easeInQuad : easeOutQuad,\r\n      useNativeDriver: true\r\n    }).start(() => this.animationLogic(value))\r\n  }\r\n\r\n  animationLogic = (value: 0 | 1) => {\r\n    if (value === 0) this.setState({ activeChildren: null }, () => this.animate(1))\r\n    else this.setState({ pointerEvents: true, authAnimation: false })\r\n  }\r\n\r\n  render() {\r\n    const { animation, pointerEvents, activeChildren } = this.state\r\n    const { children } = this.props\r\n    return (\r\n      <Animated.View\r\n        pointerEvents={pointerEvents ? 'auto' : 'none'}\r\n        style={{\r\n          opacity: animation.interpolate({ inputRange: [0, 1], outputRange: [0, 1] }),\r\n          transform: [\r\n            {\r\n              scale: animation.interpolate({ inputRange: [0, 1], outputRange: [0.94, 1] })\r\n            }\r\n          ]\r\n        }}\r\n      >\r\n        {activeChildren || children}\r\n      </Animated.View>\r\n    )\r\n  }\r\n}\r\n\r\nexport default RouteFadeAnimation\r\n```\r\n\r\n### Usage example and explanation\r\n\r\nThis component is used to wrap several routes and on pathname change preserve previous view, animate it out, replace it with new view and animate it in. Idea itself comes from react-router's documentation https://reacttraining.com/react-router/native/guides/animation/page-transitions but they use `componentWillMount` there.\r\n\r\nbasic implementation can look like this:\r\n\r\n```js\r\n<RouterFadeAnimation \r\n  pathname={routerProps.pathname} \r\n  data={routerProps.data} \r\n  authenticated={authProps.auth}>\r\n     \r\n     {routerProps.pathname === \"/home\" && <HomePage />}\r\n     {routerProps.pathname === \"/about\" && <AboutPage />}\r\n\r\n</RouterFadeAnimation>\r\n```\r\n\r\nOutside of this, there is similar component called `<RouteModalAnimation />` that overlays component above, it similarly animates views in when routerProps.data has `overlay: true` set, you will see our original component checks for this and preserves its view so it appears behind the modal, as it would otherwise dissapear due to route change.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Request a feature    **What is the current behavior?**  `getDerivedStateFromProps` does not expose `prevProps`    **What is the expected behavior?**  `getDerivedStateFromProps` should expose `prevProps` for cleaner implementation of use case mentioned below.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  react: 16.4+    I know there was a similar discussion in the issues here before regarding exposing previous props in `getDerivedStateFromProps`, but I believe I came across a use case where this can be useful, its very specific, yet it required me to replicate a lot of previous props in the state.    Below is a component I use in react-native to add an animation where screens crossfade and don't just unmount instantly, it also checks if next route is an overlay and preserves screen behind it. As you can see I had to create `prevPathname` `prevData` and `prevChildren` for this to work, which I think is not too terrible, yet results in a lot of repetition.    Perhaps my implementation is missing something to remove the repetition or maybe I am not understanding why we are not exposing prevProps?    ```js  // @flow  import React, { Component } from 'react'  import { Animated } from 'react-native'  import { durationNormal, easeInQuad, easeOutQuad } from '../services/Animation'  import type { Node } from 'react'    type Props = {    pathname: string,    data: ?{ overlay: boolean },    children: Node,    authenticated: boolean  }    type State = {    prevPathname: ?string,    prevChildren: Node,    prevData: ?{ overlay: boolean },    animation: Animated.Value,    activeChildren: Node,    pointerEvents: boolean,    authAnimation: boolean  }    class RouteFadeAnimation extends Component<Props, State> {    state = {      prevPathname: null,      prevChildren: null,      prevData: null,      animation: new Animated.Value(0),      activeChildren: null,      pointerEvents: true,      authAnimation: true    }      static getDerivedStateFromProps(nextProps: Props, prevState: State) {      const { pathname, data, children } = nextProps      const { prevPathname, prevData, prevChildren } = prevState      // This will be returned always to store \"previous\" props in state, so we can compare against them in      // future getDerivedStateFromProps, this is where I'd like to use prevProps      const prevPropsState = {        prevChildren: children,        prevPathname: pathname,        prevData: data      }      // Check if pathname changed, i.e we are going to another view      if (pathname !== prevPathname) {        // Check if current visible view is a modal, if it is, we go to default return        if (!prevData || !prevData.overlay) {          // Check if future view is not a modal          if (!data || !data.overlay) {            // Preserve current view while we are animationg out (even though pathname changed)            return {              activeChildren: prevChildren,              pointerEvents: false,              ...prevPropsState            }          // If future view is a modal, preserve current view, so it is visible behind it          } else if (data.overlay) {            return {              activeChildren: prevChildren,              ...prevPropsState            }          }        }        // If previous view was a modal (only normal view can follow after modal) reset our view persistance        // and use children as opposed to activeChildren        return {          activeChildren: null,          ...prevPropsState        }      }      // Persist prevProps in state      return {        ...prevPropsState      }    }      // This just handles animation based on cases above    componentDidUpdate(prevProps: Props) {      const { pathname, data, authenticated } = this.props      const { authAnimation } = this.state      if (authenticated && authAnimation) this.animate(1)      else if (pathname !== prevProps.pathname) {        if (!prevProps.data || !prevProps.data.overlay) {          if (!data || !data.overlay) this.animate(0)        }      }    }      animate = (value: 0 | 1) => {      let delay = value === 1 ? 60 : 0      const { authAnimation } = this.state      if (authAnimation) delay = 2000      Animated.timing(this.state.animation, {        toValue: value,        duration: durationNormal,        delay,        easing: value === 0 ? easeInQuad : easeOutQuad,        useNativeDriver: true      }).start(() => this.animationLogic(value))    }      animationLogic = (value: 0 | 1) => {      if (value === 0) this.setState({ activeChildren: null }, () => this.animate(1))      else this.setState({ pointerEvents: true, authAnimation: false })    }      render() {      const { animation, pointerEvents, activeChildren } = this.state      const { children } = this.props      return (        <Animated.View          pointerEvents={pointerEvents ? 'auto' : 'none'}          style={{            opacity: animation.interpolate({ inputRange: [0, 1], outputRange: [0, 1] }),            transform: [              {                scale: animation.interpolate({ inputRange: [0, 1], outputRange: [0.94, 1] })              }            ]          }}        >          {activeChildren || children}        </Animated.View>      )    }  }    export default RouteFadeAnimation  ```    ### Usage example and explanation    This component is used to wrap several routes and on pathname change preserve previous view, animate it out, replace it with new view and animate it in. Idea itself comes from react-router's documentation https://reacttraining.com/react-router/native/guides/animation/page-transitions but they use `componentWillMount` there.    basic implementation can look like this:    ```js  <RouterFadeAnimation     pathname={routerProps.pathname}     data={routerProps.data}     authenticated={authProps.auth}>              {routerProps.pathname === \"/home\" && <HomePage />}       {routerProps.pathname === \"/about\" && <AboutPage />}    </RouterFadeAnimation>  ```    Outside of this, there is similar component called `<RouteModalAnimation />` that overlays component above, it similarly animates views in when routerProps.data has `overlay: true` set, you will see our original component checks for this and preserves its view so it appears behind the modal, as it would otherwise dissapear due to route change.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Request a feature    **What is the current behavior?**  `getDerivedStateFromProps` does not expose `prevProps`    **What is the expected behavior?**  `getDerivedStateFromProps` should expose `prevProps` for cleaner implementation of use case mentioned below.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  react: 16.4+    I know there was a similar discussion in the issues here before regarding exposing previous props in `getDerivedStateFromProps`, but I believe I came across a use case where this can be useful, its very specific, yet it required me to replicate a lot of previous props in the state.    Below is a component I use in react-native to add an animation where screens crossfade and don't just unmount instantly, it also checks if next route is an overlay and preserves screen behind it. As you can see I had to create `prevPathname` `prevData` and `prevChildren` for this to work, which I think is not too terrible, yet results in a lot of repetition.    Perhaps my implementation is missing something to remove the repetition or maybe I am not understanding why we are not exposing prevProps?        ### Usage example and explanation    This component is used to wrap several routes and on pathname change preserve previous view, animate it out, replace it with new view and animate it in. Idea itself comes from react-router's documentation https://reacttraining.com/react-router/native/guides/animation/page-transitions but they use `componentWillMount` there.    basic implementation can look like this:        Outside of this, there is similar component called `<RouteModalAnimation />` that overlays component above, it similarly animates views in when routerProps.data has `overlay: true` set, you will see our original component checks for this and preserves its view so it appears behind the modal, as it would otherwise dissapear due to route change.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Request a feature **What is the current behavior?** `getDerivedStateFromProps` does not expose `prevProps` **What is the expected behavior?** `getDerivedStateFromProps` should expose `prevProps` for cleaner implementation of use case mentioned below. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** react: 16.4+ I know there was a similar discussion in the issues here before regarding exposing previous props in `getDerivedStateFromProps`, but I believe I came across a use case where this can be useful, its very specific, yet it required me to replicate a lot of previous props in the state. Below is a component I use in react-native to add an animation where screens crossfade and don't just unmount instantly, it also checks if next route is an overlay and preserves screen behind it. As you can see I had to create `prevPathname` `prevData` and `prevChildren` for this to work, which I think is not too terrible, yet results in a lot of repetition. Perhaps my implementation is missing something to remove the repetition or maybe I am not understanding why we are not exposing prevProps? ### Usage example and explanation This component is used to wrap several routes and on pathname change preserve previous view, animate it out, replace it with new view and animate it in. Idea itself comes from react-router's documentation  but they use `componentWillMount` there. basic implementation can look like this: Outside of this, there is similar component called `` that overlays component above, it similarly animates views in when routerProps.data has `overlay: true` set, you will see our original component checks for this and preserves its view so it appears behind the modal, as it would otherwise dissapear due to route change.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * request feature * * current behavior ? * * ` getderivedstatefromprops ` expose ` prevprops ` * * expected behavior ? * * ` getderivedstatefromprops ` expose ` prevprops ` cleaner implementation use case mentioned . * * version react , browser / o affected issue ? work previous version react ? * * react : 16.4+ know similar discussion issue regarding exposing previous prop ` getderivedstatefromprops ` , believe came across use case useful , specific , yet required replicate lot previous prop state . component use react-native add animation screen crossfade n't unmount instantly , also check next route overlay preserve screen behind . see create ` prevpathname ` ` prevdata ` ` prevchildren ` work , think terrible , yet result lot repetition . perhaps implementation missing something remove repetition maybe understanding exposing prevprops ? # # # usage example explanation component used wrap several route pathname change preserve previous view , animate , replace new view animate . idea come react-router 's documentation use ` componentwillmount ` . basic implementation look like : outside , similar component called `` overlay component , similarly animates view routerprops.data ` overlay : true ` set , see original component check preserve view appears behind modal , would otherwise dissapear due route change .",
        "title_stopwords_removal_lemmatization": "exposing prevprops getderivedstatefromprops persistent view animation"
    },
    {
        "issue_id": 330447029,
        "title": "can't yield children from a generator in render()",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-06-07T21:44:55Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug.\r\n\r\n**What is the current behavior?**\r\n\r\nvia this thread https://twitter.com/aweary/status/1004837394439290880\r\npassing the result of a generator as a child doesn't 'work'. it renders no children, without an error or warning. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\nrepro - https://codesandbox.io/s/5zp0j8389x\r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nfor the above example, a hundred `<span>`s, numbered 100 -> 1\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n16.x, all browsers \r\n\r\n\r\n(It appears the validation logic drains the iterator, so when we finally try to 'get' the children again, it returns nothing.) ",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    bug.    **What is the current behavior?**    via this thread https://twitter.com/aweary/status/1004837394439290880  passing the result of a generator as a child doesn't 'work'. it renders no children, without an error or warning.     **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    repro - https://codesandbox.io/s/5zp0j8389x      **What is the expected behavior?**    for the above example, a hundred `<span>`s, numbered 100 -> 1    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.x, all browsers       (It appears the validation logic drains the iterator, so when we finally try to 'get' the children again, it returns nothing.)",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    bug.    **What is the current behavior?**    via this thread https://twitter.com/aweary/status/1004837394439290880  passing the result of a generator as a child doesn't 'work'. it renders no children, without an error or warning.     **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    repro - https://codesandbox.io/s/5zp0j8389x      **What is the expected behavior?**    for the above example, a hundred `<span>`s, numbered 100 -> 1    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.x, all browsers       (It appears the validation logic drains the iterator, so when we finally try to 'get' the children again, it returns nothing.)",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** bug. **What is the current behavior?** via this thread  passing the result of a generator as a child doesn't 'work'. it renders no children, without an error or warning. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** repro -  **What is the expected behavior?** for the above example, a hundred ``s, numbered 100 -> 1 **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.x, all browsers (It appears the validation logic drains the iterator, so when we finally try to 'get' the children again, it returns nothing.)",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug . * * current behavior ? * * via thread passing result generator child n't 'work ' . render child , without error warning . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * repro - * * expected behavior ? * * example , hundred `` , numbered 100 - > 1 * * version react , browser / o affected issue ? work previous version react ? * * 16.x , browser ( appears validation logic drain iterator , finally try 'get ' child , return nothing . )",
        "title_stopwords_removal_lemmatization": "ca n't yield child generator render ( )"
    },
    {
        "issue_id": 320753594,
        "title": "Best practice for a meaningful componentStack in production?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-05-07T10:28:16Z",
        "status": "closed",
        "description": "Using Sentry for bug reporting in our production build we often encounter a `componentStack` like:\r\n```\r\n    in b\r\n    in li\r\n    in ul\r\n    in v\r\n    in div\r\n    in div\r\n    in i\r\n    in div\r\n    in Unknown\r\n    in t\u2026\r\n```\r\n\r\nOf course, this doesn\u2019t help to locate the problem at all. So I\u2019m wondering, what\u2019s the best practice to get usable information from ErrorBoundaries and the componentStack.\r\nThe following options seem to be available:\r\n* Set `mangle: false` in uglify (increases bundle size, but works)\r\n* Set `displayName` manually for all components (usually not feasible)\r\n* Use a [babel plugin](https://github.com/opbeat/babel-plugin-add-react-displayname) (somehow misses the majority of components for me)\r\n* Write a tool, that resolves the names using sourcemaps\r\n\r\nI\u2019m curious to hear, what most people are using. For me, only the first option works well, but it doesn\u2019t feel like a very elegant solution.",
        "remove_template_description": "Using Sentry for bug reporting in our production build we often encounter a `componentStack` like:  ```      in b      in li      in ul      in v      in div      in div      in i      in div      in Unknown      in t\u2026  ```    Of course, this doesn\u2019t help to locate the problem at all. So I\u2019m wondering, what\u2019s the best practice to get usable information from ErrorBoundaries and the componentStack.  The following options seem to be available:  * Set `mangle: false` in uglify (increases bundle size, but works)  * Set `displayName` manually for all components (usually not feasible)  * Use a [babel plugin](https://github.com/opbeat/babel-plugin-add-react-displayname) (somehow misses the majority of components for me)  * Write a tool, that resolves the names using sourcemaps    I\u2019m curious to hear, what most people are using. For me, only the first option works well, but it doesn\u2019t feel like a very elegant solution.",
        "human_words": "Using Sentry for bug reporting in our production build we often encounter a `componentStack` like:      Of course, this doesn\u2019t help to locate the problem at all. So I\u2019m wondering, what\u2019s the best practice to get usable information from ErrorBoundaries and the componentStack.  The following options seem to be available:  * Set `mangle: false` in uglify (increases bundle size, but works)  * Set `displayName` manually for all components (usually not feasible)  * Use a [babel plugin](https://github.com/opbeat/babel-plugin-add-react-displayname) (somehow misses the majority of components for me)  * Write a tool, that resolves the names using sourcemaps    I\u2019m curious to hear, what most people are using. For me, only the first option works well, but it doesn\u2019t feel like a very elegant solution.",
        "human_words_regrex": "Using Sentry for bug reporting in our production build we often encounter a `componentStack` like: Of course, this doesn\u2019t help to locate the problem at all. So I\u2019m wondering, what\u2019s the best practice to get usable information from ErrorBoundaries and the componentStack. The following options seem to be available: * Set `mangle: false` in uglify (increases bundle size, but works) * Set `displayName` manually for all components (usually not feasible) * Use a  (somehow misses the majority of components for me) * Write a tool, that resolves the names using sourcemaps I\u2019m curious to hear, what most people are using. For me, only the first option works well, but it doesn\u2019t feel like a very elegant solution.",
        "human_words_stopwords_removal_lemmatization": "using sentry bug reporting production build often encounter ` componentstack ` like : course , \u2019 help locate problem . \u2019 wondering , \u2019 best practice get usable information errorboundaries componentstack . following option seem available : * set ` mangle : false ` uglify ( increase bundle size , work ) * set ` displayname ` manually component ( usually feasible ) * use ( somehow miss majority component ) * write tool , resolve name using sourcemaps \u2019 curious hear , people using . , first option work well , \u2019 feel like elegant solution .",
        "title_stopwords_removal_lemmatization": "best practice meaningful componentstack production ?"
    },
    {
        "issue_id": 317434558,
        "title": "When unmounting a Fragment node, it's children are removed from the DOM one at a time instead of all at once",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-04-24T23:54:56Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug (maybe! - or perhaps it's just a limitation of Fragments - let me know!)\r\n\r\n**What is the current behavior?**\r\n\r\nWhen unmounting a Fragment, it's children are removed from the DOM one at time top to bottom.\r\n\r\nThis means if during the unmounting step if I'm quickly calculating where it is in the DOM, its position can change before I can save that data. I also imagine it's less performant.\r\n\r\nLook in your console for the outputs for these.\r\n\r\n**1a) Using Fragment - Element can be found:**\r\nhttps://codesandbox.io/s/k9jl6vo8yv\r\n\r\n**1b) Using Fragment - Element can't be found:**\r\nhttps://codesandbox.io/s/1omjz1m8l\r\n\r\n**2a) Using div - Element can be found (expected behaviour for Fragment):**\r\nhttps://codesandbox.io/s/l34o1kw8m\r\n\r\n**2b) Using div - Element can't be found (when switching out parent with children, with parent with no children):**\r\nhttps://codesandbox.io/s/w02yv3o4zw\r\n\r\n**What is the expected behavior?**\r\n\r\n1) That both the Fragments children would be removed from the DOM at the same time, instead of one after the other.\r\n\r\n2) That both children of the div would be removed from the DOM at the same time when essentially removing the children.\r\n\r\nThese both look like they're part of the same problem.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n16.3, unsure if it worked in previous versions.\r\n\r\n----\r\n\r\nLet me know if I can help with anything :).\r\n\r\nCheers",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Bug (maybe! - or perhaps it's just a limitation of Fragments - let me know!)    **What is the current behavior?**    When unmounting a Fragment, it's children are removed from the DOM one at time top to bottom.    This means if during the unmounting step if I'm quickly calculating where it is in the DOM, its position can change before I can save that data. I also imagine it's less performant.    Look in your console for the outputs for these.    **1a) Using Fragment - Element can be found:**  https://codesandbox.io/s/k9jl6vo8yv    **1b) Using Fragment - Element can't be found:**  https://codesandbox.io/s/1omjz1m8l    **2a) Using div - Element can be found (expected behaviour for Fragment):**  https://codesandbox.io/s/l34o1kw8m    **2b) Using div - Element can't be found (when switching out parent with children, with parent with no children):**  https://codesandbox.io/s/w02yv3o4zw    **What is the expected behavior?**    1) That both the Fragments children would be removed from the DOM at the same time, instead of one after the other.    2) That both children of the div would be removed from the DOM at the same time when essentially removing the children.    These both look like they're part of the same problem.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.3, unsure if it worked in previous versions.    ----    Let me know if I can help with anything :).    Cheers",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Bug (maybe! - or perhaps it's just a limitation of Fragments - let me know!)    **What is the current behavior?**    When unmounting a Fragment, it's children are removed from the DOM one at time top to bottom.    This means if during the unmounting step if I'm quickly calculating where it is in the DOM, its position can change before I can save that data. I also imagine it's less performant.    Look in your console for the outputs for these.    **1a) Using Fragment - Element can be found:**  https://codesandbox.io/s/k9jl6vo8yv    **1b) Using Fragment - Element can't be found:**  https://codesandbox.io/s/1omjz1m8l    **2a) Using div - Element can be found (expected behaviour for Fragment):**  https://codesandbox.io/s/l34o1kw8m    **2b) Using div - Element can't be found (when switching out parent with children, with parent with no children):**  https://codesandbox.io/s/w02yv3o4zw    **What is the expected behavior?**    1) That both the Fragments children would be removed from the DOM at the same time, instead of one after the other.    2) That both children of the div would be removed from the DOM at the same time when essentially removing the children.    These both look like they're part of the same problem.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    16.3, unsure if it worked in previous versions.    ----    Let me know if I can help with anything :).    Cheers",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug (maybe! - or perhaps it's just a limitation of Fragments - let me know!) **What is the current behavior?** When unmounting a Fragment, it's children are removed from the DOM one at time top to bottom. This means if during the unmounting step if I'm quickly calculating where it is in the DOM, its position can change before I can save that data. I also imagine it's less performant. Look in your console for the outputs for these. **1a) Using Fragment - Element can be found:**  **1b) Using Fragment - Element can't be found:**  **2a) Using div - Element can be found (expected behaviour for Fragment):**  **2b) Using div - Element can't be found (when switching out parent with children, with parent with no children):**  **What is the expected behavior?** 1) That both the Fragments children would be removed from the DOM at the same time, instead of one after the other. 2) That both children of the div would be removed from the DOM at the same time when essentially removing the children. These both look like they're part of the same problem. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 16.3, unsure if it worked in previous versions. ---- Let me know if I can help with anything :). Cheers",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug ( maybe ! - perhaps 's limitation fragment - let know ! ) * * current behavior ? * * unmounting fragment , 's child removed dom one time top bottom . mean unmounting step 'm quickly calculating dom , position change save data . also imagine 's le performant . look console output . * * 1a ) using fragment - element found : * * * * 1b ) using fragment - element ca n't found : * * * * 2a ) using div - element found ( expected behaviour fragment ) : * * * * 2b ) using div - element ca n't found ( switching parent child , parent child ) : * * * * expected behavior ? * * 1 ) fragment child would removed dom time , instead one . 2 ) child div would removed dom time essentially removing child . look like 're part problem . * * version react , browser / o affected issue ? work previous version react ? * * 16.3 , unsure worked previous version . -- -- let know help anything : ) . cheer",
        "title_stopwords_removal_lemmatization": "unmounting fragment node , 's child removed dom one time instead"
    },
    {
        "issue_id": 315374388,
        "title": "First pass context is lost in Call - Return",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2018-04-18T08:10:08Z",
        "status": "closed",
        "description": "I have been really enjoying my explorations into building better 'compound components' using the experimental `react-call-return`. This issue is intended to start a discussion of some of the shortcomings of the current API that I ran into.\r\n\r\nExperiments in which the `return` is used as a leaf node that yields some data are very successful. Since #11955 was solved I have not run into further issues with the stability of this feature.\r\n\r\nHowever, for 'compound component' usage, to implement features such as layout, my `return` often yields an element or render prop. In these cases, these elements are rendered with the `call` as the parent, and any context created in the first pass (between the `call` and `return`) is lost.\r\n\r\nA reproduction case can be found here: https://codesandbox.io/s/0p4lvy72pl, as an end-user of these components (unaware that they use call-return internally), I would expect to see 'Greetings 1' instead of 'Default 1'.\r\n\r\nI don't consider this a bug, but rather a side-effect of how I'm using the API. However, I believe the use-case above is a valid one and providing an API that supports this would be beneficial to library authors. Below I'll share some thoughts on such an API for discussion.\r\n\r\n---\r\n\r\nInitially, the API was called coroutine and yield, which suggested a subtree would yield and later resume. Presumably, this is why the API was renamed. My suggestion would be to implement the coroutine-yield functionality, which continues rendering the 'continuation' as children of the yield fiber. Of course I am not aware of all the choices that led to the current API, so input here is welcomed.\r\n\r\n`createCoroutine(children, handler, props)` would function very similarly to the current `createCall`, but the handler does not return the children to render. Instead, it returns some aggregated value. This value is passed to the second argument of `createYield(value, continuation, props)`, together with that yield element's props and index within the coroutine. The element returned from the continuation is reconciled with the yield fiber's children, preserving its position in the tree and thus also any context that was accumulated between the coroutine and yield.\r\n\r\nNote that the new API would be a strict superset of the current implementation, I imagine the call-return could be written with coroutine and yield as follows:\r\n\r\n```javascript\r\nconst createCall = (children, handler, props) => createCoroutine(\r\n  [\r\n    createYield(null, (props, values, index) => handler(values.props, values.yields), props),\r\n    ...React.Children.toArray(children),\r\n  ],\r\n  (props, [_, ...yields]) => ({ props, yields }),\r\n  props\r\n);\r\n\r\nconst createReturn = value => createYield(value, () => null);\r\n```\r\n\r\nI've dived into the reconciler implementation for call and return, and implementing an API like the above seems feasible to me. I'd definitely be willing to give it a shot once the approach is clear. However, I am not aware of all the decisions that led up to the current implementation, and the exact impact on performance (increased tree traversals) etc...\r\n\r\nCC'ing @sebmarkbage and @gaearon\r\n\r\nEDIT: I've prototyped this API on CodeSandbox here: https://codesandbox.io/s/480nx1qw97, it causes multiple renders using `setState` and `forceUpdate`, and uses some nasty traversals of `_reactInternalFiber`, it is **highly unstable**, but it illustrates the idea outlined above.",
        "remove_template_description": "I have been really enjoying my explorations into building better 'compound components' using the experimental `react-call-return`. This issue is intended to start a discussion of some of the shortcomings of the current API that I ran into.    Experiments in which the `return` is used as a leaf node that yields some data are very successful. Since #11955 was solved I have not run into further issues with the stability of this feature.    However, for 'compound component' usage, to implement features such as layout, my `return` often yields an element or render prop. In these cases, these elements are rendered with the `call` as the parent, and any context created in the first pass (between the `call` and `return`) is lost.    A reproduction case can be found here: https://codesandbox.io/s/0p4lvy72pl, as an end-user of these components (unaware that they use call-return internally), I would expect to see 'Greetings 1' instead of 'Default 1'.    I don't consider this a bug, but rather a side-effect of how I'm using the API. However, I believe the use-case above is a valid one and providing an API that supports this would be beneficial to library authors. Below I'll share some thoughts on such an API for discussion.    ---    Initially, the API was called coroutine and yield, which suggested a subtree would yield and later resume. Presumably, this is why the API was renamed. My suggestion would be to implement the coroutine-yield functionality, which continues rendering the 'continuation' as children of the yield fiber. Of course I am not aware of all the choices that led to the current API, so input here is welcomed.    `createCoroutine(children, handler, props)` would function very similarly to the current `createCall`, but the handler does not return the children to render. Instead, it returns some aggregated value. This value is passed to the second argument of `createYield(value, continuation, props)`, together with that yield element's props and index within the coroutine. The element returned from the continuation is reconciled with the yield fiber's children, preserving its position in the tree and thus also any context that was accumulated between the coroutine and yield.    Note that the new API would be a strict superset of the current implementation, I imagine the call-return could be written with coroutine and yield as follows:    ```javascript  const createCall = (children, handler, props) => createCoroutine(    [      createYield(null, (props, values, index) => handler(values.props, values.yields), props),      ...React.Children.toArray(children),    ],    (props, [_, ...yields]) => ({ props, yields }),    props  );    const createReturn = value => createYield(value, () => null);  ```    I've dived into the reconciler implementation for call and return, and implementing an API like the above seems feasible to me. I'd definitely be willing to give it a shot once the approach is clear. However, I am not aware of all the decisions that led up to the current implementation, and the exact impact on performance (increased tree traversals) etc...    CC'ing @sebmarkbage and @gaearon    EDIT: I've prototyped this API on CodeSandbox here: https://codesandbox.io/s/480nx1qw97, it causes multiple renders using `setState` and `forceUpdate`, and uses some nasty traversals of `_reactInternalFiber`, it is **highly unstable**, but it illustrates the idea outlined above.",
        "human_words": "I have been really enjoying my explorations into building better 'compound components' using the experimental `react-call-return`. This issue is intended to start a discussion of some of the shortcomings of the current API that I ran into.    Experiments in which the `return` is used as a leaf node that yields some data are very successful. Since #11955 was solved I have not run into further issues with the stability of this feature.    However, for 'compound component' usage, to implement features such as layout, my `return` often yields an element or render prop. In these cases, these elements are rendered with the `call` as the parent, and any context created in the first pass (between the `call` and `return`) is lost.    A reproduction case can be found here: https://codesandbox.io/s/0p4lvy72pl, as an end-user of these components (unaware that they use call-return internally), I would expect to see 'Greetings 1' instead of 'Default 1'.    I don't consider this a bug, but rather a side-effect of how I'm using the API. However, I believe the use-case above is a valid one and providing an API that supports this would be beneficial to library authors. Below I'll share some thoughts on such an API for discussion.    ---    Initially, the API was called coroutine and yield, which suggested a subtree would yield and later resume. Presumably, this is why the API was renamed. My suggestion would be to implement the coroutine-yield functionality, which continues rendering the 'continuation' as children of the yield fiber. Of course I am not aware of all the choices that led to the current API, so input here is welcomed.    `createCoroutine(children, handler, props)` would function very similarly to the current `createCall`, but the handler does not return the children to render. Instead, it returns some aggregated value. This value is passed to the second argument of `createYield(value, continuation, props)`, together with that yield element's props and index within the coroutine. The element returned from the continuation is reconciled with the yield fiber's children, preserving its position in the tree and thus also any context that was accumulated between the coroutine and yield.    Note that the new API would be a strict superset of the current implementation, I imagine the call-return could be written with coroutine and yield as follows:        I've dived into the reconciler implementation for call and return, and implementing an API like the above seems feasible to me. I'd definitely be willing to give it a shot once the approach is clear. However, I am not aware of all the decisions that led up to the current implementation, and the exact impact on performance (increased tree traversals) etc...    CC'ing @sebmarkbage and @gaearon    EDIT: I've prototyped this API on CodeSandbox here: https://codesandbox.io/s/480nx1qw97, it causes multiple renders using `setState` and `forceUpdate`, and uses some nasty traversals of `_reactInternalFiber`, it is **highly unstable**, but it illustrates the idea outlined above.",
        "human_words_regrex": "I have been really enjoying my explorations into building better 'compound components' using the experimental `react-call-return`. This issue is intended to start a discussion of some of the shortcomings of the current API that I ran into. Experiments in which the `return` is used as a leaf node that yields some data are very successful. Since #11955 was solved I have not run into further issues with the stability of this feature. However, for 'compound component' usage, to implement features such as layout, my `return` often yields an element or render prop. In these cases, these elements are rendered with the `call` as the parent, and any context created in the first pass (between the `call` and `return`) is lost. A reproduction case can be found here:  as an end-user of these components (unaware that they use call-return internally), I would expect to see 'Greetings 1' instead of 'Default 1'. I don't consider this a bug, but rather a side-effect of how I'm using the API. However, I believe the use-case above is a valid one and providing an API that supports this would be beneficial to library authors. Below I'll share some thoughts on such an API for discussion. --- Initially, the API was called coroutine and yield, which suggested a subtree would yield and later resume. Presumably, this is why the API was renamed. My suggestion would be to implement the coroutine-yield functionality, which continues rendering the 'continuation' as children of the yield fiber. Of course I am not aware of all the choices that led to the current API, so input here is welcomed. `createCoroutine(children, handler, props)` would function very similarly to the current `createCall`, but the handler does not return the children to render. Instead, it returns some aggregated value. This value is passed to the second argument of `createYield(value, continuation, props)`, together with that yield element's props and index within the coroutine. The element returned from the continuation is reconciled with the yield fiber's children, preserving its position in the tree and thus also any context that was accumulated between the coroutine and yield. Note that the new API would be a strict superset of the current implementation, I imagine the call-return could be written with coroutine and yield as follows: I've dived into the reconciler implementation for call and return, and implementing an API like the above seems feasible to me. I'd definitely be willing to give it a shot once the approach is clear. However, I am not aware of all the decisions that led up to the current implementation, and the exact impact on performance (increased tree traversals) etc... CC'ing @sebmarkbage and @gaearon EDIT: I've prototyped this API on CodeSandbox here:  it causes multiple renders using `setState` and `forceUpdate`, and uses some nasty traversals of `_reactInternalFiber`, it is **highly unstable**, but it illustrates the idea outlined above.",
        "human_words_stopwords_removal_lemmatization": "really enjoying exploration building better 'compound component ' using experimental ` react-call-return ` . issue intended start discussion shortcoming current api ran . experiment ` return ` used leaf node yield data successful . since # 11955 solved run issue stability feature . however , 'compound component ' usage , implement feature layout , ` return ` often yield element render prop . case , element rendered ` call ` parent , context created first pas ( ` call ` ` return ` ) lost . reproduction case found : end-user component ( unaware use call-return internally ) , would expect see 'greetings 1 ' instead 'default 1 ' . n't consider bug , rather side-effect 'm using api . however , believe use-case valid one providing api support would beneficial library author . 'll share thought api discussion . -- - initially , api called coroutine yield , suggested subtree would yield later resume . presumably , api renamed . suggestion would implement coroutine-yield functionality , continues rendering 'continuation ' child yield fiber . course aware choice led current api , input welcomed . ` createcoroutine ( child , handler , prop ) ` would function similarly current ` createcall ` , handler return child render . instead , return aggregated value . value passed second argument ` createyield ( value , continuation , prop ) ` , together yield element 's prop index within coroutine . element returned continuation reconciled yield fiber 's child , preserving position tree thus also context accumulated coroutine yield . note new api would strict superset current implementation , imagine call-return could written coroutine yield follows : 've dived reconciler implementation call return , implementing api like seems feasible . 'd definitely willing give shot approach clear . however , aware decision led current implementation , exact impact performance ( increased tree traversal ) etc ... cc'ing @ sebmarkbage @ gaearon edit : 've prototyped api codesandbox : cause multiple render using ` setstate ` ` forceupdate ` , us nasty traversal ` _reactinternalfiber ` , * * highly unstable * * , illustrates idea outlined .",
        "title_stopwords_removal_lemmatization": "first pas context lost call - return"
    },
    {
        "issue_id": 308069851,
        "title": "Dangerous strings can reach browser builtins",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2018-03-23T15:16:28Z",
        "status": "open",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA bug, but a well known and worked-around one.\r\n\r\n**What is the current behavior?**\r\n\r\n```jsx\r\nvar x = 'javascript:alert(1)';\r\nReactDOM.render(\r\n  (<a href={x}>Link</a>),\r\n  document.getElementById('container')\r\n);\r\n```\r\n\r\nproduces a link that alerts.\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**\r\n\r\n* [Load the code above in the codepen REPL](https://jsfiddle.net/Luktwrdm/202/)\r\n* After the REPL loads, click the \"Run\" button at the top left.\r\n* You should see a blue \"link\" in the bottom-right pane.\r\n* Click it.  An alert will popup.\r\n\r\nThe alert should not pop up.\r\n\r\nA simple string that reaches an `href` attribute should not cause arbitrary code execution even with user interaction.\r\n\r\n\r\n**What is the expected behavior?**\r\nA string that reaches a browser builtin like the `HTMLAElement.prototype.href` setter should not cause code execution.\r\n\r\n**Discussion**\r\n\r\n[Polymer Resin](https://docs.google.com/presentation/d/1hepAXMroHSNTM0NV1aGlntjHrw0a0QOM5X5JvfXv_N0/edit#slide=id.g227691820f_0_198) uses hooks in another webcomponents framework to intercept value before they reach browser builtins where they can be vetted.  A similar approach could work for React.\r\n\r\nIt allows values to reach browser builtins when they are innocuous or have a runtime type that indicates that the author intentionally marked them as safe for that kind of browser builtin.\r\n\r\nFor example, an `instanceof SafeURL` would be allowed to reach `HTMLAElement.prototype.href` as would any string that is a relative URL, or one with a whitelisted protocol in (`http`, `https`, `mailto`, `tel`) but not `javascript:...`.\r\n\r\nMany developers know that `<a href={...}>` is risky, but if the link is an implementation detail of a custom React element, then developers don't have the context to know which attributes they need to be careful with.  They shouldn't have to either since it is an implementation detail.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nI believe this is widespread across versions.\r\n\r\nAn earlier REPL I tried showed that it worked on version 16.2.0 from https://unpkg.com/react-dom/umd/react-dom.development.js but I don't know what version the jsfiddle above uses.\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A bug, but a well known and worked-around one.    **What is the current behavior?**    ```jsx  var x = 'javascript:alert(1)';  ReactDOM.render(    (<a href={x}>Link</a>),    document.getElementById('container')  );  ```    produces a link that alerts.      **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    * [Load the code above in the codepen REPL](https://jsfiddle.net/Luktwrdm/202/)  * After the REPL loads, click the \"Run\" button at the top left.  * You should see a blue \"link\" in the bottom-right pane.  * Click it.  An alert will popup.    The alert should not pop up.    A simple string that reaches an `href` attribute should not cause arbitrary code execution even with user interaction.      **What is the expected behavior?**  A string that reaches a browser builtin like the `HTMLAElement.prototype.href` setter should not cause code execution.    **Discussion**    [Polymer Resin](https://docs.google.com/presentation/d/1hepAXMroHSNTM0NV1aGlntjHrw0a0QOM5X5JvfXv_N0/edit#slide=id.g227691820f_0_198) uses hooks in another webcomponents framework to intercept value before they reach browser builtins where they can be vetted.  A similar approach could work for React.    It allows values to reach browser builtins when they are innocuous or have a runtime type that indicates that the author intentionally marked them as safe for that kind of browser builtin.    For example, an `instanceof SafeURL` would be allowed to reach `HTMLAElement.prototype.href` as would any string that is a relative URL, or one with a whitelisted protocol in (`http`, `https`, `mailto`, `tel`) but not `javascript:...`.    Many developers know that `<a href={...}>` is risky, but if the link is an implementation detail of a custom React element, then developers don't have the context to know which attributes they need to be careful with.  They shouldn't have to either since it is an implementation detail.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    I believe this is widespread across versions.    An earlier REPL I tried showed that it worked on version 16.2.0 from https://unpkg.com/react-dom/umd/react-dom.development.js but I don't know what version the jsfiddle above uses.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    A bug, but a well known and worked-around one.    **What is the current behavior?**        produces a link that alerts.      **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**    * [Load the code above in the codepen REPL](https://jsfiddle.net/Luktwrdm/202/)  * After the REPL loads, click the \"Run\" button at the top left.  * You should see a blue \"link\" in the bottom-right pane.  * Click it.  An alert will popup.    The alert should not pop up.    A simple string that reaches an `href` attribute should not cause arbitrary code execution even with user interaction.      **What is the expected behavior?**  A string that reaches a browser builtin like the `HTMLAElement.prototype.href` setter should not cause code execution.    **Discussion**    [Polymer Resin](https://docs.google.com/presentation/d/1hepAXMroHSNTM0NV1aGlntjHrw0a0QOM5X5JvfXv_N0/edit#slide=id.g227691820f_0_198) uses hooks in another webcomponents framework to intercept value before they reach browser builtins where they can be vetted.  A similar approach could work for React.    It allows values to reach browser builtins when they are innocuous or have a runtime type that indicates that the author intentionally marked them as safe for that kind of browser builtin.    For example, an `instanceof SafeURL` would be allowed to reach `HTMLAElement.prototype.href` as would any string that is a relative URL, or one with a whitelisted protocol in (`http`, `https`, `mailto`, `tel`) but not `javascript:...`.    Many developers know that `<a href={...}>` is risky, but if the link is an implementation detail of a custom React element, then developers don't have the context to know which attributes they need to be careful with.  They shouldn't have to either since it is an implementation detail.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    I believe this is widespread across versions.    An earlier REPL I tried showed that it worked on version 16.2.0 from https://unpkg.com/react-dom/umd/react-dom.development.js but I don't know what version the jsfiddle above uses.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** A bug, but a well known and worked-around one. **What is the current behavior?** produces a link that alerts. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle ( or CodeSandbox ( example below:** *  * After the REPL loads, click the \"Run\" button at the top left. * You should see a blue \"link\" in the bottom-right pane. * Click it. An alert will popup. The alert should not pop up. A simple string that reaches an `href` attribute should not cause arbitrary code execution even with user interaction. **What is the expected behavior?** A string that reaches a browser builtin like the `HTMLAElement.prototype.href` setter should not cause code execution. **Discussion**  uses hooks in another webcomponents framework to intercept value before they reach browser builtins where they can be vetted. A similar approach could work for React. It allows values to reach browser builtins when they are innocuous or have a runtime type that indicates that the author intentionally marked them as safe for that kind of browser builtin. For example, an `instanceof SafeURL` would be allowed to reach `HTMLAElement.prototype.href` as would any string that is a relative URL, or one with a whitelisted protocol in (` ` `mailto`, `tel`) but not `javascript:...`. Many developers know that `` is risky, but if the link is an implementation detail of a custom React element, then developers don't have the context to know which attributes they need to be careful with. They shouldn't have to either since it is an implementation detail. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** I believe this is widespread across versions. An earlier REPL I tried showed that it worked on version 16.2.0 from  but I don't know what version the jsfiddle above uses.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug , well known worked-around one . * * current behavior ? * * produce link alert . * * current behavior bug , please provide step reproduce possible minimal demo problem . bug get fixed much faster run code n't dependency react . paste link jsfiddle ( codesandbox ( example : * * * * repl load , click `` run '' button top left . * see blue `` link '' bottom-right pane . * click . alert popup . alert pop . simple string reach ` href ` attribute cause arbitrary code execution even user interaction . * * expected behavior ? * * string reach browser builtin like ` htmlaelement.prototype.href ` setter cause code execution . * * discussion * * us hook another webcomponents framework intercept value reach browser builtins vetted . similar approach could work react . allows value reach browser builtins innocuous runtime type indicates author intentionally marked safe kind browser builtin . example , ` instanceof safeurl ` would allowed reach ` htmlaelement.prototype.href ` would string relative url , one whitelisted protocol ( ` ` ` mailto ` , ` tel ` ) ` javascript : ... ` . many developer know `` risky , link implementation detail custom react element , developer n't context know attribute need careful . n't either since implementation detail . * * version react , browser / o affected issue ? work previous version react ? * * believe widespread across version . earlier repl tried showed worked version 16.2.0 n't know version jsfiddle us .",
        "title_stopwords_removal_lemmatization": "dangerous string reach browser builtins"
    },
    {
        "issue_id": 297543236,
        "title": "Ordering of componentWillMount/Unmount in React 16",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2018-02-15T18:07:04Z",
        "status": "closed",
        "description": "### Problem\r\nIt seems that the ordering of `componentWillMount` and `componentWillUnmount` is no longer guaranteed in React 16 due to support for async `componentWillUnmount`. \r\n\r\nPreviously, `componentWillUnmount` was always called on old components being removed *before* `componentWillMount` was called on new components.\r\n\r\n### Example\r\nWe have a Form component in which inputs \"register\" themselves with the parent Form in `componentWillMount` and deregister themselves in `componentWillUnmount` (this allows the Form to keep track of global state for all of the inputs). The following scenario will cause the Form to throw an error now that ordering is no longer guaranteed:\r\n\r\n```jsx\r\n{ showTextInput ? <TextInput name=\"a\" /> : <CheckboxInput name=\"a\" /> }\r\n```\r\n\r\nIn this scenario, it's possible that the Form will try to register an input with the same name before the previous input has been unmounted, which is not allowed.\r\n\r\n### Question\r\nWhile I understand the reasoning behind this change, I'm wondering what the suggested solution is if our code previously relied on `componentWillUnmount` firing before `componentWillMount`? \r\n\r\nThe most obvious solution that comes to mind is moving the `registerInput` step from `willMount` into `didMount`. However, this means we'll have to deal with an unnecessary re-render upon mounting the input. Is this still the correct approach?",
        "remove_template_description": "### Problem  It seems that the ordering of `componentWillMount` and `componentWillUnmount` is no longer guaranteed in React 16 due to support for async `componentWillUnmount`.     Previously, `componentWillUnmount` was always called on old components being removed *before* `componentWillMount` was called on new components.    ### Example  We have a Form component in which inputs \"register\" themselves with the parent Form in `componentWillMount` and deregister themselves in `componentWillUnmount` (this allows the Form to keep track of global state for all of the inputs). The following scenario will cause the Form to throw an error now that ordering is no longer guaranteed:    ```jsx  { showTextInput ? <TextInput name=\"a\" /> : <CheckboxInput name=\"a\" /> }  ```    In this scenario, it's possible that the Form will try to register an input with the same name before the previous input has been unmounted, which is not allowed.    ### Question  While I understand the reasoning behind this change, I'm wondering what the suggested solution is if our code previously relied on `componentWillUnmount` firing before `componentWillMount`?     The most obvious solution that comes to mind is moving the `registerInput` step from `willMount` into `didMount`. However, this means we'll have to deal with an unnecessary re-render upon mounting the input. Is this still the correct approach?",
        "human_words": "### Problem  It seems that the ordering of `componentWillMount` and `componentWillUnmount` is no longer guaranteed in React 16 due to support for async `componentWillUnmount`.     Previously, `componentWillUnmount` was always called on old components being removed *before* `componentWillMount` was called on new components.    ### Example  We have a Form component in which inputs \"register\" themselves with the parent Form in `componentWillMount` and deregister themselves in `componentWillUnmount` (this allows the Form to keep track of global state for all of the inputs). The following scenario will cause the Form to throw an error now that ordering is no longer guaranteed:        In this scenario, it's possible that the Form will try to register an input with the same name before the previous input has been unmounted, which is not allowed.    ### Question  While I understand the reasoning behind this change, I'm wondering what the suggested solution is if our code previously relied on `componentWillUnmount` firing before `componentWillMount`?     The most obvious solution that comes to mind is moving the `registerInput` step from `willMount` into `didMount`. However, this means we'll have to deal with an unnecessary re-render upon mounting the input. Is this still the correct approach?",
        "human_words_regrex": "### Problem It seems that the ordering of `componentWillMount` and `componentWillUnmount` is no longer guaranteed in React 16 due to support for async `componentWillUnmount`. Previously, `componentWillUnmount` was always called on old components being removed *before* `componentWillMount` was called on new components. ### Example We have a Form component in which inputs \"register\" themselves with the parent Form in `componentWillMount` and deregister themselves in `componentWillUnmount` (this allows the Form to keep track of global state for all of the inputs). The following scenario will cause the Form to throw an error now that ordering is no longer guaranteed: In this scenario, it's possible that the Form will try to register an input with the same name before the previous input has been unmounted, which is not allowed. ### Question While I understand the reasoning behind this change, I'm wondering what the suggested solution is if our code previously relied on `componentWillUnmount` firing before `componentWillMount`? The most obvious solution that comes to mind is moving the `registerInput` step from `willMount` into `didMount`. However, this means we'll have to deal with an unnecessary re-render upon mounting the input. Is this still the correct approach?",
        "human_words_stopwords_removal_lemmatization": "# # # problem seems ordering ` componentwillmount ` ` componentwillunmount ` longer guaranteed react 16 due support async ` componentwillunmount ` . previously , ` componentwillunmount ` always called old component removed * * ` componentwillmount ` called new component . # # # example form component input `` register '' parent form ` componentwillmount ` deregister ` componentwillunmount ` ( allows form keep track global state input ) . following scenario cause form throw error ordering longer guaranteed : scenario , 's possible form try register input name previous input unmounted , allowed . # # # question understand reasoning behind change , 'm wondering suggested solution code previously relied ` componentwillunmount ` firing ` componentwillmount ` ? obvious solution come mind moving ` registerinput ` step ` willmount ` ` didmount ` . however , mean 'll deal unnecessary re-render upon mounting input . still correct approach ?",
        "title_stopwords_removal_lemmatization": "ordering componentwillmount/unmount react 16"
    },
    {
        "issue_id": 295044019,
        "title": "Remove use of Proxy for events in development",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-02-07T08:17:56Z",
        "status": "closed",
        "description": "I think maybe we should revert https://github.com/facebook/react/pull/5947.\r\n\r\nPeople already think `proxyEvent` is some kind of an API: https://github.com/facebook/react/issues/12169.\r\n\r\nIt's also annoying to view in the debugger because none of the properties show up.\r\n\r\nInstead, we could seal the event object or something like that.",
        "remove_template_description": "I think maybe we should revert https://github.com/facebook/react/pull/5947.    People already think `proxyEvent` is some kind of an API: https://github.com/facebook/react/issues/12169.    It's also annoying to view in the debugger because none of the properties show up.    Instead, we could seal the event object or something like that.",
        "human_words": "I think maybe we should revert https://github.com/facebook/react/pull/5947.    People already think `proxyEvent` is some kind of an API: https://github.com/facebook/react/issues/12169.    It's also annoying to view in the debugger because none of the properties show up.    Instead, we could seal the event object or something like that.",
        "human_words_regrex": "I think maybe we should revert  People already think `proxyEvent` is some kind of an API:  It's also annoying to view in the debugger because none of the properties show up. Instead, we could seal the event object or something like that.",
        "human_words_stopwords_removal_lemmatization": "think maybe revert people already think ` proxyevent ` kind api : 's also annoying view debugger none property show . instead , could seal event object something like .",
        "title_stopwords_removal_lemmatization": "remove use proxy event development"
    },
    {
        "issue_id": 290146804,
        "title": "__source makes component stack less useful",
        "label": [
            "Type: Discussion"
        ],
        "date": "2018-01-20T00:32:03Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nSomewhere in between.\r\n\r\n**What is the current behavior?**\r\n\r\nWhen I enable `babel-plugin-transform-react-jsx-source` to automatically add a `__source` prop to every component in development, the component stack displayed for certain React warnings changes from displaying the (inferred) name of the rendering component to displaying the filename and line number of the occurrence.\r\n\r\nReact also has access to the file path, but [it is stripped](https://github.com/facebook/react/blob/30dac4e78de02fb427ee82013160ae875128d7a2/packages/shared/describeComponentFrame.js#L20) and only the filename is included. This seems to be based on the assumption that the name of a file always maps exactly to the name of the component it exports. In practice, many people place components in `ComponentName/index.js`, so `__source` currently makes the stack _less_ useful.\r\n\r\nFor example, compare:\r\n```\r\n    in DownloadDropdown (created by Foo)\r\n    in Foo (created by Bar)\r\n    in div (created by Bar)\r\n    in div (created by Bar)\r\n    in div (created by Section)\r\n    in section (created by Section)\r\n    in Section (created by Bar)\r\n    in div (created by App)\r\n    in main (created by App)\r\n    ...\r\n```\r\nto:\r\n```\r\n    in DownloadDropdown (at index.js:53)\r\n    in Foo (at index.js:183)\r\n    in div (at index.js:182)\r\n    in div (at index.js:175)\r\n    in div (at index.js:29)\r\n    in section (at index.js:28)\r\n    in Section (at index.js:173)\r\n    in div (at index.js:26)\r\n    in main (at index.js:24)\r\n    ...\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nI would like the stack to include the full file path, or at least to include the inferred component name alongside the filename.\r\n\r\nWould you accept a PR for either option?\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nReact 16.2.0. This was introduced in #6771 for 15.2.0.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Somewhere in between.    **What is the current behavior?**    When I enable `babel-plugin-transform-react-jsx-source` to automatically add a `__source` prop to every component in development, the component stack displayed for certain React warnings changes from displaying the (inferred) name of the rendering component to displaying the filename and line number of the occurrence.    React also has access to the file path, but [it is stripped](https://github.com/facebook/react/blob/30dac4e78de02fb427ee82013160ae875128d7a2/packages/shared/describeComponentFrame.js#L20) and only the filename is included. This seems to be based on the assumption that the name of a file always maps exactly to the name of the component it exports. In practice, many people place components in `ComponentName/index.js`, so `__source` currently makes the stack _less_ useful.    For example, compare:  ```      in DownloadDropdown (created by Foo)      in Foo (created by Bar)      in div (created by Bar)      in div (created by Bar)      in div (created by Section)      in section (created by Section)      in Section (created by Bar)      in div (created by App)      in main (created by App)      ...  ```  to:  ```      in DownloadDropdown (at index.js:53)      in Foo (at index.js:183)      in div (at index.js:182)      in div (at index.js:175)      in div (at index.js:29)      in section (at index.js:28)      in Section (at index.js:173)      in div (at index.js:26)      in main (at index.js:24)      ...  ```    **What is the expected behavior?**    I would like the stack to include the full file path, or at least to include the inferred component name alongside the filename.    Would you accept a PR for either option?    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.2.0. This was introduced in #6771 for 15.2.0.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Somewhere in between.    **What is the current behavior?**    When I enable `babel-plugin-transform-react-jsx-source` to automatically add a `__source` prop to every component in development, the component stack displayed for certain React warnings changes from displaying the (inferred) name of the rendering component to displaying the filename and line number of the occurrence.    React also has access to the file path, but [it is stripped](https://github.com/facebook/react/blob/30dac4e78de02fb427ee82013160ae875128d7a2/packages/shared/describeComponentFrame.js#L20) and only the filename is included. This seems to be based on the assumption that the name of a file always maps exactly to the name of the component it exports. In practice, many people place components in `ComponentName/index.js`, so `__source` currently makes the stack _less_ useful.    For example, compare:    to:      **What is the expected behavior?**    I would like the stack to include the full file path, or at least to include the inferred component name alongside the filename.    Would you accept a PR for either option?    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    React 16.2.0. This was introduced in #6771 for 15.2.0.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Somewhere in between. **What is the current behavior?** When I enable `babel-plugin-transform-react-jsx-source` to automatically add a `__source` prop to every component in development, the component stack displayed for certain React warnings changes from displaying the (inferred) name of the rendering component to displaying the filename and line number of the occurrence. React also has access to the file path, but  and only the filename is included. This seems to be based on the assumption that the name of a file always maps exactly to the name of the component it exports. In practice, many people place components in `ComponentName/index.js`, so `__source` currently makes the stack _less_ useful. For example, compare: to: **What is the expected behavior?** I would like the stack to include the full file path, or at least to include the inferred component name alongside the filename. Would you accept a PR for either option? **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.2.0. This was introduced in #6771 for 15.2.0.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * somewhere . * * current behavior ? * * enable ` babel-plugin-transform-react-jsx-source ` automatically add ` __source ` prop every component development , component stack displayed certain react warning change displaying ( inferred ) name rendering component displaying filename line number occurrence . react also access file path , filename included . seems based assumption name file always map exactly name component export . practice , many people place component ` componentname/index.js ` , ` __source ` currently make stack _less_ useful . example , compare : : * * expected behavior ? * * would like stack include full file path , least include inferred component name alongside filename . would accept pr either option ? * * version react , browser / o affected issue ? work previous version react ? * * react 16.2.0. introduced # 6771 15.2.0 .",
        "title_stopwords_removal_lemmatization": "__source make component stack le useful"
    },
    {
        "issue_id": 285220446,
        "title": "Remove legacy TODOs in ReactElement.createFactory() and ReactElementValidator.createFactoryWithValidation() ",
        "label": [
            "Component: Core Utilities",
            "Type: Discussion"
        ],
        "date": "2017-12-30T19:47:53Z",
        "status": "closed",
        "description": "I came across this line -\r\n https://github.com/facebook/react/blob/dd8b387b69d73f9e8ed4f995ccb3cd927c0d33e3/packages/react/src/ReactElement.js#L269\r\n\r\nI am interested in taking this up as my first pull-request. Please let me know what is required for adding a warning and it's related test/s. Thank you. \ud83d\ude05",
        "remove_template_description": "I came across this line -   https://github.com/facebook/react/blob/dd8b387b69d73f9e8ed4f995ccb3cd927c0d33e3/packages/react/src/ReactElement.js#L269    I am interested in taking this up as my first pull-request. Please let me know what is required for adding a warning and it's related test/s. Thank you. \ud83d\ude05",
        "human_words": "I came across this line -   https://github.com/facebook/react/blob/dd8b387b69d73f9e8ed4f995ccb3cd927c0d33e3/packages/react/src/ReactElement.js#L269    I am interested in taking this up as my first pull-request. Please let me know what is required for adding a warning and it's related test/s. Thank you. \ud83d\ude05",
        "human_words_regrex": "I came across this line -  I am interested in taking this up as my first pull-request. Please let me know what is required for adding a warning and it's related test/s. Thank you. \ud83d\ude05",
        "human_words_stopwords_removal_lemmatization": "came across line - interested taking first pull-request . please let know required adding warning 's related test/s . thank . \ud83d\ude05",
        "title_stopwords_removal_lemmatization": "remove legacy todos reactelement.createfactory ( ) reactelementvalidator.createfactorywithvalidation ( )"
    },
    {
        "issue_id": 284951633,
        "title": "Point production build at un-minified file?",
        "label": [
            "Component: Build Infrastructure",
            "Type: Discussion"
        ],
        "date": "2017-12-28T16:52:13Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nWhen `NODE_ENV === 'production'`, [react](https://github.com/facebook/react/blob/master/packages/react/npm/index.js#L4) and [react-dom](https://github.com/facebook/react/blob/master/packages/react-dom/npm/index.js#L35) both point to their respective _minified_ production builds.\r\n\r\nIn the context of being included in a larger bundle, this is undesirable because minifying an entire bundle at once produces (slightly) smaller output than when its constituent pieces have already been minified.\r\n\r\n**What is the expected behavior?**\r\n\r\nI understand the desire to keep React \"small by default\" and clearly gate the dev/prod builds, but would you consider pointing at an un-minified production build instead?\r\n\r\nSorry if this has been discussed elsewhere. I couldn't find any issues.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nThis was introduced when the NODE_ENV check was simplified to point at separate builds.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    When `NODE_ENV === 'production'`, [react](https://github.com/facebook/react/blob/master/packages/react/npm/index.js#L4) and [react-dom](https://github.com/facebook/react/blob/master/packages/react-dom/npm/index.js#L35) both point to their respective _minified_ production builds.    In the context of being included in a larger bundle, this is undesirable because minifying an entire bundle at once produces (slightly) smaller output than when its constituent pieces have already been minified.    **What is the expected behavior?**    I understand the desire to keep React \"small by default\" and clearly gate the dev/prod builds, but would you consider pointing at an un-minified production build instead?    Sorry if this has been discussed elsewhere. I couldn't find any issues.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This was introduced when the NODE_ENV check was simplified to point at separate builds.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    When `NODE_ENV === 'production'`, [react](https://github.com/facebook/react/blob/master/packages/react/npm/index.js#L4) and [react-dom](https://github.com/facebook/react/blob/master/packages/react-dom/npm/index.js#L35) both point to their respective _minified_ production builds.    In the context of being included in a larger bundle, this is undesirable because minifying an entire bundle at once produces (slightly) smaller output than when its constituent pieces have already been minified.    **What is the expected behavior?**    I understand the desire to keep React \"small by default\" and clearly gate the dev/prod builds, but would you consider pointing at an un-minified production build instead?    Sorry if this has been discussed elsewhere. I couldn't find any issues.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    This was introduced when the NODE_ENV check was simplified to point at separate builds.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** When `NODE_ENV === 'production'`,  and  both point to their respective _minified_ production builds. In the context of being included in a larger bundle, this is undesirable because minifying an entire bundle at once produces (slightly) smaller output than when its constituent pieces have already been minified. **What is the expected behavior?** I understand the desire to keep React \"small by default\" and clearly gate the dev/prod builds, but would you consider pointing at an un-minified production build instead? Sorry if this has been discussed elsewhere. I couldn't find any issues. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** This was introduced when the NODE_ENV check was simplified to point at separate builds.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * ` node_env === 'production ' ` , point respective _minified_ production build . context included larger bundle , undesirable minifying entire bundle produce ( slightly ) smaller output constituent piece already minified . * * expected behavior ? * * understand desire keep react `` small default '' clearly gate dev/prod build , would consider pointing un-minified production build instead ? sorry discussed elsewhere . could n't find issue . * * version react , browser / o affected issue ? work previous version react ? * * introduced node_env check simplified point separate build .",
        "title_stopwords_removal_lemmatization": "point production build un-minified file ?"
    },
    {
        "issue_id": 283681401,
        "title": "reconciler's tryToClaimNextHydratableInstance next-nextInstance heuristic creating duplicative elements",
        "label": [
            "Component: Server Rendering",
            "Type: Discussion"
        ],
        "date": "2017-12-20T20:10:42Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nbug (though the React code is working as intended)\r\n\r\n**What is the current behavior?**\r\nWhen hydrating from server-rendered DOM, if [react-reconciler encounters an unexpected node](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberHydrationContext.js#L229) it will peek ahead to the next DOM node and test if it is the expected node. If so, react-reconciler will delete the unexpected node and continue on by using the second node to hydrate. If the second node does not match the instance then the reconciler gives up and begins inserting DOM nodes without trying to reconcile.\r\n\r\nIn our case, we are server-side rendering the entire #document server-side and re-hydrating at that level. Some 3rd party analytics scripts are injected at the top of <body> before the hydrate call happens, causing the entire application to be injected into the body instead of reconciled with the existing nodes.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**\r\nI can force this to happen in our app by injecting two (or more) empty `script` tags at the top of <body>. I've not been able to reproduce via jsfiddle; unsure what the exact combination of flags are to force this specific code path.\r\n\r\n```\r\ndocument.body.insertBefore(document.createElement('script'), document.body.children[0]);\r\ndocument.body.insertBefore(document.createElement('script'), document.body.children[0]);\r\n```\r\n\r\n**What is the expected behavior?**\r\nIdeally the reconciler would look at all of the sibling nodes to find the matching element.\r\n\r\nA comment in the code at the relevant location says\r\n```\r\n// If we can't hydrate this instance let's try the next one.\r\n// We use this as a heuristic. It's based on intuition and not data so it\r\n// might be flawed or unnecessary.\r\n```\r\n\r\nI hacked together a change to prove out inspecting all sibling elements and that seems to be working with no unintended consequences. I modified\r\n\r\n`nextInstance = getNextHydratableSibling(nextInstance);`\r\nto be\r\n`while (nextInstance = getNextHydratableSibling(nextInstance), nextInstance && !canHydrate(fiber, nextInstance)) {};`\r\n\r\nSo nextInstance will either be the hydratable sibling or it will be null.\r\n\r\nUsing `performance.now()` on my Mac Book Pro, I do not observe this O(1) -> O(n) change to be measurable in my situation.\r\n\r\n```\r\nwith matching DOM: 118-144ms\r\nwith mismatched DOM: 116-172ms\r\nmismatchedDOM & updated function: 116-163ms\r\n```\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nThis was introduced with React 16s new hydration approach. (I'll take this over the Invariant 42 full-stop error; thanks for building the new approach!).",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  bug (though the React code is working as intended)    **What is the current behavior?**  When hydrating from server-rendered DOM, if [react-reconciler encounters an unexpected node](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberHydrationContext.js#L229) it will peek ahead to the next DOM node and test if it is the expected node. If so, react-reconciler will delete the unexpected node and continue on by using the second node to hydrate. If the second node does not match the instance then the reconciler gives up and begins inserting DOM nodes without trying to reconcile.    In our case, we are server-side rendering the entire #document server-side and re-hydrating at that level. Some 3rd party analytics scripts are injected at the top of <body> before the hydrate call happens, causing the entire application to be injected into the body instead of reconciled with the existing nodes.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**  I can force this to happen in our app by injecting two (or more) empty `script` tags at the top of <body>. I've not been able to reproduce via jsfiddle; unsure what the exact combination of flags are to force this specific code path.    ```  document.body.insertBefore(document.createElement('script'), document.body.children[0]);  document.body.insertBefore(document.createElement('script'), document.body.children[0]);  ```    **What is the expected behavior?**  Ideally the reconciler would look at all of the sibling nodes to find the matching element.    A comment in the code at the relevant location says  ```  // If we can't hydrate this instance let's try the next one.  // We use this as a heuristic. It's based on intuition and not data so it  // might be flawed or unnecessary.  ```    I hacked together a change to prove out inspecting all sibling elements and that seems to be working with no unintended consequences. I modified    `nextInstance = getNextHydratableSibling(nextInstance);`  to be  `while (nextInstance = getNextHydratableSibling(nextInstance), nextInstance && !canHydrate(fiber, nextInstance)) {};`    So nextInstance will either be the hydratable sibling or it will be null.    Using `performance.now()` on my Mac Book Pro, I do not observe this O(1) -> O(n) change to be measurable in my situation.    ```  with matching DOM: 118-144ms  with mismatched DOM: 116-172ms  mismatchedDOM & updated function: 116-163ms  ```    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  This was introduced with React 16s new hydration approach. (I'll take this over the Invariant 42 full-stop error; thanks for building the new approach!).",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  bug (though the React code is working as intended)    **What is the current behavior?**  When hydrating from server-rendered DOM, if [react-reconciler encounters an unexpected node](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberHydrationContext.js#L229) it will peek ahead to the next DOM node and test if it is the expected node. If so, react-reconciler will delete the unexpected node and continue on by using the second node to hydrate. If the second node does not match the instance then the reconciler gives up and begins inserting DOM nodes without trying to reconcile.    In our case, we are server-side rendering the entire #document server-side and re-hydrating at that level. Some 3rd party analytics scripts are injected at the top of <body> before the hydrate call happens, causing the entire application to be injected into the body instead of reconciled with the existing nodes.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**  I can force this to happen in our app by injecting two (or more) empty `script` tags at the top of <body>. I've not been able to reproduce via jsfiddle; unsure what the exact combination of flags are to force this specific code path.        **What is the expected behavior?**  Ideally the reconciler would look at all of the sibling nodes to find the matching element.    A comment in the code at the relevant location says      I hacked together a change to prove out inspecting all sibling elements and that seems to be working with no unintended consequences. I modified    `nextInstance = getNextHydratableSibling(nextInstance);`  to be  `while (nextInstance = getNextHydratableSibling(nextInstance), nextInstance && !canHydrate(fiber, nextInstance)) {};`    So nextInstance will either be the hydratable sibling or it will be null.    Using `performance.now()` on my Mac Book Pro, I do not observe this O(1) -> O(n) change to be measurable in my situation.        **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  This was introduced with React 16s new hydration approach. (I'll take this over the Invariant 42 full-stop error; thanks for building the new approach!).",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** bug (though the React code is working as intended) **What is the current behavior?** When hydrating from server-rendered DOM, if  it will peek ahead to the next DOM node and test if it is the expected node. If so, react-reconciler will delete the unexpected node and continue on by using the second node to hydrate. If the second node does not match the instance then the reconciler gives up and begins inserting DOM nodes without trying to reconcile. In our case, we are server-side rendering the entire #document server-side and re-hydrating at that level. Some 3rd party analytics scripts are injected at the top of  before the hydrate call happens, causing the entire application to be injected into the body instead of reconciled with the existing nodes. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template for React 16:  template for React 15:  I can force this to happen in our app by injecting two (or more) empty `script` tags at the top of . I've not been able to reproduce via jsfiddle; unsure what the exact combination of flags are to force this specific code path. **What is the expected behavior?** Ideally the reconciler would look at all of the sibling nodes to find the matching element. A comment in the code at the relevant location says I hacked together a change to prove out inspecting all sibling elements and that seems to be working with no unintended consequences. I modified `nextInstance = getNextHydratableSibling(nextInstance);` to be `while (nextInstance = getNextHydratableSibling(nextInstance), nextInstance && !canHydrate(fiber, nextInstance)) {};` So nextInstance will either be the hydratable sibling or it will be null. Using `performance.now()` on my Mac Book Pro, I do not observe this O(1) -> O(n) change to be measurable in my situation. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** This was introduced with React 16s new hydration approach. (I'll take this over the Invariant 42 full-stop error; thanks for building the new approach!).",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug ( though react code working intended ) * * current behavior ? * * hydrating server-rendered dom , peek ahead next dom node test expected node . , react-reconciler delete unexpected node continue using second node hydrate . second node match instance reconciler give begin inserting dom node without trying reconcile . case , server-side rendering entire # document server-side re-hydrating level . 3rd party analytics script injected top hydrate call happens , causing entire application injected body instead reconciled existing node . * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template react 16 : template react 15 : force happen app injecting two ( ) empty ` script ` tag top . 've able reproduce via jsfiddle ; unsure exact combination flag force specific code path . * * expected behavior ? * * ideally reconciler would look sibling node find matching element . comment code relevant location say hacked together change prove inspecting sibling element seems working unintended consequence . modified ` nextinstance = getnexthydratablesibling ( nextinstance ) ; ` ` ( nextinstance = getnexthydratablesibling ( nextinstance ) , nextinstance & & ! canhydrate ( fiber , nextinstance ) ) { } ; ` nextinstance either hydratable sibling null . using ` performance.now ( ) ` mac book pro , observe ( 1 ) - > ( n ) change measurable situation . * * version react , browser / o affected issue ? work previous version react ? * * introduced react 16 new hydration approach . ( 'll take invariant 42 full-stop error ; thanks building new approach ! ) .",
        "title_stopwords_removal_lemmatization": "reconciler 's trytoclaimnexthydratableinstance next-nextinstance heuristic creating duplicative element"
    },
    {
        "issue_id": 283653451,
        "title": "Stop syncing value attribute for controlled inputs",
        "label": [
            "Component: DOM",
            "Type: Discussion",
            "Type: Breaking Change"
        ],
        "date": "2017-12-20T18:21:41Z",
        "status": "open",
        "description": "Opening this as a follow up to some quick discussions in https://github.com/facebook/react/issues/11881. Syncing the `value` attribute has been a consistent source of bugs for us, and the benefits of doing so seem minimal. There's some previous discussion on the topic in https://github.com/facebook/react/pull/7359 and in other issues, I can't remember right now \ud83d\ude04 \r\n\r\nThis would be a breaking change, so it would have to be done in a major release. \r\n\r\n## Reasons to keep syncing\r\n\r\n* It prevents `form.reset()` from putting controlled form inputs into a weird state\r\n* Some browser extensions (not sure which) read from the `value` attribute in some cases (not sure which)\r\n* It can be useful for querying inputs with a specific value using an attribute selector\r\n\r\n## Reasons to stop syncing\r\n\r\n* It will reduce the complexity of `react-dom` in a non-trivial way\r\n* In turn, it will likely reduce bundle size as well\r\n* We remove a whole class of bugs (fighting with browsers that want to be helpful about input values)\r\n* Syncing the input value to the attribute potentially exposes sensitive data to third party tools ([1](https://www.reddit.com/r/analytics/comments/7ukw4n/mixpanel_js_library_has_been_harvesting_passwords/))\r\n\r\n______\r\n\r\nWhat do we think? Are these reasons good enough to keep syncing the `value` attribute? Are there other more critical reasons we should keep doing so?\r\n\r\n\r\ncc @nhunzaker @jquense @gaearon ",
        "remove_template_description": "Opening this as a follow up to some quick discussions in https://github.com/facebook/react/issues/11881. Syncing the `value` attribute has been a consistent source of bugs for us, and the benefits of doing so seem minimal. There's some previous discussion on the topic in https://github.com/facebook/react/pull/7359 and in other issues, I can't remember right now \ud83d\ude04     This would be a breaking change, so it would have to be done in a major release.     ## Reasons to keep syncing    * It prevents `form.reset()` from putting controlled form inputs into a weird state  * Some browser extensions (not sure which) read from the `value` attribute in some cases (not sure which)  * It can be useful for querying inputs with a specific value using an attribute selector    ## Reasons to stop syncing    * It will reduce the complexity of `react-dom` in a non-trivial way  * In turn, it will likely reduce bundle size as well  * We remove a whole class of bugs (fighting with browsers that want to be helpful about input values)  * Syncing the input value to the attribute potentially exposes sensitive data to third party tools ([1](https://www.reddit.com/r/analytics/comments/7ukw4n/mixpanel_js_library_has_been_harvesting_passwords/))    ______    What do we think? Are these reasons good enough to keep syncing the `value` attribute? Are there other more critical reasons we should keep doing so?      cc @nhunzaker @jquense @gaearon",
        "human_words": "Opening this as a follow up to some quick discussions in https://github.com/facebook/react/issues/11881. Syncing the `value` attribute has been a consistent source of bugs for us, and the benefits of doing so seem minimal. There's some previous discussion on the topic in https://github.com/facebook/react/pull/7359 and in other issues, I can't remember right now \ud83d\ude04     This would be a breaking change, so it would have to be done in a major release.     ## Reasons to keep syncing    * It prevents `form.reset()` from putting controlled form inputs into a weird state  * Some browser extensions (not sure which) read from the `value` attribute in some cases (not sure which)  * It can be useful for querying inputs with a specific value using an attribute selector    ## Reasons to stop syncing    * It will reduce the complexity of `react-dom` in a non-trivial way  * In turn, it will likely reduce bundle size as well  * We remove a whole class of bugs (fighting with browsers that want to be helpful about input values)  * Syncing the input value to the attribute potentially exposes sensitive data to third party tools ([1](https://www.reddit.com/r/analytics/comments/7ukw4n/mixpanel_js_library_has_been_harvesting_passwords/))    ______    What do we think? Are these reasons good enough to keep syncing the `value` attribute? Are there other more critical reasons we should keep doing so?      cc @nhunzaker @jquense @gaearon",
        "human_words_regrex": "Opening this as a follow up to some quick discussions in  Syncing the `value` attribute has been a consistent source of bugs for us, and the benefits of doing so seem minimal. There's some previous discussion on the topic in  and in other issues, I can't remember right now \ud83d\ude04 This would be a breaking change, so it would have to be done in a major release. ## Reasons to keep syncing * It prevents `form.reset()` from putting controlled form inputs into a weird state * Some browser extensions (not sure which) read from the `value` attribute in some cases (not sure which) * It can be useful for querying inputs with a specific value using an attribute selector ## Reasons to stop syncing * It will reduce the complexity of `react-dom` in a non-trivial way * In turn, it will likely reduce bundle size as well * We remove a whole class of bugs (fighting with browsers that want to be helpful about input values) * Syncing the input value to the attribute potentially exposes sensitive data to third party tools () ______ What do we think? Are these reasons good enough to keep syncing the `value` attribute? Are there other more critical reasons we should keep doing so? cc @nhunzaker @jquense @gaearon",
        "human_words_stopwords_removal_lemmatization": "opening follow quick discussion syncing ` value ` attribute consistent source bug u , benefit seem minimal . 's previous discussion topic issue , ca n't remember right \ud83d\ude04 would breaking change , would done major release . # # reason keep syncing * prevents ` form.reset ( ) ` putting controlled form input weird state * browser extension ( sure ) read ` value ` attribute case ( sure ) * useful querying input specific value using attribute selector # # reason stop syncing * reduce complexity ` react-dom ` non-trivial way * turn , likely reduce bundle size well * remove whole class bug ( fighting browser want helpful input value ) * syncing input value attribute potentially expose sensitive data third party tool ( ) ______ think ? reason good enough keep syncing ` value ` attribute ? critical reason keep ? cc @ nhunzaker @ jquense @ gaearon",
        "title_stopwords_removal_lemmatization": "stop syncing value attribute controlled input"
    },
    {
        "issue_id": 282591514,
        "title": "Improve accidental `void` return in render props?",
        "label": [
            "Type: Discussion",
            "Component: Reconciler",
            "React Core Team"
        ],
        "date": "2017-12-16T02:02:35Z",
        "status": "closed",
        "description": "We know that it is easy to accidentally forget to return from functions or arrow functions. That's why we don't allow returning `undefined` from render functions. (I think we do in the children position but that's harder to disallow.)\r\n\r\n```js\r\nclass Foo extends React.Component {\r\n  render() {\r\n    return this.props.children();\r\n  }\r\n}\r\n```\r\n\r\n```js\r\nfunction Bar() {\r\n  return <Foo>\r\n    {value => {\r\n      <div>\r\n       ...\r\n      </div>\r\n    }}\r\n  </Foo>;\r\n}\r\n```\r\n\r\nor\r\n\r\n```js\r\nfunction BarImpl(props, value) {\r\n  <div>\r\n  </div>\r\n}\r\nfunction Bar(props) {\r\n  return <Foo>{value => BarImpl(props, value)}</Foo>;\r\n}\r\n```\r\n\r\nIt can be difficult to detect an undefined return but the error/warning will also come from the implementation of `Foo`.\r\n\r\nI wonder if we can improve that somehow.",
        "remove_template_description": "We know that it is easy to accidentally forget to return from functions or arrow functions. That's why we don't allow returning `undefined` from render functions. (I think we do in the children position but that's harder to disallow.)    ```js  class Foo extends React.Component {    render() {      return this.props.children();    }  }  ```    ```js  function Bar() {    return <Foo>      {value => {        <div>         ...        </div>      }}    </Foo>;  }  ```    or    ```js  function BarImpl(props, value) {    <div>    </div>  }  function Bar(props) {    return <Foo>{value => BarImpl(props, value)}</Foo>;  }  ```    It can be difficult to detect an undefined return but the error/warning will also come from the implementation of `Foo`.    I wonder if we can improve that somehow.",
        "human_words": "We know that it is easy to accidentally forget to return from functions or arrow functions. That's why we don't allow returning `undefined` from render functions. (I think we do in the children position but that's harder to disallow.)            or        It can be difficult to detect an undefined return but the error/warning will also come from the implementation of `Foo`.    I wonder if we can improve that somehow.",
        "human_words_regrex": "We know that it is easy to accidentally forget to return from functions or arrow functions. That's why we don't allow returning `undefined` from render functions. (I think we do in the children position but that's harder to disallow.) or It can be difficult to detect an undefined return but the error/warning will also come from the implementation of `Foo`. I wonder if we can improve that somehow.",
        "human_words_stopwords_removal_lemmatization": "know easy accidentally forget return function arrow function . 's n't allow returning ` undefined ` render function . ( think child position 's harder disallow . ) difficult detect undefined return error/warning also come implementation ` foo ` . wonder improve somehow .",
        "title_stopwords_removal_lemmatization": "improve accidental ` void ` return render prop ?"
    },
    {
        "issue_id": 282230324,
        "title": "Consider making <> pure unwrapped fragment",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-12-14T20:32:57Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Feature request**\r\n\r\nCurrently if we pass Fragment with children to any custom component, this component gets that fragment as a child\r\n```javascript\r\nconst App = props => (\r\n  <MyComponent>\r\n    <Fragment>\r\n      <div/>\r\n      <div/>\r\n      <div/>\r\n    </Fragment>\r\n  </MyComponent>\r\n);\r\n\r\nconst MyComponent = props => {\r\n  Children.count(props.children); // 1\r\n\r\n  Children.map(props.children, item => {\r\n    console.log(item.type === Fragment); // true\r\n  });\r\n};\r\n```\r\n\r\nThat means in all components where children is being altered (cloned) we need to check first that each item is a fragment first, and if it is - take its children instead of itself.\r\n\r\nThis was a little unexpected, because after reading the documentation the impression was that Fragment is a pure abstraction on the caller side, that Fragment doesn't propagate down to components, but only its children.\r\n\r\nIn the same time it's understandable because Fragment might have more supported props in the future that receiving component might want to read.\r\n\r\nBut fragment shortcut `<>` will not have props, it will always mean pure abstraction (to group its children to show them by condition, for instance).\r\nSo maybe react could unwrap its children right away when elements are created and pass them down as set of children (merge with another children on the same level)?\r\n\r\n**React 16.2**\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Feature request**    Currently if we pass Fragment with children to any custom component, this component gets that fragment as a child  ```javascript  const App = props => (    <MyComponent>      <Fragment>        <div/>        <div/>        <div/>      </Fragment>    </MyComponent>  );    const MyComponent = props => {    Children.count(props.children); // 1      Children.map(props.children, item => {      console.log(item.type === Fragment); // true    });  };  ```    That means in all components where children is being altered (cloned) we need to check first that each item is a fragment first, and if it is - take its children instead of itself.    This was a little unexpected, because after reading the documentation the impression was that Fragment is a pure abstraction on the caller side, that Fragment doesn't propagate down to components, but only its children.    In the same time it's understandable because Fragment might have more supported props in the future that receiving component might want to read.    But fragment shortcut `<>` will not have props, it will always mean pure abstraction (to group its children to show them by condition, for instance).  So maybe react could unwrap its children right away when elements are created and pass them down as set of children (merge with another children on the same level)?    **React 16.2**",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Feature request**    Currently if we pass Fragment with children to any custom component, this component gets that fragment as a child      That means in all components where children is being altered (cloned) we need to check first that each item is a fragment first, and if it is - take its children instead of itself.    This was a little unexpected, because after reading the documentation the impression was that Fragment is a pure abstraction on the caller side, that Fragment doesn't propagate down to components, but only its children.    In the same time it's understandable because Fragment might have more supported props in the future that receiving component might want to read.    But fragment shortcut `<>` will not have props, it will always mean pure abstraction (to group its children to show them by condition, for instance).  So maybe react could unwrap its children right away when elements are created and pass them down as set of children (merge with another children on the same level)?    **React 16.2**",
        "human_words_regrex": " **Feature request** Currently if we pass Fragment with children to any custom component, this component gets that fragment as a child That means in all components where children is being altered (cloned) we need to check first that each item is a fragment first, and if it is - take its children instead of itself. This was a little unexpected, because after reading the documentation the impression was that Fragment is a pure abstraction on the caller side, that Fragment doesn't propagate down to components, but only its children. In the same time it's understandable because Fragment might have more supported props in the future that receiving component might want to read. But fragment shortcut `<>` will not have props, it will always mean pure abstraction (to group its children to show them by condition, for instance). So maybe react could unwrap its children right away when elements are created and pass them down as set of children (merge with another children on the same level)? **React 16.2**",
        "human_words_stopwords_removal_lemmatization": "* * feature request * * currently pas fragment child custom component , component get fragment child mean component child altered ( cloned ) need check first item fragment first , - take child instead . little unexpected , reading documentation impression fragment pure abstraction caller side , fragment n't propagate component , child . time 's understandable fragment might supported prop future receiving component might want read . fragment shortcut ` < > ` prop , always mean pure abstraction ( group child show condition , instance ) . maybe react could unwrap child right away element created pas set child ( merge another child level ) ? * * react 16.2 * *",
        "title_stopwords_removal_lemmatization": "consider making < > pure unwrapped fragment"
    },
    {
        "issue_id": 282152813,
        "title": "Bug in scryRenderedComponentsWithType",
        "label": [
            "Component: Test Utils",
            "Type: Discussion"
        ],
        "date": "2017-12-14T16:08:20Z",
        "status": "closed",
        "description": "`scryRenderedComponentsWithType` spits the following:\r\n\r\n> findAllInRenderedTree(...): instance must be a composite component\r\n\r\ntest case:\r\n\r\n```\r\nclass Accordion extends React.Component {\r\n  render() {\r\n    return (<div>{ this.props.children }</div>);\r\n  }\r\n}\r\nconst tree = ReactTestUtils.renderIntoDocument(\r\n      <div>\r\n        <Accordion height={ 0 }>\r\n          <div>Hello</div>\r\n        </Accordion>\r\n      </div>\r\n);\r\n\r\nconst elements = ReactTestUtils.scryRenderedComponentsWithType(tree, Accordion);\r\nexpect(elements[0].clientHeight).to.be.equal(0);\r\n```",
        "remove_template_description": "`scryRenderedComponentsWithType` spits the following:    > findAllInRenderedTree(...): instance must be a composite component    test case:    ```  class Accordion extends React.Component {    render() {      return (<div>{ this.props.children }</div>);    }  }  const tree = ReactTestUtils.renderIntoDocument(        <div>          <Accordion height={ 0 }>            <div>Hello</div>          </Accordion>        </div>  );    const elements = ReactTestUtils.scryRenderedComponentsWithType(tree, Accordion);  expect(elements[0].clientHeight).to.be.equal(0);  ```",
        "human_words": "`scryRenderedComponentsWithType` spits the following:    > findAllInRenderedTree(...): instance must be a composite component    test case:    ",
        "human_words_regrex": "`scryRenderedComponentsWithType` spits the following: > findAllInRenderedTree(...): instance must be a composite component test case: ",
        "human_words_stopwords_removal_lemmatization": "` scryrenderedcomponentswithtype ` spit following : > findallinrenderedtree ( ... ) : instance must composite component test case :",
        "title_stopwords_removal_lemmatization": "bug scryrenderedcomponentswithtype"
    },
    {
        "issue_id": 281836303,
        "title": "React 16's new error handling functionality seems to be doing more harm than good",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-12-13T17:39:03Z",
        "status": "closed",
        "description": "I wasn't sure where to report this, but this is a problem I'm having with a new feature.\r\n\r\nI just finished upgrading my team to React 16. Overall, I think the upgrade is great. We are using fragments and the relaxed constraints on what you can return from render(), and I'm overall very happy with it.\r\n\r\nMy only issue is with error boundaries. The feature seems to be well-intended, and does help out quite a bit. The improved error reporting especially is beautiful and will make debugging a dream.\r\n\r\nThe problem is that I believe we are leaving our users in a worse state by having to display fallback UIs. In a perfect world, we would have no client side errors and none of this would even be a discussion. But unfortunately we do have to deal with client-side errors. I agree that leaving the UI in an unpredictable state is less than desired, but I would argue that it's still better than taking away the UI completely. If a user triggers a client-side error, but the UI is still there, they can continue to use the site with little-to-no issue in the case of *most* errors. But with React 16's new functionality, even the smallest of errors will unmount the UI.\r\n\r\nOur options are:\r\n- Go with the easy route and implement a top-level error boundary that will unmount the whole UI, replacing it with a fallback that does nothing for the user.\r\n- Take significant developer time to implement fine-grained error boundaries that will still leave most of the UI untouched, only replacing components in error. But overall, this will still be taking functionality away from the user.\r\n\r\nEither way, with this new functionality, we need to have at least a top-level error boundary to display *something* to the user. Our top-level boundary still displays our navigation bar so that the user can still navigate away from the page and use other parts of the site. The alternative is that they will need to refresh the page because everything will be unmounted.\r\n\r\nI agree that displaying a fallback UI can be useful in instances where you *expect* an error in some cases (for example, when loading an image from a third party CDN or something). But in cases where a bug is producing an *unexpected* error, we should still be able to keep the UI in its previous state.\r\n\r\nThis is how I envision it working:\r\n- Error boundaries are still exactly as they are today, except...\r\n- If the error was thrown inside the render() of a component, that component will either not be mounted (if it hasn't yet been mounted) or be left in its prior state (if it has already been successfully mounted). The parent of the offending component and all of the parent's other children are still rendered.\r\n- If the error was thrown inside a lifecycle method, the offending component's tree is left as it was, and other children of its parent can still be updated.\r\n- Error boundaries can *still* display a fallback UI if they want. componentDidMount() still has the ability to set state.\r\n\r\nIf you are handling an *expected* error, you should display a fallback UI. If you are handling an *unexpected* error, you should try to leave the UI in the most unbroken state possible for the user. The error should still be reported and caught by a top-level error boundary so that it can be logged, but the UI should not need to be replaced in all instances.\r\n\r\nPerhaps I'm missing out on a standard process for handling these problems I'm talking about, and I am happy to hear what other people are doing to get around this, but I believe this feature as it exists today means more work for developers, and poor functionality for users.",
        "remove_template_description": "I wasn't sure where to report this, but this is a problem I'm having with a new feature.    I just finished upgrading my team to React 16. Overall, I think the upgrade is great. We are using fragments and the relaxed constraints on what you can return from render(), and I'm overall very happy with it.    My only issue is with error boundaries. The feature seems to be well-intended, and does help out quite a bit. The improved error reporting especially is beautiful and will make debugging a dream.    The problem is that I believe we are leaving our users in a worse state by having to display fallback UIs. In a perfect world, we would have no client side errors and none of this would even be a discussion. But unfortunately we do have to deal with client-side errors. I agree that leaving the UI in an unpredictable state is less than desired, but I would argue that it's still better than taking away the UI completely. If a user triggers a client-side error, but the UI is still there, they can continue to use the site with little-to-no issue in the case of *most* errors. But with React 16's new functionality, even the smallest of errors will unmount the UI.    Our options are:  - Go with the easy route and implement a top-level error boundary that will unmount the whole UI, replacing it with a fallback that does nothing for the user.  - Take significant developer time to implement fine-grained error boundaries that will still leave most of the UI untouched, only replacing components in error. But overall, this will still be taking functionality away from the user.    Either way, with this new functionality, we need to have at least a top-level error boundary to display *something* to the user. Our top-level boundary still displays our navigation bar so that the user can still navigate away from the page and use other parts of the site. The alternative is that they will need to refresh the page because everything will be unmounted.    I agree that displaying a fallback UI can be useful in instances where you *expect* an error in some cases (for example, when loading an image from a third party CDN or something). But in cases where a bug is producing an *unexpected* error, we should still be able to keep the UI in its previous state.    This is how I envision it working:  - Error boundaries are still exactly as they are today, except...  - If the error was thrown inside the render() of a component, that component will either not be mounted (if it hasn't yet been mounted) or be left in its prior state (if it has already been successfully mounted). The parent of the offending component and all of the parent's other children are still rendered.  - If the error was thrown inside a lifecycle method, the offending component's tree is left as it was, and other children of its parent can still be updated.  - Error boundaries can *still* display a fallback UI if they want. componentDidMount() still has the ability to set state.    If you are handling an *expected* error, you should display a fallback UI. If you are handling an *unexpected* error, you should try to leave the UI in the most unbroken state possible for the user. The error should still be reported and caught by a top-level error boundary so that it can be logged, but the UI should not need to be replaced in all instances.    Perhaps I'm missing out on a standard process for handling these problems I'm talking about, and I am happy to hear what other people are doing to get around this, but I believe this feature as it exists today means more work for developers, and poor functionality for users.",
        "human_words": "I wasn't sure where to report this, but this is a problem I'm having with a new feature.    I just finished upgrading my team to React 16. Overall, I think the upgrade is great. We are using fragments and the relaxed constraints on what you can return from render(), and I'm overall very happy with it.    My only issue is with error boundaries. The feature seems to be well-intended, and does help out quite a bit. The improved error reporting especially is beautiful and will make debugging a dream.    The problem is that I believe we are leaving our users in a worse state by having to display fallback UIs. In a perfect world, we would have no client side errors and none of this would even be a discussion. But unfortunately we do have to deal with client-side errors. I agree that leaving the UI in an unpredictable state is less than desired, but I would argue that it's still better than taking away the UI completely. If a user triggers a client-side error, but the UI is still there, they can continue to use the site with little-to-no issue in the case of *most* errors. But with React 16's new functionality, even the smallest of errors will unmount the UI.    Our options are:  - Go with the easy route and implement a top-level error boundary that will unmount the whole UI, replacing it with a fallback that does nothing for the user.  - Take significant developer time to implement fine-grained error boundaries that will still leave most of the UI untouched, only replacing components in error. But overall, this will still be taking functionality away from the user.    Either way, with this new functionality, we need to have at least a top-level error boundary to display *something* to the user. Our top-level boundary still displays our navigation bar so that the user can still navigate away from the page and use other parts of the site. The alternative is that they will need to refresh the page because everything will be unmounted.    I agree that displaying a fallback UI can be useful in instances where you *expect* an error in some cases (for example, when loading an image from a third party CDN or something). But in cases where a bug is producing an *unexpected* error, we should still be able to keep the UI in its previous state.    This is how I envision it working:  - Error boundaries are still exactly as they are today, except...  - If the error was thrown inside the render() of a component, that component will either not be mounted (if it hasn't yet been mounted) or be left in its prior state (if it has already been successfully mounted). The parent of the offending component and all of the parent's other children are still rendered.  - If the error was thrown inside a lifecycle method, the offending component's tree is left as it was, and other children of its parent can still be updated.  - Error boundaries can *still* display a fallback UI if they want. componentDidMount() still has the ability to set state.    If you are handling an *expected* error, you should display a fallback UI. If you are handling an *unexpected* error, you should try to leave the UI in the most unbroken state possible for the user. The error should still be reported and caught by a top-level error boundary so that it can be logged, but the UI should not need to be replaced in all instances.    Perhaps I'm missing out on a standard process for handling these problems I'm talking about, and I am happy to hear what other people are doing to get around this, but I believe this feature as it exists today means more work for developers, and poor functionality for users.",
        "human_words_regrex": "I wasn't sure where to report this, but this is a problem I'm having with a new feature. I just finished upgrading my team to React 16. Overall, I think the upgrade is great. We are using fragments and the relaxed constraints on what you can return from render(), and I'm overall very happy with it. My only issue is with error boundaries. The feature seems to be well-intended, and does help out quite a bit. The improved error reporting especially is beautiful and will make debugging a dream. The problem is that I believe we are leaving our users in a worse state by having to display fallback UIs. In a perfect world, we would have no client side errors and none of this would even be a discussion. But unfortunately we do have to deal with client-side errors. I agree that leaving the UI in an unpredictable state is less than desired, but I would argue that it's still better than taking away the UI completely. If a user triggers a client-side error, but the UI is still there, they can continue to use the site with little-to-no issue in the case of *most* errors. But with React 16's new functionality, even the smallest of errors will unmount the UI. Our options are: - Go with the easy route and implement a top-level error boundary that will unmount the whole UI, replacing it with a fallback that does nothing for the user. - Take significant developer time to implement fine-grained error boundaries that will still leave most of the UI untouched, only replacing components in error. But overall, this will still be taking functionality away from the user. Either way, with this new functionality, we need to have at least a top-level error boundary to display *something* to the user. Our top-level boundary still displays our navigation bar so that the user can still navigate away from the page and use other parts of the site. The alternative is that they will need to refresh the page because everything will be unmounted. I agree that displaying a fallback UI can be useful in instances where you *expect* an error in some cases (for example, when loading an image from a third party CDN or something). But in cases where a bug is producing an *unexpected* error, we should still be able to keep the UI in its previous state. This is how I envision it working: - Error boundaries are still exactly as they are today, except... - If the error was thrown inside the render() of a component, that component will either not be mounted (if it hasn't yet been mounted) or be left in its prior state (if it has already been successfully mounted). The parent of the offending component and all of the parent's other children are still rendered. - If the error was thrown inside a lifecycle method, the offending component's tree is left as it was, and other children of its parent can still be updated. - Error boundaries can *still* display a fallback UI if they want. componentDidMount() still has the ability to set state. If you are handling an *expected* error, you should display a fallback UI. If you are handling an *unexpected* error, you should try to leave the UI in the most unbroken state possible for the user. The error should still be reported and caught by a top-level error boundary so that it can be logged, but the UI should not need to be replaced in all instances. Perhaps I'm missing out on a standard process for handling these problems I'm talking about, and I am happy to hear what other people are doing to get around this, but I believe this feature as it exists today means more work for developers, and poor functionality for users.",
        "human_words_stopwords_removal_lemmatization": "n't sure report , problem 'm new feature . finished upgrading team react 16. overall , think upgrade great . using fragment relaxed constraint return render ( ) , 'm overall happy . issue error boundary . feature seems well-intended , help quite bit . improved error reporting especially beautiful make debugging dream . problem believe leaving user worse state display fallback uis . perfect world , would client side error none would even discussion . unfortunately deal client-side error . agree leaving ui unpredictable state le desired , would argue 's still better taking away ui completely . user trigger client-side error , ui still , continue use site little-to-no issue case * * error . react 16 's new functionality , even smallest error unmount ui . option : - go easy route implement top-level error boundary unmount whole ui , replacing fallback nothing user . - take significant developer time implement fine-grained error boundary still leave ui untouched , replacing component error . overall , still taking functionality away user . either way , new functionality , need least top-level error boundary display * something * user . top-level boundary still display navigation bar user still navigate away page use part site . alternative need refresh page everything unmounted . agree displaying fallback ui useful instance * expect * error case ( example , loading image third party cdn something ) . case bug producing * unexpected * error , still able keep ui previous state . envision working : - error boundary still exactly today , except ... - error thrown inside render ( ) component , component either mounted ( n't yet mounted ) left prior state ( already successfully mounted ) . parent offending component parent 's child still rendered . - error thrown inside lifecycle method , offending component 's tree left , child parent still updated . - error boundary * still * display fallback ui want . componentdidmount ( ) still ability set state . handling * expected * error , display fallback ui . handling * unexpected * error , try leave ui unbroken state possible user . error still reported caught top-level error boundary logged , ui need replaced instance . perhaps 'm missing standard process handling problem 'm talking , happy hear people get around , believe feature exists today mean work developer , poor functionality user .",
        "title_stopwords_removal_lemmatization": "react 16 's new error handling functionality seems harm good"
    },
    {
        "issue_id": 279229157,
        "title": "Chrome Extensions that mutate the DOM, NotFoundError",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-12-05T03:02:31Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nBug, but maybe this is a question...\r\n\r\n**What is the current behavior?**\r\nIn chrome (and I'm sure other browsers), chrome extensions can mutate your DOM willy-nilly.  In turn, when React goes to update the node, we get a critical error (NotFoundError), if you don't have an Error boundary in place, your whole app blows up.\r\n\r\n**How to reproduce**\r\n- Here is a fiddle with a simple phone number with a counter, it should work: https://jsfiddle.net/67htecf5/1/\r\n- Install the [Google Voice Chrome Extension](https://chrome.google.com/webstore/detail/google-voice-by-google/kcnhkahnjcbndmmehfkdnkjomaanaooo?hl=en)\r\n- Reload the fiddle once you enable the extension.\r\n\r\n**What is the expected behavior?**\r\nNot sure honestly. It's annoying that the entire page crashes rather than, maybe throwing a warning type error and skipping the corrupt node (I'm afraid of the cascading effect this type of change might have).\r\n\r\nMaybe React shouldn't cater to this type of error, in that case, what can I do about it? I have added error boundaries and they help to track these issues down, but the amount of places I have to `dangerouslySetInnerHTML` is getting a bit absurd, and it's making it tricky for new feature development. At this rate I might as well just be setting any user input text as `dangerouslySetInnerHTML` but this doesn't seem like a good solution.\r\n\r\nIt's common enough that since I've added React 16 to my project, I've fixed about 10~15 different instances, and I find one or two each week right now. They do seem to be slowing down though, but I fear this will be an ongoing fight/maintenance issue.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nReact 16.0 - Previous version of react also had similar issues, but they didn't seem to crash like react 16 does. Thankfully react 16 does have error boundaries and is more predictable in how it handles.\r\nChrome latest",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Bug, but maybe this is a question...    **What is the current behavior?**  In chrome (and I'm sure other browsers), chrome extensions can mutate your DOM willy-nilly.  In turn, when React goes to update the node, we get a critical error (NotFoundError), if you don't have an Error boundary in place, your whole app blows up.    **How to reproduce**  - Here is a fiddle with a simple phone number with a counter, it should work: https://jsfiddle.net/67htecf5/1/  - Install the [Google Voice Chrome Extension](https://chrome.google.com/webstore/detail/google-voice-by-google/kcnhkahnjcbndmmehfkdnkjomaanaooo?hl=en)  - Reload the fiddle once you enable the extension.    **What is the expected behavior?**  Not sure honestly. It's annoying that the entire page crashes rather than, maybe throwing a warning type error and skipping the corrupt node (I'm afraid of the cascading effect this type of change might have).    Maybe React shouldn't cater to this type of error, in that case, what can I do about it? I have added error boundaries and they help to track these issues down, but the amount of places I have to `dangerouslySetInnerHTML` is getting a bit absurd, and it's making it tricky for new feature development. At this rate I might as well just be setting any user input text as `dangerouslySetInnerHTML` but this doesn't seem like a good solution.    It's common enough that since I've added React 16 to my project, I've fixed about 10~15 different instances, and I find one or two each week right now. They do seem to be slowing down though, but I fear this will be an ongoing fight/maintenance issue.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 16.0 - Previous version of react also had similar issues, but they didn't seem to crash like react 16 does. Thankfully react 16 does have error boundaries and is more predictable in how it handles.  Chrome latest",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Bug, but maybe this is a question...    **What is the current behavior?**  In chrome (and I'm sure other browsers), chrome extensions can mutate your DOM willy-nilly.  In turn, when React goes to update the node, we get a critical error (NotFoundError), if you don't have an Error boundary in place, your whole app blows up.    **How to reproduce**  - Here is a fiddle with a simple phone number with a counter, it should work: https://jsfiddle.net/67htecf5/1/  - Install the [Google Voice Chrome Extension](https://chrome.google.com/webstore/detail/google-voice-by-google/kcnhkahnjcbndmmehfkdnkjomaanaooo?hl=en)  - Reload the fiddle once you enable the extension.    **What is the expected behavior?**  Not sure honestly. It's annoying that the entire page crashes rather than, maybe throwing a warning type error and skipping the corrupt node (I'm afraid of the cascading effect this type of change might have).    Maybe React shouldn't cater to this type of error, in that case, what can I do about it? I have added error boundaries and they help to track these issues down, but the amount of places I have to `dangerouslySetInnerHTML` is getting a bit absurd, and it's making it tricky for new feature development. At this rate I might as well just be setting any user input text as `dangerouslySetInnerHTML` but this doesn't seem like a good solution.    It's common enough that since I've added React 16 to my project, I've fixed about 10~15 different instances, and I find one or two each week right now. They do seem to be slowing down though, but I fear this will be an ongoing fight/maintenance issue.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 16.0 - Previous version of react also had similar issues, but they didn't seem to crash like react 16 does. Thankfully react 16 does have error boundaries and is more predictable in how it handles.  Chrome latest",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug, but maybe this is a question... **What is the current behavior?** In chrome (and I'm sure other browsers), chrome extensions can mutate your DOM willy-nilly. In turn, when React goes to update the node, we get a critical error (NotFoundError), if you don't have an Error boundary in place, your whole app blows up. **How to reproduce** - Here is a fiddle with a simple phone number with a counter, it should work:  - Install the  - Reload the fiddle once you enable the extension. **What is the expected behavior?** Not sure honestly. It's annoying that the entire page crashes rather than, maybe throwing a warning type error and skipping the corrupt node (I'm afraid of the cascading effect this type of change might have). Maybe React shouldn't cater to this type of error, in that case, what can I do about it? I have added error boundaries and they help to track these issues down, but the amount of places I have to `dangerouslySetInnerHTML` is getting a bit absurd, and it's making it tricky for new feature development. At this rate I might as well just be setting any user input text as `dangerouslySetInnerHTML` but this doesn't seem like a good solution. It's common enough that since I've added React 16 to my project, I've fixed about 10~15 different instances, and I find one or two each week right now. They do seem to be slowing down though, but I fear this will be an ongoing fight/maintenance issue. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.0 - Previous version of react also had similar issues, but they didn't seem to crash like react 16 does. Thankfully react 16 does have error boundaries and is more predictable in how it handles. Chrome latest",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug , maybe question ... * * current behavior ? * * chrome ( 'm sure browser ) , chrome extension mutate dom willy-nilly . turn , react go update node , get critical error ( notfounderror ) , n't error boundary place , whole app blow . * * reproduce * * - fiddle simple phone number counter , work : - install - reload fiddle enable extension . * * expected behavior ? * * sure honestly . 's annoying entire page crash rather , maybe throwing warning type error skipping corrupt node ( 'm afraid cascading effect type change might ) . maybe react n't cater type error , case , ? added error boundary help track issue , amount place ` dangerouslysetinnerhtml ` getting bit absurd , 's making tricky new feature development . rate might well setting user input text ` dangerouslysetinnerhtml ` n't seem like good solution . 's common enough since 've added react 16 project , 've fixed 10~15 different instance , find one two week right . seem slowing though , fear ongoing fight/maintenance issue . * * version react , browser / o affected issue ? work previous version react ? * * react 16.0 - previous version react also similar issue , n't seem crash like react 16 . thankfully react 16 error boundary predictable handle . chrome latest",
        "title_stopwords_removal_lemmatization": "chrome extension mutate dom , notfounderror"
    },
    {
        "issue_id": 277922028,
        "title": "Do not evaluate -0 prop to 0 or use SameValueZero comparison in shallowEqual to prevent double render",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-11-29T21:57:24Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nFeature / Bug (not sure)\r\n\r\n**What is the current behavior?**\r\nFor now [`shallowEqual` function](https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js#L18-L32) uses [_SameValue_](https://tc39.github.io/ecma262/#sec-samevalue) comparison (aka [`Object.is`](https://tc39.github.io/ecma262/#sec-object.is)) but `-0` is evaluated to `0` inside of React anyway. \r\n\r\nExample: https://jsfiddle.net/chicoxyzzy/Luktwrdm/46/\r\n`Object.is` comparison is false in `shallowEqual` of second `ReactDom.render` call, so as we can see `console.log` is called twice.\r\n\r\n**What is the expected behavior?**\r\n`shallowEqual` should use [_SameValueZero_ comparison](https://tc39.github.io/ecma262/#sec-samevaluezero) so React component doesn't render second time.\r\n \r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nAll browsers / [React >= 15.0.0](https://github.com/facebook/react/blob/master/CHANGELOG.md#notable-bug-fixes)\r\n\r\n\r\nThe change doesn't affect React users because `-0` evaluates to `0` so it's not a breaking change for React, but it's a breaking change for `shallowEqual` and fbjs.\r\n\r\nAlternatively we shouldn't evaluate `-0` to `0` inside of React.\r\n\r\nI'm ready to file PR as soon as we realize what the proper behavior is.",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Feature / Bug (not sure)    **What is the current behavior?**  For now [`shallowEqual` function](https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js#L18-L32) uses [_SameValue_](https://tc39.github.io/ecma262/#sec-samevalue) comparison (aka [`Object.is`](https://tc39.github.io/ecma262/#sec-object.is)) but `-0` is evaluated to `0` inside of React anyway.     Example: https://jsfiddle.net/chicoxyzzy/Luktwrdm/46/  `Object.is` comparison is false in `shallowEqual` of second `ReactDom.render` call, so as we can see `console.log` is called twice.    **What is the expected behavior?**  `shallowEqual` should use [_SameValueZero_ comparison](https://tc39.github.io/ecma262/#sec-samevaluezero) so React component doesn't render second time.     **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  All browsers / [React >= 15.0.0](https://github.com/facebook/react/blob/master/CHANGELOG.md#notable-bug-fixes)      The change doesn't affect React users because `-0` evaluates to `0` so it's not a breaking change for React, but it's a breaking change for `shallowEqual` and fbjs.    Alternatively we shouldn't evaluate `-0` to `0` inside of React.    I'm ready to file PR as soon as we realize what the proper behavior is.",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  Feature / Bug (not sure)    **What is the current behavior?**  For now [`shallowEqual` function](https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js#L18-L32) uses [_SameValue_](https://tc39.github.io/ecma262/#sec-samevalue) comparison (aka [`Object.is`](https://tc39.github.io/ecma262/#sec-object.is)) but `-0` is evaluated to `0` inside of React anyway.     Example: https://jsfiddle.net/chicoxyzzy/Luktwrdm/46/  `Object.is` comparison is false in `shallowEqual` of second `ReactDom.render` call, so as we can see `console.log` is called twice.    **What is the expected behavior?**  `shallowEqual` should use [_SameValueZero_ comparison](https://tc39.github.io/ecma262/#sec-samevaluezero) so React component doesn't render second time.     **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  All browsers / [React >= 15.0.0](https://github.com/facebook/react/blob/master/CHANGELOG.md#notable-bug-fixes)      The change doesn't affect React users because `-0` evaluates to `0` so it's not a breaking change for React, but it's a breaking change for `shallowEqual` and fbjs.    Alternatively we shouldn't evaluate `-0` to `0` inside of React.    I'm ready to file PR as soon as we realize what the proper behavior is.",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** Feature / Bug (not sure) **What is the current behavior?** For now  uses  comparison (aka ) but `-0` is evaluated to `0` inside of React anyway. Example:  `Object.is` comparison is false in `shallowEqual` of second `ReactDom.render` call, so as we can see `console.log` is called twice. **What is the expected behavior?** `shallowEqual` should use  so React component doesn't render second time. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** All browsers /  The change doesn't affect React users because `-0` evaluates to `0` so it's not a breaking change for React, but it's a breaking change for `shallowEqual` and fbjs. Alternatively we shouldn't evaluate `-0` to `0` inside of React. I'm ready to file PR as soon as we realize what the proper behavior is.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature / bug ( sure ) * * current behavior ? * * us comparison ( aka ) ` -0 ` evaluated ` 0 ` inside react anyway . example : ` object.is ` comparison false ` shallowequal ` second ` reactdom.render ` call , see ` console.log ` called twice . * * expected behavior ? * * ` shallowequal ` use react component n't render second time . * * version react , browser / o affected issue ? work previous version react ? * * browser / change n't affect react user ` -0 ` evaluates ` 0 ` 's breaking change react , 's breaking change ` shallowequal ` fbjs . alternatively n't evaluate ` -0 ` ` 0 ` inside react . 'm ready file pr soon realize proper behavior .",
        "title_stopwords_removal_lemmatization": "evaluate -0 prop 0 use samevaluezero comparison shallowequal prevent double render"
    },
    {
        "issue_id": 277533137,
        "title": "Remove support for TapEventPlugin",
        "label": [
            "Component: DOM",
            "Type: Discussion",
            "Type: Breaking Change",
            "React Core Team"
        ],
        "date": "2017-11-28T20:49:30Z",
        "status": "closed",
        "description": "Some libraries relied on it so we kept it in 16, but it's impossible to support it forever given that we want to make changes to the event system. We should deprecate [the injection it relies on](https://github.com/zilverline/react-tap-event-plugin/blob/f7ed5c560011590d24e07480686b234b2f3ea1f5/src/injectTapEventPlugin.js#L23) and remove it in React 17. The migration path is to turn it into a userland `<Tappable>` component or something like that. Hopefully somebody using `TapEventPlugin` can work on this, as we don't actively use it.",
        "remove_template_description": "Some libraries relied on it so we kept it in 16, but it's impossible to support it forever given that we want to make changes to the event system. We should deprecate [the injection it relies on](https://github.com/zilverline/react-tap-event-plugin/blob/f7ed5c560011590d24e07480686b234b2f3ea1f5/src/injectTapEventPlugin.js#L23) and remove it in React 17. The migration path is to turn it into a userland `<Tappable>` component or something like that. Hopefully somebody using `TapEventPlugin` can work on this, as we don't actively use it.",
        "human_words": "Some libraries relied on it so we kept it in 16, but it's impossible to support it forever given that we want to make changes to the event system. We should deprecate [the injection it relies on](https://github.com/zilverline/react-tap-event-plugin/blob/f7ed5c560011590d24e07480686b234b2f3ea1f5/src/injectTapEventPlugin.js#L23) and remove it in React 17. The migration path is to turn it into a userland `<Tappable>` component or something like that. Hopefully somebody using `TapEventPlugin` can work on this, as we don't actively use it.",
        "human_words_regrex": "Some libraries relied on it so we kept it in 16, but it's impossible to support it forever given that we want to make changes to the event system. We should deprecate  and remove it in React 17. The migration path is to turn it into a userland `` component or something like that. Hopefully somebody using `TapEventPlugin` can work on this, as we don't actively use it.",
        "human_words_stopwords_removal_lemmatization": "library relied kept 16 , 's impossible support forever given want make change event system . deprecate remove react 17. migration path turn userland `` component something like . hopefully somebody using ` tapeventplugin ` work , n't actively use .",
        "title_stopwords_removal_lemmatization": "remove support tapeventplugin"
    },
    {
        "issue_id": 276379810,
        "title": "React roadmap document?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-11-23T13:43:52Z",
        "status": "closed",
        "description": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nA feature\r\n\r\n**What is the current behavior?**\r\nI think many people would be interested in a document that would show the future/long term plans for React, and features that are planned.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar**\r\nIt's not a bug.\r\n\r\n**What is the expected behavior?**\r\nDocument or link exists in repo, and can be accessed to see what is planned for the future.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nN/A\r\n",
        "remove_template_description": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  A feature    **What is the current behavior?**  I think many people would be interested in a document that would show the future/long term plans for React, and features that are planned.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar**  It's not a bug.    **What is the expected behavior?**  Document or link exists in repo, and can be accessed to see what is planned for the future.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  N/A",
        "human_words": "<!--    Note: if the issue is about documentation or the website, please file it at:    https://github.com/reactjs/reactjs.org/issues/new  -->    **Do you want to request a *feature* or report a *bug*?**  A feature    **What is the current behavior?**  I think many people would be interested in a document that would show the future/long term plans for React, and features that are planned.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar**  It's not a bug.    **What is the expected behavior?**  Document or link exists in repo, and can be accessed to see what is planned for the future.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  N/A",
        "human_words_regrex": " **Do you want to request a *feature* or report a *bug*?** A feature **What is the current behavior?** I think many people would be interested in a document that would show the future/long term plans for React, and features that are planned. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar** It's not a bug. **What is the expected behavior?** Document or link exists in repo, and can be accessed to see what is planned for the future. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** N/A",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * think many people would interested document would show future/long term plan react , feature planned . * * current behavior bug , please provide step reproduce possible minimal demo problem via similar * * 's bug . * * expected behavior ? * * document link exists repo , accessed see planned future . * * version react , browser / o affected issue ? work previous version react ? * * n/a",
        "title_stopwords_removal_lemmatization": "react roadmap document ?"
    },
    {
        "issue_id": 273804066,
        "title": "Is there something like emberobserver.com?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-11-14T14:06:18Z",
        "status": "closed",
        "description": "Is there something like https://www.emberobserver.com for React world?",
        "remove_template_description": "Is there something like https://www.emberobserver.com for React world?",
        "human_words": "Is there something like https://www.emberobserver.com for React world?",
        "human_words_regrex": "Is there something like  for React world?",
        "human_words_stopwords_removal_lemmatization": "something like react world ?",
        "title_stopwords_removal_lemmatization": "something like emberobserver.com ?"
    },
    {
        "issue_id": 273131299,
        "title": "RFClarification: why is `setState` asynchronous?",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-11-11T08:59:25Z",
        "status": "closed",
        "description": "For quite a while I've tried to understood why `setState` is asynchronous. And failing to find an answer to it in the past, I came to the conclusion that it was for historical reasons and probably hard to change now. However @gaearon indicated there is a clear reason, so I am curious to find out :)\r\n\r\nAnyway, here are the reasons I often hear, but I think they can't be everything as they are too easy to counter\r\n\r\n## Async setState is required for async rendering\r\n\r\nMany initially think it is because of render efficiency. But I don't think that is the reason behind this behavior, because keeping setState sync with async rendering sounds trivial to me, something along the lines of:\r\n\r\n```javascript\r\nComponent.prototype.setState = (nextState) => {\r\n  this.state = nextState\r\n  if (!this.renderScheduled)\r\n     setImmediate(this.forceUpdate)\r\n}\r\n```\r\n\r\nIn fact, for example `mobx-react` allows synchronous assignments to observables and still respect the async nature of rendering\r\n\r\n## Async setState is needed to know which state was _rendered_\r\n\r\nThe other argument I hear sometimes is that you want to reason about the state that was _rendered_, not the state that was _requested_. But I'm not sure this principle has much merit either. Conceptually it feels strange to me. Rendering is a side effect, state is about facts. Today, I am 32 years old, and next year I will turn 33, regardless whether the owning component manages to re-render this year or not :). \r\n\r\nTo draw a (probably not to good) parallel: If you wouldn't be able to _read_ your last version of a self written word document until you printed it, that would be pretty awkward. I don't think for example game engines give you feedback on what state of the game was exactly rendered and which frames were dropped either.\r\n\r\nAn interesting observations: In 2 years `mobx-react` nobody ever asked me the question: How do I know my observables are rendered? This question just seems not relevant very often.\r\n\r\nI did encounter a few cases where knowing which data was rendered was relevant. The case I remember was where I needed to know the pixel dimensions of some data for layout purposes. But that was elegantly solved by using `didComponentUpdate` and didn't really rely on `setState` being async either. These cases seem so rare that it hardly justify to design the api primarily around them. If it can be done *somehow*, it suffices I think\r\n\r\n---\r\n\r\nI have no doubt that the React team is aware of the confusion the async nature of `setState` often introduces, so I suspect there is another very good reason for the current semantics. Tell me more :)",
        "remove_template_description": "For quite a while I've tried to understood why `setState` is asynchronous. And failing to find an answer to it in the past, I came to the conclusion that it was for historical reasons and probably hard to change now. However @gaearon indicated there is a clear reason, so I am curious to find out :)    Anyway, here are the reasons I often hear, but I think they can't be everything as they are too easy to counter    ## Async setState is required for async rendering    Many initially think it is because of render efficiency. But I don't think that is the reason behind this behavior, because keeping setState sync with async rendering sounds trivial to me, something along the lines of:    ```javascript  Component.prototype.setState = (nextState) => {    this.state = nextState    if (!this.renderScheduled)       setImmediate(this.forceUpdate)  }  ```    In fact, for example `mobx-react` allows synchronous assignments to observables and still respect the async nature of rendering    ## Async setState is needed to know which state was _rendered_    The other argument I hear sometimes is that you want to reason about the state that was _rendered_, not the state that was _requested_. But I'm not sure this principle has much merit either. Conceptually it feels strange to me. Rendering is a side effect, state is about facts. Today, I am 32 years old, and next year I will turn 33, regardless whether the owning component manages to re-render this year or not :).     To draw a (probably not to good) parallel: If you wouldn't be able to _read_ your last version of a self written word document until you printed it, that would be pretty awkward. I don't think for example game engines give you feedback on what state of the game was exactly rendered and which frames were dropped either.    An interesting observations: In 2 years `mobx-react` nobody ever asked me the question: How do I know my observables are rendered? This question just seems not relevant very often.    I did encounter a few cases where knowing which data was rendered was relevant. The case I remember was where I needed to know the pixel dimensions of some data for layout purposes. But that was elegantly solved by using `didComponentUpdate` and didn't really rely on `setState` being async either. These cases seem so rare that it hardly justify to design the api primarily around them. If it can be done *somehow*, it suffices I think    ---    I have no doubt that the React team is aware of the confusion the async nature of `setState` often introduces, so I suspect there is another very good reason for the current semantics. Tell me more :)",
        "human_words": "For quite a while I've tried to understood why `setState` is asynchronous. And failing to find an answer to it in the past, I came to the conclusion that it was for historical reasons and probably hard to change now. However @gaearon indicated there is a clear reason, so I am curious to find out :)    Anyway, here are the reasons I often hear, but I think they can't be everything as they are too easy to counter    ## Async setState is required for async rendering    Many initially think it is because of render efficiency. But I don't think that is the reason behind this behavior, because keeping setState sync with async rendering sounds trivial to me, something along the lines of:        In fact, for example `mobx-react` allows synchronous assignments to observables and still respect the async nature of rendering    ## Async setState is needed to know which state was _rendered_    The other argument I hear sometimes is that you want to reason about the state that was _rendered_, not the state that was _requested_. But I'm not sure this principle has much merit either. Conceptually it feels strange to me. Rendering is a side effect, state is about facts. Today, I am 32 years old, and next year I will turn 33, regardless whether the owning component manages to re-render this year or not :).     To draw a (probably not to good) parallel: If you wouldn't be able to _read_ your last version of a self written word document until you printed it, that would be pretty awkward. I don't think for example game engines give you feedback on what state of the game was exactly rendered and which frames were dropped either.    An interesting observations: In 2 years `mobx-react` nobody ever asked me the question: How do I know my observables are rendered? This question just seems not relevant very often.    I did encounter a few cases where knowing which data was rendered was relevant. The case I remember was where I needed to know the pixel dimensions of some data for layout purposes. But that was elegantly solved by using `didComponentUpdate` and didn't really rely on `setState` being async either. These cases seem so rare that it hardly justify to design the api primarily around them. If it can be done *somehow*, it suffices I think    ---    I have no doubt that the React team is aware of the confusion the async nature of `setState` often introduces, so I suspect there is another very good reason for the current semantics. Tell me more :)",
        "human_words_regrex": "For quite a while I've tried to understood why `setState` is asynchronous. And failing to find an answer to it in the past, I came to the conclusion that it was for historical reasons and probably hard to change now. However @gaearon indicated there is a clear reason, so I am curious to find out :) Anyway, here are the reasons I often hear, but I think they can't be everything as they are too easy to counter ## Async setState is required for async rendering Many initially think it is because of render efficiency. But I don't think that is the reason behind this behavior, because keeping setState sync with async rendering sounds trivial to me, something along the lines of: In fact, for example `mobx-react` allows synchronous assignments to observables and still respect the async nature of rendering ## Async setState is needed to know which state was _rendered_ The other argument I hear sometimes is that you want to reason about the state that was _rendered_, not the state that was _requested_. But I'm not sure this principle has much merit either. Conceptually it feels strange to me. Rendering is a side effect, state is about facts. Today, I am 32 years old, and next year I will turn 33, regardless whether the owning component manages to re-render this year or not :). To draw a (probably not to good) parallel: If you wouldn't be able to _read_ your last version of a self written word document until you printed it, that would be pretty awkward. I don't think for example game engines give you feedback on what state of the game was exactly rendered and which frames were dropped either. An interesting observations: In 2 years `mobx-react` nobody ever asked me the question: How do I know my observables are rendered? This question just seems not relevant very often. I did encounter a few cases where knowing which data was rendered was relevant. The case I remember was where I needed to know the pixel dimensions of some data for layout purposes. But that was elegantly solved by using `didComponentUpdate` and didn't really rely on `setState` being async either. These cases seem so rare that it hardly justify to design the api primarily around them. If it can be done *somehow*, it suffices I think --- I have no doubt that the React team is aware of the confusion the async nature of `setState` often introduces, so I suspect there is another very good reason for the current semantics. Tell me more :)",
        "human_words_stopwords_removal_lemmatization": "quite 've tried understood ` setstate ` asynchronous . failing find answer past , came conclusion historical reason probably hard change . however @ gaearon indicated clear reason , curious find : ) anyway , reason often hear , think ca n't everything easy counter # # async setstate required async rendering many initially think render efficiency . n't think reason behind behavior , keeping setstate sync async rendering sound trivial , something along line : fact , example ` mobx-react ` allows synchronous assignment observables still respect async nature rendering # # async setstate needed know state _rendered_ argument hear sometimes want reason state _rendered_ , state _requested_ . 'm sure principle much merit either . conceptually feel strange . rendering side effect , state fact . today , 32 year old , next year turn 33 , regardless whether owning component manages re-render year : ) . draw ( probably good ) parallel : would n't able _read_ last version self written word document printed , would pretty awkward . n't think example game engine give feedback state game exactly rendered frame dropped either . interesting observation : 2 year ` mobx-react ` nobody ever asked question : know observables rendered ? question seems relevant often . encounter case knowing data rendered relevant . case remember needed know pixel dimension data layout purpose . elegantly solved using ` didcomponentupdate ` n't really rely ` setstate ` async either . case seem rare hardly justify design api primarily around . done * somehow * , suffices think -- - doubt react team aware confusion async nature ` setstate ` often introduces , suspect another good reason current semantics . tell : )",
        "title_stopwords_removal_lemmatization": "rfclarification : ` setstate ` asynchronous ?"
    },
    {
        "issue_id": 272615283,
        "title": "Formalize top-level ES exports",
        "label": [
            "Component: Build Infrastructure",
            "Type: Discussion",
            "Type: Breaking Change",
            "React Core Team"
        ],
        "date": "2017-11-09T15:56:42Z",
        "status": "open",
        "description": "Currently we only ship CommonJS versions of all packages. However we might want to ship them as ESM in the future (https://github.com/facebook/react/issues/10021).\r\n\r\nWe can't quite easily do this because we haven't really decided on what top-level ES exports would look like from each package. For example, does `react` have a bunch of named exports, but also a default export called `React`? Should we encourage people to `import *` for better tree shaking? What about `react-test-renderer/shallow` that currently exports a class (and thus would start failing in Node were it converted to be a default export)?",
        "remove_template_description": "Currently we only ship CommonJS versions of all packages. However we might want to ship them as ESM in the future (https://github.com/facebook/react/issues/10021).    We can't quite easily do this because we haven't really decided on what top-level ES exports would look like from each package. For example, does `react` have a bunch of named exports, but also a default export called `React`? Should we encourage people to `import *` for better tree shaking? What about `react-test-renderer/shallow` that currently exports a class (and thus would start failing in Node were it converted to be a default export)?",
        "human_words": "Currently we only ship CommonJS versions of all packages. However we might want to ship them as ESM in the future (https://github.com/facebook/react/issues/10021).    We can't quite easily do this because we haven't really decided on what top-level ES exports would look like from each package. For example, does `react` have a bunch of named exports, but also a default export called `React`? Should we encourage people to `import *` for better tree shaking? What about `react-test-renderer/shallow` that currently exports a class (and thus would start failing in Node were it converted to be a default export)?",
        "human_words_regrex": "Currently we only ship CommonJS versions of all packages. However we might want to ship them as ESM in the future ( We can't quite easily do this because we haven't really decided on what top-level ES exports would look like from each package. For example, does `react` have a bunch of named exports, but also a default export called `React`? Should we encourage people to `import *` for better tree shaking? What about `react-test-renderer/shallow` that currently exports a class (and thus would start failing in Node were it converted to be a default export)?",
        "human_words_stopwords_removal_lemmatization": "currently ship commonjs version package . however might want ship esm future ( ca n't quite easily n't really decided top-level e export would look like package . example , ` react ` bunch named export , also default export called ` react ` ? encourage people ` import * ` better tree shaking ? ` react-test-renderer/shallow ` currently export class ( thus would start failing node converted default export ) ?",
        "title_stopwords_removal_lemmatization": "formalize top-level e export"
    },
    {
        "issue_id": 270314794,
        "title": "Ignore <noscript> content on the client and don't warn about mismatches ",
        "label": [
            "Component: DOM",
            "Difficulty: medium",
            "Component: Server Rendering",
            "Type: Discussion",
            "good first issue"
        ],
        "date": "2017-11-01T13:51:13Z",
        "status": "closed",
        "description": "React 16.0.0 with SSR & [lazysizes](https://github.com/aFarkas/lazysizes) 4.0.1.\r\n\r\nTrying to use the [\"the noscript pattern\"](https://github.com/aFarkas/lazysizes#the-noscript-pattern) to lazy load images with [lazysizes](https://github.com/aFarkas/lazysizes) but I'm seeing this:\r\n\r\n> Warning: Expected server HTML to contain a matching &lt;img&gt; in &lt;noscript&gt;.\r\n\r\nImage component render method:\r\n\r\n```js\r\nrender () {\r\n    const { cdn, url, width, height } = this.props\r\n\r\n    if (!url) return null\r\n\r\n    const noScriptImgProps = {\r\n      src: `${cdn}${url}`,\r\n      className: classNames('product-image'),\r\n      width,\r\n      height\r\n    }\r\n\r\n    const imgProps = {\r\n      'data-src': `${cdn}${url}`,\r\n      className: classNames('product-image', 'lazyload'),\r\n      width,\r\n      height\r\n    }\r\n\r\n    return (\r\n      <span>\r\n        <noscript>\r\n          <img {...noScriptImgProps} />\r\n        </noscript>\r\n        <img {...imgProps} />\r\n      </span>\r\n    )\r\n  }\r\n```\r\n\r\nDoes React have an issue with `noscript` tags..?\r\n\r\n",
        "remove_template_description": "React 16.0.0 with SSR & [lazysizes](https://github.com/aFarkas/lazysizes) 4.0.1.    Trying to use the [\"the noscript pattern\"](https://github.com/aFarkas/lazysizes#the-noscript-pattern) to lazy load images with [lazysizes](https://github.com/aFarkas/lazysizes) but I'm seeing this:    > Warning: Expected server HTML to contain a matching &lt;img&gt; in &lt;noscript&gt;.    Image component render method:    ```js  render () {      const { cdn, url, width, height } = this.props        if (!url) return null        const noScriptImgProps = {        src: `${cdn}${url}`,        className: classNames('product-image'),        width,        height      }        const imgProps = {        'data-src': `${cdn}${url}`,        className: classNames('product-image', 'lazyload'),        width,        height      }        return (        <span>          <noscript>            <img {...noScriptImgProps} />          </noscript>          <img {...imgProps} />        </span>      )    }  ```    Does React have an issue with `noscript` tags..?",
        "human_words": "React 16.0.0 with SSR & [lazysizes](https://github.com/aFarkas/lazysizes) 4.0.1.    Trying to use the [\"the noscript pattern\"](https://github.com/aFarkas/lazysizes#the-noscript-pattern) to lazy load images with [lazysizes](https://github.com/aFarkas/lazysizes) but I'm seeing this:    > Warning: Expected server HTML to contain a matching &lt;img&gt; in &lt;noscript&gt;.    Image component render method:        Does React have an issue with `noscript` tags..?",
        "human_words_regrex": "React 16.0.0 with SSR &  4.0.1. Trying to use the  to lazy load images with  but I'm seeing this: > Warning: Expected server HTML to contain a matching &lt;img&gt; in &lt;noscript&gt;. Image component render method: Does React have an issue with `noscript` tags..?",
        "human_words_stopwords_removal_lemmatization": "react 16.0.0 ssr & 4.0.1. trying use lazy load image 'm seeing : > warning : expected server html contain matching & lt ; img & gt ; & lt ; noscript & gt ; . image component render method : react issue ` noscript ` tag .. ?",
        "title_stopwords_removal_lemmatization": "ignore < noscript > content client n't warn mismatch"
    },
    {
        "issue_id": 270120147,
        "title": "Treat value={null} as empty string",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-10-31T21:10:34Z",
        "status": "open",
        "description": "Per @gaearon's request, I'm opening up a new issue based on https://github.com/facebook/react/issues/5013#issuecomment-340898727.\r\n\r\nCurrently, if you create an input like `<input value={null} onChange={this.handleChange} />`, the null value is a flag for React to treat this as an uncontrolled input, and a console warning is generated. However, this is often a valid condition. For example, when creating a new object (initialized w/ default values from the server then passed to the component as props) in a form that requires address, Address Line 2 is often optional. As such, passing null as value to this controlled component is a very reasonable thing to do.\r\n\r\nOne can do a workaround, i.e. `<input value={foo || ''} onChange={this.handleChange} />`, but this is an error-prone approach and quite awkward.\r\n\r\nPer issue referenced above, the React team has planned on treating null as an empty string, but that hasn't yet occurred. I'd like to propose tackling this problem in the near future.\r\n\r\nPlease let me know if I can help further.",
        "remove_template_description": "Per @gaearon's request, I'm opening up a new issue based on https://github.com/facebook/react/issues/5013#issuecomment-340898727.    Currently, if you create an input like `<input value={null} onChange={this.handleChange} />`, the null value is a flag for React to treat this as an uncontrolled input, and a console warning is generated. However, this is often a valid condition. For example, when creating a new object (initialized w/ default values from the server then passed to the component as props) in a form that requires address, Address Line 2 is often optional. As such, passing null as value to this controlled component is a very reasonable thing to do.    One can do a workaround, i.e. `<input value={foo || ''} onChange={this.handleChange} />`, but this is an error-prone approach and quite awkward.    Per issue referenced above, the React team has planned on treating null as an empty string, but that hasn't yet occurred. I'd like to propose tackling this problem in the near future.    Please let me know if I can help further.",
        "human_words": "Per @gaearon's request, I'm opening up a new issue based on https://github.com/facebook/react/issues/5013#issuecomment-340898727.    Currently, if you create an input like `<input value={null} onChange={this.handleChange} />`, the null value is a flag for React to treat this as an uncontrolled input, and a console warning is generated. However, this is often a valid condition. For example, when creating a new object (initialized w/ default values from the server then passed to the component as props) in a form that requires address, Address Line 2 is often optional. As such, passing null as value to this controlled component is a very reasonable thing to do.    One can do a workaround, i.e. `<input value={foo || ''} onChange={this.handleChange} />`, but this is an error-prone approach and quite awkward.    Per issue referenced above, the React team has planned on treating null as an empty string, but that hasn't yet occurred. I'd like to propose tackling this problem in the near future.    Please let me know if I can help further.",
        "human_words_regrex": "Per @gaearon's request, I'm opening up a new issue based on  Currently, if you create an input like ``, the null value is a flag for React to treat this as an uncontrolled input, and a console warning is generated. However, this is often a valid condition. For example, when creating a new object (initialized w/ default values from the server then passed to the component as props) in a form that requires address, Address Line 2 is often optional. As such, passing null as value to this controlled component is a very reasonable thing to do. One can do a workaround, i.e. ``, but this is an error-prone approach and quite awkward. Per issue referenced above, the React team has planned on treating null as an empty string, but that hasn't yet occurred. I'd like to propose tackling this problem in the near future. Please let me know if I can help further.",
        "human_words_stopwords_removal_lemmatization": "per @ gaearon 's request , 'm opening new issue based currently , create input like `` , null value flag react treat uncontrolled input , console warning generated . however , often valid condition . example , creating new object ( initialized w/ default value server passed component prop ) form requires address , address line 2 often optional . , passing null value controlled component reasonable thing . one workaround , i.e . `` , error-prone approach quite awkward . per issue referenced , react team planned treating null empty string , n't yet occurred . 'd like propose tackling problem near future . please let know help .",
        "title_stopwords_removal_lemmatization": "treat value= { null } empty string"
    },
    {
        "issue_id": 269937692,
        "title": "Why are Error Boundaries not triggered for event handlers?",
        "label": [
            "Component: Core Utilities",
            "Type: Discussion"
        ],
        "date": "2017-10-31T12:19:14Z",
        "status": "closed",
        "description": "\r\n**Do you want to request a *feature* or report a *bug*?**\r\nfeature , question ?\r\n\r\n**What is the current behavior?**\r\ncomponentDidCatch is not triggered when the error occurred  on event handlers in react components \r\n\r\n**What is the expected behavior?**\r\nto be honest , without reading the full documentation about error boundaries , my first attempt to test error boundaries was to trigger an error in an event handler (ouch!) , then i discovered that componentDidCatch is triggered only on react lifecycle methods and render  . I'm wondering why this design decision has been done like that ? it would be convenient to have only one component that handle all unexpected exceptions inside our components , instead now we should have two ways to handle errors inside the component.\r\nI have also created an stackoverflow question : https://stackoverflow.com/questions/47020422/why-reactjs-error-boundaries-are-not-triggered-on-event-handlers with the same concern.\r\nthanks!\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\"react\": \"^16.0.0\"",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  feature , question ?    **What is the current behavior?**  componentDidCatch is not triggered when the error occurred  on event handlers in react components     **What is the expected behavior?**  to be honest , without reading the full documentation about error boundaries , my first attempt to test error boundaries was to trigger an error in an event handler (ouch!) , then i discovered that componentDidCatch is triggered only on react lifecycle methods and render  . I'm wondering why this design decision has been done like that ? it would be convenient to have only one component that handle all unexpected exceptions inside our components , instead now we should have two ways to handle errors inside the component.  I have also created an stackoverflow question : https://stackoverflow.com/questions/47020422/why-reactjs-error-boundaries-are-not-triggered-on-event-handlers with the same concern.  thanks!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  \"react\": \"^16.0.0\"",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  feature , question ?    **What is the current behavior?**  componentDidCatch is not triggered when the error occurred  on event handlers in react components     **What is the expected behavior?**  to be honest , without reading the full documentation about error boundaries , my first attempt to test error boundaries was to trigger an error in an event handler (ouch!) , then i discovered that componentDidCatch is triggered only on react lifecycle methods and render  . I'm wondering why this design decision has been done like that ? it would be convenient to have only one component that handle all unexpected exceptions inside our components , instead now we should have two ways to handle errors inside the component.  I have also created an stackoverflow question : https://stackoverflow.com/questions/47020422/why-reactjs-error-boundaries-are-not-triggered-on-event-handlers with the same concern.  thanks!    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  \"react\": \"^16.0.0\"",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** feature , question ? **What is the current behavior?** componentDidCatch is not triggered when the error occurred on event handlers in react components **What is the expected behavior?** to be honest , without reading the full documentation about error boundaries , my first attempt to test error boundaries was to trigger an error in an event handler (ouch!) , then i discovered that componentDidCatch is triggered only on react lifecycle methods and render . I'm wondering why this design decision has been done like that ? it would be convenient to have only one component that handle all unexpected exceptions inside our components , instead now we should have two ways to handle errors inside the component. I have also created an stackoverflow question :  with the same concern. thanks! **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** \"react\": \"^16.0.0\"",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature , question ? * * current behavior ? * * componentdidcatch triggered error occurred event handler react component * * expected behavior ? * * honest , without reading full documentation error boundary , first attempt test error boundary trigger error event handler ( ouch ! ) , discovered componentdidcatch triggered react lifecycle method render . 'm wondering design decision done like ? would convenient one component handle unexpected exception inside component , instead two way handle error inside component . also created stackoverflow question : concern . thanks ! * * version react , browser / o affected issue ? work previous version react ? * * `` react '' : `` ^16.0.0 ''",
        "title_stopwords_removal_lemmatization": "error boundary triggered event handler ?"
    },
    {
        "issue_id": 269352034,
        "title": "Occams software",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-10-28T21:38:10Z",
        "status": "closed",
        "description": " I am a reasonably familiar React coder that was looking for a simple template for a image oriented app.  I downloaded and reviewed/hacked/played with many of the examples in this section.  While most are useful I did notice something that I felt was worth mentioning.\r\n\r\nPerhaps I am alone but I find that many files are  confusing when trying to figure out how code works.  Perhaps it is the hangover for java trained engineers bringing their coding style to javascript?  If so then I really wish I had been to the party!\r\n\r\nThe very nice emoji search app is a good example.  If one consolidates all the files into one file one can make a version that is clear and readable and easily understood with  fewer lines of code **than there are code modules** to wade through to figure out how the code works.\r\n\r\nI actually thought this to be impossible  (and it is impossible  with 80 character or 132 character lines) but with the full use of a 1080p monitor it is very easy to do.\r\n\r\nI am only mentioning this here because react seems to be a particularly sprawling framework that could do with a bit of grooming.  \r\n\r\nMost of the demo's from FB with react are single page demo's (more or less).  \r\n\r\nDoes anyone else agree with me? and if so I would like to propose that there be a section of examples called \"full app snippets\" (or something equally silly) for those of us who get _directory vertigo_  easily. \r\n\r\nSometimes it reminds me of sitting in the back of a car reading a book \r\n\r\non a very windy road :)\r\n![image](https://user-images.githubusercontent.com/9357805/32138757-9d1158ca-bbed-11e7-8433-4de1430e1381.png)\r\n",
        "remove_template_description": "I am a reasonably familiar React coder that was looking for a simple template for a image oriented app.  I downloaded and reviewed/hacked/played with many of the examples in this section.  While most are useful I did notice something that I felt was worth mentioning.    Perhaps I am alone but I find that many files are  confusing when trying to figure out how code works.  Perhaps it is the hangover for java trained engineers bringing their coding style to javascript?  If so then I really wish I had been to the party!    The very nice emoji search app is a good example.  If one consolidates all the files into one file one can make a version that is clear and readable and easily understood with  fewer lines of code **than there are code modules** to wade through to figure out how the code works.    I actually thought this to be impossible  (and it is impossible  with 80 character or 132 character lines) but with the full use of a 1080p monitor it is very easy to do.    I am only mentioning this here because react seems to be a particularly sprawling framework that could do with a bit of grooming.      Most of the demo's from FB with react are single page demo's (more or less).      Does anyone else agree with me? and if so I would like to propose that there be a section of examples called \"full app snippets\" (or something equally silly) for those of us who get _directory vertigo_  easily.     Sometimes it reminds me of sitting in the back of a car reading a book     on a very windy road :)  ![image](https://user-images.githubusercontent.com/9357805/32138757-9d1158ca-bbed-11e7-8433-4de1430e1381.png)",
        "human_words": "I am a reasonably familiar React coder that was looking for a simple template for a image oriented app.  I downloaded and reviewed/hacked/played with many of the examples in this section.  While most are useful I did notice something that I felt was worth mentioning.    Perhaps I am alone but I find that many files are  confusing when trying to figure out how code works.  Perhaps it is the hangover for java trained engineers bringing their coding style to javascript?  If so then I really wish I had been to the party!    The very nice emoji search app is a good example.  If one consolidates all the files into one file one can make a version that is clear and readable and easily understood with  fewer lines of code **than there are code modules** to wade through to figure out how the code works.    I actually thought this to be impossible  (and it is impossible  with 80 character or 132 character lines) but with the full use of a 1080p monitor it is very easy to do.    I am only mentioning this here because react seems to be a particularly sprawling framework that could do with a bit of grooming.      Most of the demo's from FB with react are single page demo's (more or less).      Does anyone else agree with me? and if so I would like to propose that there be a section of examples called \"full app snippets\" (or something equally silly) for those of us who get _directory vertigo_  easily.     Sometimes it reminds me of sitting in the back of a car reading a book     on a very windy road :)  ![image](https://user-images.githubusercontent.com/9357805/32138757-9d1158ca-bbed-11e7-8433-4de1430e1381.png)",
        "human_words_regrex": "I am a reasonably familiar React coder that was looking for a simple template for a image oriented app. I downloaded and reviewed/hacked/played with many of the examples in this section. While most are useful I did notice something that I felt was worth mentioning. Perhaps I am alone but I find that many files are confusing when trying to figure out how code works. Perhaps it is the hangover for java trained engineers bringing their coding style to javascript? If so then I really wish I had been to the party! The very nice emoji search app is a good example. If one consolidates all the files into one file one can make a version that is clear and readable and easily understood with fewer lines of code **than there are code modules** to wade through to figure out how the code works. I actually thought this to be impossible (and it is impossible with 80 character or 132 character lines) but with the full use of a 1080p monitor it is very easy to do. I am only mentioning this here because react seems to be a particularly sprawling framework that could do with a bit of grooming. Most of the demo's from FB with react are single page demo's (more or less). Does anyone else agree with me? and if so I would like to propose that there be a section of examples called \"full app snippets\" (or something equally silly) for those of us who get _directory vertigo_ easily. Sometimes it reminds me of sitting in the back of a car reading a book on a very windy road :) !",
        "human_words_stopwords_removal_lemmatization": "reasonably familiar react coder looking simple template image oriented app . downloaded reviewed/hacked/played many example section . useful notice something felt worth mentioning . perhaps alone find many file confusing trying figure code work . perhaps hangover java trained engineer bringing coding style javascript ? really wish party ! nice emoji search app good example . one consolidates file one file one make version clear readable easily understood fewer line code * * code module * * wade figure code work . actually thought impossible ( impossible 80 character 132 character line ) full use 1080p monitor easy . mentioning react seems particularly sprawling framework could bit grooming . demo 's fb react single page demo 's ( le ) . anyone else agree ? would like propose section example called `` full app snippet '' ( something equally silly ) u get _directory vertigo_ easily . sometimes reminds sitting back car reading book windy road : ) !",
        "title_stopwords_removal_lemmatization": "occam software"
    },
    {
        "issue_id": 268801224,
        "title": "React.Children support for portals",
        "label": [
            "Component: Core Utilities",
            "Type: Discussion"
        ],
        "date": "2017-10-26T15:14:17Z",
        "status": "closed",
        "description": "I don't think they're currently checked against. We should probably treat them same as elements.",
        "remove_template_description": "I don't think they're currently checked against. We should probably treat them same as elements.",
        "human_words": "I don't think they're currently checked against. We should probably treat them same as elements.",
        "human_words_regrex": "I don't think they're currently checked against. We should probably treat them same as elements.",
        "human_words_stopwords_removal_lemmatization": "n't think 're currently checked . probably treat element .",
        "title_stopwords_removal_lemmatization": "react.children support portal"
    },
    {
        "issue_id": 267902244,
        "title": "RFC: Plan for custom element attributes/properties in React 19",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-10-24T05:28:49Z",
        "status": "open",
        "description": "This is meant to address #7249. The doc outlines the pros and cons of various approaches React could use to handle attributes and properties on custom elements.\r\n\r\n# TOC/Summary\r\n\r\n- Background\r\n- Proposals\r\n  * Option 1: Only set properties\r\n    + Pros\r\n      - Easy to understand/implement\r\n      - Avoids conflict with future global attributes\r\n      - Takes advantage of custom element \"upgrade\"\r\n      - Custom elements treated like any other React component\r\n    + Cons\r\n      - Possibly a breaking change\r\n      - Need ref to set attribute\r\n      - Not clear how server-side rendering would work\r\n  * Option 2: Properties-if-available\r\n    + Pros\r\n      - Non-breaking change\r\n    + Cons\r\n      - Developers need to understand the heuristic\r\n      - Falling back to attributes may conflict with future globals\r\n  * Option 3: Differentiate properties with a sigil\r\n    + Pros\r\n      - Non-breaking change that developers can opt-in to\r\n      - Similar to how other libraries handle attributes/properties\r\n      - The system is explicit\r\n    + Cons\r\n      - It\u2019s new syntax\r\n      - Not clear how server-side rendering would work\r\n  * Option 4: Add an attributes object\r\n    + Pros\r\n      - The system is explicit\r\n      - Extending syntax may also solve issues with event handling\r\n    + Cons\r\n      - It\u2019s new syntax\r\n      - It may be a breaking change\r\n      - It may be a larger change than any of the previous proposals\r\n  * Option 5: An API for consuming custom elements\r\n    + Pros\r\n      - The system is explicit\r\n      - Non-breaking change\r\n      - Idiomatic to React\r\n    + Cons\r\n      - Could be a lot of work for a complex component\r\n      - May bloat bundle size\r\n      - Config needs to keep pace with the component\r\n\r\n# Background\r\n\r\nWhen React tries to pass data to a custom element it always does so using HTML attributes.\r\n\r\n```jsx\r\n<x-foo bar={baz}> // same as setAttribute('bar', baz)\r\n```\r\n\r\nBecause attributes must be serialized to strings, this approach creates problems when the data being passed is an object or array. In that scenario, we end up with something like:\r\n\r\n```html\r\n<x-foo bar=\"[object Object]\">\r\n```\r\n\r\nThe workaround for this is to use a `ref` to manually set the property.\r\n\r\n```jsx\r\n<x-foo ref={el => el.bar = baz}>\r\n```\r\n\r\nThis workaround feels a bit unnecessary as the majority of custom elements being shipped today are written with libraries which automatically generate JavaScript properties that back all of their exposed attributes. And anyone hand-authoring a vanilla custom element is [encouraged to follow this practice](https://developers.google.com/web/fundamentals/web-components/best-practices#attributes-properties) as well. We'd like to ideally see runtime communication with custom elements in React use JavaScript properties by default.\r\n\r\nThis doc outlines a few proposals for how React could be updated to make this happen.\r\n\r\n# Proposals\r\n\r\n## Option 1: Only set properties\r\n\r\nRather than try to decide if a property or attribute should be set, React could *always* set properties on custom elements. React would **NOT** check to see if the property exists on the element beforehand.\r\n\r\n**Example:**\r\n\r\n```jsx\r\n<x-foo bar={baz}>\r\n```\r\n\r\nThe above code would result in React setting the `.bar` property of the `x-foo` element equal to the value of `baz`.\r\n\r\nFor camelCased property names, React could use the same style it uses today for properties like `tabIndex`.\r\n\r\n```jsx\r\n<x-foo squidInk={pasta}> // sets .squidInk = pasta\r\n```\r\n\r\n### Pros\r\n\r\n#### Easy to understand/implement\r\n\r\nThis model is simple, explicit, and dovetails with React\u2019s [\"JavaScript-centric API to the DOM\"](https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#why-are-we-changing-this).\r\n\r\nAny element created with libraries like Polymer or Skate will automatically generate properties to back their exposed attributes. These elements should all \"just work\" with the above approach. Developers hand-authoring vanilla components are encouraged to [back attributes with properties](https://developers.google.com/web/fundamentals/web-components/best-practices#always-accept-primitive-data-strings-numbers-booleans-as-either-attributes--or-properties) as that mirrors how *modern* (i.e. not oddballs like `<input>`) HTML5 elements (`<video>`, `<audio>`, etc.) have been implemented.\r\n\r\n#### Avoids conflict with future global attributes\r\n\r\nWhen React sets an attribute on a custom element there\u2019s always the risk that a future version of HTML will ship a similarly named attribute and break things. This concern was [discussed with spec authors](https://github.com/w3c/webcomponents/issues/654) but there is no clear solution to the problem. Avoiding attributes entirely (except when a developer explicitly sets one using `ref`) may sidestep this issue until the browsers come up with a better solution.\r\n\r\n#### Takes advantage of custom element \"upgrade\"\r\n\r\nCustom elements can be lazily [upgraded](https://developers.google.com/web/fundamentals/web-components/customelements#upgrades) on the page and some PRPL patterns rely on this technique. During the upgrade process, a custom element can access the properties passed to it by React\u2014even if those properties were set before the definition loaded\u2014and use them to render initial state.\r\n\r\n#### Custom elements treated like any other React component\r\n\r\nWhen React components pass data to one another they already use properties. This would just make custom elements behave the same way.\r\n\r\n### Cons\r\n\r\n#### Possibly a breaking change\r\n\r\nIf a developer has been hand-authoring vanilla custom elements which only have an attributes API, then they will need to update their code or their app will break. The fix would be to use a `ref` to set the attribute (explained below).\r\n\r\n#### Need ref to set attribute\r\n\r\nBy changing the behavior so properties are preferred, it means developers will need to use a `ref` in order to explicitly set an attribute on a custom element.\r\n\r\n```jsx\r\n<custom-element ref={el => el.setAttribute('my-attr', val)} />\r\n```\r\n\r\nThis is just a reversal of the current behavior where developers need a `ref` in order to set a property. Since developers should rarely need to set attributes on custom elements, this seems like a reasonable trade-off.\r\n\r\n#### Not clear how server-side rendering would work\r\n\r\nIt's not clear how this model would map to server-side rendering custom elements. React could assume that the properties map to similarly named attributes and attempt to set those on the server, but this is far from bulletproof and would possibly require a heuristic for things like camelCased properties -> dash-cased attributes.\r\n\r\n## Option 2: Properties-if-available\r\n\r\nAt runtime React could attempt to detect if a property is present on a custom element. If the property is present React will use it, otherwise it will fallback to setting an attribute. This is the model Preact uses to deal with custom elements.\r\n\r\n**Pseudocode implementation:**\r\n\r\n```js\r\nif (propName in element) {\r\n  element[propName] = value;\r\n} else {\r\n  element.setAttribute(propName.toLowerCase(), value);\r\n}\r\n```\r\n\r\n**Possible steps:**\r\n\r\n* If an element has a defined property, React will use it.\r\n\r\n* If an element has an undefined property, and React is trying to pass it primitive data (string/number/boolean), it will use an attribute.\r\n\r\n    * Alternative: Warn and don\u2019t set.\r\n\r\n* If an element has an undefined property, and React is trying to pass it an object/array it will set it as a property. This is because some-attr=\"[object Object]\u201d is not useful.\r\n\r\n    * Alternative: Warn and don\u2019t set.\r\n\r\n* If the element is being rendered on the server, and React is trying to pass it a string/number/boolean, it will use an attribute.\r\n\r\n* If the element is being rendered on the server, and React is trying to pass it a object/array, it will not do anything.\r\n\r\n### Pros\r\n\r\n#### Non-breaking change\r\n\r\nIt is possible to create a custom element that only uses attributes as its interface. This authoring style is **NOT** encouraged, but it may happen regardless. If a custom element author is relying on this behavior then this change would be non-breaking for them.\r\n\r\n### Cons\r\n\r\n#### Developers need to understand the heuristic\r\n\r\nDevelopers might be confused when React sets an attribute instead of a property depending on how they\u2019ve chosen to load their element.\r\n\r\n#### Falling back to attributes may conflict with future globals\r\n\r\nSebastian [raised a concern](https://github.com/facebook/react/issues/10399#issuecomment-320847065) that using `in` to check for the existence of a property on a custom element might accidentally detect a property on the superclass (HTMLElement).\r\n\r\nThere are also other potential conflicts with global attributes [discussed previously](#avoids-conflict-with-future-global-attributes) in this doc.\r\n\r\n## Option 3: Differentiate properties with a sigil\r\n\r\nReact could continue setting attributes on custom elements, but provide a sigil that developers could use to explicitly set properties instead. This is similar to [the approach used by Glimmer.js](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_component-attributes).\r\n\r\n**Glimmer example:**\r\n\r\n```html\r\n<custom-img @src=\"corgi.jpg\" @hiResSrc=\"corgi@2x.jpg\" width=\"100%\">\r\n```\r\n\r\nIn the above example, the @ sigil indicates that `src` and `hiResSrc` should pass data to the custom element using properties, and `width` should be serialized to an attribute string.\r\n\r\nBecause React components already pass data to one another using properties, there would be no need for them to use the sigil (although it would work if they did, it would just be redundant). Instead, it would primarily be used as an explicit instruction to pass data to a custom element using JavaScript properties.\r\n\r\n*h/t to @developit of Preact for suggesting this approach :)*\r\n\r\n### Pros\r\n\r\n#### Non-breaking change that developers can opt-in to\r\n\r\nAll pre-existing React + custom element apps would continue to work exactly as they have. Developers could choose if they wanted to update their code to use the new sigil style.\r\n\r\n#### Similar to how other libraries handle attributes/properties\r\n\r\nSimilar to Glimmer, both Angular and Vue use modifiers to differentiate between attributes and properties.\r\n\r\n**Vue example:**\r\n\r\n```html\r\n<!-- Vue will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->\r\n<custom-element :foo=\"bar\u201d :squid.prop=\u201dink\u201d>\r\n```\r\n\r\n**Angular example:**\r\n\r\n```html\r\n<!-- Angular will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->\r\n<custom-element [attr.foo]=\"bar\u201d [squid]=\u201dink\u201d>\r\n```\r\n\r\n#### The system is explicit\r\n\r\nDevelopers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.\r\n\r\n### Cons\r\n\r\n#### It\u2019s new syntax\r\n\r\nDevelopers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.\r\n\r\n#### Not clear how server-side rendering would work\r\n\r\nShould the sigil switch to using a similarly named attribute?\r\n\r\n## Option 4: Add an attributes object\r\n\r\nReact could add additional syntax which lets authors explicitly pass data as attributes. If developers do not use this attributes object, then their data will be passed using JavaScript properties.\r\n\r\n**Example:**\r\n\r\n```jsx\r\nconst bar = 'baz';\r\nconst hello = 'World';\r\nconst width = '100%';\r\nconst ReactElement = <Test\r\n  foo={bar} // uses JavaScript property\r\n  attrs={{ hello, width }} // serialized to attributes\r\n/>;\r\n```\r\n\r\nThis idea was [originally proposed](https://gist.github.com/treshugart/2fb509a8828adf7fee5245bfa2a54ba7) by @treshugart, author of Skate.js, and is implemented in the [val](https://github.com/skatejs/val) library.\r\n\r\n### Pros\r\n\r\n#### The system is explicit\r\n\r\nDevelopers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.\r\n\r\n#### Extending syntax may also solve issues with event handling\r\n\r\n*Note: This is outside the scope of this document but maybe worth mentioning :)*\r\n\r\nIssue [#7901](https://github.com/facebook/react/issues/7901) requests that React bypass its synthetic event system when declarative event handlers are added to custom elements. Because custom element event names are arbitrary strings, it means they can be capitalized in any fashion. To bypass the synthetic event system today will also mean needing to come up with a heuristic for mapping event names from JSX to `addEventListener`.\r\n\r\n```js\r\n// should this listen for: 'foobar', 'FooBar', or 'fooBar'?\r\nonFooBar={handleFooBar}\r\n```\r\n\r\nHowever, if the syntax is extended to allow attributes it could also be extended to allow events as well:\r\n\r\n```js\r\nconst bar = 'baz';\r\nconst hello = 'World';\r\nconst SquidChanged = e => console.log('yo');\r\nconst ReactElement = <Test\r\n  foo={bar}\r\n  attrs={{ hello }}\r\n  events={{ SquidChanged}} // addEventListener('SquidChanged', \u2026)\r\n/>;\r\n```\r\n\r\nIn this model the variable name is used as the event name. No heuristic is needed.\r\n\r\n### Cons\r\n\r\n#### It\u2019s new syntax\r\n\r\nDevelopers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.\r\n\r\n#### It may be a breaking change\r\n\r\nIf any components already rely on properties named `attrs` or `events`, it could break them.\r\n\r\n#### It may be a larger change than any of the previous proposals\r\n\r\nFor React 17 it may be easier to make an incremental change (like one of the previous proposals) and position this proposal as something to take under consideration for a later, bigger refactor.\r\n\r\n## Option 5: An API for consuming custom elements\r\n\r\n*This proposal was offered by @sophiebits and @gaearon from the React team*\r\n\r\nReact could create a new API for consuming custom elements that maps the element\u2019s behavior with a configuration object.\r\n\r\n**Pseudocode example:**\r\n\r\n```js\r\nconst XFoo = ReactDOM.createCustomElementType({\r\n  element: \u2018x-foo\u2019,\r\n  \u2018my-attr\u2019: // something that tells React what to do with it\r\n  someRichDataProp: // something that tells React what to do with it\r\n});\r\n```\r\n\r\nThe above code returns a proxy component, `XFoo` that knows how to pass data to a custom element depending on the configuration you provide. You would use this proxy component in your app instead of using the custom element directly.\r\n\r\n**Example usage:**\r\n\r\n```jsx\r\n<XFoo someRichDataProp={...} />\r\n```\r\n\r\n### Pros\r\n\r\n#### The system is explicit\r\n\r\nDevelopers can tell React the exact behavior they want.\r\n\r\n#### Non-breaking change\r\n\r\nDevelopers can opt-in to using the object or continue using the current system.\r\n\r\n#### Idiomatic to React\r\n\r\nThis change doesn\u2019t require new JSX syntax, and feels more like other APIs in React. For example, PropTypes (even though it\u2019s being moved into its own package) has a somewhat similar approach.\r\n\r\n### Cons\r\n\r\n#### Could be a lot of work for a complex component\r\n\r\nPolymer\u2019s [paper-input](https://www.webcomponents.org/element/PolymerElements/paper-input/elements/paper-input) element has 37 properties, so it would produce a very large config. If developers are using a lot of custom elements in their app, that may equal a lot of configs they need to write.\r\n\r\n#### May bloat bundle size\r\n\r\nRelated to the above point, each custom element class now incurs the cost of its definition + its config object size.\r\n\r\n*Note: I'm not 100% sure if this is true. Someone more familiar with the React build process could verify.*\r\n\r\n#### Config needs to keep pace with the component\r\n\r\nEvery time the component does a minor version revision that adds a new property, the config will need to be updated as well. That\u2019s not difficult, but it does add maintenance. Maybe if configs are generated from source this is less of a burden, but that may mean needing to create a new tool to generate configs for each web component library.\r\n\r\n\r\ncc @sebmarkbage @gaearon @developit @treshugart @justinfagnani",
        "remove_template_description": "This is meant to address #7249. The doc outlines the pros and cons of various approaches React could use to handle attributes and properties on custom elements.    # TOC/Summary    - Background  - Proposals    * Option 1: Only set properties      + Pros        - Easy to understand/implement        - Avoids conflict with future global attributes        - Takes advantage of custom element \"upgrade\"        - Custom elements treated like any other React component      + Cons        - Possibly a breaking change        - Need ref to set attribute        - Not clear how server-side rendering would work    * Option 2: Properties-if-available      + Pros        - Non-breaking change      + Cons        - Developers need to understand the heuristic        - Falling back to attributes may conflict with future globals    * Option 3: Differentiate properties with a sigil      + Pros        - Non-breaking change that developers can opt-in to        - Similar to how other libraries handle attributes/properties        - The system is explicit      + Cons        - It\u2019s new syntax        - Not clear how server-side rendering would work    * Option 4: Add an attributes object      + Pros        - The system is explicit        - Extending syntax may also solve issues with event handling      + Cons        - It\u2019s new syntax        - It may be a breaking change        - It may be a larger change than any of the previous proposals    * Option 5: An API for consuming custom elements      + Pros        - The system is explicit        - Non-breaking change        - Idiomatic to React      + Cons        - Could be a lot of work for a complex component        - May bloat bundle size        - Config needs to keep pace with the component    # Background    When React tries to pass data to a custom element it always does so using HTML attributes.    ```jsx  <x-foo bar={baz}> // same as setAttribute('bar', baz)  ```    Because attributes must be serialized to strings, this approach creates problems when the data being passed is an object or array. In that scenario, we end up with something like:    ```html  <x-foo bar=\"[object Object]\">  ```    The workaround for this is to use a `ref` to manually set the property.    ```jsx  <x-foo ref={el => el.bar = baz}>  ```    This workaround feels a bit unnecessary as the majority of custom elements being shipped today are written with libraries which automatically generate JavaScript properties that back all of their exposed attributes. And anyone hand-authoring a vanilla custom element is [encouraged to follow this practice](https://developers.google.com/web/fundamentals/web-components/best-practices#attributes-properties) as well. We'd like to ideally see runtime communication with custom elements in React use JavaScript properties by default.    This doc outlines a few proposals for how React could be updated to make this happen.    # Proposals    ## Option 1: Only set properties    Rather than try to decide if a property or attribute should be set, React could *always* set properties on custom elements. React would **NOT** check to see if the property exists on the element beforehand.    **Example:**    ```jsx  <x-foo bar={baz}>  ```    The above code would result in React setting the `.bar` property of the `x-foo` element equal to the value of `baz`.    For camelCased property names, React could use the same style it uses today for properties like `tabIndex`.    ```jsx  <x-foo squidInk={pasta}> // sets .squidInk = pasta  ```    ### Pros    #### Easy to understand/implement    This model is simple, explicit, and dovetails with React\u2019s [\"JavaScript-centric API to the DOM\"](https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#why-are-we-changing-this).    Any element created with libraries like Polymer or Skate will automatically generate properties to back their exposed attributes. These elements should all \"just work\" with the above approach. Developers hand-authoring vanilla components are encouraged to [back attributes with properties](https://developers.google.com/web/fundamentals/web-components/best-practices#always-accept-primitive-data-strings-numbers-booleans-as-either-attributes--or-properties) as that mirrors how *modern* (i.e. not oddballs like `<input>`) HTML5 elements (`<video>`, `<audio>`, etc.) have been implemented.    #### Avoids conflict with future global attributes    When React sets an attribute on a custom element there\u2019s always the risk that a future version of HTML will ship a similarly named attribute and break things. This concern was [discussed with spec authors](https://github.com/w3c/webcomponents/issues/654) but there is no clear solution to the problem. Avoiding attributes entirely (except when a developer explicitly sets one using `ref`) may sidestep this issue until the browsers come up with a better solution.    #### Takes advantage of custom element \"upgrade\"    Custom elements can be lazily [upgraded](https://developers.google.com/web/fundamentals/web-components/customelements#upgrades) on the page and some PRPL patterns rely on this technique. During the upgrade process, a custom element can access the properties passed to it by React\u2014even if those properties were set before the definition loaded\u2014and use them to render initial state.    #### Custom elements treated like any other React component    When React components pass data to one another they already use properties. This would just make custom elements behave the same way.    ### Cons    #### Possibly a breaking change    If a developer has been hand-authoring vanilla custom elements which only have an attributes API, then they will need to update their code or their app will break. The fix would be to use a `ref` to set the attribute (explained below).    #### Need ref to set attribute    By changing the behavior so properties are preferred, it means developers will need to use a `ref` in order to explicitly set an attribute on a custom element.    ```jsx  <custom-element ref={el => el.setAttribute('my-attr', val)} />  ```    This is just a reversal of the current behavior where developers need a `ref` in order to set a property. Since developers should rarely need to set attributes on custom elements, this seems like a reasonable trade-off.    #### Not clear how server-side rendering would work    It's not clear how this model would map to server-side rendering custom elements. React could assume that the properties map to similarly named attributes and attempt to set those on the server, but this is far from bulletproof and would possibly require a heuristic for things like camelCased properties -> dash-cased attributes.    ## Option 2: Properties-if-available    At runtime React could attempt to detect if a property is present on a custom element. If the property is present React will use it, otherwise it will fallback to setting an attribute. This is the model Preact uses to deal with custom elements.    **Pseudocode implementation:**    ```js  if (propName in element) {    element[propName] = value;  } else {    element.setAttribute(propName.toLowerCase(), value);  }  ```    **Possible steps:**    * If an element has a defined property, React will use it.    * If an element has an undefined property, and React is trying to pass it primitive data (string/number/boolean), it will use an attribute.        * Alternative: Warn and don\u2019t set.    * If an element has an undefined property, and React is trying to pass it an object/array it will set it as a property. This is because some-attr=\"[object Object]\u201d is not useful.        * Alternative: Warn and don\u2019t set.    * If the element is being rendered on the server, and React is trying to pass it a string/number/boolean, it will use an attribute.    * If the element is being rendered on the server, and React is trying to pass it a object/array, it will not do anything.    ### Pros    #### Non-breaking change    It is possible to create a custom element that only uses attributes as its interface. This authoring style is **NOT** encouraged, but it may happen regardless. If a custom element author is relying on this behavior then this change would be non-breaking for them.    ### Cons    #### Developers need to understand the heuristic    Developers might be confused when React sets an attribute instead of a property depending on how they\u2019ve chosen to load their element.    #### Falling back to attributes may conflict with future globals    Sebastian [raised a concern](https://github.com/facebook/react/issues/10399#issuecomment-320847065) that using `in` to check for the existence of a property on a custom element might accidentally detect a property on the superclass (HTMLElement).    There are also other potential conflicts with global attributes [discussed previously](#avoids-conflict-with-future-global-attributes) in this doc.    ## Option 3: Differentiate properties with a sigil    React could continue setting attributes on custom elements, but provide a sigil that developers could use to explicitly set properties instead. This is similar to [the approach used by Glimmer.js](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_component-attributes).    **Glimmer example:**    ```html  <custom-img @src=\"corgi.jpg\" @hiResSrc=\"corgi@2x.jpg\" width=\"100%\">  ```    In the above example, the @ sigil indicates that `src` and `hiResSrc` should pass data to the custom element using properties, and `width` should be serialized to an attribute string.    Because React components already pass data to one another using properties, there would be no need for them to use the sigil (although it would work if they did, it would just be redundant). Instead, it would primarily be used as an explicit instruction to pass data to a custom element using JavaScript properties.    *h/t to @developit of Preact for suggesting this approach :)*    ### Pros    #### Non-breaking change that developers can opt-in to    All pre-existing React + custom element apps would continue to work exactly as they have. Developers could choose if they wanted to update their code to use the new sigil style.    #### Similar to how other libraries handle attributes/properties    Similar to Glimmer, both Angular and Vue use modifiers to differentiate between attributes and properties.    **Vue example:**    ```html  <!-- Vue will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->  <custom-element :foo=\"bar\u201d :squid.prop=\u201dink\u201d>  ```    **Angular example:**    ```html  <!-- Angular will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->  <custom-element [attr.foo]=\"bar\u201d [squid]=\u201dink\u201d>  ```    #### The system is explicit    Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.    ### Cons    #### It\u2019s new syntax    Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.    #### Not clear how server-side rendering would work    Should the sigil switch to using a similarly named attribute?    ## Option 4: Add an attributes object    React could add additional syntax which lets authors explicitly pass data as attributes. If developers do not use this attributes object, then their data will be passed using JavaScript properties.    **Example:**    ```jsx  const bar = 'baz';  const hello = 'World';  const width = '100%';  const ReactElement = <Test    foo={bar} // uses JavaScript property    attrs={{ hello, width }} // serialized to attributes  />;  ```    This idea was [originally proposed](https://gist.github.com/treshugart/2fb509a8828adf7fee5245bfa2a54ba7) by @treshugart, author of Skate.js, and is implemented in the [val](https://github.com/skatejs/val) library.    ### Pros    #### The system is explicit    Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.    #### Extending syntax may also solve issues with event handling    *Note: This is outside the scope of this document but maybe worth mentioning :)*    Issue [#7901](https://github.com/facebook/react/issues/7901) requests that React bypass its synthetic event system when declarative event handlers are added to custom elements. Because custom element event names are arbitrary strings, it means they can be capitalized in any fashion. To bypass the synthetic event system today will also mean needing to come up with a heuristic for mapping event names from JSX to `addEventListener`.    ```js  // should this listen for: 'foobar', 'FooBar', or 'fooBar'?  onFooBar={handleFooBar}  ```    However, if the syntax is extended to allow attributes it could also be extended to allow events as well:    ```js  const bar = 'baz';  const hello = 'World';  const SquidChanged = e => console.log('yo');  const ReactElement = <Test    foo={bar}    attrs={{ hello }}    events={{ SquidChanged}} // addEventListener('SquidChanged', \u2026)  />;  ```    In this model the variable name is used as the event name. No heuristic is needed.    ### Cons    #### It\u2019s new syntax    Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.    #### It may be a breaking change    If any components already rely on properties named `attrs` or `events`, it could break them.    #### It may be a larger change than any of the previous proposals    For React 17 it may be easier to make an incremental change (like one of the previous proposals) and position this proposal as something to take under consideration for a later, bigger refactor.    ## Option 5: An API for consuming custom elements    *This proposal was offered by @sophiebits and @gaearon from the React team*    React could create a new API for consuming custom elements that maps the element\u2019s behavior with a configuration object.    **Pseudocode example:**    ```js  const XFoo = ReactDOM.createCustomElementType({    element: \u2018x-foo\u2019,    \u2018my-attr\u2019: // something that tells React what to do with it    someRichDataProp: // something that tells React what to do with it  });  ```    The above code returns a proxy component, `XFoo` that knows how to pass data to a custom element depending on the configuration you provide. You would use this proxy component in your app instead of using the custom element directly.    **Example usage:**    ```jsx  <XFoo someRichDataProp={...} />  ```    ### Pros    #### The system is explicit    Developers can tell React the exact behavior they want.    #### Non-breaking change    Developers can opt-in to using the object or continue using the current system.    #### Idiomatic to React    This change doesn\u2019t require new JSX syntax, and feels more like other APIs in React. For example, PropTypes (even though it\u2019s being moved into its own package) has a somewhat similar approach.    ### Cons    #### Could be a lot of work for a complex component    Polymer\u2019s [paper-input](https://www.webcomponents.org/element/PolymerElements/paper-input/elements/paper-input) element has 37 properties, so it would produce a very large config. If developers are using a lot of custom elements in their app, that may equal a lot of configs they need to write.    #### May bloat bundle size    Related to the above point, each custom element class now incurs the cost of its definition + its config object size.    *Note: I'm not 100% sure if this is true. Someone more familiar with the React build process could verify.*    #### Config needs to keep pace with the component    Every time the component does a minor version revision that adds a new property, the config will need to be updated as well. That\u2019s not difficult, but it does add maintenance. Maybe if configs are generated from source this is less of a burden, but that may mean needing to create a new tool to generate configs for each web component library.      cc @sebmarkbage @gaearon @developit @treshugart @justinfagnani",
        "human_words": "This is meant to address #7249. The doc outlines the pros and cons of various approaches React could use to handle attributes and properties on custom elements.    # TOC/Summary    - Background  - Proposals    * Option 1: Only set properties      + Pros        - Easy to understand/implement        - Avoids conflict with future global attributes        - Takes advantage of custom element \"upgrade\"        - Custom elements treated like any other React component      + Cons        - Possibly a breaking change        - Need ref to set attribute        - Not clear how server-side rendering would work    * Option 2: Properties-if-available      + Pros        - Non-breaking change      + Cons        - Developers need to understand the heuristic        - Falling back to attributes may conflict with future globals    * Option 3: Differentiate properties with a sigil      + Pros        - Non-breaking change that developers can opt-in to        - Similar to how other libraries handle attributes/properties        - The system is explicit      + Cons        - It\u2019s new syntax        - Not clear how server-side rendering would work    * Option 4: Add an attributes object      + Pros        - The system is explicit        - Extending syntax may also solve issues with event handling      + Cons        - It\u2019s new syntax        - It may be a breaking change        - It may be a larger change than any of the previous proposals    * Option 5: An API for consuming custom elements      + Pros        - The system is explicit        - Non-breaking change        - Idiomatic to React      + Cons        - Could be a lot of work for a complex component        - May bloat bundle size        - Config needs to keep pace with the component    # Background    When React tries to pass data to a custom element it always does so using HTML attributes.        Because attributes must be serialized to strings, this approach creates problems when the data being passed is an object or array. In that scenario, we end up with something like:        The workaround for this is to use a `ref` to manually set the property.        This workaround feels a bit unnecessary as the majority of custom elements being shipped today are written with libraries which automatically generate JavaScript properties that back all of their exposed attributes. And anyone hand-authoring a vanilla custom element is [encouraged to follow this practice](https://developers.google.com/web/fundamentals/web-components/best-practices#attributes-properties) as well. We'd like to ideally see runtime communication with custom elements in React use JavaScript properties by default.    This doc outlines a few proposals for how React could be updated to make this happen.    # Proposals    ## Option 1: Only set properties    Rather than try to decide if a property or attribute should be set, React could *always* set properties on custom elements. React would **NOT** check to see if the property exists on the element beforehand.    **Example:**        The above code would result in React setting the `.bar` property of the `x-foo` element equal to the value of `baz`.    For camelCased property names, React could use the same style it uses today for properties like `tabIndex`.        ### Pros    #### Easy to understand/implement    This model is simple, explicit, and dovetails with React\u2019s [\"JavaScript-centric API to the DOM\"](https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#why-are-we-changing-this).    Any element created with libraries like Polymer or Skate will automatically generate properties to back their exposed attributes. These elements should all \"just work\" with the above approach. Developers hand-authoring vanilla components are encouraged to [back attributes with properties](https://developers.google.com/web/fundamentals/web-components/best-practices#always-accept-primitive-data-strings-numbers-booleans-as-either-attributes--or-properties) as that mirrors how *modern* (i.e. not oddballs like `<input>`) HTML5 elements (`<video>`, `<audio>`, etc.) have been implemented.    #### Avoids conflict with future global attributes    When React sets an attribute on a custom element there\u2019s always the risk that a future version of HTML will ship a similarly named attribute and break things. This concern was [discussed with spec authors](https://github.com/w3c/webcomponents/issues/654) but there is no clear solution to the problem. Avoiding attributes entirely (except when a developer explicitly sets one using `ref`) may sidestep this issue until the browsers come up with a better solution.    #### Takes advantage of custom element \"upgrade\"    Custom elements can be lazily [upgraded](https://developers.google.com/web/fundamentals/web-components/customelements#upgrades) on the page and some PRPL patterns rely on this technique. During the upgrade process, a custom element can access the properties passed to it by React\u2014even if those properties were set before the definition loaded\u2014and use them to render initial state.    #### Custom elements treated like any other React component    When React components pass data to one another they already use properties. This would just make custom elements behave the same way.    ### Cons    #### Possibly a breaking change    If a developer has been hand-authoring vanilla custom elements which only have an attributes API, then they will need to update their code or their app will break. The fix would be to use a `ref` to set the attribute (explained below).    #### Need ref to set attribute    By changing the behavior so properties are preferred, it means developers will need to use a `ref` in order to explicitly set an attribute on a custom element.        This is just a reversal of the current behavior where developers need a `ref` in order to set a property. Since developers should rarely need to set attributes on custom elements, this seems like a reasonable trade-off.    #### Not clear how server-side rendering would work    It's not clear how this model would map to server-side rendering custom elements. React could assume that the properties map to similarly named attributes and attempt to set those on the server, but this is far from bulletproof and would possibly require a heuristic for things like camelCased properties -> dash-cased attributes.    ## Option 2: Properties-if-available    At runtime React could attempt to detect if a property is present on a custom element. If the property is present React will use it, otherwise it will fallback to setting an attribute. This is the model Preact uses to deal with custom elements.    **Pseudocode implementation:**        **Possible steps:**    * If an element has a defined property, React will use it.    * If an element has an undefined property, and React is trying to pass it primitive data (string/number/boolean), it will use an attribute.        * Alternative: Warn and don\u2019t set.    * If an element has an undefined property, and React is trying to pass it an object/array it will set it as a property. This is because some-attr=\"[object Object]\u201d is not useful.        * Alternative: Warn and don\u2019t set.    * If the element is being rendered on the server, and React is trying to pass it a string/number/boolean, it will use an attribute.    * If the element is being rendered on the server, and React is trying to pass it a object/array, it will not do anything.    ### Pros    #### Non-breaking change    It is possible to create a custom element that only uses attributes as its interface. This authoring style is **NOT** encouraged, but it may happen regardless. If a custom element author is relying on this behavior then this change would be non-breaking for them.    ### Cons    #### Developers need to understand the heuristic    Developers might be confused when React sets an attribute instead of a property depending on how they\u2019ve chosen to load their element.    #### Falling back to attributes may conflict with future globals    Sebastian [raised a concern](https://github.com/facebook/react/issues/10399#issuecomment-320847065) that using `in` to check for the existence of a property on a custom element might accidentally detect a property on the superclass (HTMLElement).    There are also other potential conflicts with global attributes [discussed previously](#avoids-conflict-with-future-global-attributes) in this doc.    ## Option 3: Differentiate properties with a sigil    React could continue setting attributes on custom elements, but provide a sigil that developers could use to explicitly set properties instead. This is similar to [the approach used by Glimmer.js](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_component-attributes).    **Glimmer example:**        In the above example, the @ sigil indicates that `src` and `hiResSrc` should pass data to the custom element using properties, and `width` should be serialized to an attribute string.    Because React components already pass data to one another using properties, there would be no need for them to use the sigil (although it would work if they did, it would just be redundant). Instead, it would primarily be used as an explicit instruction to pass data to a custom element using JavaScript properties.    *h/t to @developit of Preact for suggesting this approach :)*    ### Pros    #### Non-breaking change that developers can opt-in to    All pre-existing React + custom element apps would continue to work exactly as they have. Developers could choose if they wanted to update their code to use the new sigil style.    #### Similar to how other libraries handle attributes/properties    Similar to Glimmer, both Angular and Vue use modifiers to differentiate between attributes and properties.    **Vue example:**        **Angular example:**        #### The system is explicit    Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.    ### Cons    #### It\u2019s new syntax    Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.    #### Not clear how server-side rendering would work    Should the sigil switch to using a similarly named attribute?    ## Option 4: Add an attributes object    React could add additional syntax which lets authors explicitly pass data as attributes. If developers do not use this attributes object, then their data will be passed using JavaScript properties.    **Example:**        This idea was [originally proposed](https://gist.github.com/treshugart/2fb509a8828adf7fee5245bfa2a54ba7) by @treshugart, author of Skate.js, and is implemented in the [val](https://github.com/skatejs/val) library.    ### Pros    #### The system is explicit    Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.    #### Extending syntax may also solve issues with event handling    *Note: This is outside the scope of this document but maybe worth mentioning :)*    Issue [#7901](https://github.com/facebook/react/issues/7901) requests that React bypass its synthetic event system when declarative event handlers are added to custom elements. Because custom element event names are arbitrary strings, it means they can be capitalized in any fashion. To bypass the synthetic event system today will also mean needing to come up with a heuristic for mapping event names from JSX to `addEventListener`.        However, if the syntax is extended to allow attributes it could also be extended to allow events as well:        In this model the variable name is used as the event name. No heuristic is needed.    ### Cons    #### It\u2019s new syntax    Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.    #### It may be a breaking change    If any components already rely on properties named `attrs` or `events`, it could break them.    #### It may be a larger change than any of the previous proposals    For React 17 it may be easier to make an incremental change (like one of the previous proposals) and position this proposal as something to take under consideration for a later, bigger refactor.    ## Option 5: An API for consuming custom elements    *This proposal was offered by @sophiebits and @gaearon from the React team*    React could create a new API for consuming custom elements that maps the element\u2019s behavior with a configuration object.    **Pseudocode example:**        The above code returns a proxy component, `XFoo` that knows how to pass data to a custom element depending on the configuration you provide. You would use this proxy component in your app instead of using the custom element directly.    **Example usage:**        ### Pros    #### The system is explicit    Developers can tell React the exact behavior they want.    #### Non-breaking change    Developers can opt-in to using the object or continue using the current system.    #### Idiomatic to React    This change doesn\u2019t require new JSX syntax, and feels more like other APIs in React. For example, PropTypes (even though it\u2019s being moved into its own package) has a somewhat similar approach.    ### Cons    #### Could be a lot of work for a complex component    Polymer\u2019s [paper-input](https://www.webcomponents.org/element/PolymerElements/paper-input/elements/paper-input) element has 37 properties, so it would produce a very large config. If developers are using a lot of custom elements in their app, that may equal a lot of configs they need to write.    #### May bloat bundle size    Related to the above point, each custom element class now incurs the cost of its definition + its config object size.    *Note: I'm not 100% sure if this is true. Someone more familiar with the React build process could verify.*    #### Config needs to keep pace with the component    Every time the component does a minor version revision that adds a new property, the config will need to be updated as well. That\u2019s not difficult, but it does add maintenance. Maybe if configs are generated from source this is less of a burden, but that may mean needing to create a new tool to generate configs for each web component library.      cc @sebmarkbage @gaearon @developit @treshugart @justinfagnani",
        "human_words_regrex": "This is meant to address #7249. The doc outlines the pros and cons of various approaches React could use to handle attributes and properties on custom elements. # TOC/Summary - Background - Proposals * Option 1: Only set properties + Pros - Easy to understand/implement - Avoids conflict with future global attributes - Takes advantage of custom element \"upgrade\" - Custom elements treated like any other React component + Cons - Possibly a breaking change - Need ref to set attribute - Not clear how server-side rendering would work * Option 2: Properties-if-available + Pros - Non-breaking change + Cons - Developers need to understand the heuristic - Falling back to attributes may conflict with future globals * Option 3: Differentiate properties with a sigil + Pros - Non-breaking change that developers can opt-in to - Similar to how other libraries handle attributes/properties - The system is explicit + Cons - It\u2019s new syntax - Not clear how server-side rendering would work * Option 4: Add an attributes object + Pros - The system is explicit - Extending syntax may also solve issues with event handling + Cons - It\u2019s new syntax - It may be a breaking change - It may be a larger change than any of the previous proposals * Option 5: An API for consuming custom elements + Pros - The system is explicit - Non-breaking change - Idiomatic to React + Cons - Could be a lot of work for a complex component - May bloat bundle size - Config needs to keep pace with the component # Background When React tries to pass data to a custom element it always does so using HTML attributes. Because attributes must be serialized to strings, this approach creates problems when the data being passed is an object or array. In that scenario, we end up with something like: The workaround for this is to use a `ref` to manually set the property. This workaround feels a bit unnecessary as the majority of custom elements being shipped today are written with libraries which automatically generate JavaScript properties that back all of their exposed attributes. And anyone hand-authoring a vanilla custom element is  as well. We'd like to ideally see runtime communication with custom elements in React use JavaScript properties by default. This doc outlines a few proposals for how React could be updated to make this happen. # Proposals ## Option 1: Only set properties Rather than try to decide if a property or attribute should be set, React could *always* set properties on custom elements. React would **NOT** check to see if the property exists on the element beforehand. **Example:** The above code would result in React setting the `.bar` property of the `x-foo` element equal to the value of `baz`. For camelCased property names, React could use the same style it uses today for properties like `tabIndex`. ### Pros #### Easy to understand/implement This model is simple, explicit, and dovetails with React\u2019s . Any element created with libraries like Polymer or Skate will automatically generate properties to back their exposed attributes. These elements should all \"just work\" with the above approach. Developers hand-authoring vanilla components are encouraged to  as that mirrors how *modern* (i.e. not oddballs like ``) HTML5 elements (``, ``, etc.) have been implemented. #### Avoids conflict with future global attributes When React sets an attribute on a custom element there\u2019s always the risk that a future version of HTML will ship a similarly named attribute and break things. This concern was  but there is no clear solution to the problem. Avoiding attributes entirely (except when a developer explicitly sets one using `ref`) may sidestep this issue until the browsers come up with a better solution. #### Takes advantage of custom element \"upgrade\" Custom elements can be lazily  on the page and some PRPL patterns rely on this technique. During the upgrade process, a custom element can access the properties passed to it by React\u2014even if those properties were set before the definition loaded\u2014and use them to render initial state. #### Custom elements treated like any other React component When React components pass data to one another they already use properties. This would just make custom elements behave the same way. ### Cons #### Possibly a breaking change If a developer has been hand-authoring vanilla custom elements which only have an attributes API, then they will need to update their code or their app will break. The fix would be to use a `ref` to set the attribute (explained below). #### Need ref to set attribute By changing the behavior so properties are preferred, it means developers will need to use a `ref` in order to explicitly set an attribute on a custom element. This is just a reversal of the current behavior where developers need a `ref` in order to set a property. Since developers should rarely need to set attributes on custom elements, this seems like a reasonable trade-off. #### Not clear how server-side rendering would work It's not clear how this model would map to server-side rendering custom elements. React could assume that the properties map to similarly named attributes and attempt to set those on the server, but this is far from bulletproof and would possibly require a heuristic for things like camelCased properties -> dash-cased attributes. ## Option 2: Properties-if-available At runtime React could attempt to detect if a property is present on a custom element. If the property is present React will use it, otherwise it will fallback to setting an attribute. This is the model Preact uses to deal with custom elements. **Pseudocode implementation:** **Possible steps:** * If an element has a defined property, React will use it. * If an element has an undefined property, and React is trying to pass it primitive data (string/number/boolean), it will use an attribute. * Alternative: Warn and don\u2019t set. * If an element has an undefined property, and React is trying to pass it an object/array it will set it as a property. This is because some-attr=\" that using `in` to check for the existence of a property on a custom element might accidentally detect a property on the superclass (HTMLElement). There are also other potential conflicts with global attributes  in this doc. ## Option 3: Differentiate properties with a sigil React could continue setting attributes on custom elements, but provide a sigil that developers could use to explicitly set properties instead. This is similar to . **Glimmer example:** In the above example, the @ sigil indicates that `src` and `hiResSrc` should pass data to the custom element using properties, and `width` should be serialized to an attribute string. Because React components already pass data to one another using properties, there would be no need for them to use the sigil (although it would work if they did, it would just be redundant). Instead, it would primarily be used as an explicit instruction to pass data to a custom element using JavaScript properties. *h/t to @developit of Preact for suggesting this approach :)* ### Pros #### Non-breaking change that developers can opt-in to All pre-existing React + custom element apps would continue to work exactly as they have. Developers could choose if they wanted to update their code to use the new sigil style. #### Similar to how other libraries handle attributes/properties Similar to Glimmer, both Angular and Vue use modifiers to differentiate between attributes and properties. **Vue example:** **Angular example:** #### The system is explicit Developers can tell React exactly what they want instead of relying on a heuristic like the  approach. ### Cons #### It\u2019s new syntax Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible. #### Not clear how server-side rendering would work Should the sigil switch to using a similarly named attribute? ## Option 4: Add an attributes object React could add additional syntax which lets authors explicitly pass data as attributes. If developers do not use this attributes object, then their data will be passed using JavaScript properties. **Example:** This idea was  by @treshugart, author of Skate.js, and is implemented in the  library. ### Pros #### The system is explicit Developers can tell React exactly what they want instead of relying on a heuristic like the  approach. #### Extending syntax may also solve issues with event handling *Note: This is outside the scope of this document but maybe worth mentioning :)* Issue  requests that React bypass its synthetic event system when declarative event handlers are added to custom elements. Because custom element event names are arbitrary strings, it means they can be capitalized in any fashion. To bypass the synthetic event system today will also mean needing to come up with a heuristic for mapping event names from JSX to `addEventListener`. However, if the syntax is extended to allow attributes it could also be extended to allow events as well: In this model the variable name is used as the event name. No heuristic is needed. ### Cons #### It\u2019s new syntax Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible. #### It may be a breaking change If any components already rely on properties named `attrs` or `events`, it could break them. #### It may be a larger change than any of the previous proposals For React 17 it may be easier to make an incremental change (like one of the previous proposals) and position this proposal as something to take under consideration for a later, bigger refactor. ## Option 5: An API for consuming custom elements *This proposal was offered by @sophiebits and @gaearon from the React team* React could create a new API for consuming custom elements that maps the element\u2019s behavior with a configuration object. **Pseudocode example:** The above code returns a proxy component, `XFoo` that knows how to pass data to a custom element depending on the configuration you provide. You would use this proxy component in your app instead of using the custom element directly. **Example usage:** ### Pros #### The system is explicit Developers can tell React the exact behavior they want. #### Non-breaking change Developers can opt-in to using the object or continue using the current system. #### Idiomatic to React This change doesn\u2019t require new JSX syntax, and feels more like other APIs in React. For example, PropTypes (even though it\u2019s being moved into its own package) has a somewhat similar approach. ### Cons #### Could be a lot of work for a complex component Polymer\u2019s  element has 37 properties, so it would produce a very large config. If developers are using a lot of custom elements in their app, that may equal a lot of configs they need to write. #### May bloat bundle size Related to the above point, each custom element class now incurs the cost of its definition + its config object size. *Note: I'm not 100% sure if this is true. Someone more familiar with the React build process could verify.* #### Config needs to keep pace with the component Every time the component does a minor version revision that adds a new property, the config will need to be updated as well. That\u2019s not difficult, but it does add maintenance. Maybe if configs are generated from source this is less of a burden, but that may mean needing to create a new tool to generate configs for each web component library. cc @sebmarkbage @gaearon @developit @treshugart @justinfagnani",
        "human_words_stopwords_removal_lemmatization": "meant address # 7249. doc outline pro con various approach react could use handle attribute property custom element . # toc/summary - background - proposal * option 1 : set property + pro - easy understand/implement - avoids conflict future global attribute - take advantage custom element `` upgrade '' - custom element treated like react component + con - possibly breaking change - need ref set attribute - clear server-side rendering would work * option 2 : properties-if-available + pro - non-breaking change + con - developer need understand heuristic - falling back attribute may conflict future globals * option 3 : differentiate property sigil + pro - non-breaking change developer opt-in - similar library handle attributes/properties - system explicit + con - \u2019 new syntax - clear server-side rendering would work * option 4 : add attribute object + pro - system explicit - extending syntax may also solve issue event handling + con - \u2019 new syntax - may breaking change - may larger change previous proposal * option 5 : api consuming custom element + pro - system explicit - non-breaking change - idiomatic react + con - could lot work complex component - may bloat bundle size - config need keep pace component # background react try pas data custom element always using html attribute . attribute must serialized string , approach creates problem data passed object array . scenario , end something like : workaround use ` ref ` manually set property . workaround feel bit unnecessary majority custom element shipped today written library automatically generate javascript property back exposed attribute . anyone hand-authoring vanilla custom element well . 'd like ideally see runtime communication custom element react use javascript property default . doc outline proposal react could updated make happen . # proposal # # option 1 : set property rather try decide property attribute set , react could * always * set property custom element . react would * * * * check see property exists element beforehand . * * example : * * code would result react setting ` .bar ` property ` x-foo ` element equal value ` baz ` . camelcased property name , react could use style us today property like ` tabindex ` . # # # pro # # # # easy understand/implement model simple , explicit , dovetail react \u2019 . element created library like polymer skate automatically generate property back exposed attribute . element `` work '' approach . developer hand-authoring vanilla component encouraged mirror * modern * ( i.e . oddball like `` ) html5 element ( `` , `` , etc . ) implemented . # # # # avoids conflict future global attribute react set attribute custom element \u2019 always risk future version html ship similarly named attribute break thing . concern clear solution problem . avoiding attribute entirely ( except developer explicitly set one using ` ref ` ) may sidestep issue browser come better solution . # # # # take advantage custom element `` upgrade '' custom element lazily page prpl pattern rely technique . upgrade process , custom element access property passed react\u2014even property set definition loaded\u2014and use render initial state . # # # # custom element treated like react component react component pas data one another already use property . would make custom element behave way . # # # con # # # # possibly breaking change developer hand-authoring vanilla custom element attribute api , need update code app break . fix would use ` ref ` set attribute ( explained ) . # # # # need ref set attribute changing behavior property preferred , mean developer need use ` ref ` order explicitly set attribute custom element . reversal current behavior developer need ` ref ` order set property . since developer rarely need set attribute custom element , seems like reasonable trade-off . # # # # clear server-side rendering would work 's clear model would map server-side rendering custom element . react could assume property map similarly named attribute attempt set server , far bulletproof would possibly require heuristic thing like camelcased property - > dash-cased attribute . # # option 2 : properties-if-available runtime react could attempt detect property present custom element . property present react use , otherwise fallback setting attribute . model preact us deal custom element . * * pseudocode implementation : * * * * possible step : * * * element defined property , react use . * element undefined property , react trying pas primitive data ( string/number/boolean ) , use attribute . * alternative : warn \u2019 set . * element undefined property , react trying pas object/array set property . some-attr= '' using ` ` check existence property custom element might accidentally detect property superclass ( htmlelement ) . also potential conflict global attribute doc . # # option 3 : differentiate property sigil react could continue setting attribute custom element , provide sigil developer could use explicitly set property instead . similar . * * glimmer example : * * example , @ sigil indicates ` src ` ` hiressrc ` pas data custom element using property , ` width ` serialized attribute string . react component already pas data one another using property , would need use sigil ( although would work , would redundant ) . instead , would primarily used explicit instruction pas data custom element using javascript property . * h/t @ developit preact suggesting approach : ) * # # # pro # # # # non-breaking change developer opt-in pre-existing react + custom element apps would continue work exactly . developer could choose wanted update code use new sigil style . # # # # similar library handle attributes/properties similar glimmer , angular vue use modifier differentiate attribute property . * * vue example : * * * * angular example : * * # # # # system explicit developer tell react exactly want instead relying heuristic like approach . # # # con # # # # \u2019 new syntax developer need taught use need thoroughly tested make sure backwards compatible . # # # # clear server-side rendering would work sigil switch using similarly named attribute ? # # option 4 : add attribute object react could add additional syntax let author explicitly pas data attribute . developer use attribute object , data passed using javascript property . * * example : * * idea @ treshugart , author skate.js , implemented library . # # # pro # # # # system explicit developer tell react exactly want instead relying heuristic like approach . # # # # extending syntax may also solve issue event handling * note : outside scope document maybe worth mentioning : ) * issue request react bypass synthetic event system declarative event handler added custom element . custom element event name arbitrary string , mean capitalized fashion . bypass synthetic event system today also mean needing come heuristic mapping event name jsx ` addeventlistener ` . however , syntax extended allow attribute could also extended allow event well : model variable name used event name . heuristic needed . # # # con # # # # \u2019 new syntax developer need taught use need thoroughly tested make sure backwards compatible . # # # # may breaking change component already rely property named ` attrs ` ` event ` , could break . # # # # may larger change previous proposal react 17 may easier make incremental change ( like one previous proposal ) position proposal something take consideration later , bigger refactor . # # option 5 : api consuming custom element * proposal offered @ sophiebits @ gaearon react team * react could create new api consuming custom element map element \u2019 behavior configuration object . * * pseudocode example : * * code return proxy component , ` xfoo ` know pas data custom element depending configuration provide . would use proxy component app instead using custom element directly . * * example usage : * * # # # pro # # # # system explicit developer tell react exact behavior want . # # # # non-breaking change developer opt-in using object continue using current system . # # # # idiomatic react change \u2019 require new jsx syntax , feel like apis react . example , proptypes ( even though \u2019 moved package ) somewhat similar approach . # # # con # # # # could lot work complex component polymer \u2019 element 37 property , would produce large config . developer using lot custom element app , may equal lot configs need write . # # # # may bloat bundle size related point , custom element class incurs cost definition + config object size . * note : 'm 100 % sure true . someone familiar react build process could verify . * # # # # config need keep pace component every time component minor version revision add new property , config need updated well . \u2019 difficult , add maintenance . maybe configs generated source le burden , may mean needing create new tool generate configs web component library . cc @ sebmarkbage @ gaearon @ developit @ treshugart @ justinfagnani",
        "title_stopwords_removal_lemmatization": "rfc : plan custom element attributes/properties react 19"
    },
    {
        "issue_id": 267400176,
        "title": "Adding support for component factories in \"createElement\" etc.",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-10-21T17:45:00Z",
        "status": "closed",
        "description": "Problem:\r\nLet's assume you are implementing a component suite providing some dozen superfancy ready-to-use components for React users.\r\nHowever, you do not know whether the users of your library are preferring JSX or normal JavaScript.\r\nIn the non-JSX case, most users surely want to write:\r\n\r\n```javascript\r\nFancyButton({ text: 'Click me' })\r\n```\r\ninstead of\r\n\r\n```javascript\r\nReact.createElement(FancyButton, { text: 'Click me' })\r\n```\r\nSo far, for non-JSX users, providing a component as a component factory seems to be the better solution, whereas JSX users would surely prefer the component class itself (as \"createElement\" does not support component factories yet).\r\nThis is not very convenient. The component suite provider has to decide whether the components shall be provided as factories or as classes (respectively \"render functions\" in case of stateless functional  components) or whether she/he should always provide both versions at once.\r\n\r\nFeature request:\r\nWhy not promote component factories to first-class citizens in the React world (instead of downgrading them to \"legacy\" as currently planned) and make sure that functions like \"createElement\" etc. will support component factories at the same level as component classes (respectively \"render functions\" in case of stateless functional  components) are supported currently?\r\n\r\nBTW: By having access to the component factory you also have access to the component class/function via \"factory.type\" (which is considered \"deprecated\" by the React team - I do not know why, because \"factory.type\" seems very helpful). \r\n\r\nHere's a little example:\r\nhttps://jsfiddle.net/nse64ev9/\r\n\r\nMany thanks in advance ",
        "remove_template_description": "Problem:  Let's assume you are implementing a component suite providing some dozen superfancy ready-to-use components for React users.  However, you do not know whether the users of your library are preferring JSX or normal JavaScript.  In the non-JSX case, most users surely want to write:    ```javascript  FancyButton({ text: 'Click me' })  ```  instead of    ```javascript  React.createElement(FancyButton, { text: 'Click me' })  ```  So far, for non-JSX users, providing a component as a component factory seems to be the better solution, whereas JSX users would surely prefer the component class itself (as \"createElement\" does not support component factories yet).  This is not very convenient. The component suite provider has to decide whether the components shall be provided as factories or as classes (respectively \"render functions\" in case of stateless functional  components) or whether she/he should always provide both versions at once.    Feature request:  Why not promote component factories to first-class citizens in the React world (instead of downgrading them to \"legacy\" as currently planned) and make sure that functions like \"createElement\" etc. will support component factories at the same level as component classes (respectively \"render functions\" in case of stateless functional  components) are supported currently?    BTW: By having access to the component factory you also have access to the component class/function via \"factory.type\" (which is considered \"deprecated\" by the React team - I do not know why, because \"factory.type\" seems very helpful).     Here's a little example:  https://jsfiddle.net/nse64ev9/    Many thanks in advance",
        "human_words": "Problem:  Let's assume you are implementing a component suite providing some dozen superfancy ready-to-use components for React users.  However, you do not know whether the users of your library are preferring JSX or normal JavaScript.  In the non-JSX case, most users surely want to write:      instead of      So far, for non-JSX users, providing a component as a component factory seems to be the better solution, whereas JSX users would surely prefer the component class itself (as \"createElement\" does not support component factories yet).  This is not very convenient. The component suite provider has to decide whether the components shall be provided as factories or as classes (respectively \"render functions\" in case of stateless functional  components) or whether she/he should always provide both versions at once.    Feature request:  Why not promote component factories to first-class citizens in the React world (instead of downgrading them to \"legacy\" as currently planned) and make sure that functions like \"createElement\" etc. will support component factories at the same level as component classes (respectively \"render functions\" in case of stateless functional  components) are supported currently?    BTW: By having access to the component factory you also have access to the component class/function via \"factory.type\" (which is considered \"deprecated\" by the React team - I do not know why, because \"factory.type\" seems very helpful).     Here's a little example:  https://jsfiddle.net/nse64ev9/    Many thanks in advance",
        "human_words_regrex": "Problem: Let's assume you are implementing a component suite providing some dozen superfancy ready-to-use components for React users. However, you do not know whether the users of your library are preferring JSX or normal JavaScript. In the non-JSX case, most users surely want to write: instead of So far, for non-JSX users, providing a component as a component factory seems to be the better solution, whereas JSX users would surely prefer the component class itself (as \"createElement\" does not support component factories yet). This is not very convenient. The component suite provider has to decide whether the components shall be provided as factories or as classes (respectively \"render functions\" in case of stateless functional components) or whether she/he should always provide both versions at once. Feature request: Why not promote component factories to first-class citizens in the React world (instead of downgrading them to \"legacy\" as currently planned) and make sure that functions like \"createElement\" etc. will support component factories at the same level as component classes (respectively \"render functions\" in case of stateless functional components) are supported currently? BTW: By having access to the component factory you also have access to the component class/function via \"factory.type\" (which is considered \"deprecated\" by the React team - I do not know why, because \"factory.type\" seems very helpful). Here's a little example:  Many thanks in advance",
        "human_words_stopwords_removal_lemmatization": "problem : let 's assume implementing component suite providing dozen superfancy ready-to-use component react user . however , know whether user library preferring jsx normal javascript . non-jsx case , user surely want write : instead far , non-jsx user , providing component component factory seems better solution , whereas jsx user would surely prefer component class ( `` createelement '' support component factory yet ) . convenient . component suite provider decide whether component shall provided factory class ( respectively `` render function '' case stateless functional component ) whether she/he always provide version . feature request : promote component factory first-class citizen react world ( instead downgrading `` legacy '' currently planned ) make sure function like `` createelement '' etc . support component factory level component class ( respectively `` render function '' case stateless functional component ) supported currently ? btw : access component factory also access component class/function via `` factory.type '' ( considered `` deprecated '' react team - know , `` factory.type '' seems helpful ) . 's little example : many thanks advance",
        "title_stopwords_removal_lemmatization": "adding support component factory `` createelement '' etc ."
    },
    {
        "issue_id": 266714762,
        "title": "React Test Renderer's Peer dependency keeps getting bumped",
        "label": [
            "Component: Build Infrastructure",
            "Type: Discussion"
        ],
        "date": "2017-10-19T04:08:49Z",
        "status": "closed",
        "description": "I noticed that react-test-renderer's peer dependency for React gets bumped with every version update (or at least that's what happens in version 15.  v16 is still 16.0.0). Is this required? Could the peer dependency for version 16 not stay at ^16.0.0 even after the versions of each package get bumped to say 16.1?\r\n\r\nI ask because this makes it hard for libraries to pull in react-test-renderer so that their end users (who do not use it directly) don't have to pull in a package they never use directly. \r\n\r\nThe specific example I have in mind is enzyme. For version 15, it has a peer dependency on `react@^15.5.0`, and a dependency on `react-test-renderer@^15.5.0`. if I have react 15.5 installed and enzyme tries to install the latest react-test-renderer, then it will pull in 15.6.2, which requires `react@^15.6.2`, which 15.5 does not satisfy.\r\n\r\nUntil recently, they made the test renderer a peer dependency, which was very annoying as a user of the library because you should not have to manually install a package that you don't use directly. We changed that to be a regular dependency, but are now noticing that the peer dependency the test-renderer has on react gets bumped every version change, which causes the above problem.\r\n\r\nIs it not possible to leave the peer dependency within the major version? At least for v16 going forward? Or is there another way a library can pull in the test renderer without forcing the user to do it? ",
        "remove_template_description": "I noticed that react-test-renderer's peer dependency for React gets bumped with every version update (or at least that's what happens in version 15.  v16 is still 16.0.0). Is this required? Could the peer dependency for version 16 not stay at ^16.0.0 even after the versions of each package get bumped to say 16.1?    I ask because this makes it hard for libraries to pull in react-test-renderer so that their end users (who do not use it directly) don't have to pull in a package they never use directly.     The specific example I have in mind is enzyme. For version 15, it has a peer dependency on `react@^15.5.0`, and a dependency on `react-test-renderer@^15.5.0`. if I have react 15.5 installed and enzyme tries to install the latest react-test-renderer, then it will pull in 15.6.2, which requires `react@^15.6.2`, which 15.5 does not satisfy.    Until recently, they made the test renderer a peer dependency, which was very annoying as a user of the library because you should not have to manually install a package that you don't use directly. We changed that to be a regular dependency, but are now noticing that the peer dependency the test-renderer has on react gets bumped every version change, which causes the above problem.    Is it not possible to leave the peer dependency within the major version? At least for v16 going forward? Or is there another way a library can pull in the test renderer without forcing the user to do it?",
        "human_words": "I noticed that react-test-renderer's peer dependency for React gets bumped with every version update (or at least that's what happens in version 15.  v16 is still 16.0.0). Is this required? Could the peer dependency for version 16 not stay at ^16.0.0 even after the versions of each package get bumped to say 16.1?    I ask because this makes it hard for libraries to pull in react-test-renderer so that their end users (who do not use it directly) don't have to pull in a package they never use directly.     The specific example I have in mind is enzyme. For version 15, it has a peer dependency on `react@^15.5.0`, and a dependency on `react-test-renderer@^15.5.0`. if I have react 15.5 installed and enzyme tries to install the latest react-test-renderer, then it will pull in 15.6.2, which requires `react@^15.6.2`, which 15.5 does not satisfy.    Until recently, they made the test renderer a peer dependency, which was very annoying as a user of the library because you should not have to manually install a package that you don't use directly. We changed that to be a regular dependency, but are now noticing that the peer dependency the test-renderer has on react gets bumped every version change, which causes the above problem.    Is it not possible to leave the peer dependency within the major version? At least for v16 going forward? Or is there another way a library can pull in the test renderer without forcing the user to do it?",
        "human_words_regrex": "I noticed that react-test-renderer's peer dependency for React gets bumped with every version update (or at least that's what happens in version 15. v16 is still 16.0.0). Is this required? Could the peer dependency for version 16 not stay at ^16.0.0 even after the versions of each package get bumped to say 16.1? I ask because this makes it hard for libraries to pull in react-test-renderer so that their end users (who do not use it directly) don't have to pull in a package they never use directly. The specific example I have in mind is enzyme. For version 15, it has a peer dependency on `react@^15.5.0`, and a dependency on `react-test-renderer@^15.5.0`. if I have react 15.5 installed and enzyme tries to install the latest react-test-renderer, then it will pull in 15.6.2, which requires `react@^15.6.2`, which 15.5 does not satisfy. Until recently, they made the test renderer a peer dependency, which was very annoying as a user of the library because you should not have to manually install a package that you don't use directly. We changed that to be a regular dependency, but are now noticing that the peer dependency the test-renderer has on react gets bumped every version change, which causes the above problem. Is it not possible to leave the peer dependency within the major version? At least for v16 going forward? Or is there another way a library can pull in the test renderer without forcing the user to do it?",
        "human_words_stopwords_removal_lemmatization": "noticed react-test-renderer 's peer dependency react get bumped every version update ( least 's happens version 15. v16 still 16.0.0 ) . required ? could peer dependency version 16 stay ^16.0.0 even version package get bumped say 16.1 ? ask make hard library pull react-test-renderer end user ( use directly ) n't pull package never use directly . specific example mind enzyme . version 15 , peer dependency ` react @ ^15.5.0 ` , dependency ` react-test-renderer @ ^15.5.0 ` . react 15.5 installed enzyme try install latest react-test-renderer , pull 15.6.2 , requires ` react @ ^15.6.2 ` , 15.5 satisfy . recently , made test renderer peer dependency , annoying user library manually install package n't use directly . changed regular dependency , noticing peer dependency test-renderer react get bumped every version change , cause problem . possible leave peer dependency within major version ? least v16 going forward ? another way library pull test renderer without forcing user ?",
        "title_stopwords_removal_lemmatization": "react test renderer 's peer dependency keep getting bumped"
    },
    {
        "issue_id": 264145756,
        "title": "Should React use requestAnimationFrame by default?",
        "label": [
            "Component: DOM",
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-10-10T08:47:25Z",
        "status": "closed",
        "description": "Consider the following sample code: (pasted [here too](https://gist.github.com/dakom/e68503e59c7a73c3bc926b7e8ae65a07))\r\n\r\n```\r\nclass extends React.Component {\r\n    private canRender: boolean = false;\r\n    private latestData: any;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        let nJobs = 0;\r\n        let lastRenderTime: number;\r\n        props.someObservableThing.listen(data => {\r\n            nJobs++;\r\n\r\n            this.latestData = data;\r\n\r\n            if (this.canRender) {\r\n                const now = performance.now();\r\n                this.canRender = false;\r\n                this.setState({\r\n                    data: this.latestData,\r\n                    jobsPerRender: nJobs,\r\n                    fps: (lastRenderTime === undefined) ? 0 : 1000 / (now - lastRenderTime)\r\n                });\r\n                nJobs = 0;\r\n                lastRenderTime = now;\r\n            }\r\n        });\r\n\r\n        this.state = {};\r\n    }\r\n\r\n    /* Lifecycle */\r\n    componentDidMount() {\r\n        this.canRender = true;\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.canRender = true;\r\n    }\r\n\r\n    render() {\r\n        outputStats(this.state);\r\n        return this.state.data === undefined ? null : <View {...this.state.data} />\r\n    }\r\n}\r\n```\r\n\r\nWhen outputStats is hit - I'm getting framerates of like 2000fps. In other words `requestAnimationFrame` does _not_ seem to be a limiter for react itself.\r\n\r\nIs this correct? \r\n\r\n(as a slightly separate topic- if that is true, for animation things do you think it would be good to simply wrap the `if (this.canRender) {}` block in a `requestAnimationFrame()`? I guess that's not really a React question though since the observableThing could also be capped via ticks...)\r\n",
        "remove_template_description": "Consider the following sample code: (pasted [here too](https://gist.github.com/dakom/e68503e59c7a73c3bc926b7e8ae65a07))    ```  class extends React.Component {      private canRender: boolean = false;      private latestData: any;        constructor(props) {          super(props);            let nJobs = 0;          let lastRenderTime: number;          props.someObservableThing.listen(data => {              nJobs++;                this.latestData = data;                if (this.canRender) {                  const now = performance.now();                  this.canRender = false;                  this.setState({                      data: this.latestData,                      jobsPerRender: nJobs,                      fps: (lastRenderTime === undefined) ? 0 : 1000 / (now - lastRenderTime)                  });                  nJobs = 0;                  lastRenderTime = now;              }          });            this.state = {};      }        /* Lifecycle */      componentDidMount() {          this.canRender = true;      }        componentDidUpdate() {          this.canRender = true;      }        render() {          outputStats(this.state);          return this.state.data === undefined ? null : <View {...this.state.data} />      }  }  ```    When outputStats is hit - I'm getting framerates of like 2000fps. In other words `requestAnimationFrame` does _not_ seem to be a limiter for react itself.    Is this correct?     (as a slightly separate topic- if that is true, for animation things do you think it would be good to simply wrap the `if (this.canRender) {}` block in a `requestAnimationFrame()`? I guess that's not really a React question though since the observableThing could also be capped via ticks...)",
        "human_words": "Consider the following sample code: (pasted [here too](https://gist.github.com/dakom/e68503e59c7a73c3bc926b7e8ae65a07))        When outputStats is hit - I'm getting framerates of like 2000fps. In other words `requestAnimationFrame` does _not_ seem to be a limiter for react itself.    Is this correct?     (as a slightly separate topic- if that is true, for animation things do you think it would be good to simply wrap the `if (this.canRender) {}` block in a `requestAnimationFrame()`? I guess that's not really a React question though since the observableThing could also be capped via ticks...)",
        "human_words_regrex": "Consider the following sample code: (pasted ) When outputStats is hit - I'm getting framerates of like 2000fps. In other words `requestAnimationFrame` does _not_ seem to be a limiter for react itself. Is this correct? (as a slightly separate topic- if that is true, for animation things do you think it would be good to simply wrap the `if (this.canRender) {}` block in a `requestAnimationFrame()`? I guess that's not really a React question though since the observableThing could also be capped via ticks...)",
        "human_words_stopwords_removal_lemmatization": "consider following sample code : ( pasted ) outputstats hit - 'm getting framerates like 2000fps . word ` requestanimationframe ` _not_ seem limiter react . correct ? ( slightly separate topic- true , animation thing think would good simply wrap ` ( this.canrender ) { } ` block ` requestanimationframe ( ) ` ? guess 's really react question though since observablething could also capped via tick ... )",
        "title_stopwords_removal_lemmatization": "react use requestanimationframe default ?"
    },
    {
        "issue_id": 263152967,
        "title": "How to wrap events in React 16",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-10-05T14:46:18Z",
        "status": "closed",
        "description": "Per the discussion from React 16 RC, [I was asked to open a separate issue](https://github.com/facebook/react/issues/10294#issuecomment-319475548) regarding opening up the event system in React. We currently use: \r\n\r\n```javascript\r\nrequire(\"react-dom/lib/EventPluginUtils\").executeDispatchesInOrder\r\n```\r\n\r\nBut this disappeared in React 16, which is blocking our ability to upgrade to it.\r\n\r\nBasically we grab `executeDispatchesInOrder` in order to wrap it so a certain piece of code can fire afterward. I was asked [here](https://github.com/facebook/react/issues/10294#issuecomment-319480224) why we don't just wrap `addEventListener` instead, and at least at the time, I believe my experiments showed that this didn't work because React seemed to firing its internal synthetic events at a later time (possibly batching them? I don't know). If there is a new hacky way to do this same thing, I'm happy to do that and punt on this question.\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nDepends, certainly used to work, so in that sense a bug, but would require API creation perhaps, so maybe a feature?\r\n\r\n**What is the current behavior?**\r\nNo access to event firing.\r\n\r\n**What is the expected behavior?**\r\nSome way to inject code to fire after events fire.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nReact 16, solution existed in React 15 and down.\r\n",
        "remove_template_description": "Per the discussion from React 16 RC, [I was asked to open a separate issue](https://github.com/facebook/react/issues/10294#issuecomment-319475548) regarding opening up the event system in React. We currently use:     ```javascript  require(\"react-dom/lib/EventPluginUtils\").executeDispatchesInOrder  ```    But this disappeared in React 16, which is blocking our ability to upgrade to it.    Basically we grab `executeDispatchesInOrder` in order to wrap it so a certain piece of code can fire afterward. I was asked [here](https://github.com/facebook/react/issues/10294#issuecomment-319480224) why we don't just wrap `addEventListener` instead, and at least at the time, I believe my experiments showed that this didn't work because React seemed to firing its internal synthetic events at a later time (possibly batching them? I don't know). If there is a new hacky way to do this same thing, I'm happy to do that and punt on this question.    **Do you want to request a *feature* or report a *bug*?**  Depends, certainly used to work, so in that sense a bug, but would require API creation perhaps, so maybe a feature?    **What is the current behavior?**  No access to event firing.    **What is the expected behavior?**  Some way to inject code to fire after events fire.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 16, solution existed in React 15 and down.",
        "human_words": "Per the discussion from React 16 RC, [I was asked to open a separate issue](https://github.com/facebook/react/issues/10294#issuecomment-319475548) regarding opening up the event system in React. We currently use:         But this disappeared in React 16, which is blocking our ability to upgrade to it.    Basically we grab `executeDispatchesInOrder` in order to wrap it so a certain piece of code can fire afterward. I was asked [here](https://github.com/facebook/react/issues/10294#issuecomment-319480224) why we don't just wrap `addEventListener` instead, and at least at the time, I believe my experiments showed that this didn't work because React seemed to firing its internal synthetic events at a later time (possibly batching them? I don't know). If there is a new hacky way to do this same thing, I'm happy to do that and punt on this question.    **Do you want to request a *feature* or report a *bug*?**  Depends, certainly used to work, so in that sense a bug, but would require API creation perhaps, so maybe a feature?    **What is the current behavior?**  No access to event firing.    **What is the expected behavior?**  Some way to inject code to fire after events fire.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 16, solution existed in React 15 and down.",
        "human_words_regrex": "Per the discussion from React 16 RC,  regarding opening up the event system in React. We currently use: But this disappeared in React 16, which is blocking our ability to upgrade to it. Basically we grab `executeDispatchesInOrder` in order to wrap it so a certain piece of code can fire afterward. I was asked  why we don't just wrap `addEventListener` instead, and at least at the time, I believe my experiments showed that this didn't work because React seemed to firing its internal synthetic events at a later time (possibly batching them? I don't know). If there is a new hacky way to do this same thing, I'm happy to do that and punt on this question. **Do you want to request a *feature* or report a *bug*?** Depends, certainly used to work, so in that sense a bug, but would require API creation perhaps, so maybe a feature? **What is the current behavior?** No access to event firing. **What is the expected behavior?** Some way to inject code to fire after events fire. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16, solution existed in React 15 and down.",
        "human_words_stopwords_removal_lemmatization": "per discussion react 16 rc , regarding opening event system react . currently use : disappeared react 16 , blocking ability upgrade . basically grab ` executedispatchesinorder ` order wrap certain piece code fire afterward . asked n't wrap ` addeventlistener ` instead , least time , believe experiment showed n't work react seemed firing internal synthetic event later time ( possibly batching ? n't know ) . new hacky way thing , 'm happy punt question . * * want request * feature * report * bug * ? * * depends , certainly used work , sense bug , would require api creation perhaps , maybe feature ? * * current behavior ? * * access event firing . * * expected behavior ? * * way inject code fire event fire . * * version react , browser / o affected issue ? work previous version react ? * * react 16 , solution existed react 15 .",
        "title_stopwords_removal_lemmatization": "wrap event react 16"
    },
    {
        "issue_id": 263133757,
        "title": "Consider providing a UMD build for TestUtils again",
        "label": [
            "Component: Build Infrastructure",
            "Type: Discussion"
        ],
        "date": "2017-10-05T13:53:55Z",
        "status": "closed",
        "description": "I noticed we stopped providing it, but a bunch of fiddles for old bugs use it.\r\nI wonder if we should add it back, e.g. as `react-dom-test-utils.development.js`.\r\n\r\nLet\u2019s hear what people have to say.",
        "remove_template_description": "I noticed we stopped providing it, but a bunch of fiddles for old bugs use it.  I wonder if we should add it back, e.g. as `react-dom-test-utils.development.js`.    Let\u2019s hear what people have to say.",
        "human_words": "I noticed we stopped providing it, but a bunch of fiddles for old bugs use it.  I wonder if we should add it back, e.g. as `react-dom-test-utils.development.js`.    Let\u2019s hear what people have to say.",
        "human_words_regrex": "I noticed we stopped providing it, but a bunch of fiddles for old bugs use it. I wonder if we should add it back, e.g. as `react-dom-test-utils.development.js`. Let\u2019s hear what people have to say.",
        "human_words_stopwords_removal_lemmatization": "noticed stopped providing , bunch fiddle old bug use . wonder add back , e.g . ` react-dom-test-utils.development.js ` . let \u2019 hear people say .",
        "title_stopwords_removal_lemmatization": "consider providing umd build testutils"
    },
    {
        "issue_id": 262588829,
        "title": "Performance enhancements in niche situations",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-10-03T21:14:04Z",
        "status": "open",
        "description": "I hit on a couple things that were a bit surprising to me... not sure what I'm really asking here, other than if these things are documented somewhere. Also kinda just going with the flow where this seems to be the place to raise generic \"issues\" even if they're not bugs :)\r\n\r\n1. keys can make things slower\r\n\r\nI had a bunch of items, and the only thing that changed was their x/y positions. adding a key with index made rendering slower. It's possible this is short-sighted though since it could very well change once that \"layer\" has more items changing above/below it, but I found it interesting.\r\n\r\n2. rendering null makes a _huge_ difference\r\n\r\nI had two test cases - a full graphics pipeline vs. an essentially empty POJO renderer. The difference in speed didn't matter about the data or graphics, but rather about what was returned in the components `render()`. For DOM this doesn't work of course - but for custom renderers, when it's known that a certain type of element will be an edge node - doing the side effects in render() (or some other lifecycle) and then returning `null` is _significantly_ faster than even a straight functional component that returns a simple element (which does the same side effects). This makes sense, since react then has less branches to consider (even if those branches point to nothing other than simple objects).\r\n\r\n\r\n\r\n\r\n",
        "remove_template_description": "I hit on a couple things that were a bit surprising to me... not sure what I'm really asking here, other than if these things are documented somewhere. Also kinda just going with the flow where this seems to be the place to raise generic \"issues\" even if they're not bugs :)    1. keys can make things slower    I had a bunch of items, and the only thing that changed was their x/y positions. adding a key with index made rendering slower. It's possible this is short-sighted though since it could very well change once that \"layer\" has more items changing above/below it, but I found it interesting.    2. rendering null makes a _huge_ difference    I had two test cases - a full graphics pipeline vs. an essentially empty POJO renderer. The difference in speed didn't matter about the data or graphics, but rather about what was returned in the components `render()`. For DOM this doesn't work of course - but for custom renderers, when it's known that a certain type of element will be an edge node - doing the side effects in render() (or some other lifecycle) and then returning `null` is _significantly_ faster than even a straight functional component that returns a simple element (which does the same side effects). This makes sense, since react then has less branches to consider (even if those branches point to nothing other than simple objects).",
        "human_words": "I hit on a couple things that were a bit surprising to me... not sure what I'm really asking here, other than if these things are documented somewhere. Also kinda just going with the flow where this seems to be the place to raise generic \"issues\" even if they're not bugs :)    1. keys can make things slower    I had a bunch of items, and the only thing that changed was their x/y positions. adding a key with index made rendering slower. It's possible this is short-sighted though since it could very well change once that \"layer\" has more items changing above/below it, but I found it interesting.    2. rendering null makes a _huge_ difference    I had two test cases - a full graphics pipeline vs. an essentially empty POJO renderer. The difference in speed didn't matter about the data or graphics, but rather about what was returned in the components `render()`. For DOM this doesn't work of course - but for custom renderers, when it's known that a certain type of element will be an edge node - doing the side effects in render() (or some other lifecycle) and then returning `null` is _significantly_ faster than even a straight functional component that returns a simple element (which does the same side effects). This makes sense, since react then has less branches to consider (even if those branches point to nothing other than simple objects).",
        "human_words_regrex": "I hit on a couple things that were a bit surprising to me... not sure what I'm really asking here, other than if these things are documented somewhere. Also kinda just going with the flow where this seems to be the place to raise generic \"issues\" even if they're not bugs :) 1. keys can make things slower I had a bunch of items, and the only thing that changed was their x/y positions. adding a key with index made rendering slower. It's possible this is short-sighted though since it could very well change once that \"layer\" has more items changing above/below it, but I found it interesting. 2. rendering null makes a _huge_ difference I had two test cases - a full graphics pipeline vs. an essentially empty POJO renderer. The difference in speed didn't matter about the data or graphics, but rather about what was returned in the components `render()`. For DOM this doesn't work of course - but for custom renderers, when it's known that a certain type of element will be an edge node - doing the side effects in render() (or some other lifecycle) and then returning `null` is _significantly_ faster than even a straight functional component that returns a simple element (which does the same side effects). This makes sense, since react then has less branches to consider (even if those branches point to nothing other than simple objects).",
        "human_words_stopwords_removal_lemmatization": "hit couple thing bit surprising ... sure 'm really asking , thing documented somewhere . also kinda going flow seems place raise generic `` issue '' even 're bug : ) 1. key make thing slower bunch item , thing changed x/y position . adding key index made rendering slower . 's possible short-sighted though since could well change `` layer '' item changing above/below , found interesting . 2. rendering null make _huge_ difference two test case - full graphic pipeline vs. essentially empty pojo renderer . difference speed n't matter data graphic , rather returned component ` render ( ) ` . dom n't work course - custom renderers , 's known certain type element edge node - side effect render ( ) ( lifecycle ) returning ` null ` _significantly_ faster even straight functional component return simple element ( side effect ) . make sense , since react le branch consider ( even branch point nothing simple object ) .",
        "title_stopwords_removal_lemmatization": "performance enhancement niche situation"
    },
    {
        "issue_id": 260778735,
        "title": "Use of ReactOS logo and project name",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-09-26T21:39:09Z",
        "status": "closed",
        "description": "This project seems to have subsumed almost the same name and logo of the ReactOS project. \r\n\r\nThat seems rather disengenuous.\r\n\r\nThe ReactOS logo is very close the spinning atom logo with a globe in the middle and so is yours. The project name is ReactOS and your is ReactJS. This seems at best confusing and at worst it looks as if your project is treading on the coat-tails of ReactOS.\r\n\r\nEDIT: name correction",
        "remove_template_description": "This project seems to have subsumed almost the same name and logo of the ReactOS project.     That seems rather disengenuous.    The ReactOS logo is very close the spinning atom logo with a globe in the middle and so is yours. The project name is ReactOS and your is ReactJS. This seems at best confusing and at worst it looks as if your project is treading on the coat-tails of ReactOS.    EDIT: name correction",
        "human_words": "This project seems to have subsumed almost the same name and logo of the ReactOS project.     That seems rather disengenuous.    The ReactOS logo is very close the spinning atom logo with a globe in the middle and so is yours. The project name is ReactOS and your is ReactJS. This seems at best confusing and at worst it looks as if your project is treading on the coat-tails of ReactOS.    EDIT: name correction",
        "human_words_regrex": "This project seems to have subsumed almost the same name and logo of the ReactOS project. That seems rather disengenuous. The ReactOS logo is very close the spinning atom logo with a globe in the middle and so is yours. The project name is ReactOS and your is ReactJS. This seems at best confusing and at worst it looks as if your project is treading on the coat-tails of ReactOS. EDIT: name correction",
        "human_words_stopwords_removal_lemmatization": "project seems subsumed almost name logo reactos project . seems rather disengenuous . reactos logo close spinning atom logo globe middle . project name reactos reactjs . seems best confusing worst look project treading coat-tails reactos . edit : name correction",
        "title_stopwords_removal_lemmatization": "use reactos logo project name"
    },
    {
        "issue_id": 260471845,
        "title": "Can not prevent portal unmounting when using ReactDOM.createPortal",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-09-26T02:31:21Z",
        "status": "closed",
        "description": "Previous comment https://github.com/facebook/react/issues/10143#issuecomment-331852434 \r\n\r\nWhen we use `unstable_renderIntoContainer` implements portal, we can control when the portal unmount, this seems impossible when use `createPortal`, because when parent component unmount, portal will be unmount by React itself.",
        "remove_template_description": "Previous comment https://github.com/facebook/react/issues/10143#issuecomment-331852434     When we use `unstable_renderIntoContainer` implements portal, we can control when the portal unmount, this seems impossible when use `createPortal`, because when parent component unmount, portal will be unmount by React itself.",
        "human_words": "Previous comment https://github.com/facebook/react/issues/10143#issuecomment-331852434     When we use `unstable_renderIntoContainer` implements portal, we can control when the portal unmount, this seems impossible when use `createPortal`, because when parent component unmount, portal will be unmount by React itself.",
        "human_words_regrex": "Previous comment  When we use `unstable_renderIntoContainer` implements portal, we can control when the portal unmount, this seems impossible when use `createPortal`, because when parent component unmount, portal will be unmount by React itself.",
        "human_words_stopwords_removal_lemmatization": "previous comment use ` unstable_renderintocontainer ` implement portal , control portal unmount , seems impossible use ` createportal ` , parent component unmount , portal unmount react .",
        "title_stopwords_removal_lemmatization": "prevent portal unmounting using reactdom.createportal"
    },
    {
        "issue_id": 259627491,
        "title": "In WebDriver, input gets partial value on IE11 after upgrading react-dom from to 15.6.1",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-09-21T20:47:47Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n**What is the current behavior?**\r\nWe use webdriverIO + saucelabs to run our tests and found our automation cases consistently failed on IE11 while inputing strings to textbox after upgrade react-dom from 15.5.4 to 15.6.1.\r\nThe input value will be set partially, such as, try to input \"-7d\" it will only input \"-7\", some times, it will be '-d'.\r\n\r\nIn javascript webdriverIO code:\r\nbrowser.setValue(textboxSelector, '-7d');\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**\r\nNot sure if you could see this video or not:\r\nhttps://saucelabs.com/beta/tests/bda474ef398949f6ae5dabb4a15fb1a3/watch#27\r\n\r\n**What is the expected behavior?**\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nhappens to React-dom 15.6.1 with IE11\r\nworks on React-dom 15.5.4",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  bug  **What is the current behavior?**  We use webdriverIO + saucelabs to run our tests and found our automation cases consistently failed on IE11 while inputing strings to textbox after upgrade react-dom from 15.5.4 to 15.6.1.  The input value will be set partially, such as, try to input \"-7d\" it will only input \"-7\", some times, it will be '-d'.    In javascript webdriverIO code:  browser.setValue(textboxSelector, '-7d');    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**  Not sure if you could see this video or not:  https://saucelabs.com/beta/tests/bda474ef398949f6ae5dabb4a15fb1a3/watch#27    **What is the expected behavior?**    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  happens to React-dom 15.6.1 with IE11  works on React-dom 15.5.4",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  bug  **What is the current behavior?**  We use webdriverIO + saucelabs to run our tests and found our automation cases consistently failed on IE11 while inputing strings to textbox after upgrade react-dom from 15.5.4 to 15.6.1.  The input value will be set partially, such as, try to input \"-7d\" it will only input \"-7\", some times, it will be '-d'.    In javascript webdriverIO code:  browser.setValue(textboxSelector, '-7d');    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**  Not sure if you could see this video or not:  https://saucelabs.com/beta/tests/bda474ef398949f6ae5dabb4a15fb1a3/watch#27    **What is the expected behavior?**    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  happens to React-dom 15.6.1 with IE11  works on React-dom 15.5.4",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** bug **What is the current behavior?** We use webdriverIO + saucelabs to run our tests and found our automation cases consistently failed on IE11 while inputing strings to textbox after upgrade react-dom from 15.5.4 to 15.6.1. The input value will be set partially, such as, try to input \"-7d\" it will only input \"-7\", some times, it will be '-d'. In javascript webdriverIO code: browser.setValue(textboxSelector, '-7d'); **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template:  Not sure if you could see this video or not:  **What is the expected behavior?** **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** happens to React-dom 15.6.1 with IE11 works on React-dom 15.5.4",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * use webdriverio + saucelabs run test found automation case consistently failed ie11 inputing string textbox upgrade react-dom 15.5.4 15.6.1. input value set partially , , try input `` -7d '' input `` -7 '' , time , '-d ' . javascript webdriverio code : browser.setvalue ( textboxselector , '-7d ' ) ; * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template : sure could see video : * * expected behavior ? * * * * version react , browser / o affected issue ? work previous version react ? * * happens react-dom 15.6.1 ie11 work react-dom 15.5.4",
        "title_stopwords_removal_lemmatization": "webdriver , input get partial value ie11 upgrading react-dom 15.6.1"
    },
    {
        "issue_id": 257866486,
        "title": "What should portals do when container has a child managed by React?",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-09-14T21:46:38Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n`ReactDOM.unstable_createPortal(<Component/>, target)` appends the rendered component in the target instead of replacing the contents of the target\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**\r\n\r\nhttps://codesandbox.io/s/pjx8x9z2o7\r\n\r\n**What is the expected behavior?**\r\n\r\nIt should replace the contents of the target with the new rendered component\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nreact@16.0.0-rc.3\r\nreact-dom@16.0.0-rc.3\r\n\r\n\r\nNote: I might have completely misunderstood how portals work. @gaearon [encouraged me](https://twitter.com/dan_abramov/status/908443416173924352) to open this issue \ud83d\ude04 ",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  `ReactDOM.unstable_createPortal(<Component/>, target)` appends the rendered component in the target instead of replacing the contents of the target    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**    https://codesandbox.io/s/pjx8x9z2o7    **What is the expected behavior?**    It should replace the contents of the target with the new rendered component    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react@16.0.0-rc.3  react-dom@16.0.0-rc.3      Note: I might have completely misunderstood how portals work. @gaearon [encouraged me](https://twitter.com/dan_abramov/status/908443416173924352) to open this issue \ud83d\ude04",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  `ReactDOM.unstable_createPortal(<Component/>, target)` appends the rendered component in the target instead of replacing the contents of the target    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**    https://codesandbox.io/s/pjx8x9z2o7    **What is the expected behavior?**    It should replace the contents of the target with the new rendered component    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    react@16.0.0-rc.3  react-dom@16.0.0-rc.3      Note: I might have completely misunderstood how portals work. @gaearon [encouraged me](https://twitter.com/dan_abramov/status/908443416173924352) to open this issue \ud83d\ude04",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** `ReactDOM.unstable_createPortal(, target)` appends the rendered component in the target instead of replacing the contents of the target **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template:   **What is the expected behavior?** It should replace the contents of the target with the new rendered component **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** react@16.0.0-rc.3 react-dom@16.0.0-rc.3 Note: I might have completely misunderstood how portals work. @gaearon  to open this issue \ud83d\ude04",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * ` reactdom.unstable_createportal ( , target ) ` appends rendered component target instead replacing content target * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template : * * expected behavior ? * * replace content target new rendered component * * version react , browser / o affected issue ? work previous version react ? * * react @ 16.0.0-rc.3 react-dom @ 16.0.0-rc.3 note : might completely misunderstood portal work . @ gaearon open issue \ud83d\ude04",
        "title_stopwords_removal_lemmatization": "portal container child managed react ?"
    },
    {
        "issue_id": 257551625,
        "title": "A faster diff algorithm",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-09-13T23:33:37Z",
        "status": "open",
        "description": "This is an invitation to discussion...\r\n\r\nSo, react is pretty freaking awesome and I used it quite a bit. One thing unfortunately where react is not as strong is in performance, which gave roots to Inferno and Preact. Although, this is generally a non-issue on desktop, while mobile might be a bottleneck.\r\n\r\nI know many members of the team have been working on improving bundle size (I believe through rollup support in a talk I heard), asynchronous scheduling, etc. I am also aware that @trueadm (the creator of inferno) joined the React team and is working on improving it.\r\n\r\nThe point I want to bring up is this library [petit-dom](https://github.com/yelouafi/petit-dom). It uses, is a diff algorithm (links that explain it provided in the README) and it seems to score incredibly on [vdom performance tests](https://github.com/krausest/js-framework-benchmark). In fact, it is only beat by 2 technologies, vanillajs and surplusjs [per the benchmark snapshot](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html).\r\n\r\npetit-dom beats inferno, preact, mithril, vue, angular, etc. Of course, it is not a proper js framework, however the point I am trying to make is that it is far faster and a major difference between the other frameworks seems to be its diff algorithm.\r\n\r\nI realize this would mean a rewrite of a good portion of react-dom, which is why it is simply a discussion :D.\r\n\r\nIf this is unfeasible, or simply going after the wrong target/bottleneck, let me know as it is after all a discussion.",
        "remove_template_description": "This is an invitation to discussion...    So, react is pretty freaking awesome and I used it quite a bit. One thing unfortunately where react is not as strong is in performance, which gave roots to Inferno and Preact. Although, this is generally a non-issue on desktop, while mobile might be a bottleneck.    I know many members of the team have been working on improving bundle size (I believe through rollup support in a talk I heard), asynchronous scheduling, etc. I am also aware that @trueadm (the creator of inferno) joined the React team and is working on improving it.    The point I want to bring up is this library [petit-dom](https://github.com/yelouafi/petit-dom). It uses, is a diff algorithm (links that explain it provided in the README) and it seems to score incredibly on [vdom performance tests](https://github.com/krausest/js-framework-benchmark). In fact, it is only beat by 2 technologies, vanillajs and surplusjs [per the benchmark snapshot](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html).    petit-dom beats inferno, preact, mithril, vue, angular, etc. Of course, it is not a proper js framework, however the point I am trying to make is that it is far faster and a major difference between the other frameworks seems to be its diff algorithm.    I realize this would mean a rewrite of a good portion of react-dom, which is why it is simply a discussion :D.    If this is unfeasible, or simply going after the wrong target/bottleneck, let me know as it is after all a discussion.",
        "human_words": "This is an invitation to discussion...    So, react is pretty freaking awesome and I used it quite a bit. One thing unfortunately where react is not as strong is in performance, which gave roots to Inferno and Preact. Although, this is generally a non-issue on desktop, while mobile might be a bottleneck.    I know many members of the team have been working on improving bundle size (I believe through rollup support in a talk I heard), asynchronous scheduling, etc. I am also aware that @trueadm (the creator of inferno) joined the React team and is working on improving it.    The point I want to bring up is this library [petit-dom](https://github.com/yelouafi/petit-dom). It uses, is a diff algorithm (links that explain it provided in the README) and it seems to score incredibly on [vdom performance tests](https://github.com/krausest/js-framework-benchmark). In fact, it is only beat by 2 technologies, vanillajs and surplusjs [per the benchmark snapshot](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html).    petit-dom beats inferno, preact, mithril, vue, angular, etc. Of course, it is not a proper js framework, however the point I am trying to make is that it is far faster and a major difference between the other frameworks seems to be its diff algorithm.    I realize this would mean a rewrite of a good portion of react-dom, which is why it is simply a discussion :D.    If this is unfeasible, or simply going after the wrong target/bottleneck, let me know as it is after all a discussion.",
        "human_words_regrex": "This is an invitation to discussion... So, react is pretty freaking awesome and I used it quite a bit. One thing unfortunately where react is not as strong is in performance, which gave roots to Inferno and Preact. Although, this is generally a non-issue on desktop, while mobile might be a bottleneck. I know many members of the team have been working on improving bundle size (I believe through rollup support in a talk I heard), asynchronous scheduling, etc. I am also aware that @trueadm (the creator of inferno) joined the React team and is working on improving it. The point I want to bring up is this library . It uses, is a diff algorithm (links that explain it provided in the README) and it seems to score incredibly on . In fact, it is only beat by 2 technologies, vanillajs and surplusjs . petit-dom beats inferno, preact, mithril, vue, angular, etc. Of course, it is not a proper js framework, however the point I am trying to make is that it is far faster and a major difference between the other frameworks seems to be its diff algorithm. I realize this would mean a rewrite of a good portion of react-dom, which is why it is simply a discussion :D. If this is unfeasible, or simply going after the wrong target/bottleneck, let me know as it is after all a discussion.",
        "human_words_stopwords_removal_lemmatization": "invitation discussion ... , react pretty freaking awesome used quite bit . one thing unfortunately react strong performance , gave root inferno preact . although , generally non-issue desktop , mobile might bottleneck . know many member team working improving bundle size ( believe rollup support talk heard ) , asynchronous scheduling , etc . also aware @ trueadm ( creator inferno ) joined react team working improving . point want bring library . us , diff algorithm ( link explain provided readme ) seems score incredibly . fact , beat 2 technology , vanillajs surplusjs . petit-dom beat inferno , preact , mithril , vue , angular , etc . course , proper j framework , however point trying make far faster major difference framework seems diff algorithm . realize would mean rewrite good portion react-dom , simply discussion : d. unfeasible , simply going wrong target/bottleneck , let know discussion .",
        "title_stopwords_removal_lemmatization": "faster diff algorithm"
    },
    {
        "issue_id": 254609905,
        "title": "Document that you can't rely on React 16 SSR patching up differences",
        "label": [
            "Type: Discussion"
        ],
        "date": "2017-09-01T11:12:06Z",
        "status": "closed",
        "description": "With SSR being loaded on client side, there are various wrong behaviors if the server's HTML differs from the client's HTML.\r\n\r\nFor a minimal example, I created [this repository](https://github.com/Tarnadas/react16-ssr-bug).\r\nHere is a code snippet:\r\n```js\r\nclass AppView extends React.Component {\r\n  render () {\r\n    const isServer = this.props.isServer\r\n    const styles = {\r\n      server: {\r\n        backgroundColor: 'red'\r\n      },\r\n      client: {\r\n        backgroundColor: 'green'\r\n      }\r\n    }\r\n    return (\r\n      <div>\r\n        {\r\n          isServer ?\r\n            <div style={styles.server}>isServer</div> :\r\n            <div style={styles.client}>isClient</div>\r\n        }\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\nIn the example I render a CSS background color of red for the server and green for the client. I force a difference by the server's and client's HTML with the `isServer` property.\r\n\r\nWith React 15, everything works as expected: the server renders a red background, but the client corrects it to green. With React 16 however the background stays the same, but the text changes as expected.\r\n\r\nThere are probably other similar behaviors. For example I found out about this bug, because I was conditionally rendering a complete component like so:\r\n\r\n```js\r\nreturn someCondition && <MyComponent />\r\n```\r\n\r\nIt becomes even more weird, because if there is additional JSX after that conditional rendering, it would render that additional JSX as if it is inside that `MyComponent`\r\n```js\r\nreturn (\r\n  <div>\r\n    { someCondition && <MyComponent /> }\r\n    <SomeOtherComponent />\r\n  </div>\r\n)\r\n```\r\nbecomes\r\n```js\r\nreturn (\r\n  <div>\r\n    <MyComponent>\r\n      <SomeOtherComponent />\r\n    </MyComponent>\r\n  </div>\r\n)\r\n```\r\nif `someCondition === true` on server side and `someCondition === false` on client side.\r\n\r\nYou can see this behavior on my website: http://smmdb.ddns.net/courses\r\nOpen Chrome Dev Tools and lower the width until you get the mobile view, then reload the page and see how the list is wrapped inside another Component.",
        "remove_template_description": "With SSR being loaded on client side, there are various wrong behaviors if the server's HTML differs from the client's HTML.    For a minimal example, I created [this repository](https://github.com/Tarnadas/react16-ssr-bug).  Here is a code snippet:  ```js  class AppView extends React.Component {    render () {      const isServer = this.props.isServer      const styles = {        server: {          backgroundColor: 'red'        },        client: {          backgroundColor: 'green'        }      }      return (        <div>          {            isServer ?              <div style={styles.server}>isServer</div> :              <div style={styles.client}>isClient</div>          }        </div>      )    }  }  ```    In the example I render a CSS background color of red for the server and green for the client. I force a difference by the server's and client's HTML with the `isServer` property.    With React 15, everything works as expected: the server renders a red background, but the client corrects it to green. With React 16 however the background stays the same, but the text changes as expected.    There are probably other similar behaviors. For example I found out about this bug, because I was conditionally rendering a complete component like so:    ```js  return someCondition && <MyComponent />  ```    It becomes even more weird, because if there is additional JSX after that conditional rendering, it would render that additional JSX as if it is inside that `MyComponent`  ```js  return (    <div>      { someCondition && <MyComponent /> }      <SomeOtherComponent />    </div>  )  ```  becomes  ```js  return (    <div>      <MyComponent>        <SomeOtherComponent />      </MyComponent>    </div>  )  ```  if `someCondition === true` on server side and `someCondition === false` on client side.    You can see this behavior on my website: http://smmdb.ddns.net/courses  Open Chrome Dev Tools and lower the width until you get the mobile view, then reload the page and see how the list is wrapped inside another Component.",
        "human_words": "With SSR being loaded on client side, there are various wrong behaviors if the server's HTML differs from the client's HTML.    For a minimal example, I created [this repository](https://github.com/Tarnadas/react16-ssr-bug).  Here is a code snippet:      In the example I render a CSS background color of red for the server and green for the client. I force a difference by the server's and client's HTML with the `isServer` property.    With React 15, everything works as expected: the server renders a red background, but the client corrects it to green. With React 16 however the background stays the same, but the text changes as expected.    There are probably other similar behaviors. For example I found out about this bug, because I was conditionally rendering a complete component like so:        It becomes even more weird, because if there is additional JSX after that conditional rendering, it would render that additional JSX as if it is inside that `MyComponent`    becomes    if `someCondition === true` on server side and `someCondition === false` on client side.    You can see this behavior on my website: http://smmdb.ddns.net/courses  Open Chrome Dev Tools and lower the width until you get the mobile view, then reload the page and see how the list is wrapped inside another Component.",
        "human_words_regrex": "With SSR being loaded on client side, there are various wrong behaviors if the server's HTML differs from the client's HTML. For a minimal example, I created . Here is a code snippet: In the example I render a CSS background color of red for the server and green for the client. I force a difference by the server's and client's HTML with the `isServer` property. With React 15, everything works as expected: the server renders a red background, but the client corrects it to green. With React 16 however the background stays the same, but the text changes as expected. There are probably other similar behaviors. For example I found out about this bug, because I was conditionally rendering a complete component like so: It becomes even more weird, because if there is additional JSX after that conditional rendering, it would render that additional JSX as if it is inside that `MyComponent` becomes if `someCondition === true` on server side and `someCondition === false` on client side. You can see this behavior on my website:  Open Chrome Dev Tools and lower the width until you get the mobile view, then reload the page and see how the list is wrapped inside another Component.",
        "human_words_stopwords_removal_lemmatization": "ssr loaded client side , various wrong behavior server 's html differs client 's html . minimal example , created . code snippet : example render cs background color red server green client . force difference server 's client 's html ` isserver ` property . react 15 , everything work expected : server render red background , client corrects green . react 16 however background stay , text change expected . probably similar behavior . example found bug , conditionally rendering complete component like : becomes even weird , additional jsx conditional rendering , would render additional jsx inside ` mycomponent ` becomes ` somecondition === true ` server side ` somecondition === false ` client side . see behavior website : open chrome dev tool lower width get mobile view , reload page see list wrapped inside another component .",
        "title_stopwords_removal_lemmatization": "document ca n't rely react 16 ssr patching difference"
    },
    {
        "issue_id": 251810580,
        "title": "Symbol Tagging for dangerouslySetInnerHTML to Help Prevent XSS",
        "label": [
            "Component: DOM",
            "Type: Discussion",
            "React Core Team"
        ],
        "date": "2017-08-22T01:13:23Z",
        "status": "open",
        "description": "If you're spreading props from a user provided source we have a XSS. E.g.\r\n\r\n```js\r\nvar data = JSON.parse(decodeURI(location.search.substr(1)));\r\n\r\nfunction Foo(props) {\r\n  return <div><div {...props} /><span>{props.content}</span></div>;\r\n}\r\n\r\nReactDOM.render(<Foo {...data} />, container);\r\n```\r\n\r\nThat's already true today because this URL is now an XSS hole:\r\n```\r\n?{\"content\":\"Hello\",\"dangerouslySetInnerHTML\":{\"__html\":\"<a%20onclick=\\\"alert(%27p0wned%27)\\\">Click%20me</a>\"}}\r\n```\r\n\r\nThis is very uncommon. There are many different ways to screw up getting user data. However doing that + also spreading is unusual. We decided in #3473 that React should add an extra layer of protection for these types of mistakes. This one is __much__ more uncommon than the one in #3473 though.\r\n\r\nYou should already have a pretty centralized way of sanitizing these objects so it seems to me that adding a Symbol to this object shouldn't be that big of a deal though.\r\n\r\nEither:\r\n\r\n```js\r\n{ $$typeof:Symbol.for('react.rawhtml'), __html: myHTML }\r\n```\r\nor:\r\n```js\r\n{ [Symbol.for('react.rawhtml')]: myHTML }\r\n```",
        "remove_template_description": "If you're spreading props from a user provided source we have a XSS. E.g.    ```js  var data = JSON.parse(decodeURI(location.search.substr(1)));    function Foo(props) {    return <div><div {...props} /><span>{props.content}</span></div>;  }    ReactDOM.render(<Foo {...data} />, container);  ```    That's already true today because this URL is now an XSS hole:  ```  ?{\"content\":\"Hello\",\"dangerouslySetInnerHTML\":{\"__html\":\"<a%20onclick=\\\"alert(%27p0wned%27)\\\">Click%20me</a>\"}}  ```    This is very uncommon. There are many different ways to screw up getting user data. However doing that + also spreading is unusual. We decided in #3473 that React should add an extra layer of protection for these types of mistakes. This one is __much__ more uncommon than the one in #3473 though.    You should already have a pretty centralized way of sanitizing these objects so it seems to me that adding a Symbol to this object shouldn't be that big of a deal though.    Either:    ```js  { $$typeof:Symbol.for('react.rawhtml'), __html: myHTML }  ```  or:  ```js  { [Symbol.for('react.rawhtml')]: myHTML }  ```",
        "human_words": "If you're spreading props from a user provided source we have a XSS. E.g.        That's already true today because this URL is now an XSS hole:      This is very uncommon. There are many different ways to screw up getting user data. However doing that + also spreading is unusual. We decided in #3473 that React should add an extra layer of protection for these types of mistakes. This one is __much__ more uncommon than the one in #3473 though.    You should already have a pretty centralized way of sanitizing these objects so it seems to me that adding a Symbol to this object shouldn't be that big of a deal though.    Either:      or:  ",
        "human_words_regrex": "If you're spreading props from a user provided source we have a XSS. E.g. That's already true today because this URL is now an XSS hole: This is very uncommon. There are many different ways to screw up getting user data. However doing that + also spreading is unusual. We decided in #3473 that React should add an extra layer of protection for these types of mistakes. This one is __much__ more uncommon than the one in #3473 though. You should already have a pretty centralized way of sanitizing these objects so it seems to me that adding a Symbol to this object shouldn't be that big of a deal though. Either: or: ",
        "human_words_stopwords_removal_lemmatization": "'re spreading prop user provided source x . e.g . 's already true today url x hole : uncommon . many different way screw getting user data . however + also spreading unusual . decided # 3473 react add extra layer protection type mistake . one __much__ uncommon one # 3473 though . already pretty centralized way sanitizing object seems adding symbol object n't big deal though . either : :",
        "title_stopwords_removal_lemmatization": "symbol tagging dangerouslysetinnerhtml help prevent x"
    },
    {
        "issue_id": 250734072,
        "title": "The fake event trick for rethrowing errors in DEV fires unexpected global error handlers and makes testing harder",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-08-16T19:28:44Z",
        "status": "open",
        "description": "I'm trying to make use of componentDidCatch in the React 16 beta. I already had a global window error handler which was working fine, but it unexpectedly catches errors that I would expect componentDidCatch to have handled. That is, component-local errors are being treated as window-global errors in dev builds.\r\n\r\nThe problem seems to stem from `invokeGuardedCallbackDev` in `ReactErrorUtils.js`. I think that this entire `__DEV__` block of code is problematic. The stated rational is:\r\n\r\n```\r\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\r\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\r\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\r\n  // functions in invokeGuardedCallback, and the production version of\r\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\r\n  // like caught exceptions, and the DevTools won't pause unless the developer\r\n  // takes the extra step of enabling pause on caught exceptions. This is\r\n  // untintuitive, though, because even though React has caught the error, from\r\n  // the developer's perspective, the error is uncaught.\r\n```\r\n\r\nThis is misguided because it's not about pausing on exceptions, it's about \"pause on _uncaught_ exceptions.\" However, `componentDidCatch` makes exceptions _caught_!\r\n\r\nRather than switching on prod vs dev and using try/catch in prod and window's error handler in dev, React should always use try/catch, but rethrow if you reach the root without hitting a componentDidCatch handler. This would preserve the correct \"pause on uncaught exceptions\" behavior without messing with global error handlers.",
        "remove_template_description": "I'm trying to make use of componentDidCatch in the React 16 beta. I already had a global window error handler which was working fine, but it unexpectedly catches errors that I would expect componentDidCatch to have handled. That is, component-local errors are being treated as window-global errors in dev builds.    The problem seems to stem from `invokeGuardedCallbackDev` in `ReactErrorUtils.js`. I think that this entire `__DEV__` block of code is problematic. The stated rational is:    ```    // In DEV mode, we swap out invokeGuardedCallback for a special version    // that plays more nicely with the browser's DevTools. The idea is to preserve    // \"Pause on exceptions\" behavior. Because React wraps all user-provided    // functions in invokeGuardedCallback, and the production version of    // invokeGuardedCallback uses a try-catch, all user exceptions are treated    // like caught exceptions, and the DevTools won't pause unless the developer    // takes the extra step of enabling pause on caught exceptions. This is    // untintuitive, though, because even though React has caught the error, from    // the developer's perspective, the error is uncaught.  ```    This is misguided because it's not about pausing on exceptions, it's about \"pause on _uncaught_ exceptions.\" However, `componentDidCatch` makes exceptions _caught_!    Rather than switching on prod vs dev and using try/catch in prod and window's error handler in dev, React should always use try/catch, but rethrow if you reach the root without hitting a componentDidCatch handler. This would preserve the correct \"pause on uncaught exceptions\" behavior without messing with global error handlers.",
        "human_words": "I'm trying to make use of componentDidCatch in the React 16 beta. I already had a global window error handler which was working fine, but it unexpectedly catches errors that I would expect componentDidCatch to have handled. That is, component-local errors are being treated as window-global errors in dev builds.    The problem seems to stem from `invokeGuardedCallbackDev` in `ReactErrorUtils.js`. I think that this entire `__DEV__` block of code is problematic. The stated rational is:        This is misguided because it's not about pausing on exceptions, it's about \"pause on _uncaught_ exceptions.\" However, `componentDidCatch` makes exceptions _caught_!    Rather than switching on prod vs dev and using try/catch in prod and window's error handler in dev, React should always use try/catch, but rethrow if you reach the root without hitting a componentDidCatch handler. This would preserve the correct \"pause on uncaught exceptions\" behavior without messing with global error handlers.",
        "human_words_regrex": "I'm trying to make use of componentDidCatch in the React 16 beta. I already had a global window error handler which was working fine, but it unexpectedly catches errors that I would expect componentDidCatch to have handled. That is, component-local errors are being treated as window-global errors in dev builds. The problem seems to stem from `invokeGuardedCallbackDev` in `ReactErrorUtils.js`. I think that this entire `__DEV__` block of code is problematic. The stated rational is: This is misguided because it's not about pausing on exceptions, it's about \"pause on _uncaught_ exceptions.\" However, `componentDidCatch` makes exceptions _caught_! Rather than switching on prod vs dev and using try/catch in prod and window's error handler in dev, React should always use try/catch, but rethrow if you reach the root without hitting a componentDidCatch handler. This would preserve the correct \"pause on uncaught exceptions\" behavior without messing with global error handlers.",
        "human_words_stopwords_removal_lemmatization": "'m trying make use componentdidcatch react 16 beta . already global window error handler working fine , unexpectedly catch error would expect componentdidcatch handled . , component-local error treated window-global error dev build . problem seems stem ` invokeguardedcallbackdev ` ` reacterrorutils.js ` . think entire ` __dev__ ` block code problematic . stated rational : misguided 's pausing exception , 's `` pause _uncaught_ exception . '' however , ` componentdidcatch ` make exception _caught_ ! rather switching prod v dev using try/catch prod window 's error handler dev , react always use try/catch , rethrow reach root without hitting componentdidcatch handler . would preserve correct `` pause uncaught exception '' behavior without messing global error handler .",
        "title_stopwords_removal_lemmatization": "fake event trick rethrowing error dev fire unexpected global error handler make testing harder"
    },
    {
        "issue_id": 248955534,
        "title": "Events not registered inside shadow dom",
        "label": [
            "Component: DOM",
            "HTML",
            "Type: Discussion"
        ],
        "date": "2017-08-09T08:31:07Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen you render a react component inside a shadow DOM, events will not be dispatched in react. I.e. you do something like this:\r\n\r\n```javascript\r\n<div onClick={() => alert('I have been clicked')}>foo bar</div>\r\n```\r\n\r\nbut nothing happens. Someone investigated this already, got to the bottom of it and wrote a work around: https://stackoverflow.com/questions/37866237/click-event-not-firing-when-react-component-in-a-shadow-dom\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**\r\n\r\nFollowing the official docs (https://facebook.github.io/react/docs/web-components.html ):\r\n\r\nhttps://jsfiddle.net/84v837e9/187/\r\n\r\n**What is the expected behavior?**\r\n\r\nEvents should be dispatched even when the react app is rendered in a shadow dom\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nAll browsers, tested with react 15.\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  When you render a react component inside a shadow DOM, events will not be dispatched in react. I.e. you do something like this:    ```javascript  <div onClick={() => alert('I have been clicked')}>foo bar</div>  ```    but nothing happens. Someone investigated this already, got to the bottom of it and wrote a work around: https://stackoverflow.com/questions/37866237/click-event-not-firing-when-react-component-in-a-shadow-dom    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    Following the official docs (https://facebook.github.io/react/docs/web-components.html ):    https://jsfiddle.net/84v837e9/187/    **What is the expected behavior?**    Events should be dispatched even when the react app is rendered in a shadow dom    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All browsers, tested with react 15.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  When you render a react component inside a shadow DOM, events will not be dispatched in react. I.e. you do something like this:        but nothing happens. Someone investigated this already, got to the bottom of it and wrote a work around: https://stackoverflow.com/questions/37866237/click-event-not-firing-when-react-component-in-a-shadow-dom    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**    Following the official docs (https://facebook.github.io/react/docs/web-components.html ):    https://jsfiddle.net/84v837e9/187/    **What is the expected behavior?**    Events should be dispatched even when the react app is rendered in a shadow dom    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    All browsers, tested with react 15.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** When you render a react component inside a shadow DOM, events will not be dispatched in react. I.e. you do something like this: but nothing happens. Someone investigated this already, got to the bottom of it and wrote a work around:  **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.** Following the official docs ( ):  **What is the expected behavior?** Events should be dispatched even when the react app is rendered in a shadow dom **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** All browsers, tested with react 15.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * render react component inside shadow dom , event dispatched react . i.e . something like : nothing happens . someone investigated already , got bottom wrote work around : * * current behavior bug , please provide step reproduce possible minimal demo problem . * * following official doc ( ) : * * expected behavior ? * * event dispatched even react app rendered shadow dom * * version react , browser / o affected issue ? work previous version react ? * * browser , tested react 15 .",
        "title_stopwords_removal_lemmatization": "event registered inside shadow dom"
    },
    {
        "issue_id": 248137551,
        "title": "react-test-renderer and shallow API mismatch",
        "label": [
            "Component: Shallow Renderer",
            "Type: Discussion",
            "Component: Test Renderer"
        ],
        "date": "2017-08-04T23:13:20Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nFeature\r\n\r\nCurrently, `react-test-renderer` and `react-test-renderer/shallow` have different APIs. Is there a reason for this? It would be helpful switching between them if shallow supported `create`. I can put together a PR for it if there's interest.\r\n\r\n## react-test-renderer\r\n\r\n```javascript\r\nimport TestRenderer from 'react-test-renderer';\r\n\r\nit('renders', () => {\r\n  const result = TestRenderer.create(<MyComponent />);\r\n  expect(result).toMatchSnapshot();\r\n});\r\n```\r\n\r\n## shallow\r\n\r\n```javascript\r\nimport ShallowRenderer from 'react-test-renderer/shallow';\r\n\r\nit('renders', () => {\r\n  const renderer = new ShallowRenderer()\r\n  const result = renderer.render(<MyComponent />);\r\n  expect(result).toMatchSnapshot();\r\n});\r\n```",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Feature    Currently, `react-test-renderer` and `react-test-renderer/shallow` have different APIs. Is there a reason for this? It would be helpful switching between them if shallow supported `create`. I can put together a PR for it if there's interest.    ## react-test-renderer    ```javascript  import TestRenderer from 'react-test-renderer';    it('renders', () => {    const result = TestRenderer.create(<MyComponent />);    expect(result).toMatchSnapshot();  });  ```    ## shallow    ```javascript  import ShallowRenderer from 'react-test-renderer/shallow';    it('renders', () => {    const renderer = new ShallowRenderer()    const result = renderer.render(<MyComponent />);    expect(result).toMatchSnapshot();  });  ```",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Feature    Currently, `react-test-renderer` and `react-test-renderer/shallow` have different APIs. Is there a reason for this? It would be helpful switching between them if shallow supported `create`. I can put together a PR for it if there's interest.    ## react-test-renderer        ## shallow    ",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature Currently, `react-test-renderer` and `react-test-renderer/shallow` have different APIs. Is there a reason for this? It would be helpful switching between them if shallow supported `create`. I can put together a PR for it if there's interest. ## react-test-renderer ## shallow ",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature currently , ` react-test-renderer ` ` react-test-renderer/shallow ` different apis . reason ? would helpful switching shallow supported ` create ` . put together pr 's interest . # # react-test-renderer # # shallow",
        "title_stopwords_removal_lemmatization": "react-test-renderer shallow api mismatch"
    },
    {
        "issue_id": 248029861,
        "title": "Unhandled error is displayed twice",
        "label": [
            "Resolution: Wontfix",
            "Component: Core Utilities",
            "Type: Discussion"
        ],
        "date": "2017-08-04T14:52:41Z",
        "status": "closed",
        "description": "This was a bit weird:\r\n\r\n<img width=\"967\" alt=\"screen shot 2017-08-04 at 3 51 29 pm\" src=\"https://user-images.githubusercontent.com/810438/28973995-cebc65bc-792c-11e7-8f7f-066a4ca038dd.png\">\r\n\r\nLook at the last log.\r\n\r\nNotice how our internal error that we're supposed to just give to the error boundary is said to be uncaught. I wonder why. It doesn't look like intentional.",
        "remove_template_description": "This was a bit weird:    <img width=\"967\" alt=\"screen shot 2017-08-04 at 3 51 29 pm\" src=\"https://user-images.githubusercontent.com/810438/28973995-cebc65bc-792c-11e7-8f7f-066a4ca038dd.png\">    Look at the last log.    Notice how our internal error that we're supposed to just give to the error boundary is said to be uncaught. I wonder why. It doesn't look like intentional.",
        "human_words": "This was a bit weird:    <img width=\"967\" alt=\"screen shot 2017-08-04 at 3 51 29 pm\" src=\"https://user-images.githubusercontent.com/810438/28973995-cebc65bc-792c-11e7-8f7f-066a4ca038dd.png\">    Look at the last log.    Notice how our internal error that we're supposed to just give to the error boundary is said to be uncaught. I wonder why. It doesn't look like intentional.",
        "human_words_regrex": "This was a bit weird: <img width=\"967\" alt=\"screen shot 2017-08-04 at 3 51 29 pm\" src=\" Look at the last log. Notice how our internal error that we're supposed to just give to the error boundary is said to be uncaught. I wonder why. It doesn't look like intentional.",
        "human_words_stopwords_removal_lemmatization": "bit weird : < img width= '' 967 '' alt= '' screen shot 2017-08-04 3 51 29 pm '' src= '' look last log . notice internal error 're supposed give error boundary said uncaught . wonder . n't look like intentional .",
        "title_stopwords_removal_lemmatization": "unhandled error displayed twice"
    },
    {
        "issue_id": 248003365,
        "title": "Too much unnecessary updates when a child element is moved to the front",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-08-04T13:18:50Z",
        "status": "open",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nNot sure if it's a bug or an 'accepted' behavior. But this can affect performance in some situations or even 'break the expectations' in others (e.g. animating moved elements [i.e. simple moves]) \r\n\r\n**What is the current behavior?**\r\n\r\nWhen a child element moves from the end of the list to the front  React actually moves all the other elements after the moved/last element instead of simply inserting the moved element at the front of the list.\r\n\r\nThis also can be stated more generally for an element or a block of elements moving backward with a significant shift.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**\r\n\r\nHere is a [demo](https://codesandbox.io/s/wjZkrGVzJ) that shows the DOM operations performed on DOM nodes (moves & insertions) during reconciliation. To reproduce the issue\r\n\r\n- type '0123456789x' in the input field then click `Patch!`\r\n\r\n- now type 'x0123456789' (move the last 'x' to the front) then click `Patch!` again\r\n\r\nHere's the output\r\n\r\n![image](https://user-images.githubusercontent.com/5453835/28969007-affc2dae-791a-11e7-951a-37856bc53f00.png)\r\n\r\nInstead of moving the 'x' to the front. React actually moves all the other elements after the 'x'\r\n\r\n*Note: the demo uses MutationObserver api to find out the operations. But you can also verify this behavior directly by commenting out the code that activates the dom observer (in componentDidMount) and watch the dom operations manually in the devtools element inspector*\r\n\r\n**What is the expected behavior?**\r\n\r\nReact should perform the minimal number of operations. I know that the 'minimum' will vary for each situation and not trivial to infer for the general case. But for some common cases like this one it should be feasible.\r\n\r\nFor info this use case is handled in most of the other virtual dom libs like preact, snabbdom. Inferno is a remarkable case as it will always infer the minimum number of operations (it uses an algorithm to find the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) on an array containing the indexes of the old elements).\r\n\r\nI found this behavior while working on a demo to find out how vdom libs rearrange nodes during children reconciliation. For example here is the same output for other libs ([demo](https://codesandbox.io/s/BkLpXYQn))\r\n\r\n![image](https://user-images.githubusercontent.com/5453835/28969902-567219c0-791e-11e7-9f3d-29bf988cdab1.png)\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nThe demo uses the 0.16 version. But I tried with 0.15 and it has the same behavior",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Not sure if it's a bug or an 'accepted' behavior. But this can affect performance in some situations or even 'break the expectations' in others (e.g. animating moved elements [i.e. simple moves])     **What is the current behavior?**    When a child element moves from the end of the list to the front  React actually moves all the other elements after the moved/last element instead of simply inserting the moved element at the front of the list.    This also can be stated more generally for an element or a block of elements moving backward with a significant shift.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**    Here is a [demo](https://codesandbox.io/s/wjZkrGVzJ) that shows the DOM operations performed on DOM nodes (moves & insertions) during reconciliation. To reproduce the issue    - type '0123456789x' in the input field then click `Patch!`    - now type 'x0123456789' (move the last 'x' to the front) then click `Patch!` again    Here's the output    ![image](https://user-images.githubusercontent.com/5453835/28969007-affc2dae-791a-11e7-951a-37856bc53f00.png)    Instead of moving the 'x' to the front. React actually moves all the other elements after the 'x'    *Note: the demo uses MutationObserver api to find out the operations. But you can also verify this behavior directly by commenting out the code that activates the dom observer (in componentDidMount) and watch the dom operations manually in the devtools element inspector*    **What is the expected behavior?**    React should perform the minimal number of operations. I know that the 'minimum' will vary for each situation and not trivial to infer for the general case. But for some common cases like this one it should be feasible.    For info this use case is handled in most of the other virtual dom libs like preact, snabbdom. Inferno is a remarkable case as it will always infer the minimum number of operations (it uses an algorithm to find the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) on an array containing the indexes of the old elements).    I found this behavior while working on a demo to find out how vdom libs rearrange nodes during children reconciliation. For example here is the same output for other libs ([demo](https://codesandbox.io/s/BkLpXYQn))    ![image](https://user-images.githubusercontent.com/5453835/28969902-567219c0-791e-11e7-9f3d-29bf988cdab1.png)    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    The demo uses the 0.16 version. But I tried with 0.15 and it has the same behavior",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Not sure if it's a bug or an 'accepted' behavior. But this can affect performance in some situations or even 'break the expectations' in others (e.g. animating moved elements [i.e. simple moves])     **What is the current behavior?**    When a child element moves from the end of the list to the front  React actually moves all the other elements after the moved/last element instead of simply inserting the moved element at the front of the list.    This also can be stated more generally for an element or a block of elements moving backward with a significant shift.    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**    Here is a [demo](https://codesandbox.io/s/wjZkrGVzJ) that shows the DOM operations performed on DOM nodes (moves & insertions) during reconciliation. To reproduce the issue    - type '0123456789x' in the input field then click `Patch!`    - now type 'x0123456789' (move the last 'x' to the front) then click `Patch!` again    Here's the output    ![image](https://user-images.githubusercontent.com/5453835/28969007-affc2dae-791a-11e7-951a-37856bc53f00.png)    Instead of moving the 'x' to the front. React actually moves all the other elements after the 'x'    *Note: the demo uses MutationObserver api to find out the operations. But you can also verify this behavior directly by commenting out the code that activates the dom observer (in componentDidMount) and watch the dom operations manually in the devtools element inspector*    **What is the expected behavior?**    React should perform the minimal number of operations. I know that the 'minimum' will vary for each situation and not trivial to infer for the general case. But for some common cases like this one it should be feasible.    For info this use case is handled in most of the other virtual dom libs like preact, snabbdom. Inferno is a remarkable case as it will always infer the minimum number of operations (it uses an algorithm to find the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) on an array containing the indexes of the old elements).    I found this behavior while working on a demo to find out how vdom libs rearrange nodes during children reconciliation. For example here is the same output for other libs ([demo](https://codesandbox.io/s/BkLpXYQn))    ![image](https://user-images.githubusercontent.com/5453835/28969902-567219c0-791e-11e7-9f3d-29bf988cdab1.png)    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    The demo uses the 0.16 version. But I tried with 0.15 and it has the same behavior",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Not sure if it's a bug or an 'accepted' behavior. But this can affect performance in some situations or even 'break the expectations' in others (e.g. animating moved elements  that shows the DOM operations performed on DOM nodes (moves & insertions) during reconciliation. To reproduce the issue - type '0123456789x' in the input field then click `Patch!` - now type 'x0123456789' (move the last 'x' to the front) then click `Patch!` again Here's the output ! Instead of moving the 'x' to the front. React actually moves all the other elements after the 'x' *Note: the demo uses MutationObserver api to find out the operations. But you can also verify this behavior directly by commenting out the code that activates the dom observer (in componentDidMount) and watch the dom operations manually in the devtools element inspector* **What is the expected behavior?** React should perform the minimal number of operations. I know that the 'minimum' will vary for each situation and not trivial to infer for the general case. But for some common cases like this one it should be feasible. For info this use case is handled in most of the other virtual dom libs like preact, snabbdom. Inferno is a remarkable case as it will always infer the minimum number of operations (it uses an algorithm to find the  on an array containing the indexes of the old elements). I found this behavior while working on a demo to find out how vdom libs rearrange nodes during children reconciliation. For example here is the same output for other libs () ! **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** The demo uses the 0.16 version. But I tried with 0.15 and it has the same behavior",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * sure 's bug 'accepted ' behavior . affect performance situation even 'break expectation ' others ( e.g . animating moved element show dom operation performed dom node ( move & insertion ) reconciliation . reproduce issue - type '0123456789x ' input field click ` patch ! ` - type 'x0123456789 ' ( move last ' x ' front ) click ` patch ! ` 's output ! instead moving ' x ' front . react actually move element ' x ' * note : demo us mutationobserver api find operation . also verify behavior directly commenting code activates dom observer ( componentdidmount ) watch dom operation manually devtools element inspector * * * expected behavior ? * * react perform minimal number operation . know 'minimum ' vary situation trivial infer general case . common case like one feasible . info use case handled virtual dom libs like preact , snabbdom . inferno remarkable case always infer minimum number operation ( us algorithm find array containing index old element ) . found behavior working demo find vdom libs rearrange node child reconciliation . example output libs ( ) ! * * version react , browser / o affected issue ? work previous version react ? * * demo us 0.16 version . tried 0.15 behavior",
        "title_stopwords_removal_lemmatization": "much unnecessary update child element moved front"
    },
    {
        "issue_id": 242029054,
        "title": "Remove unstable_renderIntoContainer",
        "label": [
            "Type: Discussion",
            "Component: Reconciler",
            "Type: Breaking Change",
            "React Core Team"
        ],
        "date": "2017-07-11T12:25:32Z",
        "status": "open",
        "description": "My hunch is we want to remove it before 16 because `unstable_createPortal` accomplishes the same thing. I remember `unstable_renderIntoContainer` adding a bunch of complexity that would be nice to get rid of before committing to support it for another release cycle.",
        "remove_template_description": "My hunch is we want to remove it before 16 because `unstable_createPortal` accomplishes the same thing. I remember `unstable_renderIntoContainer` adding a bunch of complexity that would be nice to get rid of before committing to support it for another release cycle.",
        "human_words": "My hunch is we want to remove it before 16 because `unstable_createPortal` accomplishes the same thing. I remember `unstable_renderIntoContainer` adding a bunch of complexity that would be nice to get rid of before committing to support it for another release cycle.",
        "human_words_regrex": "My hunch is we want to remove it before 16 because `unstable_createPortal` accomplishes the same thing. I remember `unstable_renderIntoContainer` adding a bunch of complexity that would be nice to get rid of before committing to support it for another release cycle.",
        "human_words_stopwords_removal_lemmatization": "hunch want remove 16 ` unstable_createportal ` accomplishes thing . remember ` unstable_renderintocontainer ` adding bunch complexity would nice get rid committing support another release cycle .",
        "title_stopwords_removal_lemmatization": "remove unstable_renderintocontainer"
    },
    {
        "issue_id": 239393451,
        "title": "Don't convert attributes for DOM elements to strings for custom elements",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-06-29T07:49:15Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nReact converts values to strings before passing them to the native `setAttribute` methods of DOM elements.\r\n\r\n**What is the expected behavior?**\r\n\r\nCustom Elements are landing in browsers. It is possible for Custom Elements to extend `setAttribute` (at least in Chrome) to do custom things with input values before passing onto `super.setAttribute()`.\r\n\r\nThis means that Custom Element authors can accept values other than strings, which can bring performance benefits. For example, imagine Custom Elements designed for rendering to WebGL, and when using them imperatively, the overhead of strings can be avoided.\r\n\r\nFor example, suppose we have this class:\r\n\r\n```js\r\ncustomElements.define('gl-mesh', class extends HTMLElement {\r\n  setAttribute(attr, value) {\r\n    if (value instanceof DOMMatrix) {\r\n        // use raw numbers here, for performance.\r\n    }\r\n    else if (typeof value == 'string') {\r\n        // otherwise, parse a string, which is slower.\r\n    }\r\n    super.setAttribute(attr, value)\r\n  }\r\n})\r\n```\r\n\r\nIf React converts values to strings before ever passing them into `setAttribute`, then Custom Element authors can not allow end users to benefit from performance improvements.\r\n\r\nBrowsers allow anything to be passed into `setAttribute`, so React should do the same. If a Custom Element doesn't extend `setAttribute`, the native super class will do the string conversion anyways, so React doesn't have to.\r\n\r\nIn my case, this would be awesome because then I could pass number-based values to my webgl-rendering Custom Elements, and propagate those directly into WebGL without having to convert strings to numbers every tick (for hundreds if not thousands of WebGL objects).\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\n15.6",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    React converts values to strings before passing them to the native `setAttribute` methods of DOM elements.    **What is the expected behavior?**    Custom Elements are landing in browsers. It is possible for Custom Elements to extend `setAttribute` (at least in Chrome) to do custom things with input values before passing onto `super.setAttribute()`.    This means that Custom Element authors can accept values other than strings, which can bring performance benefits. For example, imagine Custom Elements designed for rendering to WebGL, and when using them imperatively, the overhead of strings can be avoided.    For example, suppose we have this class:    ```js  customElements.define('gl-mesh', class extends HTMLElement {    setAttribute(attr, value) {      if (value instanceof DOMMatrix) {          // use raw numbers here, for performance.      }      else if (typeof value == 'string') {          // otherwise, parse a string, which is slower.      }      super.setAttribute(attr, value)    }  })  ```    If React converts values to strings before ever passing them into `setAttribute`, then Custom Element authors can not allow end users to benefit from performance improvements.    Browsers allow anything to be passed into `setAttribute`, so React should do the same. If a Custom Element doesn't extend `setAttribute`, the native super class will do the string conversion anyways, so React doesn't have to.    In my case, this would be awesome because then I could pass number-based values to my webgl-rendering Custom Elements, and propagate those directly into WebGL without having to convert strings to numbers every tick (for hundreds if not thousands of WebGL objects).    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    15.6",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    Feature    **What is the current behavior?**    React converts values to strings before passing them to the native `setAttribute` methods of DOM elements.    **What is the expected behavior?**    Custom Elements are landing in browsers. It is possible for Custom Elements to extend `setAttribute` (at least in Chrome) to do custom things with input values before passing onto `super.setAttribute()`.    This means that Custom Element authors can accept values other than strings, which can bring performance benefits. For example, imagine Custom Elements designed for rendering to WebGL, and when using them imperatively, the overhead of strings can be avoided.    For example, suppose we have this class:        If React converts values to strings before ever passing them into `setAttribute`, then Custom Element authors can not allow end users to benefit from performance improvements.    Browsers allow anything to be passed into `setAttribute`, so React should do the same. If a Custom Element doesn't extend `setAttribute`, the native super class will do the string conversion anyways, so React doesn't have to.    In my case, this would be awesome because then I could pass number-based values to my webgl-rendering Custom Elements, and propagate those directly into WebGL without having to convert strings to numbers every tick (for hundreds if not thousands of WebGL objects).    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    15.6",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Feature **What is the current behavior?** React converts values to strings before passing them to the native `setAttribute` methods of DOM elements. **What is the expected behavior?** Custom Elements are landing in browsers. It is possible for Custom Elements to extend `setAttribute` (at least in Chrome) to do custom things with input values before passing onto `super.setAttribute()`. This means that Custom Element authors can accept values other than strings, which can bring performance benefits. For example, imagine Custom Elements designed for rendering to WebGL, and when using them imperatively, the overhead of strings can be avoided. For example, suppose we have this class: If React converts values to strings before ever passing them into `setAttribute`, then Custom Element authors can not allow end users to benefit from performance improvements. Browsers allow anything to be passed into `setAttribute`, so React should do the same. If a Custom Element doesn't extend `setAttribute`, the native super class will do the string conversion anyways, so React doesn't have to. In my case, this would be awesome because then I could pass number-based values to my webgl-rendering Custom Elements, and propagate those directly into WebGL without having to convert strings to numbers every tick (for hundreds if not thousands of WebGL objects). **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 15.6",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * feature * * current behavior ? * * react convert value string passing native ` setattribute ` method dom element . * * expected behavior ? * * custom element landing browser . possible custom element extend ` setattribute ` ( least chrome ) custom thing input value passing onto ` super.setattribute ( ) ` . mean custom element author accept value string , bring performance benefit . example , imagine custom element designed rendering webgl , using imperatively , overhead string avoided . example , suppose class : react convert value string ever passing ` setattribute ` , custom element author allow end user benefit performance improvement . browser allow anything passed ` setattribute ` , react . custom element n't extend ` setattribute ` , native super class string conversion anyways , react n't . case , would awesome could pas number-based value webgl-rendering custom element , propagate directly webgl without convert string number every tick ( hundred thousand webgl object ) . * * version react , browser / o affected issue ? work previous version react ? * * 15.6",
        "title_stopwords_removal_lemmatization": "n't convert attribute dom element string custom element"
    },
    {
        "issue_id": 238704590,
        "title": "Render Callbacks Fire Even Though an Error Happened",
        "label": [
            "Type: Discussion",
            "Component: Reconciler",
            "React Core Team"
        ],
        "date": "2017-06-27T00:19:04Z",
        "status": "closed",
        "description": "I think something like this both throws and prints success.\r\n\r\n```js\r\nfunction Throw() {\r\n  throw new Error();\r\n}\r\nReactDOM.render(<Throw />, () => console.log('success'));\r\n```\r\n\r\nThis means that it is not safe to wrap this in a Promise like this for example:\r\n\r\n```js\r\nnew Promise(resolve => ReactDOM.render(..., ..., resolve));\r\n```\r\n\r\nBecause if this throws, then the error is silenced. The Promise was already resolved. I hit this in the ServerIntegration-test",
        "remove_template_description": "I think something like this both throws and prints success.    ```js  function Throw() {    throw new Error();  }  ReactDOM.render(<Throw />, () => console.log('success'));  ```    This means that it is not safe to wrap this in a Promise like this for example:    ```js  new Promise(resolve => ReactDOM.render(..., ..., resolve));  ```    Because if this throws, then the error is silenced. The Promise was already resolved. I hit this in the ServerIntegration-test",
        "human_words": "I think something like this both throws and prints success.        This means that it is not safe to wrap this in a Promise like this for example:        Because if this throws, then the error is silenced. The Promise was already resolved. I hit this in the ServerIntegration-test",
        "human_words_regrex": "I think something like this both throws and prints success. This means that it is not safe to wrap this in a Promise like this for example: Because if this throws, then the error is silenced. The Promise was already resolved. I hit this in the ServerIntegration-test",
        "human_words_stopwords_removal_lemmatization": "think something like throw print success . mean safe wrap promise like example : throw , error silenced . promise already resolved . hit serverintegration-test",
        "title_stopwords_removal_lemmatization": "render callback fire even though error happened"
    },
    {
        "issue_id": 227840957,
        "title": "[RFC] onChange -> onInput, and don't polyfill onInput for uncontrolled components",
        "label": [
            "Component: DOM",
            "Type: Discussion",
            "Type: Breaking Change",
            "React Core Team"
        ],
        "date": "2017-05-10T23:47:56Z",
        "status": "open",
        "description": "`onChange` is a nicer name for what `onInput` does and the fact that it has propagated up to other high-level components as the default name is much nicer than `onInput` as a high level event name.\r\n\r\nGenerally it has been helpful for the many new-comers to React that don't know the DOM well (which is a lot more than the inverse). However, that doesn't change the fact that it can be confusing for people that are familiar.\r\n\r\nUnfortunately, changing it now would cause confusion for everyone that already knows React.\r\n\r\nThe reason I'd like to change it now is because I'd like to get away from polyfilling it for __uncontrolled__ components. This use case is filled with all kinds of imperative code which leads to edge cases. E.g. reading/setting `e.target.value` or reading/setting `ref.value`.\r\n\r\nWhen you use __controlled__ components you shouldn't need to touch them imperatively and therefore won't hit the edge cases. Ideally we should get away from reading from `e.target.value` and instead just pass the `value` directly to the event handler.\r\n\r\n## Proposal:\r\n\r\n__Controlled Components__\r\n\r\n- `onInput`: Polyfilled and works like `onChange` does today. It is allowed to over-fire many events even if nothing changed. May have special Fiber rules regarding synchronous flushing. _Optional: Pass `value` as second arg._\r\n- `onChange`: Works like `onInput` for one version but warns about being deprecated and suggests switching to `onInput`. In next version it works like the browser but still warns and tells you to use `onInput` forever.\r\n\r\n_Optional: Add a getter/setter on DOM `.value` in development mode and warn if this is used directly._\r\n\r\n__Uncontrolled Components__\r\n\r\n- `onInput`: Not polyfilled. Works however the browser works. Warns about browser differences if you don't also specify `onClick`, `onKeyDown` and/or `onKeyUp`. The warnings suggests implementing those listeners to cover more edge cases, or switch to a controlled component.\r\n- `onChange`: Not polyfilled. Works however the browser works.\r\n",
        "remove_template_description": "`onChange` is a nicer name for what `onInput` does and the fact that it has propagated up to other high-level components as the default name is much nicer than `onInput` as a high level event name.    Generally it has been helpful for the many new-comers to React that don't know the DOM well (which is a lot more than the inverse). However, that doesn't change the fact that it can be confusing for people that are familiar.    Unfortunately, changing it now would cause confusion for everyone that already knows React.    The reason I'd like to change it now is because I'd like to get away from polyfilling it for __uncontrolled__ components. This use case is filled with all kinds of imperative code which leads to edge cases. E.g. reading/setting `e.target.value` or reading/setting `ref.value`.    When you use __controlled__ components you shouldn't need to touch them imperatively and therefore won't hit the edge cases. Ideally we should get away from reading from `e.target.value` and instead just pass the `value` directly to the event handler.    ## Proposal:    __Controlled Components__    - `onInput`: Polyfilled and works like `onChange` does today. It is allowed to over-fire many events even if nothing changed. May have special Fiber rules regarding synchronous flushing. _Optional: Pass `value` as second arg._  - `onChange`: Works like `onInput` for one version but warns about being deprecated and suggests switching to `onInput`. In next version it works like the browser but still warns and tells you to use `onInput` forever.    _Optional: Add a getter/setter on DOM `.value` in development mode and warn if this is used directly._    __Uncontrolled Components__    - `onInput`: Not polyfilled. Works however the browser works. Warns about browser differences if you don't also specify `onClick`, `onKeyDown` and/or `onKeyUp`. The warnings suggests implementing those listeners to cover more edge cases, or switch to a controlled component.  - `onChange`: Not polyfilled. Works however the browser works.",
        "human_words": "`onChange` is a nicer name for what `onInput` does and the fact that it has propagated up to other high-level components as the default name is much nicer than `onInput` as a high level event name.    Generally it has been helpful for the many new-comers to React that don't know the DOM well (which is a lot more than the inverse). However, that doesn't change the fact that it can be confusing for people that are familiar.    Unfortunately, changing it now would cause confusion for everyone that already knows React.    The reason I'd like to change it now is because I'd like to get away from polyfilling it for __uncontrolled__ components. This use case is filled with all kinds of imperative code which leads to edge cases. E.g. reading/setting `e.target.value` or reading/setting `ref.value`.    When you use __controlled__ components you shouldn't need to touch them imperatively and therefore won't hit the edge cases. Ideally we should get away from reading from `e.target.value` and instead just pass the `value` directly to the event handler.    ## Proposal:    __Controlled Components__    - `onInput`: Polyfilled and works like `onChange` does today. It is allowed to over-fire many events even if nothing changed. May have special Fiber rules regarding synchronous flushing. _Optional: Pass `value` as second arg._  - `onChange`: Works like `onInput` for one version but warns about being deprecated and suggests switching to `onInput`. In next version it works like the browser but still warns and tells you to use `onInput` forever.    _Optional: Add a getter/setter on DOM `.value` in development mode and warn if this is used directly._    __Uncontrolled Components__    - `onInput`: Not polyfilled. Works however the browser works. Warns about browser differences if you don't also specify `onClick`, `onKeyDown` and/or `onKeyUp`. The warnings suggests implementing those listeners to cover more edge cases, or switch to a controlled component.  - `onChange`: Not polyfilled. Works however the browser works.",
        "human_words_regrex": "`onChange` is a nicer name for what `onInput` does and the fact that it has propagated up to other high-level components as the default name is much nicer than `onInput` as a high level event name. Generally it has been helpful for the many new-comers to React that don't know the DOM well (which is a lot more than the inverse). However, that doesn't change the fact that it can be confusing for people that are familiar. Unfortunately, changing it now would cause confusion for everyone that already knows React. The reason I'd like to change it now is because I'd like to get away from polyfilling it for __uncontrolled__ components. This use case is filled with all kinds of imperative code which leads to edge cases. E.g. reading/setting `e.target.value` or reading/setting `ref.value`. When you use __controlled__ components you shouldn't need to touch them imperatively and therefore won't hit the edge cases. Ideally we should get away from reading from `e.target.value` and instead just pass the `value` directly to the event handler. ## Proposal: __Controlled Components__ - `onInput`: Polyfilled and works like `onChange` does today. It is allowed to over-fire many events even if nothing changed. May have special Fiber rules regarding synchronous flushing. _Optional: Pass `value` as second arg._ - `onChange`: Works like `onInput` for one version but warns about being deprecated and suggests switching to `onInput`. In next version it works like the browser but still warns and tells you to use `onInput` forever. _Optional: Add a getter/setter on DOM `.value` in development mode and warn if this is used directly._ __Uncontrolled Components__ - `onInput`: Not polyfilled. Works however the browser works. Warns about browser differences if you don't also specify `onClick`, `onKeyDown` and/or `onKeyUp`. The warnings suggests implementing those listeners to cover more edge cases, or switch to a controlled component. - `onChange`: Not polyfilled. Works however the browser works.",
        "human_words_stopwords_removal_lemmatization": "` onchange ` nicer name ` oninput ` fact propagated high-level component default name much nicer ` oninput ` high level event name . generally helpful many new-comers react n't know dom well ( lot inverse ) . however , n't change fact confusing people familiar . unfortunately , changing would cause confusion everyone already know react . reason 'd like change 'd like get away polyfilling __uncontrolled__ component . use case filled kind imperative code lead edge case . e.g . reading/setting ` e.target.value ` reading/setting ` ref.value ` . use __controlled__ component n't need touch imperatively therefore wo n't hit edge case . ideally get away reading ` e.target.value ` instead pas ` value ` directly event handler . # # proposal : __controlled components__ - ` oninput ` : polyfilled work like ` onchange ` today . allowed over-fire many event even nothing changed . may special fiber rule regarding synchronous flushing . _optional : pas ` value ` second arg._ - ` onchange ` : work like ` oninput ` one version warns deprecated suggests switching ` oninput ` . next version work like browser still warns tell use ` oninput ` forever . _optional : add getter/setter dom ` .value ` development mode warn used directly._ __uncontrolled components__ - ` oninput ` : polyfilled . work however browser work . warns browser difference n't also specify ` onclick ` , ` onkeydown ` and/or ` onkeyup ` . warning suggests implementing listener cover edge case , switch controlled component . - ` onchange ` : polyfilled . work however browser work .",
        "title_stopwords_removal_lemmatization": "[ rfc ] onchange - > oninput , n't polyfill oninput uncontrolled component"
    },
    {
        "issue_id": 220404366,
        "title": "If ReactDOM.render is asynchronous, how to catch exceptions?",
        "label": [
            "Type: Discussion",
            "Component: Reconciler"
        ],
        "date": "2017-04-08T14:51:48Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nI want to request a feature.\r\n\r\n**What is the current behavior?**\r\nThe callback is called, but doesn't pass an error if one occurred.\r\nhttps://facebook.github.io/react/docs/react-dom.html#render\r\n\r\n**What is the expected behavior?**\r\nIf an error occurs during rendering, I would want to handle the error in the callback.\r\n\r\nRight now, I'm using this:\r\n```jsx\r\n    return new Promise(resolve => {\r\n        const routerProps = {\r\n            routes,\r\n            history,\r\n            onUpdate\r\n        };\r\n\r\n        try {\r\n            render((\r\n                <Provider store={_store}>\r\n                    <Router {...routerProps}/>\r\n                </Provider>\r\n            ), document.getElementById('...-editor'), () => {\r\n                resolve();\r\n            });\r\n        } catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n```\r\n\r\nBut I would like to use this:\r\n```jsx\r\n    return new Promise(resolve => {\r\n        const routerProps = {\r\n            routes,\r\n            history,\r\n            onUpdate\r\n        };\r\n\r\n        render((\r\n            <Provider store={_store}>\r\n                <Router {...routerProps}/>\r\n            </Provider>\r\n        ), document.getElementById('...-editor'), error => {\r\n            if (error) {\r\n                reject(error);\r\n            } else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n```\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nI'm using the major version 15 and have not checked any other versions.",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  I want to request a feature.    **What is the current behavior?**  The callback is called, but doesn't pass an error if one occurred.  https://facebook.github.io/react/docs/react-dom.html#render    **What is the expected behavior?**  If an error occurs during rendering, I would want to handle the error in the callback.    Right now, I'm using this:  ```jsx      return new Promise(resolve => {          const routerProps = {              routes,              history,              onUpdate          };            try {              render((                  <Provider store={_store}>                      <Router {...routerProps}/>                  </Provider>              ), document.getElementById('...-editor'), () => {                  resolve();              });          } catch (error) {              reject(error);          }      });  ```    But I would like to use this:  ```jsx      return new Promise(resolve => {          const routerProps = {              routes,              history,              onUpdate          };            render((              <Provider store={_store}>                  <Router {...routerProps}/>              </Provider>          ), document.getElementById('...-editor'), error => {              if (error) {                  reject(error);              } else {                  resolve();              }          });      });  ```    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  I'm using the major version 15 and have not checked any other versions.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  I want to request a feature.    **What is the current behavior?**  The callback is called, but doesn't pass an error if one occurred.  https://facebook.github.io/react/docs/react-dom.html#render    **What is the expected behavior?**  If an error occurs during rendering, I would want to handle the error in the callback.    Right now, I'm using this:      But I would like to use this:      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  I'm using the major version 15 and have not checked any other versions.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** I want to request a feature. **What is the current behavior?** The callback is called, but doesn't pass an error if one occurred.  **What is the expected behavior?** If an error occurs during rendering, I would want to handle the error in the callback. Right now, I'm using this: But I would like to use this: **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** I'm using the major version 15 and have not checked any other versions.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * want request feature . * * current behavior ? * * callback called , n't pas error one occurred . * * expected behavior ? * * error occurs rendering , would want handle error callback . right , 'm using : would like use : * * version react , browser / o affected issue ? work previous version react ? * * 'm using major version 15 checked version .",
        "title_stopwords_removal_lemmatization": "reactdom.render asynchronous , catch exception ?"
    },
    {
        "issue_id": 218363074,
        "title": "Define specific browser support guidelines",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-03-31T00:10:28Z",
        "status": "open",
        "description": "As it stands the only real solid guideline we have for browser support is that we support IE9+. But there are so many other outdated browser versions that are unreasonable to support or worry about.\r\n\r\nIt would be useful if we had more specific guidelines on what browsers we should target. Does Safari on iOS 3 matter? FireFox 4? You get the idea.\r\n\r\nIf we had a well-documented range of browser version that we *know* should work it would make it a lot easier to run through our DOM fixtures in BrowserStack and know we're safe.\r\n\r\nMaybe the internal core team can work internally with analytics to see what browsers Facebook needs to support and work forward from there?\r\n\r\ncc @gaearon @nhunzaker ",
        "remove_template_description": "As it stands the only real solid guideline we have for browser support is that we support IE9+. But there are so many other outdated browser versions that are unreasonable to support or worry about.    It would be useful if we had more specific guidelines on what browsers we should target. Does Safari on iOS 3 matter? FireFox 4? You get the idea.    If we had a well-documented range of browser version that we *know* should work it would make it a lot easier to run through our DOM fixtures in BrowserStack and know we're safe.    Maybe the internal core team can work internally with analytics to see what browsers Facebook needs to support and work forward from there?    cc @gaearon @nhunzaker",
        "human_words": "As it stands the only real solid guideline we have for browser support is that we support IE9+. But there are so many other outdated browser versions that are unreasonable to support or worry about.    It would be useful if we had more specific guidelines on what browsers we should target. Does Safari on iOS 3 matter? FireFox 4? You get the idea.    If we had a well-documented range of browser version that we *know* should work it would make it a lot easier to run through our DOM fixtures in BrowserStack and know we're safe.    Maybe the internal core team can work internally with analytics to see what browsers Facebook needs to support and work forward from there?    cc @gaearon @nhunzaker",
        "human_words_regrex": "As it stands the only real solid guideline we have for browser support is that we support IE9+. But there are so many other outdated browser versions that are unreasonable to support or worry about. It would be useful if we had more specific guidelines on what browsers we should target. Does Safari on iOS 3 matter? FireFox 4? You get the idea. If we had a well-documented range of browser version that we *know* should work it would make it a lot easier to run through our DOM fixtures in BrowserStack and know we're safe. Maybe the internal core team can work internally with analytics to see what browsers Facebook needs to support and work forward from there? cc @gaearon @nhunzaker",
        "human_words_stopwords_removal_lemmatization": "stand real solid guideline browser support support ie9+ . many outdated browser version unreasonable support worry . would useful specific guideline browser target . safari io 3 matter ? firefox 4 ? get idea . well-documented range browser version * know * work would make lot easier run dom fixture browserstack know 're safe . maybe internal core team work internally analytics see browser facebook need support work forward ? cc @ gaearon @ nhunzaker",
        "title_stopwords_removal_lemmatization": "define specific browser support guideline"
    },
    {
        "issue_id": 216416941,
        "title": "Event Handler on React Component not invoked when React Component is rendered inside a Web Component",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-03-23T12:51:10Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nA React Component with an Event Handler (for example onClick) is rendered inside a Web Component. When the Component is clicked the Event does not receive the React Component (specified callback is not invoked)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**\r\n\r\nYou can reproduce it with Web Component example contained in the react repository (https://github.com/facebook/react/blob/master/examples/webcomponents/index.html): Replace the 'a' element with a button and add for example an onClick event handler. \r\n\r\nYou can find a modified version of the Web Component example (based on the 15.4.2 codebase - https://github.com/facebook/react/blob/v15.4.2/examples/webcomponents/index.html) here:\r\nhttps://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-index-html-L50 \r\n\r\n**What is the expected behavior?**\r\nThe event handler should be called.\r\n\r\nFor testing I have modified `getEventTarget.js` to return the target from the `path` property of the `nativeEvent` (instead of the \"original\" `target` from the `nativeEvent`). With this addition it works - \r\nthe Event Handler is called.\r\n\r\nYou can find the modified version also in the gist: https://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-geteventtarget-js-L6\r\n\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n15.4.x and 16.x\r\nI've tested in Chrome, Firefox and Safari. I don't know if it works in previous versions of React (don't think so)",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  A React Component with an Event Handler (for example onClick) is rendered inside a Web Component. When the Component is clicked the Event does not receive the React Component (specified callback is not invoked)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**    You can reproduce it with Web Component example contained in the react repository (https://github.com/facebook/react/blob/master/examples/webcomponents/index.html): Replace the 'a' element with a button and add for example an onClick event handler.     You can find a modified version of the Web Component example (based on the 15.4.2 codebase - https://github.com/facebook/react/blob/v15.4.2/examples/webcomponents/index.html) here:  https://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-index-html-L50     **What is the expected behavior?**  The event handler should be called.    For testing I have modified `getEventTarget.js` to return the target from the `path` property of the `nativeEvent` (instead of the \"original\" `target` from the `nativeEvent`). With this addition it works -   the Event Handler is called.    You can find the modified version also in the gist: https://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-geteventtarget-js-L6      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  15.4.x and 16.x  I've tested in Chrome, Firefox and Safari. I don't know if it works in previous versions of React (don't think so)",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  A React Component with an Event Handler (for example onClick) is rendered inside a Web Component. When the Component is clicked the Event does not receive the React Component (specified callback is not invoked)    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**    You can reproduce it with Web Component example contained in the react repository (https://github.com/facebook/react/blob/master/examples/webcomponents/index.html): Replace the 'a' element with a button and add for example an onClick event handler.     You can find a modified version of the Web Component example (based on the 15.4.2 codebase - https://github.com/facebook/react/blob/v15.4.2/examples/webcomponents/index.html) here:  https://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-index-html-L50     **What is the expected behavior?**  The event handler should be called.    For testing I have modified `getEventTarget.js` to return the target from the `path` property of the `nativeEvent` (instead of the \"original\" `target` from the `nativeEvent`). With this addition it works -   the Event Handler is called.    You can find the modified version also in the gist: https://gist.github.com/nilshartmann/3a520920e5fc920bfde49e077ad3beab#file-geteventtarget-js-L6      **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  15.4.x and 16.x  I've tested in Chrome, Firefox and Safari. I don't know if it works in previous versions of React (don't think so)",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** A React Component with an Event Handler (for example onClick) is rendered inside a Web Component. When the Component is clicked the Event does not receive the React Component (specified callback is not invoked) **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template:  You can reproduce it with Web Component example contained in the react repository ( Replace the 'a' element with a button and add for example an onClick event handler. You can find a modified version of the Web Component example (based on the 15.4.2 codebase -  here:  **What is the expected behavior?** The event handler should be called. For testing I have modified `getEventTarget.js` to return the target from the `path` property of the `nativeEvent` (instead of the \"original\" `target` from the `nativeEvent`). With this addition it works - the Event Handler is called. You can find the modified version also in the gist:  **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** 15.4.x and 16.x I've tested in Chrome, Firefox and Safari. I don't know if it works in previous versions of React (don't think so)",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * react component event handler ( example onclick ) rendered inside web component . component clicked event receive react component ( specified callback invoked ) * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template : reproduce web component example contained react repository ( replace ' ' element button add example onclick event handler . find modified version web component example ( based 15.4.2 codebase - : * * expected behavior ? * * event handler called . testing modified ` geteventtarget.js ` return target ` path ` property ` nativeevent ` ( instead `` original '' ` target ` ` nativeevent ` ) . addition work - event handler called . find modified version also gist : * * version react , browser / o affected issue ? work previous version react ? * * 15.4.x 16.x 've tested chrome , firefox safari . n't know work previous version react ( n't think )",
        "title_stopwords_removal_lemmatization": "event handler react component invoked react component rendered inside web component"
    },
    {
        "issue_id": 215772653,
        "title": "Boolean attributes on Web Components",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-03-21T15:09:51Z",
        "status": "closed",
        "description": "When setting boolean attributes on Web Components\r\n`<x-search somebool name={this.props.name} />`\r\nthey get rendered as attribute/value pairs instead\r\n`<x-search somebool=\"true\" name={this.props.name}>`\r\n\r\nThis causes problems with some AMP components, for eg. `<amp-iframe />` which has a `resizable` attribute that gets rendered as `resizable=\"true\"`. This results in non valid AMP content and developers crying with blood tears on their keyboards :)\r\n> The attribute 'resizable' in tag 'amp-iframe' is set to the invalid value 'true'. (see https://www.ampproject.org/docs/reference/components/amp-iframe)\r\n\r\nIs there any reason for the current behaviour? Will changing this break something else?",
        "remove_template_description": "When setting boolean attributes on Web Components  `<x-search somebool name={this.props.name} />`  they get rendered as attribute/value pairs instead  `<x-search somebool=\"true\" name={this.props.name}>`    This causes problems with some AMP components, for eg. `<amp-iframe />` which has a `resizable` attribute that gets rendered as `resizable=\"true\"`. This results in non valid AMP content and developers crying with blood tears on their keyboards :)  > The attribute 'resizable' in tag 'amp-iframe' is set to the invalid value 'true'. (see https://www.ampproject.org/docs/reference/components/amp-iframe)    Is there any reason for the current behaviour? Will changing this break something else?",
        "human_words": "When setting boolean attributes on Web Components  `<x-search somebool name={this.props.name} />`  they get rendered as attribute/value pairs instead  `<x-search somebool=\"true\" name={this.props.name}>`    This causes problems with some AMP components, for eg. `<amp-iframe />` which has a `resizable` attribute that gets rendered as `resizable=\"true\"`. This results in non valid AMP content and developers crying with blood tears on their keyboards :)  > The attribute 'resizable' in tag 'amp-iframe' is set to the invalid value 'true'. (see https://www.ampproject.org/docs/reference/components/amp-iframe)    Is there any reason for the current behaviour? Will changing this break something else?",
        "human_words_regrex": "When setting boolean attributes on Web Components `` they get rendered as attribute/value pairs instead `` This causes problems with some AMP components, for eg. `` which has a `resizable` attribute that gets rendered as `resizable=\"true\"`. This results in non valid AMP content and developers crying with blood tears on their keyboards :) > The attribute 'resizable' in tag 'amp-iframe' is set to the invalid value 'true'. (see  Is there any reason for the current behaviour? Will changing this break something else?",
        "human_words_stopwords_removal_lemmatization": "setting boolean attribute web component `` get rendered attribute/value pair instead `` cause problem amp component , eg . `` ` resizable ` attribute get rendered ` resizable= '' true '' ` . result non valid amp content developer cry blood tear keyboard : ) > attribute 'resizable ' tag 'amp-iframe ' set invalid value 'true ' . ( see reason current behaviour ? changing break something else ?",
        "title_stopwords_removal_lemmatization": "boolean attribute web component"
    },
    {
        "issue_id": 209510106,
        "title": "Disabling or destroying event's target stops further event propagation.",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-02-22T16:39:52Z",
        "status": "open",
        "description": "Disabling a submit button within a form on `onClick`, stops the event propagation to the forms `onSubmit` handler.\r\n\r\nThe fiddle:\r\n ```\r\nimport React from \"react\";\r\n\r\nclass SomeForm extends React.Component {\r\n    constructor(props){\r\n       super(props)\r\n       this.state = {\r\n          disabled:false\r\n       }\r\n    }\r\n    handleClick() {\r\n        this.setState({\r\n          disabled:true\r\n        });\r\n        console.log(\"Clicked button\");\r\n    }\r\n    handleSubmit(e){\r\n      alert(\"Submitted the form\")\r\n    }\r\n    render() {\r\n        let opts = {};\r\n        opts.disabled = this.state.disabled; // disabling the button stops the event propagation\r\n        \r\n        return (<form onSubmit={this.handleSubmit.bind(this)}>\r\n              <button {...opts} \r\n                type=\"submit\" \r\n                onClick={this.handleClick.bind(this)}>\r\n                Continue\r\n              </button>\r\n         </form>)\r\n    }\r\n}\r\n\r\nReactDOM.render(<SomeForm />, document.getElementById('a'));\r\n```\r\n[JsBin with the live example](http://jsbin.com/kidabifono/1/edit?js,output)\r\n\r\nExpected behavior: The event gets propagated unless explicitly swallowed via `e.preventDefault() && e.stopPropagation()`\r\n\r\n**React version:** 15.4.2\r\n**Browser:** Chrome 56.0.2924.87 x64\r\n\r\nUnfortunately I cannot tell if this happens with older versions.",
        "remove_template_description": "Disabling a submit button within a form on `onClick`, stops the event propagation to the forms `onSubmit` handler.    The fiddle:   ```  import React from \"react\";    class SomeForm extends React.Component {      constructor(props){         super(props)         this.state = {            disabled:false         }      }      handleClick() {          this.setState({            disabled:true          });          console.log(\"Clicked button\");      }      handleSubmit(e){        alert(\"Submitted the form\")      }      render() {          let opts = {};          opts.disabled = this.state.disabled; // disabling the button stops the event propagation                    return (<form onSubmit={this.handleSubmit.bind(this)}>                <button {...opts}                   type=\"submit\"                   onClick={this.handleClick.bind(this)}>                  Continue                </button>           </form>)      }  }    ReactDOM.render(<SomeForm />, document.getElementById('a'));  ```  [JsBin with the live example](http://jsbin.com/kidabifono/1/edit?js,output)    Expected behavior: The event gets propagated unless explicitly swallowed via `e.preventDefault() && e.stopPropagation()`    **React version:** 15.4.2  **Browser:** Chrome 56.0.2924.87 x64    Unfortunately I cannot tell if this happens with older versions.",
        "human_words": "Disabling a submit button within a form on `onClick`, stops the event propagation to the forms `onSubmit` handler.    The fiddle:     [JsBin with the live example](http://jsbin.com/kidabifono/1/edit?js,output)    Expected behavior: The event gets propagated unless explicitly swallowed via `e.preventDefault() && e.stopPropagation()`    **React version:** 15.4.2  **Browser:** Chrome 56.0.2924.87 x64    Unfortunately I cannot tell if this happens with older versions.",
        "human_words_regrex": "Disabling a submit button within a form on `onClick`, stops the event propagation to the forms `onSubmit` handler. The fiddle:  Expected behavior: The event gets propagated unless explicitly swallowed via `e.preventDefault() && e.stopPropagation()` **React version:** 15.4.2 **Browser:** Chrome 56.0.2924.87 x64 Unfortunately I cannot tell if this happens with older versions.",
        "human_words_stopwords_removal_lemmatization": "disabling submit button within form ` onclick ` , stop event propagation form ` onsubmit ` handler . fiddle : expected behavior : event get propagated unless explicitly swallowed via ` e.preventdefault ( ) & & e.stoppropagation ( ) ` * * react version : * * 15.4.2 * * browser : * * chrome 56.0.2924.87 x64 unfortunately tell happens older version .",
        "title_stopwords_removal_lemmatization": "disabling destroying event 's target stop event propagation ."
    },
    {
        "issue_id": 206457623,
        "title": "Chrome 56 breaks touch events",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2017-02-09T10:06:20Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nReact attaches events to the `document` node which causes the latest version of Chrome to issue the following warning.\r\n```\r\nUnable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080\r\n```\r\nIt appears that [Chrome now treats all document level touch events as passive](https://www.chromestatus.com/features/5093566007214080).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**\r\n\r\n```\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div\r\n          className=\"box\"\r\n          onTouchStart={e=>{e.preventDefault()}}\r\n          onTouchMove={e=>{e.preventDefault()}}\r\n      >\r\n          Drag Me\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n`preventDefault` should be allowed, which means React should pass `{ passive: false }` when adding event listeners.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\nReact 15.4.1, Chrome 56.0.2924.87, Windows 10\r\n",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  React attaches events to the `document` node which causes the latest version of Chrome to issue the following warning.  ```  Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080  ```  It appears that [Chrome now treats all document level touch events as passive](https://www.chromestatus.com/features/5093566007214080).    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**    ```  class App extends Component {    render() {      return (        <div            className=\"box\"            onTouchStart={e=>{e.preventDefault()}}            onTouchMove={e=>{e.preventDefault()}}        >            Drag Me        </div>      );    }  }  ```    **What is the expected behavior?**  `preventDefault` should be allowed, which means React should pass `{ passive: false }` when adding event listeners.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 15.4.1, Chrome 56.0.2924.87, Windows 10",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**  Bug    **What is the current behavior?**  React attaches events to the `document` node which causes the latest version of Chrome to issue the following warning.    It appears that [Chrome now treats all document level touch events as passive](https://www.chromestatus.com/features/5093566007214080).    **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**        **What is the expected behavior?**  `preventDefault` should be allowed, which means React should pass `{ passive: false }` when adding event listeners.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  React 15.4.1, Chrome 56.0.2924.87, Windows 10",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** Bug **What is the current behavior?** React attaches events to the `document` node which causes the latest version of Chrome to issue the following warning. It appears that . **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template:  **What is the expected behavior?** `preventDefault` should be allowed, which means React should pass `{ passive: false }` when adding event listeners. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 15.4.1, Chrome 56.0.2924.87, Windows 10",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * bug * * current behavior ? * * react attache event ` document ` node cause latest version chrome issue following warning . appears . * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template : * * expected behavior ? * * ` preventdefault ` allowed , mean react pas ` { passive : false } ` adding event listener . * * version react , browser / o affected issue ? work previous version react ? * * react 15.4.1 , chrome 56.0.2924.87 , window 10",
        "title_stopwords_removal_lemmatization": "chrome 56 break touch event"
    },
    {
        "issue_id": 199760450,
        "title": "[Fiber] Should we clear an error boundary's update queue whenever it captures an error?",
        "label": [
            "Component: Core Utilities",
            "Type: Discussion",
            "React Core Team"
        ],
        "date": "2017-01-10T08:32:00Z",
        "status": "open",
        "description": "Seems like we should at least do this on the root.",
        "remove_template_description": "Seems like we should at least do this on the root.",
        "human_words": "Seems like we should at least do this on the root.",
        "human_words_regrex": "Seems like we should at least do this on the root.",
        "human_words_stopwords_removal_lemmatization": "seems like least root .",
        "title_stopwords_removal_lemmatization": "[ fiber ] clear error boundary 's update queue whenever capture error ?"
    },
    {
        "issue_id": 197168524,
        "title": "Strange performance problem in Google Chrome - putListener appears in the timeline",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2016-12-22T12:53:38Z",
        "status": "closed",
        "description": "**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA performance problem in the latest Chrome on Windows 10. Firefox/Edge work fine.\r\n\r\n**What is the current behavior?**\r\nChrome freezes for a few seconds on the second render. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**\r\n\r\nPlease open http://pink-wren.surge.sh/.\r\n\r\nIn the first input type 2. This will cause that all items to be redrawn.\r\nObserve how browser freezes for a few seconds. \r\nAfterward, everything works fine.\r\n\r\nChrome Inspector timeline reveals strange React behavior.\r\n\r\n![image](https://cloud.githubusercontent.com/assets/433394/21426157/84cdf686-c84d-11e6-9958-54ecb5747689.png)\r\n\r\n**What is the expected behavior?**\r\nThis should not happen.\r\n\r\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\r\n\r\nI tried React 15.4.1 and 15.3.1 on Windows 10.",
        "remove_template_description": "**Do you want to request a *feature* or report a *bug*?**    A performance problem in the latest Chrome on Windows 10. Firefox/Edge work fine.    **What is the current behavior?**  Chrome freezes for a few seconds on the second render.     **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**    Please open http://pink-wren.surge.sh/.    In the first input type 2. This will cause that all items to be redrawn.  Observe how browser freezes for a few seconds.   Afterward, everything works fine.    Chrome Inspector timeline reveals strange React behavior.    ![image](https://cloud.githubusercontent.com/assets/433394/21426157/84cdf686-c84d-11e6-9958-54ecb5747689.png)    **What is the expected behavior?**  This should not happen.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    I tried React 15.4.1 and 15.3.1 on Windows 10.",
        "human_words": "**Do you want to request a *feature* or report a *bug*?**    A performance problem in the latest Chrome on Windows 10. Firefox/Edge work fine.    **What is the current behavior?**  Chrome freezes for a few seconds on the second render.     **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**    Please open http://pink-wren.surge.sh/.    In the first input type 2. This will cause that all items to be redrawn.  Observe how browser freezes for a few seconds.   Afterward, everything works fine.    Chrome Inspector timeline reveals strange React behavior.    ![image](https://cloud.githubusercontent.com/assets/433394/21426157/84cdf686-c84d-11e6-9958-54ecb5747689.png)    **What is the expected behavior?**  This should not happen.    **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**    I tried React 15.4.1 and 15.3.1 on Windows 10.",
        "human_words_regrex": "**Do you want to request a *feature* or report a *bug*?** A performance problem in the latest Chrome on Windows 10. Firefox/Edge work fine. **What is the current behavior?** Chrome freezes for a few seconds on the second render. **If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via  or similar (template:  Please open  In the first input type 2. This will cause that all items to be redrawn. Observe how browser freezes for a few seconds. Afterward, everything works fine. Chrome Inspector timeline reveals strange React behavior. ! **What is the expected behavior?** This should not happen. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** I tried React 15.4.1 and 15.3.1 on Windows 10.",
        "human_words_stopwords_removal_lemmatization": "* * want request * feature * report * bug * ? * * performance problem latest chrome window 10. firefox/edge work fine . * * current behavior ? * * chrome freeze second second render . * * current behavior bug , please provide step reproduce possible minimal demo problem via similar ( template : please open first input type 2. cause item redrawn . observe browser freeze second . afterward , everything work fine . chrome inspector timeline reveals strange react behavior . ! * * expected behavior ? * * happen . * * version react , browser / o affected issue ? work previous version react ? * * tried react 15.4.1 15.3.1 window 10 .",
        "title_stopwords_removal_lemmatization": "strange performance problem google chrome - putlistener appears timeline"
    },
    {
        "issue_id": 191277212,
        "title": "Firefox validation triggers on input component render",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2016-11-23T13:58:23Z",
        "status": "closed",
        "description": "When using native form validation and loading a page with a form containing an input with the `required` prop set, it triggers browser validation immediately. This produces Firefox's native error highlighting. This is because Firefox appears to run validation when the DOM is used to set a value on an existing input component. \r\n\r\nThe behavior can be seen here: http://codepen.io/anon/pen/zowOzo\r\n\r\nAngular has [run into this already](https://github.com/ggershoni/angular.js/commit/cc311740c6b680c68a88c44fecd97ede1f18f831).\r\n",
        "remove_template_description": "When using native form validation and loading a page with a form containing an input with the `required` prop set, it triggers browser validation immediately. This produces Firefox's native error highlighting. This is because Firefox appears to run validation when the DOM is used to set a value on an existing input component.     The behavior can be seen here: http://codepen.io/anon/pen/zowOzo    Angular has [run into this already](https://github.com/ggershoni/angular.js/commit/cc311740c6b680c68a88c44fecd97ede1f18f831).",
        "human_words": "When using native form validation and loading a page with a form containing an input with the `required` prop set, it triggers browser validation immediately. This produces Firefox's native error highlighting. This is because Firefox appears to run validation when the DOM is used to set a value on an existing input component.     The behavior can be seen here: http://codepen.io/anon/pen/zowOzo    Angular has [run into this already](https://github.com/ggershoni/angular.js/commit/cc311740c6b680c68a88c44fecd97ede1f18f831).",
        "human_words_regrex": "When using native form validation and loading a page with a form containing an input with the `required` prop set, it triggers browser validation immediately. This produces Firefox's native error highlighting. This is because Firefox appears to run validation when the DOM is used to set a value on an existing input component. The behavior can be seen here:  Angular has .",
        "human_words_stopwords_removal_lemmatization": "using native form validation loading page form containing input ` required ` prop set , trigger browser validation immediately . produce firefox 's native error highlighting . firefox appears run validation dom used set value existing input component . behavior seen : angular .",
        "title_stopwords_removal_lemmatization": "firefox validation trigger input component render"
    },
    {
        "issue_id": 183838077,
        "title": "[RFC] Enabling form.reset() on controlled inputs, make value and defaultValue more transparent",
        "label": [
            "Component: DOM",
            "Type: Discussion"
        ],
        "date": "2016-10-19T00:39:21Z",
        "status": "closed",
        "description": "I would like to make a case for supporting `form.reset()` for controlled inputs, and to make control over value and defaultValue more direct.\r\n\r\n### Background\r\n\r\nReact synchronizes the `value` attribute _and_ the `value` property on inputs. I believe this is for two reasons:\r\n\r\n1. It is easy for testing frameworks like Selenium to select on `[value=\"*\"]` when testing\r\n2. `form.reset` reverts an input back to it's value attribute. It also does not trigger change events, which causes input state to be out of sync with React state.\r\n\r\nThere are many reasons listed in https://github.com/facebook/react/issues/11896 to stop syncing the value attribute, so I'll keep this issue focused on my desired outcome.\r\n\r\n### The Change\r\n\r\nI want to be able to control the value attribute _and_ property directly from a component, at the same time:\r\n\r\n```javascript\r\n// I won't add Flow types, but this is just for clarity\r\ntype Widget {\r\n  name: string\r\n}\r\n\r\nclass EditWidget extends React.Component {\r\n  constructor() { \r\n    this.state = this.props.widget\r\n  }\r\n  onChange(event) {\r\n    this.setState({ name: event.target.value })\r\n  }\r\n  render() {\r\n    return (\r\n      <form>\r\n        <input value={this.state.name} defaultValue={this.props.widget.name} onChange={this.onChange} />\r\n        <button type=\"reset\">Revert</button>\r\n        <button type=\"submit\">Save</button>\r\n      </form>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n#### With this change:\r\n\r\n1. The `value` React property directly maps to the value _property_\r\n2. The `defaultValue` React property directly maps to the value _attribute_\r\n3. Both `value` and `defaultValue` are configurable at the same time\r\n4. An input becomes controlled when it specifies a `value` property\r\n5. Support form.reset, sending synthetic change events for fields that mismatch the last tracked value (or maybe just fire blindly for simplicity)\r\n\r\n### Why\r\n\r\nThis change creates a more controlled input, and makes it much clearer how React applies changes. More control is granted to the user. It provides away to allow props coming into a form to dictate a canonical state for the form, while still supporting native browser behavior.\r\n\r\nAlso, it means that we don't synchronize the value attribute, which would save a lot of headaches \ud83d\ude04.\r\n\r\n### Things to figure out\r\n\r\nServer rendering. What property do we use? In the case, we can only send along the default value. That might be fine for most cases, but I have not thought through the edge cases.",
        "remove_template_description": "I would like to make a case for supporting `form.reset()` for controlled inputs, and to make control over value and defaultValue more direct.    ### Background    React synchronizes the `value` attribute _and_ the `value` property on inputs. I believe this is for two reasons:    1. It is easy for testing frameworks like Selenium to select on `[value=\"*\"]` when testing  2. `form.reset` reverts an input back to it's value attribute. It also does not trigger change events, which causes input state to be out of sync with React state.    There are many reasons listed in https://github.com/facebook/react/issues/11896 to stop syncing the value attribute, so I'll keep this issue focused on my desired outcome.    ### The Change    I want to be able to control the value attribute _and_ property directly from a component, at the same time:    ```javascript  // I won't add Flow types, but this is just for clarity  type Widget {    name: string  }    class EditWidget extends React.Component {    constructor() {       this.state = this.props.widget    }    onChange(event) {      this.setState({ name: event.target.value })    }    render() {      return (        <form>          <input value={this.state.name} defaultValue={this.props.widget.name} onChange={this.onChange} />          <button type=\"reset\">Revert</button>          <button type=\"submit\">Save</button>        </form>      )    }  }  ```    #### With this change:    1. The `value` React property directly maps to the value _property_  2. The `defaultValue` React property directly maps to the value _attribute_  3. Both `value` and `defaultValue` are configurable at the same time  4. An input becomes controlled when it specifies a `value` property  5. Support form.reset, sending synthetic change events for fields that mismatch the last tracked value (or maybe just fire blindly for simplicity)    ### Why    This change creates a more controlled input, and makes it much clearer how React applies changes. More control is granted to the user. It provides away to allow props coming into a form to dictate a canonical state for the form, while still supporting native browser behavior.    Also, it means that we don't synchronize the value attribute, which would save a lot of headaches \ud83d\ude04.    ### Things to figure out    Server rendering. What property do we use? In the case, we can only send along the default value. That might be fine for most cases, but I have not thought through the edge cases.",
        "human_words": "I would like to make a case for supporting `form.reset()` for controlled inputs, and to make control over value and defaultValue more direct.    ### Background    React synchronizes the `value` attribute _and_ the `value` property on inputs. I believe this is for two reasons:    1. It is easy for testing frameworks like Selenium to select on `[value=\"*\"]` when testing  2. `form.reset` reverts an input back to it's value attribute. It also does not trigger change events, which causes input state to be out of sync with React state.    There are many reasons listed in https://github.com/facebook/react/issues/11896 to stop syncing the value attribute, so I'll keep this issue focused on my desired outcome.    ### The Change    I want to be able to control the value attribute _and_ property directly from a component, at the same time:        #### With this change:    1. The `value` React property directly maps to the value _property_  2. The `defaultValue` React property directly maps to the value _attribute_  3. Both `value` and `defaultValue` are configurable at the same time  4. An input becomes controlled when it specifies a `value` property  5. Support form.reset, sending synthetic change events for fields that mismatch the last tracked value (or maybe just fire blindly for simplicity)    ### Why    This change creates a more controlled input, and makes it much clearer how React applies changes. More control is granted to the user. It provides away to allow props coming into a form to dictate a canonical state for the form, while still supporting native browser behavior.    Also, it means that we don't synchronize the value attribute, which would save a lot of headaches \ud83d\ude04.    ### Things to figure out    Server rendering. What property do we use? In the case, we can only send along the default value. That might be fine for most cases, but I have not thought through the edge cases.",
        "human_words_regrex": "I would like to make a case for supporting `form.reset()` for controlled inputs, and to make control over value and defaultValue more direct. ### Background React synchronizes the `value` attribute _and_ the `value` property on inputs. I believe this is for two reasons: 1. It is easy for testing frameworks like Selenium to select on `[value=\"*\"]` when testing 2. `form.reset` reverts an input back to it's value attribute. It also does not trigger change events, which causes input state to be out of sync with React state. There are many reasons listed in  to stop syncing the value attribute, so I'll keep this issue focused on my desired outcome. ### The Change I want to be able to control the value attribute _and_ property directly from a component, at the same time: #### With this change: 1. The `value` React property directly maps to the value _property_ 2. The `defaultValue` React property directly maps to the value _attribute_ 3. Both `value` and `defaultValue` are configurable at the same time 4. An input becomes controlled when it specifies a `value` property 5. Support form.reset, sending synthetic change events for fields that mismatch the last tracked value (or maybe just fire blindly for simplicity) ### Why This change creates a more controlled input, and makes it much clearer how React applies changes. More control is granted to the user. It provides away to allow props coming into a form to dictate a canonical state for the form, while still supporting native browser behavior. Also, it means that we don't synchronize the value attribute, which would save a lot of headaches \ud83d\ude04. ### Things to figure out Server rendering. What property do we use? In the case, we can only send along the default value. That might be fine for most cases, but I have not thought through the edge cases.",
        "human_words_stopwords_removal_lemmatization": "would like make case supporting ` form.reset ( ) ` controlled input , make control value defaultvalue direct . # # # background react synchronizes ` value ` attribute _and_ ` value ` property input . believe two reason : 1. easy testing framework like selenium select ` [ value= '' * '' ] ` testing 2 . ` form.reset ` reverts input back 's value attribute . also trigger change event , cause input state sync react state . many reason listed stop syncing value attribute , 'll keep issue focused desired outcome . # # # change want able control value attribute _and_ property directly component , time : # # # # change : 1. ` value ` react property directly map value _property_ 2. ` defaultvalue ` react property directly map value _attribute_ 3. ` value ` ` defaultvalue ` configurable time 4. input becomes controlled specifies ` value ` property 5. support form.reset , sending synthetic change event field mismatch last tracked value ( maybe fire blindly simplicity ) # # # change creates controlled input , make much clearer react applies change . control granted user . provides away allow prop coming form dictate canonical state form , still supporting native browser behavior . also , mean n't synchronize value attribute , would save lot headache \ud83d\ude04 . # # # thing figure server rendering . property use ? case , send along default value . might fine case , thought edge case .",
        "title_stopwords_removal_lemmatization": "[ rfc ] enabling form.reset ( ) controlled input , make value defaultvalue transparent"
    },
    {
        "issue_id": 182373497,
        "title": "Fiber Principles: Contributing To Fiber",
        "label": [
            "Type: Discussion",
            "Component: Reconciler",
            "React Core Team"
        ],
        "date": "2016-10-11T21:02:05Z",
        "status": "closed",
        "description": "I just wanted to document a few unique design patterns that apply to Fiber, but not necessarily anything else. I'll start here.\n- You may mutate the fiber that you're working on during `beginWork` and `completeWork` phases but you may not have any other global side-effects. If you need a global side-effect, that have to be moved to the `commitWork` phase.\n- Fiber is a fixed data structure. It shares the same hidden class. Never add fields outside of construction in `ReactFiber`.\n- Nothing in the reconciler uses dynamic dispatch. I.e. we don't call a first class function, except for user code such as ref callbacks, functional components, render methods, etc. The rest is a static function available in a closure. I.e. use `myHelper(obj)` instead of `obj.myHelper()`. Any time we need to branch logic we use a switch statement over a `tag` which is a number that indicates which type of object we're dealing with and which branch to take (see pattern matching).\n- Many modules are instantiated with a `HostConfig` object. It is a single constructor that gets called on initialization time. This should be inlinable by a compiler.\n- Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. Calling other functions is fine - the only limitation is that they can't be recursive.\n- If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm. E.g. parent first, depth first:\n\n``` js\nlet root = fiber;\nlet node = fiber;\nwhile (true) {\n  // Do something with node\n  if (node.child) {\n    node = node.child;\n    continue;\n  }\n  if (node === root) {\n    return;\n  }\n  while (!node.sibling) {\n    if (!node.return || node.return === root) {\n      return;\n    }\n    node = node.return;\n  }\n  node = node.sibling;\n}\n```\n\nWhy does it need to be this complicated?\n- We can use the normal JS stack for this but any time we yield in a `requestIdleCallback` we would have to rebuild the stack when we continue. Since this only lasts for about 50ms when idle, we would spend some time unwinding and rebuilding the stack each time. It is not too bad. However, everything along the stack would have to be aware of how to \"unwind\" when we abort in the middle of the work flow.\n- It is plausible we could do this at the level of OCaml algebraic effects but we don't currently have all the features we need and we don't get the performance tradeoffs we want out of the box atm. This is a plausible future way forward though.\n- Most code lives outside of this recursion so it doesn't matter much for most cases.\n- Most of what React does is in the space of what the normal stack does. E.g. memoization, error handling, etc. Using the normal stack too, just makes it more difficult to get those to interact.\n- Everything we put on the stack we generally have to put on the heap too because we memoize it. Maintaining the stack and the heap with the same data is theoretically less efficient.\n- That said, all of these optimizations might be moot because JS stacks are much more efficient than JS heaps.\n- One thing that I wanted to try was to compile React components to do work directly on these data structures, just like normal programming languages compile to make mutations etc. to the stack. I think that's where the ideal implementation of React is.\n\nLet's just try it and see how it goes. :D\n\ncc @spicyj @gaearon @acdlite \n",
        "remove_template_description": "I just wanted to document a few unique design patterns that apply to Fiber, but not necessarily anything else. I'll start here. - You may mutate the fiber that you're working on during `beginWork` and `completeWork` phases but you may not have any other global side-effects. If you need a global side-effect, that have to be moved to the `commitWork` phase. - Fiber is a fixed data structure. It shares the same hidden class. Never add fields outside of construction in `ReactFiber`. - Nothing in the reconciler uses dynamic dispatch. I.e. we don't call a first class function, except for user code such as ref callbacks, functional components, render methods, etc. The rest is a static function available in a closure. I.e. use `myHelper(obj)` instead of `obj.myHelper()`. Any time we need to branch logic we use a switch statement over a `tag` which is a number that indicates which type of object we're dealing with and which branch to take (see pattern matching). - Many modules are instantiated with a `HostConfig` object. It is a single constructor that gets called on initialization time. This should be inlinable by a compiler. - Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. Calling other functions is fine - the only limitation is that they can't be recursive. - If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm. E.g. parent first, depth first:  ``` js let root = fiber; let node = fiber; while (true) {   // Do something with node   if (node.child) {     node = node.child;     continue;   }   if (node === root) {     return;   }   while (!node.sibling) {     if (!node.return || node.return === root) {       return;     }     node = node.return;   }   node = node.sibling; } ```  Why does it need to be this complicated? - We can use the normal JS stack for this but any time we yield in a `requestIdleCallback` we would have to rebuild the stack when we continue. Since this only lasts for about 50ms when idle, we would spend some time unwinding and rebuilding the stack each time. It is not too bad. However, everything along the stack would have to be aware of how to \"unwind\" when we abort in the middle of the work flow. - It is plausible we could do this at the level of OCaml algebraic effects but we don't currently have all the features we need and we don't get the performance tradeoffs we want out of the box atm. This is a plausible future way forward though. - Most code lives outside of this recursion so it doesn't matter much for most cases. - Most of what React does is in the space of what the normal stack does. E.g. memoization, error handling, etc. Using the normal stack too, just makes it more difficult to get those to interact. - Everything we put on the stack we generally have to put on the heap too because we memoize it. Maintaining the stack and the heap with the same data is theoretically less efficient. - That said, all of these optimizations might be moot because JS stacks are much more efficient than JS heaps. - One thing that I wanted to try was to compile React components to do work directly on these data structures, just like normal programming languages compile to make mutations etc. to the stack. I think that's where the ideal implementation of React is.  Let's just try it and see how it goes. :D  cc @spicyj @gaearon @acdlite",
        "human_words": "I just wanted to document a few unique design patterns that apply to Fiber, but not necessarily anything else. I'll start here. - You may mutate the fiber that you're working on during `beginWork` and `completeWork` phases but you may not have any other global side-effects. If you need a global side-effect, that have to be moved to the `commitWork` phase. - Fiber is a fixed data structure. It shares the same hidden class. Never add fields outside of construction in `ReactFiber`. - Nothing in the reconciler uses dynamic dispatch. I.e. we don't call a first class function, except for user code such as ref callbacks, functional components, render methods, etc. The rest is a static function available in a closure. I.e. use `myHelper(obj)` instead of `obj.myHelper()`. Any time we need to branch logic we use a switch statement over a `tag` which is a number that indicates which type of object we're dealing with and which branch to take (see pattern matching). - Many modules are instantiated with a `HostConfig` object. It is a single constructor that gets called on initialization time. This should be inlinable by a compiler. - Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. Calling other functions is fine - the only limitation is that they can't be recursive. - If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm. E.g. parent first, depth first:    Why does it need to be this complicated? - We can use the normal JS stack for this but any time we yield in a `requestIdleCallback` we would have to rebuild the stack when we continue. Since this only lasts for about 50ms when idle, we would spend some time unwinding and rebuilding the stack each time. It is not too bad. However, everything along the stack would have to be aware of how to \"unwind\" when we abort in the middle of the work flow. - It is plausible we could do this at the level of OCaml algebraic effects but we don't currently have all the features we need and we don't get the performance tradeoffs we want out of the box atm. This is a plausible future way forward though. - Most code lives outside of this recursion so it doesn't matter much for most cases. - Most of what React does is in the space of what the normal stack does. E.g. memoization, error handling, etc. Using the normal stack too, just makes it more difficult to get those to interact. - Everything we put on the stack we generally have to put on the heap too because we memoize it. Maintaining the stack and the heap with the same data is theoretically less efficient. - That said, all of these optimizations might be moot because JS stacks are much more efficient than JS heaps. - One thing that I wanted to try was to compile React components to do work directly on these data structures, just like normal programming languages compile to make mutations etc. to the stack. I think that's where the ideal implementation of React is.  Let's just try it and see how it goes. :D  cc @spicyj @gaearon @acdlite",
        "human_words_regrex": "I just wanted to document a few unique design patterns that apply to Fiber, but not necessarily anything else. I'll start here. - You may mutate the fiber that you're working on during `beginWork` and `completeWork` phases but you may not have any other global side-effects. If you need a global side-effect, that have to be moved to the `commitWork` phase. - Fiber is a fixed data structure. It shares the same hidden class. Never add fields outside of construction in `ReactFiber`. - Nothing in the reconciler uses dynamic dispatch. I.e. we don't call a first class function, except for user code such as ref callbacks, functional components, render methods, etc. The rest is a static function available in a closure. I.e. use `myHelper(obj)` instead of `obj.myHelper()`. Any time we need to branch logic we use a switch statement over a `tag` which is a number that indicates which type of object we're dealing with and which branch to take (see pattern matching). - Many modules are instantiated with a `HostConfig` object. It is a single constructor that gets called on initialization time. This should be inlinable by a compiler. - Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. Calling other functions is fine - the only limitation is that they can't be recursive. - If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm. E.g. parent first, depth first: Why does it need to be this complicated? - We can use the normal JS stack for this but any time we yield in a `requestIdleCallback` we would have to rebuild the stack when we continue. Since this only lasts for about 50ms when idle, we would spend some time unwinding and rebuilding the stack each time. It is not too bad. However, everything along the stack would have to be aware of how to \"unwind\" when we abort in the middle of the work flow. - It is plausible we could do this at the level of OCaml algebraic effects but we don't currently have all the features we need and we don't get the performance tradeoffs we want out of the box atm. This is a plausible future way forward though. - Most code lives outside of this recursion so it doesn't matter much for most cases. - Most of what React does is in the space of what the normal stack does. E.g. memoization, error handling, etc. Using the normal stack too, just makes it more difficult to get those to interact. - Everything we put on the stack we generally have to put on the heap too because we memoize it. Maintaining the stack and the heap with the same data is theoretically less efficient. - That said, all of these optimizations might be moot because JS stacks are much more efficient than JS heaps. - One thing that I wanted to try was to compile React components to do work directly on these data structures, just like normal programming languages compile to make mutations etc. to the stack. I think that's where the ideal implementation of React is. Let's just try it and see how it goes. :D cc @spicyj @gaearon @acdlite",
        "human_words_stopwords_removal_lemmatization": "wanted document unique design pattern apply fiber , necessarily anything else . 'll start . - may mutate fiber 're working ` beginwork ` ` completework ` phase may global side-effects . need global side-effect , moved ` commitwork ` phase . - fiber fixed data structure . share hidden class . never add field outside construction ` reactfiber ` . - nothing reconciler us dynamic dispatch . i.e . n't call first class function , except user code ref callback , functional component , render method , etc . rest static function available closure . i.e . use ` myhelper ( obj ) ` instead ` obj.myhelper ( ) ` . time need branch logic use switch statement ` tag ` number indicates type object 're dealing branch take ( see pattern matching ) . - many module instantiated ` hostconfig ` object . single constructor get called initialization time . inlinable compiler . - nothing fiber us normal j stack . meaning use stack compiled flat function needed . calling function fine - limitation ca n't recursive . - ca n't use recursion , traverse tree ? learn use singly linked list tree traversal algorithm . e.g . parent first , depth first : need complicated ? - use normal j stack time yield ` requestidlecallback ` would rebuild stack continue . since last 50ms idle , would spend time unwinding rebuilding stack time . bad . however , everything along stack would aware `` unwind '' abort middle work flow . - plausible could level ocaml algebraic effect n't currently feature need n't get performance tradeoff want box atm . plausible future way forward though . - code life outside recursion n't matter much case . - react space normal stack . e.g . memoization , error handling , etc . using normal stack , make difficult get interact . - everything put stack generally put heap memoize . maintaining stack heap data theoretically le efficient . - said , optimization might moot j stack much efficient j heap . - one thing wanted try compile react component work directly data structure , like normal programming language compile make mutation etc . stack . think 's ideal implementation react . let 's try see go . : cc @ spicyj @ gaearon @ acdlite",
        "title_stopwords_removal_lemmatization": "fiber principle : contributing fiber"
    },
    {
        "issue_id": 175864617,
        "title": "React.Children.count is incorrect for false value",
        "label": [
            "Component: Core Utilities",
            "Type: Discussion"
        ],
        "date": "2016-09-08T21:06:37Z",
        "status": "closed",
        "description": "**Do you want to request a _feature_ or report a _bug_?**\n\nI think this is a bug.\n\n**What is the current behavior?**\n\nIf you try to use `React.Children.count`, and the children contains a child with the value `false`, the result will be off by one. For example,\n\n```\nfunction Root() {\n    return (\n    <Hello>\n      {false}\n    </Hello>\n  );\n}\n\nfunction Hello({children}) {\n  return (\n    <div>\n      Count: {React.Children.count(children)}\n      <br />\n      toArray length: {React.Children.toArray(children).length}\n    </div>\n  );\n}\n```\n\nWill render\n\n```\nCount: 1\ntoArray length: 0\n```\n\nIf you replace `false` with `null` or `[]` the count will be 0.\n\n[Here's a fiddle that demonstrates the issue](https://jsfiddle.net/nqy0re3a/).\n\n**What is the expected behavior?**\n\nThe count shouldn't include `false` nodes.\n\n**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**\n\nI've repro'd this on Firefox 48 and Chrome 53. I don't know if this worked in previous versions of React.\n",
        "remove_template_description": "**Do you want to request a _feature_ or report a _bug_?**  I think this is a bug.  **What is the current behavior?**  If you try to use `React.Children.count`, and the children contains a child with the value `false`, the result will be off by one. For example,  ``` function Root() {     return (     <Hello>       {false}     </Hello>   ); }  function Hello({children}) {   return (     <div>       Count: {React.Children.count(children)}       <br />       toArray length: {React.Children.toArray(children).length}     </div>   ); } ```  Will render  ``` Count: 1 toArray length: 0 ```  If you replace `false` with `null` or `[]` the count will be 0.  [Here's a fiddle that demonstrates the issue](https://jsfiddle.net/nqy0re3a/).  **What is the expected behavior?**  The count shouldn't include `false` nodes.  **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  I've repro'd this on Firefox 48 and Chrome 53. I don't know if this worked in previous versions of React.",
        "human_words": "**Do you want to request a _feature_ or report a _bug_?**  I think this is a bug.  **What is the current behavior?**  If you try to use `React.Children.count`, and the children contains a child with the value `false`, the result will be off by one. For example,    Will render    If you replace `false` with `null` or `[]` the count will be 0.  [Here's a fiddle that demonstrates the issue](https://jsfiddle.net/nqy0re3a/).  **What is the expected behavior?**  The count shouldn't include `false` nodes.  **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**  I've repro'd this on Firefox 48 and Chrome 53. I don't know if this worked in previous versions of React.",
        "human_words_regrex": "**Do you want to request a _feature_ or report a _bug_?** I think this is a bug. **What is the current behavior?** If you try to use `React.Children.count`, and the children contains a child with the value `false`, the result will be off by one. For example, Will render If you replace `false` with `null` or `. **What is the expected behavior?** The count shouldn't include `false` nodes. **Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** I've repro'd this on Firefox 48 and Chrome 53. I don't know if this worked in previous versions of React.",
        "human_words_stopwords_removal_lemmatization": "* * want request _feature_ report _bug_ ? * * think bug . * * current behavior ? * * try use ` react.children.count ` , child contains child value ` false ` , result one . example , render replace ` false ` ` null ` ` . * * expected behavior ? * * count n't include ` false ` node . * * version react , browser / o affected issue ? work previous version react ? * * 've repro 'd firefox 48 chrome 53. n't know worked previous version react .",
        "title_stopwords_removal_lemmatization": "react.children.count incorrect false value"
    },
    {
        "issue_id": 175631601,
        "title": "Umbrella: New Life-Cycles Ideas",
        "label": [
            "Type: Discussion",
            "Type: Umbrella",
            "Component: Component API"
        ],
        "date": "2016-09-07T23:36:49Z",
        "status": "closed",
        "description": "I'll use this gather a few ideas of new life-cycle methods that help avoid existing problematic cases when using Fiber or other async rendering solutions.\n- `componentDidServerRender`: Gets called after the entire tree has rendered on the server. Useful for aborting buffered renders, or logging. Got the idea from #7671. This could possibly replace `componentWillMount`.\n- `componentWasMounted` and `componentWasUpdated`: Similar to `componentDidMount` and `componentDidUpdate` but happens asynchronously in spare cycles after a component has already appeared on the screen. That way triggering things like I/O doesn't have to block the component from rendering on the screen and dropping frames since `componentDidMount` have to be synchronous. This is not appropriate to use for Flux store subscriptions since you may be missing events that way. However, we can use \"lazy subscriptions\" as an alternative solution. #5053.\n- `componentWasUnmounted`: Similar to the above, this would happen in spare cycles for clean up purposes where clean up is not synchronously needed. This may not be needed as a separate life-cycles since we can possibly just make `componentWillUnmount` async. #6003.\n- `componentWillMountNow` and `componentWillUpdateNow`: This would be a fiber specific thing. Unlike the current `componentWillMount` / `componentWillUpdate` it actually happens _after_ `render` and _after_ all the children's `render` have been called, but right _before_ any side-effects are committed to the DOM. The use case of reading the current scroll position in `componentWillUpdate` only to reset it later doesn't work with async rendering because you can scroll between `componentWillUpdate` and `componentDidUpdate`. This could possibly replace `componentWillUpdate`.\n",
        "remove_template_description": "I'll use this gather a few ideas of new life-cycle methods that help avoid existing problematic cases when using Fiber or other async rendering solutions. - `componentDidServerRender`: Gets called after the entire tree has rendered on the server. Useful for aborting buffered renders, or logging. Got the idea from #7671. This could possibly replace `componentWillMount`. - `componentWasMounted` and `componentWasUpdated`: Similar to `componentDidMount` and `componentDidUpdate` but happens asynchronously in spare cycles after a component has already appeared on the screen. That way triggering things like I/O doesn't have to block the component from rendering on the screen and dropping frames since `componentDidMount` have to be synchronous. This is not appropriate to use for Flux store subscriptions since you may be missing events that way. However, we can use \"lazy subscriptions\" as an alternative solution. #5053. - `componentWasUnmounted`: Similar to the above, this would happen in spare cycles for clean up purposes where clean up is not synchronously needed. This may not be needed as a separate life-cycles since we can possibly just make `componentWillUnmount` async. #6003. - `componentWillMountNow` and `componentWillUpdateNow`: This would be a fiber specific thing. Unlike the current `componentWillMount` / `componentWillUpdate` it actually happens _after_ `render` and _after_ all the children's `render` have been called, but right _before_ any side-effects are committed to the DOM. The use case of reading the current scroll position in `componentWillUpdate` only to reset it later doesn't work with async rendering because you can scroll between `componentWillUpdate` and `componentDidUpdate`. This could possibly replace `componentWillUpdate`.",
        "human_words": "I'll use this gather a few ideas of new life-cycle methods that help avoid existing problematic cases when using Fiber or other async rendering solutions. - `componentDidServerRender`: Gets called after the entire tree has rendered on the server. Useful for aborting buffered renders, or logging. Got the idea from #7671. This could possibly replace `componentWillMount`. - `componentWasMounted` and `componentWasUpdated`: Similar to `componentDidMount` and `componentDidUpdate` but happens asynchronously in spare cycles after a component has already appeared on the screen. That way triggering things like I/O doesn't have to block the component from rendering on the screen and dropping frames since `componentDidMount` have to be synchronous. This is not appropriate to use for Flux store subscriptions since you may be missing events that way. However, we can use \"lazy subscriptions\" as an alternative solution. #5053. - `componentWasUnmounted`: Similar to the above, this would happen in spare cycles for clean up purposes where clean up is not synchronously needed. This may not be needed as a separate life-cycles since we can possibly just make `componentWillUnmount` async. #6003. - `componentWillMountNow` and `componentWillUpdateNow`: This would be a fiber specific thing. Unlike the current `componentWillMount` / `componentWillUpdate` it actually happens _after_ `render` and _after_ all the children's `render` have been called, but right _before_ any side-effects are committed to the DOM. The use case of reading the current scroll position in `componentWillUpdate` only to reset it later doesn't work with async rendering because you can scroll between `componentWillUpdate` and `componentDidUpdate`. This could possibly replace `componentWillUpdate`.",
        "human_words_regrex": "I'll use this gather a few ideas of new life-cycle methods that help avoid existing problematic cases when using Fiber or other async rendering solutions. - `componentDidServerRender`: Gets called after the entire tree has rendered on the server. Useful for aborting buffered renders, or logging. Got the idea from #7671. This could possibly replace `componentWillMount`. - `componentWasMounted` and `componentWasUpdated`: Similar to `componentDidMount` and `componentDidUpdate` but happens asynchronously in spare cycles after a component has already appeared on the screen. That way triggering things like I/O doesn't have to block the component from rendering on the screen and dropping frames since `componentDidMount` have to be synchronous. This is not appropriate to use for Flux store subscriptions since you may be missing events that way. However, we can use \"lazy subscriptions\" as an alternative solution. #5053. - `componentWasUnmounted`: Similar to the above, this would happen in spare cycles for clean up purposes where clean up is not synchronously needed. This may not be needed as a separate life-cycles since we can possibly just make `componentWillUnmount` async. #6003. - `componentWillMountNow` and `componentWillUpdateNow`: This would be a fiber specific thing. Unlike the current `componentWillMount` / `componentWillUpdate` it actually happens _after_ `render` and _after_ all the children's `render` have been called, but right _before_ any side-effects are committed to the DOM. The use case of reading the current scroll position in `componentWillUpdate` only to reset it later doesn't work with async rendering because you can scroll between `componentWillUpdate` and `componentDidUpdate`. This could possibly replace `componentWillUpdate`.",
        "human_words_stopwords_removal_lemmatization": "'ll use gather idea new life-cycle method help avoid existing problematic case using fiber async rendering solution . - ` componentdidserverrender ` : get called entire tree rendered server . useful aborting buffered render , logging . got idea # 7671. could possibly replace ` componentwillmount ` . - ` componentwasmounted ` ` componentwasupdated ` : similar ` componentdidmount ` ` componentdidupdate ` happens asynchronously spare cycle component already appeared screen . way triggering thing like i/o n't block component rendering screen dropping frame since ` componentdidmount ` synchronous . appropriate use flux store subscription since may missing event way . however , use `` lazy subscription '' alternative solution . # 5053 . - ` componentwasunmounted ` : similar , would happen spare cycle clean purpose clean synchronously needed . may needed separate life-cycles since possibly make ` componentwillunmount ` async . # 6003 . - ` componentwillmountnow ` ` componentwillupdatenow ` : would fiber specific thing . unlike current ` componentwillmount ` / ` componentwillupdate ` actually happens _after_ ` render ` _after_ child 's ` render ` called , right _before_ side-effects committed dom . use case reading current scroll position ` componentwillupdate ` reset later n't work async rendering scroll ` componentwillupdate ` ` componentdidupdate ` . could possibly replace ` componentwillupdate ` .",
        "title_stopwords_removal_lemmatization": "umbrella : new life-cycles idea"
    },
    {
        "issue_id": 175393882,
        "title": "Deprecate componentWillMount Maybe?",
        "label": [
            "Type: Discussion",
            "Component: Component API"
        ],
        "date": "2016-09-07T01:48:55Z",
        "status": "closed",
        "description": "Let's use this thread to discuss use cases for componentWillMount and alternative solutions to those problems. Generally the solution is simply to use componentDidMount and two pass rendering if necessary.\n\nThere are several problems with doing global side-effects in the \"componentWill\" phase. That includes starting network requests or subscribing to Flux stores etc.\n\n1) It is confusing when used with error boundaries because currently `componentWillUnmount` can be called without `componentDidMount` ever being called. `componentWill*` is a false promise until all the children have successfully completed. Currently, this only applies when error boundaries are used but we'll probably want to revert this decision and simply not call `componentWillUnmount` here.\n\n2) The Fiber experiment doesn't really have a good way to call `componentWillUnmount` when a new render gets aborted because a higher priority update interrupted it. Similarly, our sister project [ComponentKit](http://componentkit.org/) does reconciliation in threads where it is not safe to perform side-effects yet.\n\n3) Callbacks from `componentWillMount` that update parent components with a `setState` is completely unsupported and lead to strange and order dependent race conditions. We already know that we want to deprecate that pattern.\n\n4) The reconciliation order of children can easily be dependent upon if you perform global side-effects in `componentWillMount`. They're already not fully guaranteed because updates can cause unexpected reconciliation orders. Relying on order also limits future use cases such as async or streaming rendering and parallelized rendering.\n\nThe only legit use case for `componentWillMount` is to call `this.setState` on yourself. Even then you never really need it since you can just initialize your initial state to whatever you had. We only really kept it around for a very specific use case:\n\n``` js\nclass Foo {\n  state = { data: null };\n  // ANTI-PATTERN\n  componentWillMount() {\n    this._subscription = GlobalStore.getFromCacheOrFetch(data => this.setState({ data: data });\n  }\n  componentWillUnmount() {\n    if (this._subscription) {\n      GlobalStore.cancel(this._subscription);\n    }\n  }\n  ...\n}\n```\n\nWhen the same callback can be used both synchronously and asynchronously it is convenient to avoid an extra rerender if data is already available.\n\nThe solution is to split this API out into a synchronous version and an asynchronous version.\n\n``` js\nclass Foo {\n  state = { data: GlobalStore.getFromCacheOrNull() };\n  componentDidMount() {\n    if (!this.state.data) {\n      this._subscription = GlobalStore.fetch(data => this.setState({ data: data });\n    }\n  }\n  componentWillUnmount() {\n    if (this._subscription) {\n      GlobalStore.cancel(this._subscription);\n    }\n  }\n  ...\n}\n```\n\nThis guarantees that the side-effect only happens if the component successfully mounts. If the async side-effect is needed, then a two-pass rendering is needed regardless.\n\nI'd argue that it is not too much boilerplate since you need a `componentWillUnmount` anyway. This can all be hidden inside a Higher-Order Component.\n\nGlobal side-effects in `componentWillReceiveProps` and `componentWillUpdate` are also bad since they're not guaranteed to complete. Due to aborts or errors. You should prefer `componentDidUpdate` when possible. However, they will likely remain in some form even if their use case is constrained. They're also not nearly as bad since they will still get their `componentWillUnmount` invoked for cleanup.\n",
        "remove_template_description": "Let's use this thread to discuss use cases for componentWillMount and alternative solutions to those problems. Generally the solution is simply to use componentDidMount and two pass rendering if necessary.  There are several problems with doing global side-effects in the \"componentWill\" phase. That includes starting network requests or subscribing to Flux stores etc.  1) It is confusing when used with error boundaries because currently `componentWillUnmount` can be called without `componentDidMount` ever being called. `componentWill*` is a false promise until all the children have successfully completed. Currently, this only applies when error boundaries are used but we'll probably want to revert this decision and simply not call `componentWillUnmount` here.  2) The Fiber experiment doesn't really have a good way to call `componentWillUnmount` when a new render gets aborted because a higher priority update interrupted it. Similarly, our sister project [ComponentKit](http://componentkit.org/) does reconciliation in threads where it is not safe to perform side-effects yet.  3) Callbacks from `componentWillMount` that update parent components with a `setState` is completely unsupported and lead to strange and order dependent race conditions. We already know that we want to deprecate that pattern.  4) The reconciliation order of children can easily be dependent upon if you perform global side-effects in `componentWillMount`. They're already not fully guaranteed because updates can cause unexpected reconciliation orders. Relying on order also limits future use cases such as async or streaming rendering and parallelized rendering.  The only legit use case for `componentWillMount` is to call `this.setState` on yourself. Even then you never really need it since you can just initialize your initial state to whatever you had. We only really kept it around for a very specific use case:  ``` js class Foo {   state = { data: null };   // ANTI-PATTERN   componentWillMount() {     this._subscription = GlobalStore.getFromCacheOrFetch(data => this.setState({ data: data });   }   componentWillUnmount() {     if (this._subscription) {       GlobalStore.cancel(this._subscription);     }   }   ... } ```  When the same callback can be used both synchronously and asynchronously it is convenient to avoid an extra rerender if data is already available.  The solution is to split this API out into a synchronous version and an asynchronous version.  ``` js class Foo {   state = { data: GlobalStore.getFromCacheOrNull() };   componentDidMount() {     if (!this.state.data) {       this._subscription = GlobalStore.fetch(data => this.setState({ data: data });     }   }   componentWillUnmount() {     if (this._subscription) {       GlobalStore.cancel(this._subscription);     }   }   ... } ```  This guarantees that the side-effect only happens if the component successfully mounts. If the async side-effect is needed, then a two-pass rendering is needed regardless.  I'd argue that it is not too much boilerplate since you need a `componentWillUnmount` anyway. This can all be hidden inside a Higher-Order Component.  Global side-effects in `componentWillReceiveProps` and `componentWillUpdate` are also bad since they're not guaranteed to complete. Due to aborts or errors. You should prefer `componentDidUpdate` when possible. However, they will likely remain in some form even if their use case is constrained. They're also not nearly as bad since they will still get their `componentWillUnmount` invoked for cleanup.",
        "human_words": "Let's use this thread to discuss use cases for componentWillMount and alternative solutions to those problems. Generally the solution is simply to use componentDidMount and two pass rendering if necessary.  There are several problems with doing global side-effects in the \"componentWill\" phase. That includes starting network requests or subscribing to Flux stores etc.  1) It is confusing when used with error boundaries because currently `componentWillUnmount` can be called without `componentDidMount` ever being called. `componentWill*` is a false promise until all the children have successfully completed. Currently, this only applies when error boundaries are used but we'll probably want to revert this decision and simply not call `componentWillUnmount` here.  2) The Fiber experiment doesn't really have a good way to call `componentWillUnmount` when a new render gets aborted because a higher priority update interrupted it. Similarly, our sister project [ComponentKit](http://componentkit.org/) does reconciliation in threads where it is not safe to perform side-effects yet.  3) Callbacks from `componentWillMount` that update parent components with a `setState` is completely unsupported and lead to strange and order dependent race conditions. We already know that we want to deprecate that pattern.  4) The reconciliation order of children can easily be dependent upon if you perform global side-effects in `componentWillMount`. They're already not fully guaranteed because updates can cause unexpected reconciliation orders. Relying on order also limits future use cases such as async or streaming rendering and parallelized rendering.  The only legit use case for `componentWillMount` is to call `this.setState` on yourself. Even then you never really need it since you can just initialize your initial state to whatever you had. We only really kept it around for a very specific use case:    When the same callback can be used both synchronously and asynchronously it is convenient to avoid an extra rerender if data is already available.  The solution is to split this API out into a synchronous version and an asynchronous version.    This guarantees that the side-effect only happens if the component successfully mounts. If the async side-effect is needed, then a two-pass rendering is needed regardless.  I'd argue that it is not too much boilerplate since you need a `componentWillUnmount` anyway. This can all be hidden inside a Higher-Order Component.  Global side-effects in `componentWillReceiveProps` and `componentWillUpdate` are also bad since they're not guaranteed to complete. Due to aborts or errors. You should prefer `componentDidUpdate` when possible. However, they will likely remain in some form even if their use case is constrained. They're also not nearly as bad since they will still get their `componentWillUnmount` invoked for cleanup.",
        "human_words_regrex": "Let's use this thread to discuss use cases for componentWillMount and alternative solutions to those problems. Generally the solution is simply to use componentDidMount and two pass rendering if necessary. There are several problems with doing global side-effects in the \"componentWill\" phase. That includes starting network requests or subscribing to Flux stores etc. 1) It is confusing when used with error boundaries because currently `componentWillUnmount` can be called without `componentDidMount` ever being called. `componentWill*` is a false promise until all the children have successfully completed. Currently, this only applies when error boundaries are used but we'll probably want to revert this decision and simply not call `componentWillUnmount` here. 2) The Fiber experiment doesn't really have a good way to call `componentWillUnmount` when a new render gets aborted because a higher priority update interrupted it. Similarly, our sister project  does reconciliation in threads where it is not safe to perform side-effects yet. 3) Callbacks from `componentWillMount` that update parent components with a `setState` is completely unsupported and lead to strange and order dependent race conditions. We already know that we want to deprecate that pattern. 4) The reconciliation order of children can easily be dependent upon if you perform global side-effects in `componentWillMount`. They're already not fully guaranteed because updates can cause unexpected reconciliation orders. Relying on order also limits future use cases such as async or streaming rendering and parallelized rendering. The only legit use case for `componentWillMount` is to call `this.setState` on yourself. Even then you never really need it since you can just initialize your initial state to whatever you had. We only really kept it around for a very specific use case: When the same callback can be used both synchronously and asynchronously it is convenient to avoid an extra rerender if data is already available. The solution is to split this API out into a synchronous version and an asynchronous version. This guarantees that the side-effect only happens if the component successfully mounts. If the async side-effect is needed, then a two-pass rendering is needed regardless. I'd argue that it is not too much boilerplate since you need a `componentWillUnmount` anyway. This can all be hidden inside a Higher-Order Component. Global side-effects in `componentWillReceiveProps` and `componentWillUpdate` are also bad since they're not guaranteed to complete. Due to aborts or errors. You should prefer `componentDidUpdate` when possible. However, they will likely remain in some form even if their use case is constrained. They're also not nearly as bad since they will still get their `componentWillUnmount` invoked for cleanup.",
        "human_words_stopwords_removal_lemmatization": "let 's use thread discus use case componentwillmount alternative solution problem . generally solution simply use componentdidmount two pas rendering necessary . several problem global side-effects `` componentwill '' phase . includes starting network request subscribing flux store etc . 1 ) confusing used error boundary currently ` componentwillunmount ` called without ` componentdidmount ` ever called . ` componentwill * ` false promise child successfully completed . currently , applies error boundary used 'll probably want revert decision simply call ` componentwillunmount ` . 2 ) fiber experiment n't really good way call ` componentwillunmount ` new render get aborted higher priority update interrupted . similarly , sister project reconciliation thread safe perform side-effects yet . 3 ) callback ` componentwillmount ` update parent component ` setstate ` completely unsupported lead strange order dependent race condition . already know want deprecate pattern . 4 ) reconciliation order child easily dependent upon perform global side-effects ` componentwillmount ` . 're already fully guaranteed update cause unexpected reconciliation order . relying order also limit future use case async streaming rendering parallelized rendering . legit use case ` componentwillmount ` call ` this.setstate ` . even never really need since initialize initial state whatever . really kept around specific use case : callback used synchronously asynchronously convenient avoid extra rerender data already available . solution split api synchronous version asynchronous version . guarantee side-effect happens component successfully mount . async side-effect needed , two-pass rendering needed regardless . 'd argue much boilerplate since need ` componentwillunmount ` anyway . hidden inside higher-order component . global side-effects ` componentwillreceiveprops ` ` componentwillupdate ` also bad since 're guaranteed complete . due abort error . prefer ` componentdidupdate ` possible . however , likely remain form even use case constrained . 're also nearly bad since still get ` componentwillunmount ` invoked cleanup .",
        "title_stopwords_removal_lemmatization": "deprecate componentwillmount maybe ?"
    },
    {
        "issue_id": 165836052,
        "title": "Discussion: should state be immutable by default?",
        "label": [
            "Type: Discussion",
            "Component: Component API"
        ],
        "date": "2016-07-15T17:15:49Z",
        "status": "closed",
        "description": "Taking some hard perspective from Redux, should a component's state be immutable by default, or would that be too much overhead for React? \n\nSide note, and possibly previously addressed topic: Shouldn't `setState()` be immutable by default? I realize there are [immutability helpers](https://facebook.github.io/react/docs/update.html), but _man_ that syntax is hard on the eyes. \n\nNot so much \"sugar\" as \"vinegar\". :) I also know there is a [section on Immutability.js](https://facebook.github.io/react/docs/advanced-performance.html#immutable-js-to-the-rescue) on the Advanced Performance page, but it doesn't address `setState()` directly.\n\nIt's not clear (at least to me) from [the setState() docs](https://facebook.github.io/react/docs/component-api.html#setstate) whether React already handles this. \n\n> returns an object\n> \ud83d\udc4d \n> \n> containing keys to update.\n> \u2753 \n\nSorry for the sidebar. Just wanting to get a confirmation either way. \nhttps://github.com/facebook/immutable-js/wiki/Immutable-as-React-state\n",
        "remove_template_description": "Taking some hard perspective from Redux, should a component's state be immutable by default, or would that be too much overhead for React?   Side note, and possibly previously addressed topic: Shouldn't `setState()` be immutable by default? I realize there are [immutability helpers](https://facebook.github.io/react/docs/update.html), but _man_ that syntax is hard on the eyes.   Not so much \"sugar\" as \"vinegar\". :) I also know there is a [section on Immutability.js](https://facebook.github.io/react/docs/advanced-performance.html#immutable-js-to-the-rescue) on the Advanced Performance page, but it doesn't address `setState()` directly.  It's not clear (at least to me) from [the setState() docs](https://facebook.github.io/react/docs/component-api.html#setstate) whether React already handles this.   > returns an object > \ud83d\udc4d  >  > containing keys to update. > \u2753   Sorry for the sidebar. Just wanting to get a confirmation either way.  https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state",
        "human_words": "Taking some hard perspective from Redux, should a component's state be immutable by default, or would that be too much overhead for React?   Side note, and possibly previously addressed topic: Shouldn't `setState()` be immutable by default? I realize there are [immutability helpers](https://facebook.github.io/react/docs/update.html), but _man_ that syntax is hard on the eyes.   Not so much \"sugar\" as \"vinegar\". :) I also know there is a [section on Immutability.js](https://facebook.github.io/react/docs/advanced-performance.html#immutable-js-to-the-rescue) on the Advanced Performance page, but it doesn't address `setState()` directly.  It's not clear (at least to me) from [the setState() docs](https://facebook.github.io/react/docs/component-api.html#setstate) whether React already handles this.   > returns an object > \ud83d\udc4d  >  > containing keys to update. > \u2753   Sorry for the sidebar. Just wanting to get a confirmation either way.  https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state",
        "human_words_regrex": "Taking some hard perspective from Redux, should a component's state be immutable by default, or would that be too much overhead for React? Side note, and possibly previously addressed topic: Shouldn't `setState()` be immutable by default? I realize there are , but _man_ that syntax is hard on the eyes. Not so much \"sugar\" as \"vinegar\". :) I also know there is a  on the Advanced Performance page, but it doesn't address `setState()` directly. It's not clear (at least to me) from  whether React already handles this. > returns an object > \ud83d\udc4d > > containing keys to update. > \u2753 Sorry for the sidebar. Just wanting to get a confirmation either way. ",
        "human_words_stopwords_removal_lemmatization": "taking hard perspective redux , component 's state immutable default , would much overhead react ? side note , possibly previously addressed topic : n't ` setstate ( ) ` immutable default ? realize , _man_ syntax hard eye . much `` sugar '' `` vinegar '' . : ) also know advanced performance page , n't address ` setstate ( ) ` directly . 's clear ( least ) whether react already handle . > return object > \ud83d\udc4d > > containing key update . > \u2753 sorry sidebar . wanting get confirmation either way .",
        "title_stopwords_removal_lemmatization": "discussion : state immutable default ?"
    }
]